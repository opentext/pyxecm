{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PYXECM","text":"<p>A python library to interact with Opentext Extended ECM REST API.  API documentation is available on OpenText Developer</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Copyright \u00a9 2023 Open Text Corporation, All Rights Reserved. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"payload-syntax/","title":"Payload Syntax","text":""},{"location":"payload-syntax/#customizing","title":"Customizing","text":"<p>The customizing payload can be defined in either of the following standards:</p> <ul> <li>Terraform / HCL</li> <li>YAML</li> </ul> Terraform / HCLYAML <p>The Terraform language uses the following types for its values:</p> <ul> <li><code>string</code>: a sequence of Unicode characters representing some text, like <code>\"hello\"</code>.</li> <li><code>number</code>: a numeric value. The number type can represent both whole numbers like 15 and fractional values like <code>6.283185</code>.</li> <li><code>bool</code>: a boolean value, either true or false. bool values can be used in conditional logic.</li> <li><code>list (or tuple)</code>: a sequence of values, like <code>[\"user1\", \"user2\"]</code>.</li> <li><code>map (or dictionary)</code>: a group of values identified by named labels, like <code>{name = \"nwheeler\", security_clearance = 50}</code>.</li> </ul> <p>Most of the customizing settings may have an optional field called <code>enabled</code> that allows to dynamically turn on / off customization settings based on a boolean value that may be read from a Terraform variable (or could just be <code>False</code> or <code>True</code>). In case you are using additional external payload (see above) you need to provide <code>False</code> or <code>True</code> directly. If <code>enabled</code> is not specified then <code>enabled = True</code> is assumed (this is the default).</p> <p>The YAML language uses the following types for its values:</p> <ul> <li><code>string</code>: a sequence of Unicode characters representing some text, like <code>hello</code>.</li> <li><code>number</code>: a numeric value. The number type can represent both whole numbers like 15 and fractional values like <code>6.283185</code>.</li> <li><code>bool</code>: a boolean value, either <code>True</code> or <code>False</code>.</li> <li><code>list</code>: a sequence of values, like <code>[\"user1\", \"user2\"]</code> or   <pre><code>- name: user1\n- name: user2\n</code></pre></li> <li><code>dictionary</code>: a group of values identified by named labels, like <code>{name = \"nwheeler\", security_clearance = 50}</code>.   <pre><code>  name: nwheeler\n  security_clearance: 50\n</code></pre></li> </ul> <p>Sample usage:   <pre><code>users:\n  - name: nwheeler\n    security_clearance: 50\n  - name: adminton\n    security_clearance: 90\n</code></pre></p> <p>Most of the customizing settings may have an optional field called <code>enabled</code> that allows to dynamically turn on / off customization settings based on a boolean value. If <code>enabled</code> is not specified then <code>enabled = True</code> is assumed (this is the default).</p>"},{"location":"payload-syntax/#otds-customizing-syntax","title":"OTDS Customizing Syntax","text":"<p>The payload syntax for OTDS customizing uses the following lists (the list elements are maps):</p>"},{"location":"payload-syntax/#partitions","title":"partitions","text":"<p><code>partitions</code> allows to create new partitions in OTDS. It is also possible to directly put the new partition into an existing <code>access role</code>:</p> Terraform / HCLYAML <pre><code>partitions = [\n  {\n      enabled     = true\n      name        = \"Salesforce\"\n      description = \"Salesforce user partition\"\n      synced      = false\n      access_role = \"Access to cs\"\n  }\n]\n</code></pre> <pre><code>partitions:\n  - enabled: True\n    name: \"Salesforce\"\n    description: \"Salesforce user partition\"\n    synced: False\n    access_role: \"Access to cs\"\n</code></pre>"},{"location":"payload-syntax/#oauthclients","title":"oauthClients","text":"<p><code>oauthClients</code> allows to create new OAuth client in OTDS. Each list element includes a switch <code>enabled</code> to turn them on or off. This switch can be controlled by a Terraform variable. <code>name</code> defines the name of the OTDS OAuth client and <code>description</code> should describe what the OAuth client is used for. Each OAuth client has the typical elements such as <code>confidential</code>, OTDS <code>partition</code>, a <code>redirect_url</code>, <code>permission_scope</code>, <code>default_scope</code>, and <code>allow_impersonation</code>. If there's a predefined secret it can be provided by <code>secret</code>.</p> Terraform / HCLYAML <pre><code>oauthClients = [\n  {\n    enabled             = var.enable_salesforce\n    name                = \"salesforce\"\n    description         = \"OAuth client for Salesforce\"\n    confidential        = true\n    partition           = \"Global\"\n    redirect_urls       = [\"https://salesforce.com/services/authcallback/OTDS\"]\n    permission_scopes   = [\"full\"]\n    default_scopes      = [\"full\"]\n    allow_impersonation = true\n    secret              = var.salesforce_oauth_secret\n  }\n]\n</code></pre> <pre><code>  oauthClients:\n  - allow_impersonation: true\n    confidential: true\n    default_scopes:\n    - full\n    description: OAuth client for Salesforce\n    enabled: ${var.enable_salesforce}\n    name: salesforce\n    partition: Global\n    permission_scopes:\n    - full\n    redirect_urls:\n    - https://salesforce.com/services/authcallback/OTDS\n    secret: ${var.salesforce_oauth_secret}\n</code></pre>"},{"location":"payload-syntax/#authhandlers","title":"authHandlers","text":"<p><code>authHandlers</code> is a list of additional OTDS authentication handlers. The values can also use terraform variables.</p> Terraform / HCLYAML <pre><code>authHandlers = [\n  {\n    enabled                = true\n    name                   = \"...\"\n    description            = \"...\"\n    type                   = \"...\" # either SAML, OAUTH, or SAP\n    provider_name          = \"...\" # required for SAML and OAUTH\n    saml_url               = \"...\" # required for SAML\n    otds_url               = \"https://${local.otds_dns_name}/otdsws/login\" # required for SAML\n    certificate_file       = \"...\" # required only for SAP\n    certificate_password   = \"...\" # required only for SAP\n    client_id              = \"...\" # required only for OAUTH\n    client_secret          = \"...\" # required only for OAUTH\n    active_by_default      = false # replace standard OTDS login page\n    authorization_endpoint = \"...\" # required only for OAUTH\n    token_endpoint         = \"...\" # required only for OAUTH\n    scope_string           = \"id\"\n  },\n]\n</code></pre> <pre><code>  authHandlers:\n  - active_by_default: false\n    authorization_endpoint: '...'\n    certificate_file: '...'\n    certificate_password: '...'\n    client_id: '...'\n    client_secret: '...'\n    description: '...'\n    enabled: true\n    name: '...'\n    otds_url: https://${local.otds_dns_name}/otdsws/login\n    provider_name: '...'\n    saml_url: '...'\n    scope_string: '...'\n    token_endpoint: '...'\n    type: '...'\n</code></pre>"},{"location":"payload-syntax/#trustedsites","title":"trustedSites","text":"<p><code>trustedSites</code> allows you to define trusted sites for OTDS. Each trusted site defines a URL and can be enabled or disabled. Regular expressions are allowed to define patterns.</p> Terraform / HCLYAML <pre><code>trustedSites = [\n  {\n    enabled = var.enable_successfactors\n    url     = \"https://[^/]+\\\\.successfactors\\\\.eu/.*\"\n  },\n  {\n    enabled = var.enable_successfactors\n    url     = \"https://[^/]+\\\\.successfactors\\\\.com/.*\"\n  },\n  {\n    enabled = var.enable_salesforce\n    url     = \"https://[^/]+\\\\.salesforce\\\\.com/.*\"\n  },\n  {\n    enabled = var.enable_salesforce\n    url     = \"https://[^/]+\\\\.force\\\\.com/.*\"\n  },\n  {\n    enabled = var.enable_o365\n    url     = \"https://[^/]+\\\\.microsoft\\\\.com/.*\"\n  },\n  {\n    enabled = var.enable_o365\n    url     = \"https://[^/]+\\\\.sharepoint\\\\.com/.*\"\n  },\n  {\n    enabled = var.enable_o365\n    url     = \"https://[^/]+\\\\.office\\\\.com/.*\"\n  },\n  {\n    enabled = var.enable_appworks\n    url     = \"https://${local.otawp_dns_name}\" # AppWorks endpoint\n  },\n]\n</code></pre> <pre><code>trustedSites:\n- enabled: ${var.enable_successfactors}\n  url: https://[^/]+\\\\.successfactors\\\\.eu/.*\n- enabled: ${var.enable_successfactors}\n  url: https://[^/]+\\\\.successfactors\\\\.com/.*\n- enabled: ${var.enable_salesforce}\n  url: https://[^/]+\\\\.salesforce\\\\.com/.*\n- enabled: ${var.enable_salesforce}\n  url: https://[^/]+\\\\.force\\\\.com/.*\n- enabled: ${var.enable_o365}\n  url: https://[^/]+\\\\.microsoft\\\\.com/.*\n- enabled: ${var.enable_o365}\n  url: https://[^/]+\\\\.sharepoint\\\\.com/.*\n- enabled: ${var.enable_o365}\n  url: https://[^/]+\\\\.office\\\\.com/.*\n- enabled: ${var.enable_appworks}\n  url: https://${local.otawp_dns_name}\n</code></pre>"},{"location":"payload-syntax/#systemattributes","title":"systemAttributes","text":"<p><code>systemAttributes</code> allows you to set system attributes in OTDS. Each trusted site has a name, value and an optional description.</p> Terraform / HCLYAML <pre><code>systemAttributes = [\n  {\n    name        = \"otds.as.SameSiteCookieVal\"\n    value       = \"None\"\n    description = \"SameSite Cookie Attribute\"\n  }\n]\n</code></pre> <pre><code>systemAttributes:\n- description: SameSite Cookie Attribute\n  name: otds.as.SameSiteCookieVal\n  value: None\n</code></pre>"},{"location":"payload-syntax/#additionalgroupmemberships","title":"additionalGroupMemberships","text":"<p><code>additionalGroupMemberships</code> allows to put a pre-existing users or groups into existing OTDS groups. Each element consists of a <code>parent_group</code> value combined with either a <code>group_name</code> or <code>user_name</code> value depending whether you wannt to add a user or group.</p> Terraform / HCLYAML <pre><code>additionalGroupMemberships = [\n  {\n    parent_group = \"Business Administrators@Content Server Members\"\n    user_name    = \"otadmin@otds.admin\"\n  }\n]\n</code></pre> <pre><code>additionalGroupMemberships:\n- parent_group: Business Administrators@Content Server Members\n  user_name: otadmin@otds.admin\n</code></pre>"},{"location":"payload-syntax/#additionalaccessrolememberships","title":"additionalAccessRoleMemberships","text":"<p><code>additionalAccessRoleMemberships</code> allows to put pre-existing users for groups into existing OTDS Access Roles. Each element consists of a <code>access_role</code> value combined with either a <code>group_name</code>, <code>user_name</code>, or <code>partition_name</code> value depending whether you wannt to add a user, group, or a whole OTDS partition to the OTDS Access Role.</p> Terraform / HCLYAML <pre><code>additionalAccessRoleMemberships = [\n  {\n    access_role = \"Access to cs\"\n    group_name  = \"otdsadmins@otds.admin\"\n  },\n  {\n    # Add the Content Server Members partition to the AppworksGateway access role\n    enabled        = var.enable_appworks_gateway\n    access_role    = \"Access to gatewayresource\"\n    partition_name = \"Content Server Members\"\n  }\n]\n</code></pre> <pre><code>additionalAccessRoleMemberships:\n- access_role: Access to cs\n  group_name: otdsadmins@otds.admin\n- access_role: Access to gatewayresource\n  enabled: ${var.enable_appworks_gateway}\n  partition_name: Content Server Members\n</code></pre>"},{"location":"payload-syntax/#extended-ecm-customizing-syntax","title":"Extended ECM Customizing Syntax","text":"<p>The payload syntax for Extended ECM configurations uses these lists (most elements are maps, some are plain strings):</p>"},{"location":"payload-syntax/#groups","title":"groups","text":"<p><code>groups</code> is a list of Extended ECM user groups that are automatically created during the deployment. Each group has a name and (optionally) a list of parent groups. The switch <code>enabled</code> is used to turn groups on or off. This switch can be controlled by a Terraform variable. <code>enable_o365</code> is used to control whether or not a Microsoft 365 group should be created matching the Extended ECM group. The example below shows two groups. The <code>Finance</code> group is a child group of the <code>Innovate</code> group. The <code>Finance</code> group is also created in Microsoft 365 if the variable <code>var.enable_o365</code> evaluates to <code>true</code>.</p> Terraform / HCLYAML <pre><code>groups = [\n  {\n    name          = \"Innovate\"\n    parent_groups = []\n  },\n  {\n    name          = \"Finance\"\n    parent_groups = [\"Innovate\"]\n    enable_o365   = var.enable_o365\n  }\n]\n</code></pre> <pre><code>groups:\n- name: Innovate\n  parent_groups: []\n- enable_o365: ${var.enable_o365}\n  name: Finance\n  parent_groups:\n  - Innovate\n</code></pre>"},{"location":"payload-syntax/#users","title":"users","text":"<p><code>users</code> is a list of Extended ECM users that are automatically created during deployment. The password of these users is randomly generated and can be printed by <code>terraform output -json</code> (all users have the same password). Each user need to have a base group that must be in the <code>groups</code> section of the payload. Optionally a user can have a list of additional groups. A user can also have a list of favorites. Favorites can either be the logical name of a workspace instance used in the payload (see workspace below) or it can be a nickname of an Extended item. Users can also have a security clearance level and multiple supplementatal markings. Both are optional. <code>security_clearance</code> is used to define the security clearance level of the user. This needs to match one of the existing security clearnace levels that have been defined in the <code>securityClearances</code>section in the payload. <code>supplemental_markings</code> defines a list of supplemental markings the user should get. These need to match markings defined in the <code>supplementalMarkings</code> section in the payload. The field <code>privileges</code> defines the standard privileges of a user. If it is omitted users get the default privileges <code>[\"Login\", \"Public Access\"]</code>. The customizing module is also able to automatically configure Microsoft 365 users for each Extended ECM user. To make this work, the Terraform variable for Office 365 / Microsoft 365 need to be configured. In particular <code>var.enable_o365</code> needs to be <code>true</code>. In the user settings <code>enable_o365</code> has to be set to <code>true</code> as well (or you use the variable <code>var.enable_o365</code> if the payload is in the <code>customization.tf</code> file). <code>m365_skus</code> defines a list of Microsoft 365 SKUs that should be assigned to the user. These are the technical SKU IDs that are documented by Microsoft: Licensing Service Plans. Inside the <code>customizing.tf</code> file you also find a convinient map called <code>m365_skus</code> that map the SKU ID to readable names (such as \"Microsoft 365 E3\" or \"Microsoft 365 E5\").</p> Terraform / HCLYAML <pre><code>users = [\n  {\n    name                  = \"adminton\"\n    password              = local.password\n    firstname             = \"Adam\"\n    lastname              = \"Minton\"\n    email                 = \"adminton@innovate.com\"\n    title                 = \"Administrator\"\n    base_group            = \"Administration\"\n    groups                = [\"IT\"]\n    favorites             = [\"workspace-a\", \"nickname-a\"]\n    security_clearance    = 50\n    supplemental_markings = [\"EUZONE\"]\n    privileges            = [\"Login\", \"Public Access\", \"Content Manager\", \"Modify Users\", \"Modify Groups\", \"User Admin Rights\", \"Grant Discovery\", \"System Admin Rights\"]\n    enable_o365           = var.enable_o365\n    m365_skus             = [var.m365_skus[\"Microsoft 365 E3\"]]\n    extra_attributes = [\n        {\n          name  = \"oTExtraAttr0\"\n          value = \"adminton${var.salesforce_username_suffix}\"\n        }\n    ]\n  },\n  {\n    name                  = \"nwheeler\"\n    password              = local.password\n    firstname             = \"Nick\"\n    lastname              = \"Wheeler\"\n    email                 = \"nwheeler@innovate.com\"\n    title                 = \"Sales Director\"\n    base_group            = \"Sales\"\n    groups                = [\"Manager\", \"Office365\"]\n    favorites             = [\"workspace-b\", \"nickname-b\"]\n    security_clearance    = 95\n    supplemental_markings = [\"EU-GDPR-PD\", \"EUZONE\"]\n  }\n]\n</code></pre> <pre><code>users:\n- base_group: Administration\n  email: adminton@innovate.com\n  enable_o365: ${var.enable_o365}\n  extra_attributes:\n  - name: oTExtraAttr0\n    value: adminton${var.salesforce_username_suffix}\n  favorites:\n  - workspace-a\n  - nickname-a\n  firstname: Adam\n  groups:\n  - IT\n  lastname: Minton\n  m365_skus:\n  - ${var.m365_skus[\"Microsoft 365 E3\"]}\n  name: adminton\n  password: ${local.password}\n  privileges:\n  - Login\n  - Public Access\n  - Content Manager\n  - Modify Users\n  - Modify Groups\n  - User Admin Rights\n  - Grant Discovery\n  - System Admin Rights\n  security_clearance: 50\n  supplemental_markings:\n  - EUZONE\n  title: Administrator\n- base_group: Sales\n  email: nwheeler@innovate.com\n  favorites:\n  - workspace-b\n  - nickname-b\n  firstname: Nick\n  groups:\n  - Manager\n  - Office365\n  lastname: Wheeler\n  name: nwheeler\n  password: ${local.password}\n  security_clearance: 95\n  supplemental_markings:\n  - EU-GDPR-PD\n  - EUZONE\n  title: Sales Director\n</code></pre>"},{"location":"payload-syntax/#items","title":"items","text":"<p><code>items</code> and <code>itemsPost</code> are lists of Extended ECM items such as folders, shortcuts or URLs that should be created automatically but are not included in transports. All items are created in the <code>Enterprise Workspace</code> of Extended ECM or any subfolder. Each item needs to have <code>name</code> and <code>type</code> values. The parent ID of the item can either be specified by a nick name (<code>parent_nickname</code>) or by the path in the Enterprise Workspace (<code>parent_path</code>). The value <code>parent_path</code> is a list of folder names starting from the root level in the Enterprise Workspaces. <code>parent_path = [\"Administration\", \"WebReports\"]</code> creates the item in the <code>Websites</code> folder which is itself in the <code>Administration</code> top-level folder. The list <code>items</code> is processed at the beginning of the automation (before transports are applied) and <code>itemsPost</code> is applied at the end of the automation (after transports have been applied).</p> Terraform / HCLYAML <pre><code>items = [\n    {\n      parent_nickname   = \"\" # empty string = not set\n      parent_path       = [\"Administration\", \"WebReports\"]\n      name              = \"Case Management\"\n      description       = \"Case Management with eFiles and eCases\"\n      type              = var.otcs_item_types[\"Folder\"]\n      url               = \"\" # \"\" = not set\n      original_nickname = 0  # 0 = not set\n      original_path     = [] # [] = not set\n    },\n]\n\nitemsPost = [\n  {\n    parent_nickname = \"\" # empty string = not set\n    parent_path = [\n      \"Administration\", \"Websites\"\n    ]\n    name              = \"OpenText Homepage\"\n    description       = \"The OpenText web site\"\n    type              = var.otcs_item_types[\"URL\"]\n    url               = \"https://www.opentext.com\"\n    original_nickname = 0  # 0 = not set\n    original_path     = [] # [] = not set\n  }\n]\n</code></pre> <pre><code>items:\n- description: Case Management with eFiles and eCases\n  name: Case Management\n  original_nickname: 0\n  original_path: []\n  parent_nickname: ''\n  parent_path:\n  - Administration\n  - WebReports\n  type: ${var.otcs_item_types[\"Folder\"]}\n  url: ''\nitemsPost:\n- description: The OpenText web site\n  name: OpenText Homepage\n  original_nickname: 0\n  original_path: []\n  parent_nickname: ''\n  parent_path:\n  - Administration\n  - Websites\n  type: ${var.otcs_item_types[\"URL\"]}\n  url: https://www.opentext.com\n</code></pre>"},{"location":"payload-syntax/#permissions","title":"permissions","text":"<p><code>permissions</code> and <code>permissionsPost</code> are both lists of Exteneded ECM items, each with a specific permission set that should be applied to the item. The item can be specified via a path (list of folder names in Enterprise workspace in top-down order), via a nickname, or via a volume. Permission values are listed as list strings in <code>[...]</code> for <code>owner_permissions</code>, <code>owner_group_permissions</code>, or <code>public_permissions</code>. They can be a combination of the following values: <code>see</code>, <code>see_contents</code>, <code>modify</code>, <code>edit_attributes</code>, <code>add_items</code>, <code>reserve</code>, <code>add_major_version</code>, <code>delete_versions</code>, <code>delete</code>, and <code>edit_permissions</code>. The <code>apply_to</code> specifies if the permissions should only be applied to the item itself (value 0) or only to sub-items (value 1) or the item and its sub-items (value 2). The list specified by <code>permissions</code> is applied before the transport packages are applied and <code>permissionsPost</code> is applied after the transport packages have been processed.</p> Terraform / HCLYAML <pre><code>permissions = [\n  {\n    path = [\"...\", \"...\"]\n    volume = \"...\"   # identified by volume type ID\n    nickname = \"...\" # an item with this nick name needs to exist\n    owner_permissions = []\n    owner_group_permissions = []\n    public_permissions = [\"see\", \"see_content\"]\n    groups = [\n        {\n          name = \"...\"\n          permissions = []\n        }\n    ]\n    users = [\n        {\n          name = \"...\"\n          permissions = []\n        }\n    ]\n    apply_to = 2\n  }\n]\n</code></pre> <pre><code>permissions:\n- apply_to: 2\n  groups:\n  - name: '...'\n    permissions: []\n  nickname: '...'\n  owner_group_permissions: []\n  owner_permissions: []\n  path:\n  - '...'\n  - '...'\n  public_permissions:\n  - see\n  - see_content\n  users:\n  - name: '...'\n    permissions: []\n  volume: '...'\n</code></pre>"},{"location":"payload-syntax/#renamings","title":"renamings","text":"<p><code>renamings</code> is a list of Extended ECM items (e.g. volume names) that are automatically renamed during deployment. You have to either provide the <code>nodeid</code> (only a few node IDs are really know upfront such as 2000 for the Enterprise Workspace) or a <code>volume</code> (type ID). In case of volumes there's a list of known volume types defined at the beginning of the <code>customizing.tf</code> file with the variable <code>otcs_volumes</code>. You can also specific a description that will be used to update the description of the node / item.</p> Terraform / HCLYAML <pre><code>renamings = [\n  {\n    nodeid      = 2000\n    name        = \"Innovate\"\n    description = \"Innovate's Enterprise Workspace\"\n  },\n  {\n    volume      = var.otcs_volumes[\"Content Server Document Templates\"]\n    name        = \"Content Server Document Templates\"\n    description = \"Extended ECM Workspace and Document Templates\"\n  }\n]\n</code></pre> <pre><code>renamings:\n- description: Innovate's Enterprise Workspace\n  name: Innovate\n  nodeid: 2000\n- description: Extended ECM Workspace and Document Templates\n  name: Content Server Document Templates\n  volume: ${var.otcs_volumes[\"Content Server Document Templates\"]}\n</code></pre>"},{"location":"payload-syntax/#adminsettings","title":"adminSettings","text":"<p><code>adminSettings</code> and <code>adminSettingsPost</code> are lists admin stettings that are applied before the transport packages (<code>adminSettings</code>) or directly after the transport packages (<code>adminSettingsPost</code>) in the customizing process. Each setting is defined by a <code>description</code>, the <code>filename</code> of an XML file that includes the actual Extended ECM admin settings that are applied automatically (using XML import / LLConfig). These files need to be stored inside the <code>setting/payload</code> sub-folder inside the terraform folder. Each admin setting may have a field called <code>enabled</code> that allows to dyanmically turn on / off admin settings based on a boolean value that may be read from a Terraform variable (or could just be <code>False</code> or <code>True</code>).</p> Terraform / HCLYAML <pre><code>adminSettings = [\n  {\n    description = \"Apply minimum settings for Government Desktop (Inbox) that are required before users and groups are created.\"\n    filename    = \"GovernmentSettings-Inbox.xml\", # this needs to happen before users and groups are created\n  },\n  {\n    enabled     = var.enable_o365\n    description = \"These settings are removed by a side-effect during MS Teams automation. We need to re-enable them.\"\n    filename    = \"O365Settings.xml\",\n  }\n]\nadminSettingsPost = [\n  {\n    description = \"Apply Document Template settings that are dependent on Classification elements.\"\n    filename    = \"DocumentTemplatesSettings.xml\"\n  },\n]\n</code></pre> <pre><code>adminSettings:\n- description: Apply minimum settings for Government Desktop (Inbox) that are required\n    before users and groups are created.\n  filename: GovernmentSettings-Inbox.xml\n- description: These settings are removed by a side-effect during MS Teams automation.\n    We need to re-enable them.\n  enabled: ${var.enable_o365}\n  filename: O365Settings.xml\nadminSettingsPost:\n- description: Apply Document Template settings that are dependent on Classification\n    elements.\n  filename: DocumentTemplatesSettings.xml\n</code></pre>"},{"location":"payload-syntax/#externalsystems","title":"externalSystems","text":"<p><code>externalSystems</code> is a list of connections to external business applications such as SAP S/4HANA, Salesforce, or SuccessFactors. Some of the fields are common, some are specific for the type of the external system. Each external system has a field called <code>enabled</code> that allows to dyanmically turn on / off external system configurations based on a boolean value that may be read from a Terraform variable (or could just be <code>False</code> or <code>True</code>). The field <code>external_system_type</code> needs to have one of these values: <code>SAP</code>, <code>Salesforce</code>, <code>SuccessFactors</code>, or <code>AppWorks Platform</code>.</p> Terraform / HCLYAML <pre><code>externalSystems = [\n  {\n    enabled                  = var.enable_sap\n    external_system_type     = \"SAP\"\n    external_system_name     = \"TM6\"\n    external_system_number   = var.sap_external_system_number\n    description              = \"SAP S/4HANA on-premise\"\n    as_url                   = \"https://tmcerp1.eimdemo.biz:8443/sap/bc/srt/xip/otx/ecmlinkservice/100/ecmlinkspiservice/basicauthbinding\"\n    base_url                 = \"https://tmcerp1.eimdemo.biz:8443\"\n    client                   = var.sap_external_system_client\n    username                 = \"demo\"\n    password                 = local.password\n    certificate_file         = \"/certificates/TM6.pse\"\n    certificate_password     = \"topsecret\"\n    destination              = var.sap_external_system_destination\n    archive_logical_name     = var.sap_archive_logical_name\n    archive_certificate_file = \"/certificates/${var.sap_archive_certificate_file}\"\n  },\n  {\n    enabled                = var.enable_salesforce\n    external_system_type   = \"Salesforce\"\n    external_system_name   = \"SFDC-HTTP\"\n    description            = \"Salesforce\"\n    as_url                 = \"https://idea02dev-dev-ed.my.salesforce.com/services/Soap/c/48.0/\"\n    base_url               = \"https://idea02dev-dev-ed.my.salesforce.com\"\n    username               = \"idea02a2dev@opentext.com\"\n    password               = local.password\n    oauth_client_id        = \"...\"\n    oauth_client_secret    = \"...\"\n    authorization_endpoint = \"https://salesforce.com/services/oauth2/authorize\"\n    token_endpoint         = \"https://salesforce.com/services/oauth2/token\"\n  },\n  {\n    enabled              = var.enable_successfactors\n    external_system_type = \"SuccessFactors\"\n    external_system_name = \"SuccessFactors\"\n    description          = \"SAP SuccessFactors\"\n    as_url               = \"https://apisalesdemo8.successfactors.com/odata/v2\"\n    base_url             = \"https://pmsalesdemo8.successfactors.com\"\n    username             = \"sfadmin@SFPART035780\"\n    password             = local.password\n    saml_url             = \"https://salesdemo.successfactors.eu/idp/samlmetadata?company=SFSALES004711\"\n    otds_sp_endpoint     = \"https://otds.xecm-cloud.com/otdsws\"\n    oauth_client_id      = \"...\"\n    oauth_client_secret  = \"...\"\n  }\n]\n</code></pre> <pre><code>externalSystems:\n- archive_logical_name: ${var.sap_archive_logical_name}\n  archive_certificate_file: \"/certificates/${var.sap_archive_certificate_file}\"\n  as_url: https://tmcerp1.eimdemo.biz:8443/sap/bc/srt/xip/otx/ecmlinkservice/100/ecmlinkspiservice/basicauthbinding\n  base_url: https://tmcerp1.eimdemo.biz:8443\n  certificate_file: /certificates/TM6.pse\n  certificate_password: topsecret\n  client: ${var.sap_external_system_client}\n  description: SAP S/4HANA on-premise\n  destination: ${var.sap_external_system_destination}\n  enabled: ${var.enable_sap}\n  external_system_name: TM6\n  external_system_type: SAP\n  password: ${local.password}\n  username: demo\n- as_url: https://idea02dev-dev-ed.my.salesforce.com/services/Soap/c/48.0/\n  authorization_endpoint: https://salesforce.com/services/oauth2/authorize\n  base_url: https://idea02dev-dev-ed.my.salesforce.com\n  description: Salesforce\n  enabled: ${var.enable_salesforce}\n  external_system_name: SFDC-HTTP\n  external_system_type: Salesforce\n  oauth_client_id: '...'\n  oauth_client_secret: '...'\n  password: ${local.password}\n  token_endpoint: https://salesforce.com/services/oauth2/token\n  username: idea02a2dev@opentext.com\n- as_url: https://apisalesdemo8.successfactors.com/odata/v2\n  base_url: https://pmsalesdemo8.successfactors.com\n  description: SAP SuccessFactors\n  enabled: ${var.enable_successfactors}\n  external_system_name: SuccessFactors\n  external_system_type: SuccessFactors\n  oauth_client_id: '...'\n  oauth_client_secret: '...'\n  otds_sp_endpoint: https://otds.xecm-cloud.com/otdsws\n  password: ${local.password}\n  saml_url: https://salesdemo.successfactors.eu/idp/samlmetadata?company=SFSALES004711\n  username: sfadmin@SFPART035780\n</code></pre>"},{"location":"payload-syntax/#transportpackages","title":"transportPackages","text":"<p><code>transportPackages</code> is a list of transport packages that should be applied automatically. These packages need to be accessible via the provided URLs. The <code>name</code> must be the exact file name of the ZIP package. Description is optional.</p> Terraform / HCLYAML <pre><code>transportPackages = [\n    {\n      enabled     = true\n      url         = \"https://terrarium.blob.core.windows.net/transports/Terrarium-010-Categories.zip\"\n      name        = \"Terrarium 010 Categories.zip\"\n      description = \"Terrarium Category definitions\"\n    },\n    {\n      url         = \"https://terrarium.blob.core.windows.net/transports/Terrarium-020-Classifications.zip\"\n      name        = \"Terrarium 20 Classifications.zip\"\n      description = \"Terrarium Classification definitions\"\n    },\n    {\n      enabled     = var.enable_sap\n      url         = \"${var.transporturl}/Terrarium-110-Business-Object-Types-SAP.zip\"\n      name        = \"Terrarium 110 Business Object Types (SAP).zip\"\n      description = \"Terrarium Business Object types for SAP\"\n      extractions = [\n        {\n          enabled = true\n          xpath   = \"/livelink/llnode[@objtype='889']\"\n        }\n      ]\n    },\n    {\n      enabled     = var.enable_o365\n      url         = \"${var.transporturl}/Terrarium-115-Scheduled-Processing-Microsoft.zip\"\n      name        = \"Terrarium 115 Scheduled Processing (Microsoft).zip\"\n      description = \"Terrarium Scheduled Processing Jobs for Microsoft Office 365\"\n      replacements = [\n        {\n          placeholder = \"M365x62444544.onmicrosoft.com\"\n          value       = var.o365_domain\n        },\n        {\n          placeholder = \"M365x61936377.onmicrosoft.com\"\n          value       = var.o365_domain\n        }\n      ]\n    }\n]\n</code></pre> <pre><code>transportPackages:\n- description: Terrarium Category definitions\n  name: Terrarium 010 Categories.zip\n  url: https://terrarium.blob.core.windows.net/transports/Terrarium-010-Categories.zip\n- description: Terrarium Classification definitions\n  name: Terrarium 20 Classifications.zip\n  url: https://terrarium.blob.core.windows.net/transports/Terrarium-020-Classifications.zip\n</code></pre>"},{"location":"payload-syntax/#contenttransportpackages","title":"contentTransportPackages","text":"<p><code>contentTransportPackages</code> is a list of content transport packages that should be automatically applied. Content Transport Package typically are used to import documents into workspaces that are created before. These packages need to be accessible via the provided URLs. The <code>name</code> must be the exact file name of the ZIP package. Description is optional. Other than the <code>transportPackages</code> these transports are deployed after users and wrkspace instances have been processed. This allows to transport content into workspaces instances or use users inside thse transport packages (e.g. owners, user attributes, etc.)</p> Terraform / HCLYAML <pre><code>contentTransportPackages = [\n  {\n    url         = \"${var.transporturl}/Terrarium-300-Government-Content.zip\"\n    name        = \"Terrarium 300 Government Content.zip\"\n    description = \"Terrarium demo documents for Government scenario\"\n  },\n  {\n    url         = \"${var.transporturl}/Terrarium-310-Enterprise-Asset-Management-Content.zip\"\n    name        = \"Terrarium 310 Enterprise Asset Management Content.zip\"\n    description = \"Terrarium demo documents for Enterprise Asset Management scenario\"\n  }\n]\n</code></pre> <pre><code>contentTransportPackages:\n- description: Terrarium demo documents for Government scenario\n  name: Terrarium 300 Government Content.zip\n  url: ${var.transporturl}/Terrarium-300-Government-Content.zip\n- description: Terrarium demo documents for Enterprise Asset Management scenario\n  name: Terrarium 310 Enterprise Asset Management Content.zip\n  url: ${var.transporturl}/Terrarium-310-Enterprise-Asset-Management-Content.zip\n</code></pre>"},{"location":"payload-syntax/#workspaces","title":"workspaces","text":"<p><code>workspaces</code> is a list of business workspaces instances that should be automatically created. Category, Roles, and Business Relationships can be provided. The <code>id</code> needs to be a unique value in the payload. It does not need to be something related to any of the actual Extended ECM workspace data. It is only used to establish relationship between different workspaces in the payload (using the list of IDs in <code>relationships</code>). Important: If the workspace type definition uses a pattern to generate the workspace name then the <code>name</code> in the payload should match the pattern in the workspace definition. Otherwise incremental deployments of the payload may not find the existing workspaces and may try to recreate them resulting in an error. The <code>nickname</code> is the Extended ECM nickname that allows to refer to this itemwithout knowing its technical ID.</p> <p>Business Object information can be provided with a <code>business_objects</code> list. Each list item defines the external system (see above), the business object type, and business object ID. This list is optional.</p> <p>Roles and membership information is provided with the <code>members</code> list. Each list item defines membership for a single workspace role which is defined with <code>role</code>. Members can be defined by two lists: <code>users</code> and <code>groups</code>. In the first example below the role <code>Sales Representative</code> is populated with user <code>nwheeler</code> and with the groups <code>Sales</code> and <code>Management</code>.</p> <p>Classification information is optional and can be provided separately for Records Management classifications and normal/regular classifications. Both types of classifications need to be provided as pathes inside the respective classifications trees (top down). There can be only one Records Management classification but multiple regular classifications. That's why the element <code>classification_pathes</code> is a list of pathes.</p> <p>Category information is provided in a list of blocks. Each block includes the category <code>name</code>, <code>set</code> name (optional, can be empty of the attribute is not in a set), <code>attribute</code> name, and the attribute <code>value</code>. Multi-value attributes are a comma-separated list of items in square brackets. The example below shows a customer workspace and a contract workspace that are related to each other (the customer workspace has an attribute <code>Sales Organization</code> that has multiple values: 1000 and 2000). The contract workspace has a multi-line attribute set. For multi-line attribute sets the payload needs an additional <code>row</code> value that specifies the row number in the multi-line set (starting with 1 for the first row).</p> <p>A thrid workspace in the example below is for <code>Material</code> - it has an additional field called <code>template_name</code> which is optional. It can be used if there are multiple templates for one workspace type. If it is not specified and the workspace type has multiple workspace templates the first template is automatically selected.</p> Terraform / HCLYAML <pre><code>workspaces = [\n  {\n    id          = \"50031\"\n    name        = \"Global Trade AG (50031)\"\n    nickname    = \"ws_customer_global_trade\"\n    description = \"Strategic customer in Germany\"\n    type_name   = \"Customer\"\n    template_name = \"Customer\"\n    business_objects = [\n        {\n          external_system = var.sap_external_system_name\n          bo_type         = \"KNA1\"\n          bo_id           = \"0000050031\"\n        }\n    ]\n    members = [\n        {\n          role   = \"Sales Representative\"\n          users  = [\"nwheeler\"]\n          groups = [\"Sales\", \"Management\"]\n        }\n    ]\n    classification_pathes = []\n    rm_classification_path = [\n        \"RM Classifications\",\n        \"Case Management\",\n        \"Building Authorities\",\n        \"01.Buildings\",\n        \"01.Building applications\",\n        \"02.Alteration and repair\",\n    ]\n    categories = [\n        {\n          name      = \"Customer\"\n          set       = \"\"\n          attribute = \"Customer Number\"\n          value     = \"50031\"\n        },\n        {\n          name      = \"Customer\"\n          set       = \"\"\n          attribute = \"Sales organisation\"\n          value     = [\"1000\", \"2000\"]\n        },\n        {\n          name      = \"Customer\"\n          set       = \"Rating\"\n          attribute = \"Institute\"\n          value     = \"Dun &amp; Bradstreet\"\n        }\n    ]\n    relationships = [\n        \"0040000019\"\n    ]\n  },\n  {\n    id          = \"0040000019\"\n    name        = \"0040000019 - Global Trade AG\"\n    description = \"\"\n    type_name   = \"Sales Contract\"\n    members = [\n        {\n          role  = \"Contract Manager\"\n          users = [\"dfoxhoven\"]\n        }\n    ]\n    categories = [\n        {\n          name      = \"Contract\"\n          set       = \"Contract Data\"\n          attribute = \"Function\"\n          value     = \"Sales\"\n        },\n        {\n          name      = \"Contract\"\n          set       = \"Contract Data\"\n          attribute = \"Contract Number\"\n          value     = \"0040000019\"\n        },\n        {\n          name      = \"Contract\"\n          set       = \"Contract Line Items\"\n          row       = 1\n          attribute = \"Material Number\"\n          value     = \"P-100\"\n        }\n    ]\n  },\n  {\n    id            = \"R-9010\"\n    name          = \"R-9010 - Notebook WebCam Model '16\"\n    description   = \"\"\n    type_name     = \"Material\"\n    template_name = \"Material (Operating Supplies)\"\n    members = [\n      {\n        role  = \"Master Data Management\"\n        users = [\"kmurray\"]\n      }\n    ]\n    categories = [\n      {\n        name      = \"Material\"\n        set       = \"\"\n        attribute = \"Material Number\"\n        value     = \"R-9010\"\n      },\n      {\n        name      = \"Material\"\n        set       = \"\"\n        attribute = \"Material Description\"\n        value     = \"Notebook WebCam Model '16\"\n      }\n    ]\n  }\n]\n</code></pre> <pre><code>workspaces:\n- business_objects:\n  - bo_id: '0000050031'\n    bo_type: KNA1\n    external_system: ${var.sap_external_system_name}\n  categories:\n  - attribute: Customer Number\n    name: Customer\n    set: ''\n    value: '50031'\n  - attribute: Sales organisation\n    name: Customer\n    set: ''\n    value:\n    - '1000'\n    - '2000'\n  - attribute: Institute\n    name: Customer\n    set: Rating\n    value: Dun &amp; Bradstreet\n  classification_pathes: []\n  description: Strategic customer in Germany\n  id: '50031'\n  members:\n  - groups:\n    - Sales\n    - Management\n    role: Sales Representative\n    users:\n    - nwheeler\n  name: Global Trade AG (50031)\n  relationships:\n  - 0040000019\n  rm_classification_path:\n  - RM Classifications\n  - Case Management\n  - Building Authorities\n  - 01.Buildings\n  - 01.Building applications\n  - 02.Alteration and repair\n  template_name: Customer\n  type_name: Customer\n- categories:\n  - attribute: Function\n    name: Contract\n    set: Contract Data\n    value: Sales\n  - attribute: Contract Number\n    name: Contract\n    set: Contract Data\n    value: 0040000019\n  - attribute: Material Number\n    name: Contract\n    row: 1\n    set: Contract Line Items\n    value: P-100\n  description: ''\n  id: 0040000019\n  members:\n  - role: Contract Manager\n    users:\n    - dfoxhoven\n  name: 0040000019 - Global Trade AG\n  type_name: Sales Contract\n- categories:\n  - attribute: Material Number\n    name: Material\n    set: ''\n    value: R-9010\n  - attribute: Material Description\n    name: Material\n    set: ''\n    value: Notebook WebCam Model '16\n  description: ''\n  id: R-9010\n  members:\n  - role: Master Data Management\n    users:\n    - kmurray\n  name: R-9010 - Notebook WebCam Model '16\n  template_name: Material (Operating Supplies)\n  type_name: Material\n</code></pre>"},{"location":"payload-syntax/#webreports","title":"webReports","text":"<p><code>webReports</code> and <code>webReportsPost</code> are two lists of Extended ECM web reports that should be automatically executed during deployment. Having two lists give you the option to run some webReports after the business configuration and some others after demo content has been produced. These Web Reports have typically been deployd to Extended ECM system with the transport warehouse before. Each list item specifies one Web Report. The <code>nickname</code> is mandatory and defines the nickname of the Web Report to be executed. So you need to give each webReport you want to run a nickname before putting it in a transport package. The element <code>description</code> is optional. The <code>parameters</code> set defines parameter name and parameter value pairs. The corresponding Web Report in Extended ECM must have exactly these parameters defined.</p> Terraform / HCLYAML <pre><code>webReports = [\n  {\n    nickname    = \"web_report_unset_xgov_doc_view\"\n    description = \"Web Report to disable the Brava document view side bar\"\n    parameters = {\n        \"user_name\" = \"swang\"\n    }\n  },\n  {\n    nickname    = \"web_report_set_cust_sf\"\n    description = \"Web Report to auto-configure Extended ECM for SuccessFactors Module Specific Settings\"\n  }\n]\n\nwebReportsPost = [\n  {\n    nickname    = \"web_report_set_cust_sf\"\n    description = \"Web Report to auto-configure Extended ECM for SuccessFactors Module Specific Settings\"\n  }\n]\n</code></pre> <pre><code>webReports:\n- description: Web Report to disable the Brava document view side bar\n  nickname: web_report_unset_xgov_doc_view\n  parameters:\n    user_name: swang\n- description: Web Report to auto-configure Extended ECM for SuccessFactors Module\n    Specific Settings\n  nickname: web_report_set_cust_sf\nwebReportsPost:\n- description: Web Report to auto-configure Extended ECM for SuccessFactors Module\n    Specific Settings\n  nickname: web_report_set_cust_sf\n</code></pre>"},{"location":"payload-syntax/#csapplications","title":"csApplications","text":"<p><code>csApplications</code> is a list of Content Server Applications that should autmatically be deployed. Each element has a <code>name</code> for the application and optionally a <code>description</code>.</p> Terraform / HCLYAML <pre><code>csApplications = [\n  {\n    name        = \"OTPOReports\"\n    description = \"OpenText Physical Objects Reports\"\n  },\n  {\n    name        = \"OTRMReports\"\n    description = \"OpenText Records Management Reports\"\n  },\n  {\n    name        = \"OTRMSecReports\"\n    description = \"OpenText Security Clearance Reports\"\n  }\n]\n</code></pre> <pre><code>csApplications:\n- description: OpenText Physical Objects Reports\n  name: OTPOReports\n- description: OpenText Records Management Reports\n  name: OTRMReports\n- description: OpenText Security Clearance Reports\n  name: OTRMSecReports\n</code></pre>"},{"location":"payload-syntax/#assignments","title":"assignments","text":"<p><code>assignments</code> is a list of assignments. Assignments are typically used for Extended ECM for Government. Each assignment assigns either a <code>workspace</code> or an Extended ECM item with a <code>nickname</code> to a defined list of <code>users</code> or <code>groups</code>. Assignments have a <code>subject</code> (title) and <code>instructions</code> for the target users or groups.</p> Terraform / HCLYAML <pre><code>assignments = [\n  {\n    subject     = \"Assignment on building extension M6P 1Y7-02-001-00001\"\n    instruction = \"Please review this building extension\"\n    workspace   = \"1063938\"\n    nickname    = \"\"\n    users       = [\"swang\", \"gbecker\"]\n    groups      = [\"Case Management\"]\n  }\n]\n</code></pre> <pre><code>assignments:\n- groups:\n  - Case Management\n  instruction: Please review this building extension\n  nickname: ''\n  subject: Assignment on building extension M6P 1Y7-02-001-00001\n  users:\n  - swang\n  - gbecker\n  workspace: '1063938'\n</code></pre>"},{"location":"payload-syntax/#workspacetemplateregistrations","title":"workspaceTemplateRegistrations","text":"<p><code>workspaceTemplateRegistrations</code> is used to register certain workspace templates for the use as projects in Extended ECM for Engineering demo scenarios. Each registration has two mandatory fields. <code>workspace_type_name</code> defines the name of the workspace type and <code>workspace_template_name</code> defines the specific name of the workspace templates (as each workspace type may have multiple templates).</p> Terraform / HCLYAML <pre><code>  workspaceTemplateRegistrations = [\n    {\n      workspace_type_name     = \"SAP PPM Project\"\n      workspace_template_name = \"Project\"\n    }\n  ]\n</code></pre> <pre><code>workspaceTemplateRegistrations:\n- workspace_template_name: Project\n  workspace_type_name: SAP PPM Project\n</code></pre>"},{"location":"payload-syntax/#advanced-customizing-syntax","title":"Advanced Customizing Syntax","text":"<p>For advanced use cases that are not covered by Extended ECM or OTDS APIs, there are additional customizing capabilities. This includes calling SAP Remote Function Calls (RFC), executing commands in the Kubernetes Pods or triggering web hooks (HTTP POST requests):</p>"},{"location":"payload-syntax/#execpodcommands","title":"execPodCommands","text":"<p><code>execPodCommands</code> is used to execute a Linux command inside a Kubernetes pod using the Kubernetes API (similar to what <code>kubectl exec</code> does). This may be handy to influence / change some of the intrinsics of the pods. If <code>eanbled</code> evaluates to <code>true</code> then the command will be called during the customization process. The <code>pod_name</code> must match is technical name of the pod in the Kubernetes deployment (you can get the pod names with <code>kubectl get pods</code>). <code>command</code> is a list of the command terms and parameters. The first element is typically the Linux shell that is used for executing the command and the second parameter is typically <code>-c</code> if the command is run in non-interactive mode. <code>interactive</code> defines if the command is run interactively or not. The default is to run the command non-interactively. Only for longer running commands you should prefer to run the command interactively.</p> Terraform / HCLYAML <pre><code>execPodCommands = [\n    {\n      enabled     = false\n      description = \"Test\"\n      pod_name    = \"otcs-admin-0\"\n      command     = [\"/bin/sh\", \"-c\", \"touch /tmp/python_was_here\"]\n      interactive = false\n    }\n]\n</code></pre> <pre><code>execPodCommands:\n- command:\n  - /bin/sh\n  - -c\n  - touch /tmp/python_was_here\n  description: Test\n  enabled: false\n  interactive: false\n  pod_name: otcs-admin-0\n</code></pre>"},{"location":"payload-syntax/#webhooks","title":"webHooks","text":"<p><code>webHooks</code> and <code>webHooksPost</code> are used to call (HTTP request) defined URLs that may trigger certain activities as webhooks. <code>webHooks</code> is called at the beginning of the customization process and <code>webHooksPost</code> is called at the end. If <code>eanbled</code> evaluates to <code>true</code> then the weekhook is active. <code>url</code> defines the URL of the web hook. <code>method</code> can we one of the typical HTTP request types (POST, GET, PUT, ...). If it is omitted the default is <code>POST</code>. <code>description</code> should describe the purpose of the web hook. The parameters <code>payload</code> and <code>headers</code> are maps (dictionaries) of name, value pairs. These are passed as additional header or body values to the HTTP request.</p> Terraform / HCLYAML <pre><code>webHooks = [\n  {\n    enabled     = var.enable_sap\n    url         = \"https://.../start_sap\"\n    method      = \"POST\"\n    description = \"Start SAP S/4HANA Web Hook\"\n    payload     = {\n        parameter = \"value\"\n    }\n    headers     = {} # if empty a standard header will be set\n  }\n]\nwebHooksPost = [\n  {\n    enabled     = var.enable_sap\n    url         = \"https://.../stop_sap\"\n    method      = \"POST\"\n    description = \"Stop SAP S/4HANA Web Hook\"\n    payload     = {}\n    headers     = {} # if empty a standard header will be set\n  }\n]\n</code></pre> <pre><code>webHooks:\n- description: Start SAP S/4HANA Web Hook\n  enabled: ${var.enable_sap}\n  headers: {}\n  method: POST\n  payload:\n    parameter: value\n  url: https://.../start_sap\nwebHooksPost:\n- description: Stop SAP S/4HANA Web Hook\n  enabled: ${var.enable_sap}\n  headers: {}\n  method: POST\n  payload: {}\n  url: https://.../stop_sap\n</code></pre>"},{"location":"payload-syntax/#saprfcs","title":"sapRFCs","text":"<p><code>sapRFCs</code> are defining a list of SAP Remote Function Calls (RFC) that are called to automate things in SAP S/4HANA. If <code>eanbled</code> evaluates to <code>true</code> then the RFC will be called during the customization process. <code>name</code> is the technical SAP name of the RFC. <code>description</code> is optional and is just informative. If the RFC requires parameters they can be passed via the <code>parameters</code> block (name, value pairs).</p> Terraform / HCLYAML <pre><code>sapRFCs = [\n    {\n      enabled     = var.enable_sap\n      name        = \"SM02_ADD_MESSAGE\"\n      description = \"Write message into SAP message center\"\n      parameters = {\n          \"MESSAGE\" = \"Start processing Terrarium RFC calls...\"\n      }\n    },\n    {\n      enabled     = var.enable_sap\n      name        = \"ZFM_GECKO_RFC_CR_UPD_ALL_WKSP\"\n      description = \"Create workspace for all SAP Customers (KNA1)\"\n      parameters = {\n          \"OBJECTTYPE\" = \"KNA1\"\n          \"OBJECTKEY\"  = \"\"\n          \"SYNC\"       = \"\"\n      }\n    }\n]\n</code></pre> <pre><code>sapRFCs:\n- description: Write message into SAP message center\n  enabled: ${var.enable_sap}\n  name: SM02_ADD_MESSAGE\n  parameters:\n    MESSAGE: Start processing Terrarium RFC calls...\n- description: Create workspace for all SAP Customers (KNA1)\n  enabled: ${var.enable_sap}\n  name: ZFM_GECKO_RFC_CR_UPD_ALL_WKSP\n  parameters:\n    OBJECTKEY: ''\n    OBJECTTYPE: KNA1\n    SYNC: ''\n</code></pre>"},{"location":"pyxecm/assoc/","title":"Assoc","text":"<p>Extended ECM Assoc Module to implement functions to read / write from so called \"Assoc\" data structures in Extended ECM. Right now this module is used to tweak settings in XML-based transport packages that include Assoc structures inside some of the XML elements.</p> <p>Class: Assoc Methods:</p> <p>stringToDict: convert an Assoc string to an Python dict representing the assoc values dictToString: converting an Assoc dict to an Assoc string</p>"},{"location":"pyxecm/assoc/#pyxecm.helper.assoc.Assoc","title":"<code>Assoc</code>","text":"<p>Class to handle Extended ECM Assoc data structures.</p> Source code in <code>pyxecm/helper/assoc.py</code> <pre><code>class Assoc:\n    \"\"\"Class to handle Extended ECM Assoc data structures.\"\"\"\n\n    @classmethod\n    def is_unicode_escaped(cls, assoc_string: str) -&gt; bool:\n        \"\"\"Determine if a string is unicode escaped.\n\n        Args:\n            assoc_string (str): string with the Assoc data\n\n        Returns:\n            bool: True if string is in Unicode, False otherwise\n        \"\"\"\n\n        pattern = r\"\\\\u[0-9a-fA-F]{4}\"\n        matches = re.findall(pattern, assoc_string)\n\n        return len(matches) &gt; 0\n\n    @classmethod\n    def escape_unicode(cls, assoc_string: str) -&gt; str:\n        \"\"\"Escape / Encode a given string in Unicode\n\n        Args:\n            assoc_string (str): Source string\n\n        Returns:\n            str: Escaped string\n        \"\"\"\n\n        encoded_string = assoc_string.encode(\"unicode_escape\")  # .decode()\n\n        return encoded_string\n\n    @classmethod\n    def unescape_unicode(cls, assoc_string: str) -&gt; str:\n        \"\"\"Unescape / Decode a given string\n\n        Args:\n            assoc_string (str): Source string\n\n        Returns:\n            str: Unescaped string\n        \"\"\"\n        try:\n            decoded_string = bytes(assoc_string, \"utf-8\").decode(\"unicode_escape\")\n            return decoded_string\n        except UnicodeDecodeError:\n            return assoc_string\n\n    @classmethod\n    def is_html_escaped(cls, assoc_string: str) -&gt; bool:\n        decoded_string = html.unescape(assoc_string)\n        return assoc_string != decoded_string\n\n    @classmethod\n    def unescape_html(cls, assoc_string: str) -&gt; str:\n        decoded_string = html.unescape(assoc_string)\n        return decoded_string\n\n    @classmethod\n    def string_to_dict(cls, assoc_string: str) -&gt; dict:\n        \"\"\"Convert an Assoc string to a Python dict.\n           Each comma-separated element of the Assoc will\n           become a dict element.\n\n        Args:\n            assoc_string (str): Source Assoc string\n\n        Returns:\n            dict: Python dict with the Assoc elements\n        \"\"\"\n\n        if cls.is_html_escaped(assoc_string):\n            assoc_string = cls.unescape_html(assoc_string)\n        if cls.is_unicode_escaped(assoc_string):\n            assoc_string = cls.unescape_unicode(assoc_string)\n\n        # Split the string using regex pattern\n        pieces = re.split(r\",(?=(?:[^']*'[^']*')*[^']*$)\", assoc_string)\n\n        # Trim any leading/trailing spaces from each piece\n        pieces = [piece.strip() for piece in pieces]\n\n        # Split the last pieces from the assoc close tag\n        last_piece = pieces[-1].split(\"&gt;\")[0]\n\n        # Remove the first two and last pieces from the list\n        # the first two are mostly \"1\" and \"?\"\n        pieces = pieces[2:-1]\n\n        # Insert the last pieces separately\n        pieces.append(last_piece)\n\n        assoc_dict: dict = {}\n\n        for piece in pieces:\n            name = piece.split(\"=\")[0]\n            if name[0] == \"'\":\n                name = name[1:]\n            if name[-1] == \"'\":\n                name = name[:-1]\n            value = piece.split(\"=\")[1]\n            if value[0] == \"'\":\n                value = value[1:]\n            if value[-1] == \"'\":\n                value = value[:-1]\n            assoc_dict[name] = value\n\n        return assoc_dict\n\n    @classmethod\n    def dict_to_string(cls, assoc_dict: dict) -&gt; str:\n        \"\"\"Convert a Python dict to an Assoc string\n\n        Args:\n            assoc_dict (dict): Source dict\n\n        Returns:\n            str: Assoc string\n        \"\"\"\n\n        assoc_string: str = \"A&amp;lt;1,?,\"\n\n        for item in assoc_dict.items():\n            assoc_string += \"\\u0027\" + item[0] + \"\\u0027\"\n            assoc_string += \"=\"\n            # Extended ECM's XML is a bit special in cases.\n            # If the value is empty set (curly braces) it does\n            # not put it in quotes. As Extended ECM is also very\n            # picky about XML syntax we better produce it exactly like that.\n            if item[1] == \"{}\":\n                assoc_string += item[1] + \",\"\n            else:\n                assoc_string += \"\\u0027\" + item[1] + \"\\u0027,\"\n\n        if assoc_dict.items():\n            assoc_string = assoc_string[:-1]\n        assoc_string += \"&amp;gt;\"\n        return assoc_string\n\n    @classmethod\n    def extract_substring(\n        cls, input_string: str, start_sequence: str, stop_sequence: str\n    ):\n        start_index = input_string.find(start_sequence)\n        if start_index == -1:\n            return None\n\n        end_index = input_string.find(stop_sequence, start_index)\n        if end_index == -1:\n            return None\n\n        end_index += len(stop_sequence)\n        return input_string[start_index:end_index]\n\n    @classmethod\n    def extract_assoc_string(cls, input_string: str, is_escaped: bool = False) -&gt; str:\n        if is_escaped:\n            assoc_string = cls.extract_substring(input_string, \"A&amp;lt;\", \"&amp;gt;\")\n        else:\n            assoc_string = cls.extract_substring(input_string, \"A&lt;\", \"&gt;\")\n        return assoc_string\n</code></pre>"},{"location":"pyxecm/assoc/#pyxecm.helper.assoc.Assoc.dict_to_string","title":"<code>dict_to_string(assoc_dict)</code>  <code>classmethod</code>","text":"<p>Convert a Python dict to an Assoc string</p> <p>Parameters:</p> Name Type Description Default <code>assoc_dict</code> <code>dict</code> <p>Source dict</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Assoc string</p> Source code in <code>pyxecm/helper/assoc.py</code> <pre><code>@classmethod\ndef dict_to_string(cls, assoc_dict: dict) -&gt; str:\n    \"\"\"Convert a Python dict to an Assoc string\n\n    Args:\n        assoc_dict (dict): Source dict\n\n    Returns:\n        str: Assoc string\n    \"\"\"\n\n    assoc_string: str = \"A&amp;lt;1,?,\"\n\n    for item in assoc_dict.items():\n        assoc_string += \"\\u0027\" + item[0] + \"\\u0027\"\n        assoc_string += \"=\"\n        # Extended ECM's XML is a bit special in cases.\n        # If the value is empty set (curly braces) it does\n        # not put it in quotes. As Extended ECM is also very\n        # picky about XML syntax we better produce it exactly like that.\n        if item[1] == \"{}\":\n            assoc_string += item[1] + \",\"\n        else:\n            assoc_string += \"\\u0027\" + item[1] + \"\\u0027,\"\n\n    if assoc_dict.items():\n        assoc_string = assoc_string[:-1]\n    assoc_string += \"&amp;gt;\"\n    return assoc_string\n</code></pre>"},{"location":"pyxecm/assoc/#pyxecm.helper.assoc.Assoc.escape_unicode","title":"<code>escape_unicode(assoc_string)</code>  <code>classmethod</code>","text":"<p>Escape / Encode a given string in Unicode</p> <p>Parameters:</p> Name Type Description Default <code>assoc_string</code> <code>str</code> <p>Source string</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Escaped string</p> Source code in <code>pyxecm/helper/assoc.py</code> <pre><code>@classmethod\ndef escape_unicode(cls, assoc_string: str) -&gt; str:\n    \"\"\"Escape / Encode a given string in Unicode\n\n    Args:\n        assoc_string (str): Source string\n\n    Returns:\n        str: Escaped string\n    \"\"\"\n\n    encoded_string = assoc_string.encode(\"unicode_escape\")  # .decode()\n\n    return encoded_string\n</code></pre>"},{"location":"pyxecm/assoc/#pyxecm.helper.assoc.Assoc.is_unicode_escaped","title":"<code>is_unicode_escaped(assoc_string)</code>  <code>classmethod</code>","text":"<p>Determine if a string is unicode escaped.</p> <p>Parameters:</p> Name Type Description Default <code>assoc_string</code> <code>str</code> <p>string with the Assoc data</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if string is in Unicode, False otherwise</p> Source code in <code>pyxecm/helper/assoc.py</code> <pre><code>@classmethod\ndef is_unicode_escaped(cls, assoc_string: str) -&gt; bool:\n    \"\"\"Determine if a string is unicode escaped.\n\n    Args:\n        assoc_string (str): string with the Assoc data\n\n    Returns:\n        bool: True if string is in Unicode, False otherwise\n    \"\"\"\n\n    pattern = r\"\\\\u[0-9a-fA-F]{4}\"\n    matches = re.findall(pattern, assoc_string)\n\n    return len(matches) &gt; 0\n</code></pre>"},{"location":"pyxecm/assoc/#pyxecm.helper.assoc.Assoc.string_to_dict","title":"<code>string_to_dict(assoc_string)</code>  <code>classmethod</code>","text":"<p>Convert an Assoc string to a Python dict.    Each comma-separated element of the Assoc will    become a dict element.</p> <p>Parameters:</p> Name Type Description Default <code>assoc_string</code> <code>str</code> <p>Source Assoc string</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Python dict with the Assoc elements</p> Source code in <code>pyxecm/helper/assoc.py</code> <pre><code>@classmethod\ndef string_to_dict(cls, assoc_string: str) -&gt; dict:\n    \"\"\"Convert an Assoc string to a Python dict.\n       Each comma-separated element of the Assoc will\n       become a dict element.\n\n    Args:\n        assoc_string (str): Source Assoc string\n\n    Returns:\n        dict: Python dict with the Assoc elements\n    \"\"\"\n\n    if cls.is_html_escaped(assoc_string):\n        assoc_string = cls.unescape_html(assoc_string)\n    if cls.is_unicode_escaped(assoc_string):\n        assoc_string = cls.unescape_unicode(assoc_string)\n\n    # Split the string using regex pattern\n    pieces = re.split(r\",(?=(?:[^']*'[^']*')*[^']*$)\", assoc_string)\n\n    # Trim any leading/trailing spaces from each piece\n    pieces = [piece.strip() for piece in pieces]\n\n    # Split the last pieces from the assoc close tag\n    last_piece = pieces[-1].split(\"&gt;\")[0]\n\n    # Remove the first two and last pieces from the list\n    # the first two are mostly \"1\" and \"?\"\n    pieces = pieces[2:-1]\n\n    # Insert the last pieces separately\n    pieces.append(last_piece)\n\n    assoc_dict: dict = {}\n\n    for piece in pieces:\n        name = piece.split(\"=\")[0]\n        if name[0] == \"'\":\n            name = name[1:]\n        if name[-1] == \"'\":\n            name = name[:-1]\n        value = piece.split(\"=\")[1]\n        if value[0] == \"'\":\n            value = value[1:]\n        if value[-1] == \"'\":\n            value = value[:-1]\n        assoc_dict[name] = value\n\n    return assoc_dict\n</code></pre>"},{"location":"pyxecm/assoc/#pyxecm.helper.assoc.Assoc.unescape_unicode","title":"<code>unescape_unicode(assoc_string)</code>  <code>classmethod</code>","text":"<p>Unescape / Decode a given string</p> <p>Parameters:</p> Name Type Description Default <code>assoc_string</code> <code>str</code> <p>Source string</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unescaped string</p> Source code in <code>pyxecm/helper/assoc.py</code> <pre><code>@classmethod\ndef unescape_unicode(cls, assoc_string: str) -&gt; str:\n    \"\"\"Unescape / Decode a given string\n\n    Args:\n        assoc_string (str): Source string\n\n    Returns:\n        str: Unescaped string\n    \"\"\"\n    try:\n        decoded_string = bytes(assoc_string, \"utf-8\").decode(\"unicode_escape\")\n        return decoded_string\n    except UnicodeDecodeError:\n        return assoc_string\n</code></pre>"},{"location":"pyxecm/browser/","title":"Browser Automation","text":"<p>browser_automation Module to implement a class to automate configuration via a browser interface. These are typically used as fallback options if no REST API or LLConfig can be used.</p> <p>Class: BrowserAutomation Methods:</p> <p>init : class initializer. Start the browser session. set_chrome_options: Sets chrome options for Selenium. Chrome options for headless browser is enabled get_page: Load a page into the browser based on a given URL. find_elem_and_click: Find an page element and click it find_elem_and_set: Find an page element and fill it with a new text. find_element_and_download: Clicks a page element to initiate a download. run_login: Login to target system via the browser implicit_wait: Waits for the browser to finish tasks (e.g. fully loading a page).                This setting is valid for the whole browser session.                See https://www.selenium.dev/documentation/webdriver/waits/ end_session: End the browser session</p>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation","title":"<code>BrowserAutomation</code>","text":"<p>Class to automate settings via a browser interface.</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>class BrowserAutomation:\n    \"\"\"Class to automate settings via a browser interface.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        user_name: str,\n        user_password: str,\n        download_directory: str = \"/tmp\",\n        take_screenshots: bool = False,\n        automation_name: str = \"screen\",\n    ) -&gt; None:\n        self.base_url = base_url\n        self.user_name = user_name\n        self.user_password = user_password\n        self.logged_in = False\n        self.download_directory = download_directory\n\n        self.take_screenshots = take_screenshots\n        self.screenshot_names = automation_name\n        self.screen_counter = 1\n\n        self.screenshot_directory = \"/tmp/browser_automations/{}\".format(\n            automation_name\n        )\n\n        if self.take_screenshots:\n            os.makedirs(self.screenshot_directory)\n        chromedriver_autoinstaller.install()\n        self.browser = webdriver.Chrome(options=self.set_chrome_options())\n\n    # end method definition\n\n    def __del__(self):\n        if self.browser:\n            self.browser.close()\n            del self.browser\n            self.browser = None\n\n    def set_chrome_options(self) -&gt; Options:\n        \"\"\"Sets chrome options for Selenium.\n           Chrome options for headless browser is enabled.\n\n        Returns:\n            Options: Options to call the browser with\n        \"\"\"\n\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")\n        chrome_options.add_argument(\"--no-sandbox\")\n        chrome_options.add_argument(\"--disable-dev-shm-usage\")\n        chrome_prefs = {}\n        chrome_options.experimental_options[\"prefs\"] = chrome_prefs\n        chrome_prefs[\"profile.default_content_settings\"] = {\"images\": 2}\n\n        chrome_options.add_experimental_option(\n            \"prefs\", {\"download.default_directory\": self.download_directory}\n        )\n\n        return chrome_options\n\n    # end method definition\n\n    def take_screenshot(self) -&gt; bool:\n        \"\"\"Take a screenshot of the current browser window and save it as PNG file\n\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\n\n        screenshot_file = \"{}/{}-{}.png\".format(\n            self.screenshot_directory, self.screenshot_names, self.screen_counter\n        )\n        logger.info(\"Save browser screenshot to -&gt; %s\", screenshot_file)\n        result = self.browser.get_screenshot_as_file(screenshot_file)\n        self.screen_counter += 1\n\n        return result\n\n    def get_page(self, url: str = \"\") -&gt; bool:\n        \"\"\"Load a page into the browser based on a given URL.\n\n        Args:\n            url (str): URL to load. If empty just the base URL will be used\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\n\n        page_url = self.base_url + url\n\n        try:\n            logger.info(\"Load page -&gt; %s\", page_url)\n            self.browser.get(page_url)\n        except WebDriverException as exception:\n            logger.error(\"Cannot load page -&gt; %s; error -&gt; %s\", page_url, exception)\n            return False\n\n        logger.info(\"Page title after get page -&gt; %s\", self.browser.title)\n\n        if self.take_screenshots:\n            self.take_screenshot()\n\n        return True\n\n    # end method definition\n\n    def find_elem_and_click(self, find_elem: str, find_method: str = By.ID) -&gt; bool:\n        \"\"\"Find an page element and click it.\n\n        Args:\n            find_elem (str): name of the page element\n            find_method (str): either By.ID, By.NAME, By.CLASS_NAME, BY.XPATH\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\n\n        # We don't want to expose class \"By\" outside this module,\n        # so we map the string values to the By class values:\n        if find_method == \"id\":\n            find_method = By.ID\n        elif find_method == \"name\":\n            find_method = By.NAME\n        elif find_method == \"class_name\":\n            find_method = By.CLASS_NAME\n        elif find_method == \"xpath\":\n            find_method = By.XPATH\n        else:\n            logger.error(\"Unsupported find method!\")\n            return False\n\n        try:\n            elem = self.browser.find_element(by=find_method, value=find_elem)\n        except NoSuchElementException as exception:\n            logger.error(\n                \"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\n                find_elem,\n                find_method,\n                exception,\n            )\n            return False\n\n        logger.info(\"Found element -&gt; %s by -&gt; %s\", find_elem, find_method)\n\n        try:\n            elem.click()\n        except ElementClickInterceptedException as exception:\n            logger.error(\n                \"Cannot click page element -&gt; %s; error -&gt; %s\", find_elem, exception\n            )\n            return False\n\n        logger.info(\"Successfully clicked element -&gt; %s\", find_elem)\n\n        if self.take_screenshots:\n            self.take_screenshot()\n\n        return True\n\n    # end method definition\n\n    def find_elem_and_set(\n        self,\n        find_elem: str,\n        elem_value: str,\n        find_method: str = By.ID,\n        is_sensitive: bool = False,\n    ) -&gt; bool:\n        \"\"\"Find an page element and fill it with a new text.\n\n        Args:\n            find_elem (str): name of the page element\n            elem_value (str): new text string for the page element\n            find_method (str): either By.ID, By.NAME, By.CLASS_NAME, or By.XPATH\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\n\n        # We don't want to expose class \"By\" outside this module,\n        # so we map the string values to the By class values:\n        if find_method == \"id\":\n            find_method = By.ID\n        elif find_method == \"name\":\n            find_method = By.NAME\n        elif find_method == \"class_name\":\n            find_method = By.CLASS_NAME\n        elif find_method == \"xpath\":\n            find_method = By.XPATH\n        else:\n            logger.error(\"Unsupported find method!\")\n            return False\n\n        logger.info(\"Try to find element -&gt; %s by -&gt; %s...\", find_elem, find_method)\n\n        try:\n            elem = self.browser.find_element(find_method, find_elem)\n        except NoSuchElementException as exception:\n            logger.error(\n                \"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\n                find_elem,\n                find_method,\n                exception,\n            )\n            return False\n\n        if not is_sensitive:\n            logger.info(\"Set element -&gt; %s to value -&gt; %s...\", find_elem, elem_value)\n        else:\n            logger.info(\"Set element -&gt; %s to value -&gt; &lt;sensitive&gt;...\", find_elem)\n\n        try:\n            elem.clear()  # clear existing text in the input field\n            elem.send_keys(elem_value)  # write new text into the field\n        except ElementNotInteractableException as exception:\n            logger.error(\n                \"Cannot set page element -&gt; %s to value -&gt; %s; error -&gt; %s\",\n                find_elem,\n                elem_value,\n                exception,\n            )\n            return False\n\n        return True\n\n    # end method definition\n\n    def find_element_and_download(\n        self, find_elem: str, find_method: str = By.ID, download_time: int = 30\n    ) -&gt; str | None:\n        \"\"\"Clicks a page element to initiate a download\n\n        Args:\n            find_elem (str): page element to click for download\n            find_method (str, optional): method to find the element. Defaults to By.ID.\n            download_time (int, optional): time in seconds to wait for the download to complete\n        Returns:\n            str | None: filename of the download\n        \"\"\"\n\n        # Record the list of files in the download directory before the download\n        initial_files = set(os.listdir(self.download_directory))\n\n        if not self.find_elem_and_click(\n            find_elem=find_elem,\n            find_method=find_method,\n        ):\n            return None\n\n        # Wait for the download to complete\n        #        time.sleep(download_time)\n\n        self.browser.implicitly_wait(download_time)\n\n        # Record the list of files in the download directory after the download\n        current_files = set(os.listdir(self.download_directory))\n\n        # Determine the name of the downloaded file\n        new_file = (current_files - initial_files).pop()\n\n        return new_file\n\n    # end method definition\n\n    def run_login(\n        self,\n        user_field: str = \"otds_username\",\n        password_field: str = \"otds_password\",\n        login_button: str = \"loginbutton\",\n    ) -&gt; bool:\n        \"\"\"Login to target system via the browser\"\"\"\n\n        self.logged_in = False\n\n        if (\n            not self.get_page()  # assuming the base URL leads towards the login page\n            or not self.find_elem_and_set(\n                find_elem=user_field, elem_value=self.user_name\n            )\n            or not self.find_elem_and_set(\n                find_elem=password_field,\n                elem_value=self.user_password,\n                is_sensitive=True,\n            )\n            or not self.find_elem_and_click(find_elem=login_button)\n        ):\n            logger.error(\n                \"Cannot log into target system using URL -&gt; %s and user -&gt; %s\",\n                self.base_url,\n                self.user_name,\n            )\n            return False\n\n        logger.info(\"Page title after login -&gt; %s\", self.browser.title)\n\n        # Some special handling for Salesforce login:\n        if \"Verify\" in self.browser.title:\n            logger.error(\n                \"Site is asking for a Verification Token. You may need to whitelist your IP!\"\n            )\n            return False\n        if \"Login\" in self.browser.title:\n            logger.error(\n                \"Authentication failed. You may have given the wrong password!\"\n            )\n            return False\n\n        self.logged_in = True\n\n        return True\n\n    # end method definition\n\n    def implicit_wait(self, wait_time: float):\n        \"\"\"Waits for the browser to finish tasks (e.g. fully loading a page)\n           This setting is valid for the whole browser session and not just\n           for a single command.\n\n        Args:\n            wait_time (float): time in seconds to wait\n        \"\"\"\n\n        logger.info(\"Implicit wait for max -&gt; %s seconds...\", str(wait_time))\n        self.browser.implicitly_wait(wait_time)\n\n    def end_session(self):\n        \"\"\"End the browser session\"\"\"\n\n        self.browser.close()\n        self.logged_in = False\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.end_session","title":"<code>end_session()</code>","text":"<p>End the browser session</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def end_session(self):\n    \"\"\"End the browser session\"\"\"\n\n    self.browser.close()\n    self.logged_in = False\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.find_elem_and_click","title":"<code>find_elem_and_click(find_elem, find_method=By.ID)</code>","text":"<p>Find an page element and click it.</p> <p>Parameters:</p> Name Type Description Default <code>find_elem</code> <code>str</code> <p>name of the page element</p> required <code>find_method</code> <code>str</code> <p>either By.ID, By.NAME, By.CLASS_NAME, BY.XPATH</p> <code>ID</code> <p>Returns:     bool: True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def find_elem_and_click(self, find_elem: str, find_method: str = By.ID) -&gt; bool:\n    \"\"\"Find an page element and click it.\n\n    Args:\n        find_elem (str): name of the page element\n        find_method (str): either By.ID, By.NAME, By.CLASS_NAME, BY.XPATH\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n\n    # We don't want to expose class \"By\" outside this module,\n    # so we map the string values to the By class values:\n    if find_method == \"id\":\n        find_method = By.ID\n    elif find_method == \"name\":\n        find_method = By.NAME\n    elif find_method == \"class_name\":\n        find_method = By.CLASS_NAME\n    elif find_method == \"xpath\":\n        find_method = By.XPATH\n    else:\n        logger.error(\"Unsupported find method!\")\n        return False\n\n    try:\n        elem = self.browser.find_element(by=find_method, value=find_elem)\n    except NoSuchElementException as exception:\n        logger.error(\n            \"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\n            find_elem,\n            find_method,\n            exception,\n        )\n        return False\n\n    logger.info(\"Found element -&gt; %s by -&gt; %s\", find_elem, find_method)\n\n    try:\n        elem.click()\n    except ElementClickInterceptedException as exception:\n        logger.error(\n            \"Cannot click page element -&gt; %s; error -&gt; %s\", find_elem, exception\n        )\n        return False\n\n    logger.info(\"Successfully clicked element -&gt; %s\", find_elem)\n\n    if self.take_screenshots:\n        self.take_screenshot()\n\n    return True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.find_elem_and_set","title":"<code>find_elem_and_set(find_elem, elem_value, find_method=By.ID, is_sensitive=False)</code>","text":"<p>Find an page element and fill it with a new text.</p> <p>Parameters:</p> Name Type Description Default <code>find_elem</code> <code>str</code> <p>name of the page element</p> required <code>elem_value</code> <code>str</code> <p>new text string for the page element</p> required <code>find_method</code> <code>str</code> <p>either By.ID, By.NAME, By.CLASS_NAME, or By.XPATH</p> <code>ID</code> <p>Returns:     bool: True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def find_elem_and_set(\n    self,\n    find_elem: str,\n    elem_value: str,\n    find_method: str = By.ID,\n    is_sensitive: bool = False,\n) -&gt; bool:\n    \"\"\"Find an page element and fill it with a new text.\n\n    Args:\n        find_elem (str): name of the page element\n        elem_value (str): new text string for the page element\n        find_method (str): either By.ID, By.NAME, By.CLASS_NAME, or By.XPATH\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n\n    # We don't want to expose class \"By\" outside this module,\n    # so we map the string values to the By class values:\n    if find_method == \"id\":\n        find_method = By.ID\n    elif find_method == \"name\":\n        find_method = By.NAME\n    elif find_method == \"class_name\":\n        find_method = By.CLASS_NAME\n    elif find_method == \"xpath\":\n        find_method = By.XPATH\n    else:\n        logger.error(\"Unsupported find method!\")\n        return False\n\n    logger.info(\"Try to find element -&gt; %s by -&gt; %s...\", find_elem, find_method)\n\n    try:\n        elem = self.browser.find_element(find_method, find_elem)\n    except NoSuchElementException as exception:\n        logger.error(\n            \"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\n            find_elem,\n            find_method,\n            exception,\n        )\n        return False\n\n    if not is_sensitive:\n        logger.info(\"Set element -&gt; %s to value -&gt; %s...\", find_elem, elem_value)\n    else:\n        logger.info(\"Set element -&gt; %s to value -&gt; &lt;sensitive&gt;...\", find_elem)\n\n    try:\n        elem.clear()  # clear existing text in the input field\n        elem.send_keys(elem_value)  # write new text into the field\n    except ElementNotInteractableException as exception:\n        logger.error(\n            \"Cannot set page element -&gt; %s to value -&gt; %s; error -&gt; %s\",\n            find_elem,\n            elem_value,\n            exception,\n        )\n        return False\n\n    return True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.find_element_and_download","title":"<code>find_element_and_download(find_elem, find_method=By.ID, download_time=30)</code>","text":"<p>Clicks a page element to initiate a download</p> <p>Parameters:</p> Name Type Description Default <code>find_elem</code> <code>str</code> <p>page element to click for download</p> required <code>find_method</code> <code>str</code> <p>method to find the element. Defaults to By.ID.</p> <code>ID</code> <code>download_time</code> <code>int</code> <p>time in seconds to wait for the download to complete</p> <code>30</code> <p>Returns:     str | None: filename of the download</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def find_element_and_download(\n    self, find_elem: str, find_method: str = By.ID, download_time: int = 30\n) -&gt; str | None:\n    \"\"\"Clicks a page element to initiate a download\n\n    Args:\n        find_elem (str): page element to click for download\n        find_method (str, optional): method to find the element. Defaults to By.ID.\n        download_time (int, optional): time in seconds to wait for the download to complete\n    Returns:\n        str | None: filename of the download\n    \"\"\"\n\n    # Record the list of files in the download directory before the download\n    initial_files = set(os.listdir(self.download_directory))\n\n    if not self.find_elem_and_click(\n        find_elem=find_elem,\n        find_method=find_method,\n    ):\n        return None\n\n    # Wait for the download to complete\n    #        time.sleep(download_time)\n\n    self.browser.implicitly_wait(download_time)\n\n    # Record the list of files in the download directory after the download\n    current_files = set(os.listdir(self.download_directory))\n\n    # Determine the name of the downloaded file\n    new_file = (current_files - initial_files).pop()\n\n    return new_file\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.get_page","title":"<code>get_page(url='')</code>","text":"<p>Load a page into the browser based on a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to load. If empty just the base URL will be used</p> <code>''</code> <p>Returns:     bool: True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def get_page(self, url: str = \"\") -&gt; bool:\n    \"\"\"Load a page into the browser based on a given URL.\n\n    Args:\n        url (str): URL to load. If empty just the base URL will be used\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n\n    page_url = self.base_url + url\n\n    try:\n        logger.info(\"Load page -&gt; %s\", page_url)\n        self.browser.get(page_url)\n    except WebDriverException as exception:\n        logger.error(\"Cannot load page -&gt; %s; error -&gt; %s\", page_url, exception)\n        return False\n\n    logger.info(\"Page title after get page -&gt; %s\", self.browser.title)\n\n    if self.take_screenshots:\n        self.take_screenshot()\n\n    return True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.implicit_wait","title":"<code>implicit_wait(wait_time)</code>","text":"<p>Waits for the browser to finish tasks (e.g. fully loading a page)    This setting is valid for the whole browser session and not just    for a single command.</p> <p>Parameters:</p> Name Type Description Default <code>wait_time</code> <code>float</code> <p>time in seconds to wait</p> required Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def implicit_wait(self, wait_time: float):\n    \"\"\"Waits for the browser to finish tasks (e.g. fully loading a page)\n       This setting is valid for the whole browser session and not just\n       for a single command.\n\n    Args:\n        wait_time (float): time in seconds to wait\n    \"\"\"\n\n    logger.info(\"Implicit wait for max -&gt; %s seconds...\", str(wait_time))\n    self.browser.implicitly_wait(wait_time)\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.run_login","title":"<code>run_login(user_field='otds_username', password_field='otds_password', login_button='loginbutton')</code>","text":"<p>Login to target system via the browser</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def run_login(\n    self,\n    user_field: str = \"otds_username\",\n    password_field: str = \"otds_password\",\n    login_button: str = \"loginbutton\",\n) -&gt; bool:\n    \"\"\"Login to target system via the browser\"\"\"\n\n    self.logged_in = False\n\n    if (\n        not self.get_page()  # assuming the base URL leads towards the login page\n        or not self.find_elem_and_set(\n            find_elem=user_field, elem_value=self.user_name\n        )\n        or not self.find_elem_and_set(\n            find_elem=password_field,\n            elem_value=self.user_password,\n            is_sensitive=True,\n        )\n        or not self.find_elem_and_click(find_elem=login_button)\n    ):\n        logger.error(\n            \"Cannot log into target system using URL -&gt; %s and user -&gt; %s\",\n            self.base_url,\n            self.user_name,\n        )\n        return False\n\n    logger.info(\"Page title after login -&gt; %s\", self.browser.title)\n\n    # Some special handling for Salesforce login:\n    if \"Verify\" in self.browser.title:\n        logger.error(\n            \"Site is asking for a Verification Token. You may need to whitelist your IP!\"\n        )\n        return False\n    if \"Login\" in self.browser.title:\n        logger.error(\n            \"Authentication failed. You may have given the wrong password!\"\n        )\n        return False\n\n    self.logged_in = True\n\n    return True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.set_chrome_options","title":"<code>set_chrome_options()</code>","text":"<p>Sets chrome options for Selenium.    Chrome options for headless browser is enabled.</p> <p>Returns:</p> Name Type Description <code>Options</code> <code>Options</code> <p>Options to call the browser with</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def set_chrome_options(self) -&gt; Options:\n    \"\"\"Sets chrome options for Selenium.\n       Chrome options for headless browser is enabled.\n\n    Returns:\n        Options: Options to call the browser with\n    \"\"\"\n\n    chrome_options = Options()\n    chrome_options.add_argument(\"--headless\")\n    chrome_options.add_argument(\"--no-sandbox\")\n    chrome_options.add_argument(\"--disable-dev-shm-usage\")\n    chrome_prefs = {}\n    chrome_options.experimental_options[\"prefs\"] = chrome_prefs\n    chrome_prefs[\"profile.default_content_settings\"] = {\"images\": 2}\n\n    chrome_options.add_experimental_option(\n        \"prefs\", {\"download.default_directory\": self.download_directory}\n    )\n\n    return chrome_options\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.take_screenshot","title":"<code>take_screenshot()</code>","text":"<p>Take a screenshot of the current browser window and save it as PNG file</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def take_screenshot(self) -&gt; bool:\n    \"\"\"Take a screenshot of the current browser window and save it as PNG file\n\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n\n    screenshot_file = \"{}/{}-{}.png\".format(\n        self.screenshot_directory, self.screenshot_names, self.screen_counter\n    )\n    logger.info(\"Save browser screenshot to -&gt; %s\", screenshot_file)\n    result = self.browser.get_screenshot_as_file(screenshot_file)\n    self.screen_counter += 1\n\n    return result\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.By","title":"<code>By</code>","text":"<p>Dummy class to avoid errors if selenium module cannot be imported</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>class By:\n    \"\"\"Dummy class to avoid errors if selenium module cannot be imported\"\"\"\n\n    ID: str = \"\"\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.Options","title":"<code>Options</code>","text":"<p>Dummy class to avoid errors if selenium module cannot be imported</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>class Options:\n    \"\"\"Dummy class to avoid errors if selenium module cannot be imported\"\"\"\n</code></pre>"},{"location":"pyxecm/customizer/","title":"Customizer","text":"<p>[Automate OpenText Directory Services (OTDS) and Extended ECM (OTCS) configurations]</p> <p>Data classes to handle settings read from environment variables * CustomizerSettings: Class to manage settings * CustomizerSettingsOTDS: Class for OTDS related settings * CustomizerSettingsOTCS: Class for OTCS related settings * CustomizerSettingsOTAC: Class for OTAC related settings * CustomizerSettingsOTPD: Class for OTPD related settings * CustomizerSettingsOTIV: Class for OTIV related settings * CustomizerSettingsK8S: Class for K8s related settings * CustomizerSettingsOTAWP: Class for OTAWP related settings * CustomizerSettingsM365: Class for O365 related settings * CustomizerSettingsAviator: Class for Aviator related settings</p> <p>Methods of class Customizer:</p> <p>init: object initializer for class Customizer log_header: Helper method to output a section header in the log file init_browser_automation: initialize browser automation for Content Aviator init_m365: initialize the Microsoft 365 object init_k8s: initialize the Kubernetes object we use to talk to the Kubernetes API init_otds: initialize the OTDS object init_otac: initialize the OTAC object init_otcs: initialize the OTCS (Extended ECM) object init_otiv: initialize the OTIV (Intelligent Viewing) object and its OTDS settings init_otpd: initialize the PowerDocs object init_otawp: initialize OTDS settings for AppWorks Platform</p> restart the OTCS backend and frontend pods - <p>required to make certain configurations effective</p> <p>restart_otac_service: restart spawner process in Archive Center restart_otawp_pod: restart the AppWorks Platform Pod to make settings effective consolidate_otds: consolidate OTDS users / groups (to get to a fully synchronized state)</p> <p>import_powerdocs_configuration: import PowerDocs database</p> <p>set_maintenance_mode: Enable or Disable Maintenance Mode</p> <p>customization_run: Central function to initiate the customization</p>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer","title":"<code>Customizer</code>","text":"<p>Customizer Class to control the cusomization automation</p> <p>Args: None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>class Customizer:\n    \"\"\"Customizer Class to control the cusomization automation\n\n    Args: None\n    \"\"\"\n\n    def __init__(\n        self,\n        settings: CustomizerSettings = CustomizerSettings(),\n        otds: CustomizerSettingsOTDS = CustomizerSettingsOTDS(),\n        otcs: CustomizerSettingsOTCS = CustomizerSettingsOTCS(),\n        otac: CustomizerSettingsOTAC = CustomizerSettingsOTAC(),\n        otpd: CustomizerSettingsOTPD = CustomizerSettingsOTPD(),\n        otiv: CustomizerSettingsOTIV = CustomizerSettingsOTIV(),\n        k8s: CustomizerSettingsK8S = CustomizerSettingsK8S(),\n        otawp: CustomizerSettingsOTAWP = CustomizerSettingsOTAWP(),\n        m365: CustomizerSettingsM365 = CustomizerSettingsM365(),\n        aviator: CustomizerSettingsAviator = CustomizerSettingsAviator(),\n    ):\n        self.settings = settings\n\n        # OTDS Constants:\n        self.otds_settings = otds\n\n        # Content Server Constants:\n        self.otcs_settings = otcs\n\n        # Archive Center constants:\n        self.otac_settings = otac\n\n        # PowerDocs constants:\n        self.otpd_settings = otpd\n\n        # Intelligent Viewing constants:\n        self.otiv_settings = otiv\n\n        # AppWorks Platform constants:\n        self.otawp_settings = otawp\n\n        # K8s Mode\n        self.k8s_settings = k8s\n\n        # Microsoft 365 Environment variables:\n        self.m365_settings = m365\n\n        # Aviator variables:\n        self.aviator_settings = aviator\n\n        # Initialize Objects for later assignment\n        self.otds_object: OTDS | None = None\n        self.otcs_object: OTCS | None = None\n        self.otcs_backend_object: OTCS | None = None\n        self.otcs_frontend_object: OTCS | None = None\n        self.otpd_object: OTPD | None = None\n        self.otac_object: OTAC | None = None\n        self.otiv_object: OTIV | None = None\n        self.k8s_object: K8s | None = None\n        self.m365_object: M365 | None = None\n        self.browser_automation_object: BrowserAutomation | None = None\n\n    def log_header(self, text: str, char: str = \"=\", length: int = 60):\n        \"\"\"Helper method to output a section header in the log file\n\n        Args:\n            text (str): _description_\n            char (str, optional): header line character. Defaults to \"=\".\n            length (int, optional): maxium length. Defaults to 60.\n        Returns:\n            None\n        \"\"\"\n\n        # Calculate the remaining space for the text after adding spaces\n        available_space = max(\n            0, length - len(text) - 2\n        )  # 2 accounts for the spaces each side of the text\n\n        # Calculate the number of characters needed on each side\n        char_count = available_space // 2\n        extra_char = available_space % 2  # do we have lost 1 char?\n\n        # Ensure there are at least 3 characters on each side\n        char_count = max(3, char_count)\n\n        # Build the header string, extra_char is either 0 or 1\n        logger.info(\n            \"%s %s %s\", char * char_count, text, char * (char_count + extra_char)\n        )\n\n        # end function definition\n\n    def init_m365(self) -&gt; M365:\n        \"\"\"Initialize the M365 object we use to talk to the Microsoft Graph API.\n\n        Args:\n            None\n        Returns:\n            object: M365 object or None if the object couldn't be created or\n                    the authentication fails.\n        \"\"\"\n\n        logger.info(\n            \"Microsoft 365 Tenant ID             = %s\", self.m365_settings.tenant_id\n        )\n        logger.info(\n            \"Microsoft 365 Client ID             = %s\", self.m365_settings.client_id\n        )\n        logger.debug(\n            \"Microsoft 365 Client Secret         = %s\", self.m365_settings.client_secret\n        )\n        logger.info(\n            \"Microsoft 365 User                  = %s\",\n            (\n                self.m365_settings.user\n                if self.m365_settings.user != \"\"\n                else \"&lt;not configured&gt;\"\n            ),\n        )\n        logger.debug(\n            \"Microsoft 365 Password              = %s\",\n            (\n                self.m365_settings.password\n                if self.m365_settings.password != \"\"\n                else \"&lt;not configured&gt;\"\n            ),\n        )\n        logger.info(\n            \"Microsoft 365 Domain                = %s\", self.m365_settings.domain\n        )\n        logger.info(\n            \"Microsoft 365 Default License SKU   = %s\", self.m365_settings.sku_id\n        )\n        logger.info(\n            \"Microsoft 365 Teams App             = %s\",\n            self.m365_settings.teams_app_name,\n        )\n\n        m365_object = M365(\n            tenant_id=self.m365_settings.tenant_id,\n            client_id=self.m365_settings.client_id,\n            client_secret=self.m365_settings.client_secret,\n            domain=self.m365_settings.domain,\n            sku_id=self.m365_settings.sku_id,\n            teams_app_name=self.m365_settings.teams_app_name,\n        )\n\n        if m365_object and m365_object.authenticate():\n            logger.info(\"Connected to Microsoft Graph API.\")\n            return m365_object\n        else:\n            logger.error(\"Failed to connect to Microsoft Graph API.\")\n            return m365_object\n\n        # end function definition\n\n    def init_k8s(self) -&gt; K8s:\n        \"\"\"Initialize the Kubernetes object we use to talk to the Kubernetes API.\n\n        Args:\n            None\n        Returns:\n            K8s: K8s object\n        Side effects:\n            The global variables otcs_replicas_frontend and otcs_replicas_backend are initialized\n        \"\"\"\n\n        logger.info(\"Connection parameters Kubernetes (K8s):\")\n        logger.info(\"K8s inCluster -&gt; %s\", self.k8s_settings.in_cluster)\n        logger.info(\"K8s namespace -&gt; %s\", self.k8s_settings.namespace)\n        logger.info(\n            \"K8s kubeconfig file -&gt; %s\",\n            self.k8s_settings.kubeconfig_file,\n        )\n\n        k8s_object = K8s(\n            in_cluster=self.k8s_settings.in_cluster,\n            kubeconfig_file=self.k8s_settings.kubeconfig_file,\n            namespace=self.k8s_settings.namespace,\n        )\n        if k8s_object:\n            logger.info(\"Kubernetes API is ready now.\")\n        else:\n            logger.error(\"Cannot establish connection to Kubernetes.\")\n\n        # Get number of replicas for frontend:\n        otcs_frontend_scale = k8s_object.get_stateful_set_scale(\n            self.otcs_settings.k8s_statefulset_frontend\n        )\n        if not otcs_frontend_scale:\n            logger.error(\n                \"Cannot find Kubernetes Stateful Set for OTCS Frontends -&gt; %s\",\n                self.otcs_settings.k8s_statefulset_frontend,\n            )\n            sys.exit()\n\n        self.otcs_settings.replicas_frontend = otcs_frontend_scale.spec.replicas  # type: ignore\n        logger.info(\n            \"Stateful Set -&gt; %s has -&gt; %s replicas\",\n            self.otcs_settings.k8s_statefulset_frontend,\n            self.otcs_settings.replicas_frontend,\n        )\n\n        # Get number of replicas for backend:\n        otcs_backend_scale = k8s_object.get_stateful_set_scale(\n            self.otcs_settings.k8s_statefulset_backend\n        )\n        if not otcs_backend_scale:\n            logger.error(\n                \"Cannot find Kubernetes Stateful Set for OTCS Backends -&gt; %s\",\n                self.otcs_settings.k8s_statefulset_backend,\n            )\n            sys.exit()\n\n        self.otcs_settings.replicas_backend = otcs_backend_scale.spec.replicas  # type: ignore\n        logger.info(\n            \"Stateful Set -&gt; %s has -&gt; %s replicas\",\n            self.otcs_settings.k8s_statefulset_backend,\n            self.otcs_settings.replicas_backend,\n        )\n\n        return k8s_object\n\n        # end function definition\n\n    def init_otds(self) -&gt; OTDS:\n        \"\"\"Initialize the OTDS object and parameters and authenticate at OTDS once it is ready.\n\n        Args:\n            None\n        Returns:\n            object: OTDS object\n        \"\"\"\n\n        logger.info(\"Connection parameters OTDS:\")\n        logger.info(\"OTDS Protocol          = %s\", self.otds_settings.protocol)\n        logger.info(\"OTDS Public Protocol   = %s\", self.otds_settings.public_protocol)\n        logger.info(\"OTDS Hostname          = %s\", self.otds_settings.hostname)\n        logger.info(\"OTDS Public URL        = %s\", self.otds_settings.public_url)\n        logger.info(\"OTDS Port              = %s\", str(self.otds_settings.port))\n        logger.info(\"OTDS Admin User        = %s\", self.otds_settings.username)\n        logger.debug(\"OTDS Admin Password    = %s\", self.otds_settings.password)\n        logger.debug(\"OTDS Ticket            = %s\", self.otds_settings.otds_ticket)\n        logger.info(\"OTDS Admin Partition   = %s\", self.otds_settings.admin_partition)\n\n        otds_object = OTDS(\n            protocol=self.otds_settings.protocol,\n            hostname=self.otds_settings.hostname,\n            port=self.otds_settings.port,\n            username=self.otds_settings.username,\n            password=self.otds_settings.password,\n            otds_ticket=self.otds_settings.otds_ticket,\n        )\n\n        logger.info(\"Authenticating to OTDS...\")\n        otds_cookie = otds_object.authenticate()\n        while otds_cookie is None:\n            logger.warning(\"Waiting 30 seconds for OTDS to become ready...\")\n            time.sleep(30)\n            otds_cookie = otds_object.authenticate()\n        logger.info(\"OTDS is ready now.\")\n\n        logger.info(\"Enable OTDS audit...\")\n\n        if self.otds_settings.enable_audit:\n            otds_object.enable_audit()\n\n        if self.otds_settings.disable_password_policy:\n            logger.info(\"Disable OTDS password expiry...\")\n            # Setting the value to 0 disables password expiry.\n            # The default is 90 days and we may have Terrarium\n            # instances that are running longer than that. This\n            # avoids problems with customerizer re-runs of\n            # instances that are &gt; 90 days old.\n            otds_object.update_password_policy(\n                update_values={\"passwordMaximumDuration\": 0}\n            )\n\n        return otds_object\n\n        # end function definition\n\n    def init_otac(self) -&gt; OTAC:\n        \"\"\"Initialize the OTAC object and parameters.\n          Configure the Archive Server as a known server\n          if environment variable OTAC_KNOWN_SERVER is set.\n\n        Args: None\n        Return:\n            OTAC object\n        \"\"\"\n\n        logger.info(\"Connection parameters OTAC:\")\n        logger.info(\"OTAC Protocol          = %s\", self.otac_settings.protocol)\n        logger.info(\"OTAC Hostname          = %s\", self.otac_settings.hostname)\n        logger.info(\"OTAC Public URL        = %s\", self.otac_settings.public_url)\n        logger.info(\"OTAC Port              = %s\", str(self.otac_settings.port))\n        logger.info(\"OTAC Admin User        = %s\", self.otac_settings.admin)\n        logger.debug(\"OTAC Admin Password   = %s\", self.otac_settings.password)\n        logger.info(\n            \"OTAC Known Server      = %s\",\n            (\n                self.otac_settings.known_server\n                if self.otac_settings.known_server != \"\"\n                else \"&lt;not configured&gt;\"\n            ),\n        )\n\n        otac_object = OTAC(\n            self.otac_settings.protocol,\n            self.otac_settings.hostname,\n            int(self.otac_settings.port),\n            self.otac_settings.admin,\n            self.otac_settings.password,\n            self.otds_settings.username,\n            self.otds_settings.password,\n        )\n\n        # is there a known server configured for Archive Center (to sync content with)\n        if otac_object and self.otac_settings.known_server != \"\":\n            # wait until the OTAC pod is in ready state\n            logger.info(\"Waiting for Archive Center to become ready...\")\n            self.k8s_object.wait_pod_condition(self.otac_settings.k8s_pod_name, \"Ready\")\n\n            logger.info(\"Configure known host for Archive Center...\")\n            response = otac_object.exec_command(\n                f\"cf_create_host {self.otac_settings.known_server} 0 /archive 8080 8090\"\n            )\n            if not response or not response.ok:\n                logger.error(\"Failed to configure known host for Archive Center!\")\n\n            logger.info(\"Configure host alias for Archive Center...\")\n            response = otac_object.exec_command(\n                f\"cf_set_variable MY_HOST_ALIASES {self.otac_settings.k8s_pod_name},{self.otac_settings.public_url},otac DS\"\n            )\n            if not response or not response.ok:\n                logger.error(\"Failed to configure host alias for Archive Center!\")\n\n            # Restart the spawner in Archive Center:\n            logger.info(\"Restart Archive Center Spawner...\")\n            self.restart_otac_service()\n        else:\n            logger.info(\n                \"Skip configuration of known host for Archive Center (OTAC_KNOWN_SERVER is not set).\"\n            )\n\n        return otac_object\n\n        # end function definition\n\n    def init_otcs(\n        self,\n        hostname: str,\n        port: int,\n        partition_name: str,\n        resource_name: str,\n    ) -&gt; OTCS:\n        \"\"\"Initialize the OTCS class and parameters and authenticate at OTCS once it is ready.\n\n        Args:\n            hostname (str): OTCS hostname\n            port (int): port number of OTCS\n            partition_name (str): name of OTDS Partition for Extended ECM users\n            resource_name (str): name of OTDS resource for Extended ECM\n        Returns:\n            OTCS: OTCS object\n        \"\"\"\n\n        logger.info(\"Connection parameters OTCS (Extended ECM):\")\n        logger.info(\"OTCS Protocol              = %s\", self.otcs_settings.protocol)\n        logger.info(\n            \"OTCS Public Protocol       = %s\", self.otcs_settings.public_protocol\n        )\n        logger.info(\"OTCS Hostname              = %s\", hostname)\n        logger.info(\"OTCS Public URL            = %s\", self.otcs_settings.public_url)\n        logger.info(\"OTCS Port                  = %s\", str(port))\n        logger.info(\"OTCS Admin User            = %s\", self.otcs_settings.admin)\n        logger.debug(\"OTCS Admin Password        = %s\", self.otcs_settings.password)\n        logger.info(\"OTCS User Partition        = %s\", partition_name)\n        logger.info(\"OTCS Resource Name         = %s\", resource_name)\n        logger.info(\n            \"OTCS User Default License  = %s\", self.otcs_settings.license_feature\n        )\n        logger.info(\n            \"OTCS K8s Frontend Pods     = %s\",\n            self.otcs_settings.k8s_statefulset_frontend,\n        )\n        logger.info(\n            \"OTCS K8s Backend Pods      = %s\",\n            self.otcs_settings.k8s_statefulset_backend,\n        )\n\n        logger.debug(\"Checking if OTCS object has already been initialized\")\n\n        otds_ticket = (\n            self.otds_object.cookie()[\"OTDSTicket\"] if self.otds_object else None\n        )\n        otcs_object = OTCS(\n            self.otcs_settings.protocol,\n            hostname,\n            int(port),\n            self.otcs_settings.public_protocol + \"://\" + self.otcs_settings.public_url,\n            self.otcs_settings.admin,\n            self.otcs_settings.password,\n            partition_name,\n            resource_name,\n            otds_ticket=otds_ticket,\n        )\n\n        # It is important to wait for OTCS to be configured - otherwise we\n        # may interfere with the OTCS container automation and run into errors\n        logger.info(\"Wait for OTCS to be configured...\")\n        otcs_configured = otcs_object.is_configured()\n        while not otcs_configured:\n            logger.warning(\"OTCS is not configured yet. Waiting 30 seconds...\")\n            time.sleep(30)\n            otcs_configured = otcs_object.is_configured()\n        logger.info(\"OTCS is configured now.\")\n\n        logger.info(\"Authenticating to OTCS...\")\n        otcs_cookie = otcs_object.authenticate()\n        while otcs_cookie is None:\n            logger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\n            time.sleep(30)\n            otcs_cookie = otcs_object.authenticate()\n        logger.info(\"OTCS is ready now.\")\n\n        if self.otcs_settings.update_admin_user:\n            # Set first name and last name of Admin user (ID = 1000):\n            otcs_object.update_user(1000, field=\"first_name\", value=\"Terrarium\")\n            otcs_object.update_user(1000, field=\"last_name\", value=\"Admin\")\n\n        if \"OTCS_RESSOURCE_ID\" not in self.settings.placeholder_values:\n            self.settings.placeholder_values[\n                \"OTCS_RESSOURCE_ID\"\n            ] = self.otds_object.get_resource(self.otcs_settings.resource_name)[\n                \"resourceID\"\n            ]\n            logger.debug(\n                \"Placeholder values after OTCS init = %s\",\n                self.settings.placeholder_values,\n            )\n\n        if self.otawp_settings.enabled:\n            otcs_resource = self.otds_object.get_resource(\n                self.otcs_settings.resource_name\n            )\n            otcs_resource[\n                \"logoutURL\"\n            ] = f\"{self.otawp_settings.public_protocol}://{self.otawp_settings.public_url}/home/system/wcp/sso/sso_logout.htm\"\n            otcs_resource[\"logoutMethod\"] = \"GET\"\n\n            self.otds_object.update_resource(name=\"cs\", resource=otcs_resource)\n\n        # Allow impersonation of the resource for all users:\n        self.otds_object.impersonate_resource(resource_name)\n\n        return otcs_object\n\n        # end function definition\n\n    def init_otiv(self) -&gt; OTIV | None:\n        \"\"\"Initialize the OTIV (Intelligent Viewing) object and its OTDS settings.\n\n        Args:\n        Returns:\n            objects: OTIV object\n        \"\"\"\n\n        logger.info(\"Parameters for OTIV (Intelligent Viewing):\")\n        logger.info(\"OTDS Resource Name       = %s\", self.otiv_settings.resource_name)\n        logger.info(\"OTIV License File        = %s\", self.otiv_settings.license_file)\n        logger.info(\"OTIV Product Name        = %s\", self.otiv_settings.product_name)\n        logger.info(\n            \"OTIV Product Description = %s\", self.otiv_settings.product_description\n        )\n        logger.info(\"OTIV License Feature     = %s\", self.otiv_settings.license_feature)\n\n        otiv_object = OTIV(\n            resource_name=self.otiv_settings.resource_name,\n            product_name=self.otiv_settings.product_name,\n            product_description=self.otiv_settings.product_description,\n            license_file=self.otiv_settings.license_file,\n            default_license=self.otiv_settings.license_feature,\n        )\n\n        otiv_resource = self.otds_object.get_resource(self.otiv_settings.resource_name)\n        while otiv_resource is None:\n            logger.warning(\n                \"OTDS Resource -&gt; %s for Intelligent Viewing not found. OTIV may not be ready. Wait 30 sec...\",\n                self.otiv_settings.resource_name,\n            )\n            time.sleep(30)\n            otiv_resource = self.otds_object.get_resource(\n                self.otiv_settings.resource_name\n            )\n\n        otiv_license = self.otds_object.add_license_to_resource(\n            self.otiv_settings.license_file,\n            self.otiv_settings.product_name,\n            self.otiv_settings.product_description,\n            otiv_resource[\"resourceID\"],\n        )\n        if not otiv_license:\n            logger.info(\n                \"Couldn't apply license -&gt; %s for product -&gt; %s. Intelligent Viewing may not be deployed!\",\n                self.otiv_settings.license_file,\n                self.otiv_settings.product_name,\n            )\n            return None\n\n        return otiv_object\n\n        # end function definition\n\n    def init_otpd(self) -&gt; OTPD:\n        \"\"\"Initialize the OTPD (PowerDocs) object and parameters.\n\n        Args:\n            None\n        Returns:\n            object: OTPD (PowerDocs) object\n        \"\"\"\n\n        logger.info(\"Connection parameters OTPD (PowerDocs):\")\n        logger.info(\"OTPD Protocol             = %s\", self.otpd_settings.protocol)\n        logger.info(\"OTPD Hostname             = %s\", self.otpd_settings.hostname)\n        logger.info(\"OTPD Port                 = %s\", str(self.otpd_settings.port))\n        logger.info(\"OTPD API User             = %s\", self.otpd_settings.user)\n        logger.info(\"OTPD Tenant               = %s\", self.otpd_settings.tenant)\n        logger.info(\n            \"OTPD Database Import File = %s\",\n            (\n                self.otpd_settings.db_importfile\n                if self.otpd_settings.db_importfile != \"\"\n                else \"&lt;not configured&gt;\"\n            ),\n        )\n        logger.info(\"OTPD K8s Pod Name         = %s\", self.otpd_settings.k8s_pod_name)\n\n        otpd_object = OTPD(\n            self.otpd_settings.protocol,\n            self.otpd_settings.hostname,\n            int(self.otpd_settings.port),\n            self.otpd_settings.user,\n            self.otpd_settings.password,\n        )\n\n        # wait until the OTPD pod is in ready state\n        self.k8s_object.wait_pod_condition(self.otpd_settings.k8s_pod_name, \"Ready\")\n\n        # We have a race condition here. Even if the pod is ready\n        # it may not yet have fully initialized its database.\n        # Then the \"apply_setting()\" calls below may fail with\n        # an error. This should be improved in the future. For now\n        # we just wait a minute hoping that the DB is initialized then.\n        logger.info(\"Wait some time for PowerDocs database to be initialized...\")\n        time.sleep(60)\n        logger.info(\"Configure some basic PowerDocs settings...\")\n\n        # Fix settings for local Kubernetes deployments.\n        # Unclear why this is not the default.\n        if otpd_object:\n            otpd_object.apply_setting(\"LocalOtdsUrl\", \"http://otds/otdsws\")\n            otpd_object.apply_setting(\n                \"LocalApplicationServerUrlForContentManager\",\n                \"http://localhost:8080/c4ApplicationServer\",\n                self.otpd_settings.tenant,\n            )\n\n        return otpd_object\n\n        # end function definition\n\n    def init_otawp(self):\n        \"\"\"Initialize OTDS for Appworks Platform\n        Args:\n        Return: None\n        \"\"\"\n\n        logger.info(\"Connection parameters OTAWP:\")\n        logger.info(\"OTAWP Enabled          = %s\", str(self.otawp_settings.enabled))\n        logger.info(\"OTAWP Resource         = %s\", self.otawp_settings.resource_name)\n        logger.info(\"OTAWP Access Role      = %s\", self.otawp_settings.access_role_name)\n        logger.info(\"OTAWP Admin User       = %s\", self.otawp_settings.admin)\n        logger.debug(\"OTAWP Password         = %s\", self.otawp_settings.password)\n        logger.info(\"OTAWP K8s Stateful Set = %s\", self.otawp_settings.k8s_statefulset)\n        logger.info(\"OTAWP K8s Config Map   = %s\", self.otawp_settings.k8s_configmap)\n\n        logger.info(\n            \"Wait for OTCS to create its OTDS resource with name -&gt; %s...\",\n            self.otcs_settings.resource_name,\n        )\n\n        # Loop to wait for OTCS to create its OTDS resource\n        # (we need it to update the AppWorks K8s Config Map):\n        otcs_resource = self.otds_object.get_resource(self.otcs_settings.resource_name)\n        while otcs_resource is None:\n            logger.warning(\n                \"OTDS resource for Content Server with name -&gt; %s does not exist yet. Waiting...\",\n                self.otcs_settings.resource_name,\n            )\n            time.sleep(30)\n            otcs_resource = self.otds_object.get_resource(\n                self.otcs_settings.resource_name\n            )\n\n        otcs_resource_id = otcs_resource[\"resourceID\"]\n\n        logger.info(\"OTDS resource ID for Content Server -&gt; %s\", otcs_resource_id)\n\n        # make sure code is idempotent and only try to add ressource if it doesn't exist already:\n        awp_resource = self.otds_object.get_resource(self.otawp_settings.resource_name)\n        if not awp_resource:\n            logger.info(\n                \"OTDS resource -&gt; %s for AppWorks Platform does not yet exist. Creating...\",\n                self.otawp_settings.resource_name,\n            )\n            # Create a Python dict with the special payload we need for AppWorks:\n            additional_payload = {}\n            additional_payload[\"connectorid\"] = \"rest\"\n            additional_payload[\"resourceType\"] = \"rest\"\n            user_attribute_mapping = [\n                {\n                    \"sourceAttr\": [\"oTExternalID1\"],\n                    \"destAttr\": \"__NAME__\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"displayname\"],\n                    \"destAttr\": \"DisplayName\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\"sourceAttr\": [\"mail\"], \"destAttr\": \"Email\", \"mappingFormat\": \"%s\"},\n                {\n                    \"sourceAttr\": [\"oTTelephoneNumber\"],\n                    \"destAttr\": \"Telephone\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTMobile\"],\n                    \"destAttr\": \"Mobile\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n                    \"destAttr\": \"Fax\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTStreetAddress,l,st,postalCode,c\"],\n                    \"destAttr\": \"Address\",\n                    \"mappingFormat\": \"%s%n%s %s %s%n%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTCompany\"],\n                    \"destAttr\": \"Company\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"ds-pwp-account-disabled\"],\n                    \"destAttr\": \"AccountDisabled\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTExtraAttr9\"],\n                    \"destAttr\": \"IsServiceAccount\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"custom:proxyConfiguration\"],\n                    \"destAttr\": \"ProxyConfiguration\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"c\"],\n                    \"destAttr\": \"Identity-CountryOrRegion\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"gender\"],\n                    \"destAttr\": \"Identity-Gender\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"displayName\"],\n                    \"destAttr\": \"Identity-DisplayName\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTStreetAddress\"],\n                    \"destAttr\": \"Identity-Address\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"l\"],\n                    \"destAttr\": \"Identity-City\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"mail\"],\n                    \"destAttr\": \"Identity-Email\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"givenName\"],\n                    \"destAttr\": \"Identity-FirstName\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"sn\"],\n                    \"destAttr\": \"Identity-LastName\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"initials\"],\n                    \"destAttr\": \"Identity-MiddleNames\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTMobile\"],\n                    \"destAttr\": \"Identity-Mobile\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"postalCode\"],\n                    \"destAttr\": \"Identity-PostalCode\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"st\"],\n                    \"destAttr\": \"Identity-StateOrProvince\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"title\"],\n                    \"destAttr\": \"Identity-title\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"physicalDeliveryOfficeName\"],\n                    \"destAttr\": \"Identity-physicalDeliveryOfficeName\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n                    \"destAttr\": \"Identity-oTFacsimileTelephoneNumber\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"notes\"],\n                    \"destAttr\": \"Identity-notes\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTCompany\"],\n                    \"destAttr\": \"Identity-oTCompany\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTDepartment\"],\n                    \"destAttr\": \"Identity-oTDepartment\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"birthDate\"],\n                    \"destAttr\": \"Identity-Birthday\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"cn\"],\n                    \"destAttr\": \"Identity-UserName\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"Description\"],\n                    \"destAttr\": \"Identity-UserDescription\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"oTTelephoneNumber\"],\n                    \"destAttr\": \"Identity-Phone\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"displayName\"],\n                    \"destAttr\": \"Identity-IdentityDisplayName\",\n                    \"mappingFormat\": \"%s\",\n                },\n            ]\n            additional_payload[\"userAttributeMapping\"] = user_attribute_mapping\n            group_attribute_mapping = [\n                {\n                    \"sourceAttr\": [\"cn\"],\n                    \"destAttr\": \"__NAME__\",\n                    \"mappingFormat\": '%js:function format(name) { return name.replace(/&amp;/g,\"-and-\"); }',\n                },\n                {\n                    \"sourceAttr\": [\"description\"],\n                    \"destAttr\": \"Description\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"description\"],\n                    \"destAttr\": \"Identity-Description\",\n                    \"mappingFormat\": \"%s\",\n                },\n                {\n                    \"sourceAttr\": [\"displayName\"],\n                    \"destAttr\": \"Identity-DisplayName\",\n                    \"mappingFormat\": \"%s\",\n                },\n            ]\n            additional_payload[\"groupAttributeMapping\"] = group_attribute_mapping\n            additional_payload[\"connectorName\"] = \"REST (Generic)\"\n            additional_payload[\"pcCreatePermissionAllowed\"] = \"true\"\n            additional_payload[\"pcModifyPermissionAllowed\"] = \"true\"\n            additional_payload[\"pcDeletePermissionAllowed\"] = \"false\"\n            additional_payload[\"connectionParamInfo\"] = [\n                {\n                    \"name\": \"fBaseURL\",\n                    \"value\": \"http://appworks:8080/home/system/app/otdspush\",\n                },\n                {\"name\": \"fUsername\", \"value\": self.otawp_settings.admin},\n                {\"name\": \"fPassword\", \"value\": self.otawp_settings.password},\n            ]\n\n            awp_resource = self.otds_object.add_resource(\n                self.otawp_settings.resource_name,\n                \"AppWorks Platform\",\n                \"AppWorks Platform\",\n                additional_payload,\n            )\n        else:\n            logger.info(\n                \"OTDS resource -&gt; %s for AppWorks Platform does already exist.\",\n                self.otawp_settings.resource_name,\n            )\n\n        awp_resource_id = awp_resource[\"resourceID\"]\n\n        logger.info(\"OTDS resource ID for AppWorks Platform -&gt; %s\", awp_resource_id)\n\n        self.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = str(awp_resource_id)\n\n        logger.debug(\n            \"Placeholder values after OTAWP init = %s\", self.settings.placeholder_values\n        )\n\n        logger.info(\"Update AppWorks Kubernetes Config Map with OTDS resource IDs...\")\n\n        config_map = self.k8s_object.get_config_map(self.otawp_settings.k8s_configmap)\n        if not config_map:\n            logger.error(\n                \"Failed to retrieve AppWorks Kubernetes Config Map -&gt; %s\",\n                self.otawp_settings.k8s_configmap,\n            )\n        else:\n            solution = yaml.safe_load(config_map.data[\"solution.yaml\"])  # type: ignore\n\n            # Change values as required\n            solution[\"platform\"][\"organizations\"][\"system\"][\"otds\"][\n                \"resourceId\"\n            ] = awp_resource_id\n            solution[\"platform\"][\"content\"][\"ContentServer\"][\n                \"contentServerUrl\"\n            ] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cs/cs\"\n            solution[\"platform\"][\"content\"][\"ContentServer\"][\n                \"contentServerSupportDirectoryUrl\"\n            ] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cssupport\"\n            solution[\"platform\"][\"content\"][\"ContentServer\"][\n                \"otdsResourceId\"\n            ] = otcs_resource_id\n            solution[\"platform\"][\"authenticators\"][\"OTDS_auth\"][\"publicLoginUrl\"] = (\n                self.otds_settings.public_protocol\n                + \"://\"\n                + self.otds_settings.public_url\n                + \"/otdsws/login\"\n            )\n            solution[\"platform\"][\"security\"][\"contentSecurityPolicy\"] = (\n                \"frame-ancestors 'self' \"\n                + self.otcs_settings.public_protocol\n                + \"://\"\n                + self.otcs_settings.public_url\n            )\n            data = {\"solution.yaml\": yaml.dump(solution)}\n            result = self.k8s_object.replace_config_map(\n                self.otawp_settings.k8s_configmap, data\n            )\n            if result:\n                logger.info(\"Successfully updated AppWorks Solution YAML.\")\n            else:\n                logger.error(\"Failed to update AppWorks Solution YAML.\")\n            logger.debug(\"Solution YAML for AppWorks -&gt; %s\", solution)\n\n        logger.info(\"Scale AppWorks Kubernetes Stateful Set to 1...\")\n        self.k8s_object.scale_stateful_set(\n            sts_name=self.otawp_settings.k8s_statefulset, scale=1\n        )\n\n        # Add the OTCS Admin user to the AppWorks Access Role in OTDS\n        self.otds_object.add_user_to_access_role(\n            \"Access to \" + self.otawp_settings.resource_name, \"otadmin@otds.admin\"\n        )\n\n        # Loop to wait for OTCS to create its OTDS user partition:\n        otcs_partition = self.otds_object.get_partition(\n            self.otcs_settings.partition, show_error=False\n        )\n        while otcs_partition is None:\n            logger.warning(\n                \"OTDS user partition for Content Server with name -&gt; %s does not exist yet. Waiting...\",\n                self.otcs_settings.partition,\n            )\n\n            time.sleep(30)\n            otcs_partition = self.otds_object.get_partition(\n                self.otcs_settings.partition, show_error=False\n            )\n\n        # Add the OTDS user partition for OTCS to the AppWorks Platform Access Role in OTDS.\n        # This will effectvely sync all OTCS users with AppWorks Platform:\n        self.otds_object.add_partition_to_access_role(\n            self.otawp_settings.access_role_name, self.otcs_settings.partition\n        )\n\n        # Add the OTDS admin partition to the AppWorks Platform Access Role in OTDS.\n        self.otds_object.add_partition_to_access_role(\n            self.otawp_settings.access_role_name, self.otds_settings.admin_partition\n        )\n\n        # Set Group inclusion for Access Role for OTAWP to \"True\":\n        self.otds_object.update_access_role_attributes(\n            self.otawp_settings.access_role_name,\n            [{\"name\": \"pushAllGroups\", \"values\": [\"True\"]}],\n        )\n\n        # Add ResourceID User to OTDSAdmin to allow push\n        self.otds_object.add_user_to_group(\n            user=str(awp_resource_id) + \"@otds.admin\", group=\"otdsadmins@otds.admin\"\n        )\n\n        # Allow impersonation for all users:\n        self.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n\n        # Add SPS license for OTAWP\n        # check if the license file exists, otherwise skip for versions pre 24.1\n        if os.path.isfile(self.otawp_settings.license_file):\n            logger.info(\n                \"OTAWP license file (%s) found, assiging to ressource %s\",\n                self.otawp_settings.license_file,\n                self.otawp_settings.resource_name,\n            )\n\n            otawp_license = self.otds_object.add_license_to_resource(\n                self.otawp_settings.license_file,\n                self.otawp_settings.product_name,\n                self.otawp_settings.product_description,\n                awp_resource[\"resourceID\"],\n            )\n            if not otawp_license:\n                logger.error(\n                    \"Couldn't apply license -&gt; %s for product -&gt; %s to OTDS resource -&gt; %s\",\n                    self.otawp_settings.license_file,\n                    self.otawp_settings.product_name,\n                    awp_resource[\"resourceID\"],\n                )\n            else:\n                logger.info(\n                    \"Successfully applied license -&gt; %s for product -&gt; %s to OTDS resource -&gt; %s\",\n                    self.otawp_settings.license_file,\n                    self.otawp_settings.product_name,\n                    awp_resource[\"resourceID\"],\n                )\n\n            # Assign AppWorks license to Content Server Members Partiton and otds.admin:\n            for partition_name in [\"otds.admin\", self.otcs_settings.partition]:\n                if self.otds_object.is_partition_licensed(\n                    partition_name=partition_name,\n                    resource_id=awp_resource[\"resourceID\"],\n                    license_feature=\"USERS\",\n                    license_name=self.otawp_settings.product_name,\n                ):\n                    logger.info(\n                        \"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\n                        partition_name,\n                        self.otawp_settings.product_name,\n                        \"USERS\",\n                    )\n                else:\n                    assigned_license = self.otds_object.assign_partition_to_license(\n                        partition_name,\n                        awp_resource[\"resourceID\"],\n                        \"USERS\",\n                        self.otawp_settings.product_name,\n                    )\n                    if not assigned_license:\n                        logger.error(\n                            \"Partition -&gt; %s could not be assigned to license -&gt; %s (%s)\",\n                            partition_name,\n                            self.otawp_settings.product_name,\n                            \"USERS\",\n                        )\n                    else:\n                        logger.info(\n                            \"Partition -&gt; %s successfully assigned to license -&gt; %s (%s)\",\n                            partition_name,\n                            self.otawp_settings.product_name,\n                            \"USERS\",\n                        )\n\n        # end function definition\n\n    def restart_otcs_service(self, otcs_object: OTCS, extra_wait_time: int = 60):\n        \"\"\"Restart the Content Server service in all OTCS pods\n\n        Args:\n            otcs_object: OTCS class instance (object)\n        Returns:\n            None\n        \"\"\"\n\n        if not self.k8s_object:\n            logger.warning(\n                \"Kubernetes integration not available, skipping restart of services\"\n            )\n            return\n\n        logger.info(\"Restart OTCS frontend and backend pods...\")\n\n        # Restart all frontends:\n        for x in range(0, self.otcs_settings.replicas_frontend):\n            pod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\n\n            logger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n            )\n            logger.info(\"Restarting pod -&gt; %s\", pod_name)\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n            )\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n            )\n\n        # Restart all backends:\n        for x in range(0, self.otcs_settings.replicas_backend):\n            pod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\n\n            logger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n            )\n            logger.info(\"Restarting pod -&gt; %s\", pod_name)\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n            )\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n            )\n\n        logger.info(\"Re-Authenticating to OTCS after restart of pods...\")\n        otcs_cookie = otcs_object.authenticate(revalidate=True)\n        while otcs_cookie is None:\n            logger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\n            time.sleep(30)\n            otcs_cookie = otcs_object.authenticate(revalidate=True)\n        logger.info(\"OTCS is ready again.\")\n\n        # Reactivate Liveness probes in all pods:\n        for x in range(0, self.otcs_settings.replicas_frontend):\n            pod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\n\n            logger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n            )\n\n        for x in range(0, self.otcs_settings.replicas_backend):\n            pod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\n\n            logger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\n            self.k8s_object.exec_pod_command(\n                pod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n            )\n\n        logger.info(\"Restart OTCS frontend and backend pods has been completed.\")\n\n        # optional, give some additional time to make sure service is responsive\n        if extra_wait_time &gt; 0:\n            logger.info(\n                \"Wait %s seconds to make sure OTCS is responsive again...\",\n                str(extra_wait_time),\n            )\n            time.sleep(extra_wait_time)\n        logger.info(\"Continue customizing...\")\n\n        # end function definition\n\n    def restart_otac_service(self) -&gt; bool:\n        \"\"\"Restart the Archive Center spawner service in OTAC pod\n\n        Args:\n            None\n        Returns:\n            bool: True if restart was done, False if error occured\n        \"\"\"\n\n        if not self.otac_settings.enabled:\n            return False\n\n        logger.info(\n            \"Restarting spawner service in Archive Center pod -&gt; %s\",\n            self.otac_settings.k8s_pod_name,\n        )\n        # The Archive Center Spawner needs to be run in \"interactive\" mode - otherwise the command will \"hang\":\n        # The \"-c\" parameter is not required in this case\n        # False is given as parameter as OTAC writes non-errors to stderr\n        response = self.k8s_object.exec_pod_command_interactive(\n            self.otac_settings.k8s_pod_name,\n            [\"/bin/sh\", \"/etc/init.d/spawner restart\"],\n            60,\n            False,\n        )\n\n        if response:\n            return True\n        else:\n            return False\n\n        # end function definition\n\n    def restart_otawp_pod(self):\n        \"\"\"Delete the AppWorks Platform Pod to make Kubernetes restart it.\n\n        Args:\n        Returns:\n            None\n        \"\"\"\n\n        self.k8s_object.delete_pod(self.otawp_settings.k8s_statefulset + \"-0\")\n\n        # end function definition\n\n    def consolidate_otds(self):\n        \"\"\"Consolidate OTDS resources\n        Args:\n        Return: None\n        \"\"\"\n\n        self.otds_object.consolidate(self.otcs_settings.resource_name)\n\n        if self.otawp_settings.enabled:  # is AppWorks Platform deployed?\n            self.otds_object.consolidate(self.otawp_settings.resource_name)\n\n        # end function definition\n\n    def import_powerdocs_configuration(self, otpd_object: OTPD):\n        \"\"\"Import a database export (zip file) into the PowerDocs database\n\n        Args:\n            otpd_object (object): PowerDocs object\n        \"\"\"\n\n        if self.otpd_settings.db_importfile.startswith(\"http\"):\n            # Download file from remote location specified by the OTPD_DBIMPORTFILE\n            # this must be a public place without authentication:\n            logger.info(\n                \"Download PowerDocs database file from URL -&gt; %s\",\n                self.otpd_settings.db_importfile,\n            )\n\n            try:\n                package = requests.get(self.otpd_settings.db_importfile, timeout=60)\n                package.raise_for_status()\n                logger.info(\n                    \"Successfully downloaded PowerDocs database file -&gt; %s; status code -&gt; %s\",\n                    self.otpd_settings.db_importfile,\n                    package.status_code,\n                )\n                filename = \"/tmp/otpd_db_import.zip\"\n                with open(filename, mode=\"wb\") as localfile:\n                    localfile.write(package.content)\n\n                logger.info(\n                    \"Starting import on %s://%s:%s of %s\",\n                    self.otpd_settings.protocol,\n                    self.otpd_settings.hostname,\n                    self.otpd_settings.port,\n                    self.otpd_settings.db_importfile,\n                )\n                response = otpd_object.import_database(filename=filename)\n                logger.info(\"Response -&gt; %s\", response)\n\n            except requests.exceptions.HTTPError as err:\n                logger.error(\"Request error -&gt; %s\", err)\n\n        # end function definition\n\n    def set_maintenance_mode(self, enable: bool = True):\n        \"\"\"Enable or Disable Maintenance Mode\n\n        Args:\n            enable (bool, optional): _description_. Defaults to True.\n        \"\"\"\n        if enable and self.k8s_settings.enabled:\n            self.log_header(\"Enable Maintenance Mode\")\n            logger.info(\n                \"Put OTCS frontends in Maitenance Mode by changing the Kubernetes Ingress backend service...\"\n            )\n            self.k8s_object.update_ingress_backend_services(\n                self.otcs_settings.k8s_ingress,\n                \"otcs\",\n                self.otcs_settings.maintenance_service_name,\n                self.otcs_settings.mainteance_service_port,\n            )\n            logger.info(\"OTCS frontend is now in Maintenance Mode!\")\n        elif not self.k8s_settings.enabled:\n            logger.warning(\n                \"Kubernetes Integration disabled - Cannot Enable/Disable Maintenance Mode\"\n            )\n            self.k8s_object = None\n        else:\n            # Changing the Ingress backend service to OTCS frontend service:\n            logger.info(\n                \"Put OTCS frontend back in Production Mode by changing the Kubernetes Ingress backend service...\"\n            )\n            self.k8s_object.update_ingress_backend_services(\n                self.otcs_settings.k8s_ingress,\n                \"otcs\",\n                self.otcs_settings.hostname_frontend,\n                self.otcs_settings.port_frontend,\n            )\n            logger.info(\"OTCS frontend is now back in Production Mode!\")\n\n    def customization_run(self):\n        \"\"\"Central function to initiate the customization\"\"\"\n        # Set Timer for duration calculation\n        self.settings.customizer_start_time = (\n            self.settings.customizer_end_time\n        ) = datetime.now()\n\n        # Initialize the OTDS, OTCS and OTPD objects and wait for the\n        # pods to be ready. If any of this fails we bail out:\n\n        self.log_header(\"Initialize OTDS\")\n\n        self.otds_object = self.init_otds()\n        if not self.otds_object:\n            logger.error(\"Failed to initialize OTDS - exiting...\")\n            sys.exit()\n\n        # Establish in-cluster Kubernetes connection\n        self.log_header(\"Initialize Kubernetes\")\n        if self.k8s_settings.enabled:\n            self.k8s_object = self.init_k8s()\n\n            if not self.k8s_object:\n                logger.error(\"Failed to initialize Kubernetes - exiting...\")\n                sys.exit()\n\n        # Put Frontend in Maintenance mode to make sure nobody interferes\n        # during customization:\n        if self.otcs_settings.maintenance_mode:\n            self.set_maintenance_mode(True)\n\n        if self.otawp_settings.enabled:  # is AppWorks Platform deployed?\n            self.log_header(\"Initialize OTAWP\")\n\n            # Configure required OTDS resources as AppWorks doesn't do this on its own:\n            self.init_otawp()\n        else:\n            self.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = \"\"\n\n        self.log_header(\"Initialize OTCS backend\")\n        self.otcs_backend_object = self.init_otcs(\n            self.otcs_settings.hostname_backend,\n            int(self.otcs_settings.port_backend),\n            self.otcs_settings.partition,\n            self.otcs_settings.resource_name,\n        )\n        if not self.otcs_backend_object:\n            logger.error(\"Failed to initialize OTCS backend - exiting...\")\n            sys.exit()\n\n        self.log_header(\"Initialize OTCS frontend\")\n        self.otcs_frontend_object = self.init_otcs(\n            self.otcs_settings.hostname_frontend,\n            int(self.otcs_settings.port_frontend),\n            self.otcs_settings.partition,\n            self.otcs_settings.resource_name,\n        )\n        if not self.otcs_frontend_object:\n            logger.error(\"Failed to initialize OTCS frontend - exiting...\")\n            sys.exit()\n\n        if self.otac_settings.enabled:  # is Archive Center deployed?\n            self.log_header(\"Initialize OTAC\")\n\n            self.otac_object = self.init_otac()\n            if not self.otac_object:\n                logger.error(\"Failed to initialize OTAC - exiting...\")\n                sys.exit()\n        else:\n            self.otac_object = None\n\n        if self.otiv_settings.enabled:  # is Intelligent Viewing deployed?\n            self.log_header(\"Initialize OTIV\")\n\n            self.otiv_object = self.init_otiv()\n        else:\n            self.otiv_object = None\n\n        if self.otpd_settings.enabled:  # is PowerDocs deployed?\n            self.log_header(\"Initialize OTPD\")\n\n            self.otpd_object = self.init_otpd()\n            if not self.otpd_object:\n                logger.error(\"Failed to initialize OTPD - exiting...\")\n                sys.exit()\n        else:\n            self.otpd_object = None\n\n        if (\n            self.m365_settings.enabled\n            and self.m365_settings.user != \"\"\n            and self.m365_settings.password != \"\"\n        ):  # is M365 enabled?\n            self.log_header(\"Initialize MS Graph API\")\n\n            # Initialize the M365 object and connection to M365 Graph API:\n            self.m365_object = self.init_m365()\n\n            self.log_header(\"Upload MS Teams App\")\n\n            # Download MS Teams App from OTCS (this has with 23.2 a nasty side-effect\n            # of unsetting 2 checkboxes on that config page - we reset these checkboxes\n            # with the settings file \"O365Settings.xml\"):\n            response = self.otcs_frontend_object.download_config_file(\n                \"/cs/cs?func=officegroups.DownloadTeamsPackage\",\n                \"/tmp/ot.xecm.teams.zip\",\n            )\n            # this app upload will be done with the user credentials - this is required:\n            self.m365_object.authenticate_user(\n                self.m365_settings.user, self.m365_settings.password\n            )\n\n            # Check if the app is already installed in the apps catalog:\n            response = self.m365_object.get_teams_apps(\n                f\"contains(displayName, '{self.m365_settings.teams_app_name}')\"\n            )\n            if self.m365_object.exist_result_item(\n                response, \"displayName\", self.m365_settings.teams_app_name\n            ):\n                app_catalog_id = self.m365_object.get_result_value(\n                    response=response, key=\"id\", index=0\n                )  # 0 = Index = first item\n                app_catalog_version = self.m365_object.get_result_value(\n                    response=response,\n                    key=\"version\",\n                    index=0,\n                    sub_dict_name=\"appDefinitions\",\n                )\n                logger.info(\n                    \"Extended ECM Teams App is already in app catalog with app catalog ID -&gt; %s and version -&gt; %s. Check if we have a newer version to upload...\",\n                    app_catalog_id,\n                    app_catalog_version,\n                )\n                app_upload_version = self.m365_object.extract_version_from_app_manifest(\n                    app_path=\"/tmp/ot.xecm.teams.zip\"\n                )\n                if app_catalog_version &lt; app_upload_version:\n                    logger.info(\n                        \"Upgrading Extended ECM Teams App in catalog from version -&gt; %s to version -&gt; %s...\",\n                        app_catalog_version,\n                        app_upload_version,\n                    )\n                    response = self.m365_object.upload_teams_app(\n                        app_path=\"/tmp/ot.xecm.teams.zip\",\n                        update_existing_app=True,\n                        app_catalog_id=app_catalog_id,\n                    )\n                else:\n                    logger.info(\n                        \"No upgrade required. The upload version -&gt; %s is not newer than the version -&gt; %s which is in the M365 app catalog.\",\n                        app_upload_version,\n                        app_catalog_version,\n                    )\n            else:\n                logger.info(\n                    \"Extended Teams ECM App is not yet in app catalog. Installing as new app...\"\n                )\n                response = self.m365_object.upload_teams_app(\n                    app_path=\"/tmp/ot.xecm.teams.zip\"\n                )\n\n            # logger.info(\"======== Upload Outlook Add-In ============\")\n\n            # # Download MS Outlook Add-In from OTCS:\n            # MANIFEST_FILE = \"/tmp/BusinessWorkspace.Manifest.xml\"\n            # if not self.otcs_frontend_object.download_config_file(\n            #     \"/cs/cs?func=outlookaddin.DownloadManifest\",\n            #     MANIFEST_FILE,\n            #     \"DeployedContentServer\",\n            #     self.otcs_settings.public_url,\n            # ):\n            #     logger.error(\"Failed to download M365 Outlook Add-In from Extended ECM!\")\n            # else:\n            #     # THIS IS NOT IMPLEMENTED DUE TO LACK OF M365 GRAPH API SUPPORT!\n            #     # Do it manually for now: https://admin.microsoft.com/#/Settings/IntegratedApps\n            #     logger.info(\"Successfully downloaded M365 Outlook Add-In from Extended ECM to %s\", MANIFEST_FILE)\n            #     self.m365_object.upload_outlook_app(MANIFEST_FILE)\n        else:\n            self.m365_object = None\n\n        # self.log_header(\"Initialize Browser Automation...\")\n\n        # We initialize a Selenium based browser automation for\n        # those die-hard settings that cannot be automated via REST API\n        # nor LLConfig nor Transport:\n        # self.browser_automation_object = self.init_browser_automation()\n        # if not self.browser_automation_object:\n        #     logger.error(\"Failed to initialize Browser Automation - exiting...\")\n        #     sys.exit()\n\n        self.log_header(\"Processing Payload\")\n\n        cust_payload_list = []\n        # Is uncompressed payload provided?\n        if os.path.exists(self.settings.cust_payload):\n            logger.info(\"Found payload file -&gt; %s\", self.settings.cust_payload)\n            cust_payload_list.append(self.settings.cust_payload)\n        # Is compressed payload provided?\n        if os.path.exists(self.settings.cust_payload_gz):\n            logger.info(\n                \"Found compressed payload file -&gt; %s\", self.settings.cust_payload_gz\n            )\n            cust_payload_list.append(self.settings.cust_payload_gz)\n\n        # do we have additional payload as an external file?\n        if os.path.exists(self.settings.cust_payload_external):\n            for filename in os.scandir(self.settings.cust_payload_external):\n                if filename.is_file() and os.path.getsize(filename) &gt; 0:\n                    logger.info(\"Found external payload file -&gt; %s\", filename.path)\n                    cust_payload_list.append(filename.path)\n        else:\n            logger.info(\n                \"No external payload file -&gt; %s\", self.settings.cust_payload_external\n            )\n\n        for cust_payload in cust_payload_list:\n            # Open the payload file. If this fails we bail out:\n            logger.info(\"Starting processing of payload -&gt; %s\", cust_payload)\n\n            # Set startTime for duration calculation\n            start_time = datetime.now()\n\n            payload_object = Payload(\n                payload_source=cust_payload,\n                custom_settings_dir=self.settings.cust_settings_dir,\n                k8s_object=self.k8s_object,\n                otds_object=self.otds_object,\n                otac_object=self.otac_object,\n                otcs_backend_object=self.otcs_backend_object,\n                otcs_frontend_object=self.otcs_frontend_object,\n                otcs_restart_callback=self.restart_otcs_service,\n                otiv_object=self.otiv_object,\n                m365_object=self.m365_object,\n                browser_automation_object=self.browser_automation_object,\n                placeholder_values=self.settings.placeholder_values,  # this dict includes placeholder replacements for the Ressource IDs of OTAWP and OTCS\n                log_header_callback=self.log_header,\n                stop_on_error=self.settings.stop_on_error,\n                aviator_enabled=self.aviator_settings.enabled,\n            )\n            # Load the payload file and initialize the payload sections:\n            if not payload_object.init_payload():\n                logger.error(\n                    \"Failed to initialize payload -&gt; %s - skipping...\", cust_payload\n                )\n                continue\n\n            # Now process the payload in the defined ordering:\n            payload_object.process_payload()\n\n            self.log_header(\"Consolidate OTDS Resources\")\n            self.consolidate_otds()\n\n            # Upload payload file for later review to Enterprise Workspace\n            self.log_header(\"Upload Payload file to Extended ECM\")\n            response = self.otcs_backend_object.get_node_from_nickname(\n                self.settings.cust_target_folder_nickname\n            )\n            target_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\n            if not target_folder_id:\n                target_folder_id = 2000  # use Enterprise Workspace as fallback\n            # Write YAML file with upadated payload (including IDs, etc.).\n            # We need to write to /tmp as initial location is read-only:\n            payload_file = os.path.basename(cust_payload)\n            payload_file = (\n                payload_file[: -len(\".gz.b64\")]\n                if payload_file.endswith(\".gz.b64\")\n                else payload_file\n            )\n            cust_payload = \"/tmp/\" + payload_file\n\n            with open(cust_payload, \"w\", encoding=\"utf-8\") as file:\n                yaml.dump(payload_object.get_payload(), file)\n\n            # Check if the payload file has been uploaded before.\n            # This can happen if we re-run the python container.\n            # In this case we add a version to the existing document:\n            response = self.otcs_backend_object.get_node_by_parent_and_name(\n                int(target_folder_id), os.path.basename(cust_payload)\n            )\n            target_document_id = self.otcs_backend_object.get_result_value(\n                response, \"id\"\n            )\n            if target_document_id:\n                response = self.otcs_backend_object.add_document_version(\n                    int(target_document_id),\n                    cust_payload,\n                    os.path.basename(cust_payload),\n                    \"text/plain\",\n                    \"Updated payload file after re-run of customization\",\n                )\n            else:\n                response = self.otcs_backend_object.upload_file_to_parent(\n                    cust_payload,\n                    os.path.basename(cust_payload),\n                    \"text/plain\",\n                    int(target_folder_id),\n                )\n\n            duration = datetime.now() - start_time\n            self.log_header(\n                \"Customizer completed processing of payload -&gt; {} in {}\".format(\n                    cust_payload,\n                    duration,\n                )\n            )\n\n        if self.otcs_settings.maintenance_mode:\n            self.set_maintenance_mode(False)\n\n        # Restart AppWorksPlatform pod if it is deployed (to make settings effective):\n        if self.otawp_settings.enabled:  # is AppWorks Platform deployed?\n            otawp_resource = self.otds_object.get_resource(\n                self.otawp_settings.resource_name\n            )\n            if (\n                not \"allowImpersonation\" in otawp_resource\n                or not otawp_resource[\"allowImpersonation\"]\n            ):\n                # Allow impersonation for all users:\n                logger.warning(\n                    \"OTAWP impersonation is not correct in OTDS before OTAWP pod restart!\"\n                )\n            else:\n                logger.info(\n                    \"OTAWP impersonation is correct in OTDS before OTAWP pod restart!\"\n                )\n            logger.info(\"Restart OTAWP pod...\")\n            self.restart_otawp_pod()\n            # For some reason we need to double-check that the impersonation for OTAWP has been set correctly\n            # and if not set it again:\n            otawp_resource = self.otds_object.get_resource(\n                self.otawp_settings.resource_name\n            )\n            if (\n                not \"allowImpersonation\" in otawp_resource\n                or not otawp_resource[\"allowImpersonation\"]\n            ):\n                # Allow impersonation for all users:\n                logger.warning(\n                    \"OTAWP impersonation is not correct in OTDS - set it once more...\"\n                )\n                self.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n\n        # Upload log file for later review to \"Deployment\" folder in \"Administration\" folder\n        if os.path.exists(self.settings.cust_log_file):\n            self.log_header(\"Upload log file to Extended ECM\")\n            #            logger.info(\"========== Upload log file to Extended ECM =============\")\n            response = self.otcs_backend_object.get_node_from_nickname(\n                self.settings.cust_target_folder_nickname\n            )\n            target_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\n            if not target_folder_id:\n                target_folder_id = 2000  # use Enterprise Workspace as fallback\n            # Check if the log file has been uploaded before.\n            # This can happen if we re-run the python container:\n            # In this case we add a version to the existing document:\n            response = self.otcs_backend_object.get_node_by_parent_and_name(\n                int(target_folder_id), os.path.basename(self.settings.cust_log_file)\n            )\n            target_document_id = self.otcs_backend_object.get_result_value(\n                response, \"id\"\n            )\n            if target_document_id:\n                response = self.otcs_backend_object.add_document_version(\n                    int(target_document_id),\n                    self.settings.cust_log_file,\n                    os.path.basename(self.settings.cust_log_file),\n                    \"text/plain\",\n                    \"Updated Python Log after re-run of customization\",\n                )\n            else:\n                response = self.otcs_backend_object.upload_file_to_parent(\n                    self.settings.cust_log_file,\n                    os.path.basename(self.settings.cust_log_file),\n                    \"text/plain\",\n                    int(target_folder_id),\n                )\n\n        self.settings.customizer_end_time = datetime.now()\n        self.log_header(\n            \"Customizer completed in {}\".format(\n                self.settings.customizer_end_time - self.settings.customizer_start_time\n            )\n        )\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.consolidate_otds","title":"<code>consolidate_otds()</code>","text":"<p>Consolidate OTDS resources Args: Return: None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def consolidate_otds(self):\n    \"\"\"Consolidate OTDS resources\n    Args:\n    Return: None\n    \"\"\"\n\n    self.otds_object.consolidate(self.otcs_settings.resource_name)\n\n    if self.otawp_settings.enabled:  # is AppWorks Platform deployed?\n        self.otds_object.consolidate(self.otawp_settings.resource_name)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.customization_run","title":"<code>customization_run()</code>","text":"<p>Central function to initiate the customization</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def customization_run(self):\n    \"\"\"Central function to initiate the customization\"\"\"\n    # Set Timer for duration calculation\n    self.settings.customizer_start_time = (\n        self.settings.customizer_end_time\n    ) = datetime.now()\n\n    # Initialize the OTDS, OTCS and OTPD objects and wait for the\n    # pods to be ready. If any of this fails we bail out:\n\n    self.log_header(\"Initialize OTDS\")\n\n    self.otds_object = self.init_otds()\n    if not self.otds_object:\n        logger.error(\"Failed to initialize OTDS - exiting...\")\n        sys.exit()\n\n    # Establish in-cluster Kubernetes connection\n    self.log_header(\"Initialize Kubernetes\")\n    if self.k8s_settings.enabled:\n        self.k8s_object = self.init_k8s()\n\n        if not self.k8s_object:\n            logger.error(\"Failed to initialize Kubernetes - exiting...\")\n            sys.exit()\n\n    # Put Frontend in Maintenance mode to make sure nobody interferes\n    # during customization:\n    if self.otcs_settings.maintenance_mode:\n        self.set_maintenance_mode(True)\n\n    if self.otawp_settings.enabled:  # is AppWorks Platform deployed?\n        self.log_header(\"Initialize OTAWP\")\n\n        # Configure required OTDS resources as AppWorks doesn't do this on its own:\n        self.init_otawp()\n    else:\n        self.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = \"\"\n\n    self.log_header(\"Initialize OTCS backend\")\n    self.otcs_backend_object = self.init_otcs(\n        self.otcs_settings.hostname_backend,\n        int(self.otcs_settings.port_backend),\n        self.otcs_settings.partition,\n        self.otcs_settings.resource_name,\n    )\n    if not self.otcs_backend_object:\n        logger.error(\"Failed to initialize OTCS backend - exiting...\")\n        sys.exit()\n\n    self.log_header(\"Initialize OTCS frontend\")\n    self.otcs_frontend_object = self.init_otcs(\n        self.otcs_settings.hostname_frontend,\n        int(self.otcs_settings.port_frontend),\n        self.otcs_settings.partition,\n        self.otcs_settings.resource_name,\n    )\n    if not self.otcs_frontend_object:\n        logger.error(\"Failed to initialize OTCS frontend - exiting...\")\n        sys.exit()\n\n    if self.otac_settings.enabled:  # is Archive Center deployed?\n        self.log_header(\"Initialize OTAC\")\n\n        self.otac_object = self.init_otac()\n        if not self.otac_object:\n            logger.error(\"Failed to initialize OTAC - exiting...\")\n            sys.exit()\n    else:\n        self.otac_object = None\n\n    if self.otiv_settings.enabled:  # is Intelligent Viewing deployed?\n        self.log_header(\"Initialize OTIV\")\n\n        self.otiv_object = self.init_otiv()\n    else:\n        self.otiv_object = None\n\n    if self.otpd_settings.enabled:  # is PowerDocs deployed?\n        self.log_header(\"Initialize OTPD\")\n\n        self.otpd_object = self.init_otpd()\n        if not self.otpd_object:\n            logger.error(\"Failed to initialize OTPD - exiting...\")\n            sys.exit()\n    else:\n        self.otpd_object = None\n\n    if (\n        self.m365_settings.enabled\n        and self.m365_settings.user != \"\"\n        and self.m365_settings.password != \"\"\n    ):  # is M365 enabled?\n        self.log_header(\"Initialize MS Graph API\")\n\n        # Initialize the M365 object and connection to M365 Graph API:\n        self.m365_object = self.init_m365()\n\n        self.log_header(\"Upload MS Teams App\")\n\n        # Download MS Teams App from OTCS (this has with 23.2 a nasty side-effect\n        # of unsetting 2 checkboxes on that config page - we reset these checkboxes\n        # with the settings file \"O365Settings.xml\"):\n        response = self.otcs_frontend_object.download_config_file(\n            \"/cs/cs?func=officegroups.DownloadTeamsPackage\",\n            \"/tmp/ot.xecm.teams.zip\",\n        )\n        # this app upload will be done with the user credentials - this is required:\n        self.m365_object.authenticate_user(\n            self.m365_settings.user, self.m365_settings.password\n        )\n\n        # Check if the app is already installed in the apps catalog:\n        response = self.m365_object.get_teams_apps(\n            f\"contains(displayName, '{self.m365_settings.teams_app_name}')\"\n        )\n        if self.m365_object.exist_result_item(\n            response, \"displayName\", self.m365_settings.teams_app_name\n        ):\n            app_catalog_id = self.m365_object.get_result_value(\n                response=response, key=\"id\", index=0\n            )  # 0 = Index = first item\n            app_catalog_version = self.m365_object.get_result_value(\n                response=response,\n                key=\"version\",\n                index=0,\n                sub_dict_name=\"appDefinitions\",\n            )\n            logger.info(\n                \"Extended ECM Teams App is already in app catalog with app catalog ID -&gt; %s and version -&gt; %s. Check if we have a newer version to upload...\",\n                app_catalog_id,\n                app_catalog_version,\n            )\n            app_upload_version = self.m365_object.extract_version_from_app_manifest(\n                app_path=\"/tmp/ot.xecm.teams.zip\"\n            )\n            if app_catalog_version &lt; app_upload_version:\n                logger.info(\n                    \"Upgrading Extended ECM Teams App in catalog from version -&gt; %s to version -&gt; %s...\",\n                    app_catalog_version,\n                    app_upload_version,\n                )\n                response = self.m365_object.upload_teams_app(\n                    app_path=\"/tmp/ot.xecm.teams.zip\",\n                    update_existing_app=True,\n                    app_catalog_id=app_catalog_id,\n                )\n            else:\n                logger.info(\n                    \"No upgrade required. The upload version -&gt; %s is not newer than the version -&gt; %s which is in the M365 app catalog.\",\n                    app_upload_version,\n                    app_catalog_version,\n                )\n        else:\n            logger.info(\n                \"Extended Teams ECM App is not yet in app catalog. Installing as new app...\"\n            )\n            response = self.m365_object.upload_teams_app(\n                app_path=\"/tmp/ot.xecm.teams.zip\"\n            )\n\n        # logger.info(\"======== Upload Outlook Add-In ============\")\n\n        # # Download MS Outlook Add-In from OTCS:\n        # MANIFEST_FILE = \"/tmp/BusinessWorkspace.Manifest.xml\"\n        # if not self.otcs_frontend_object.download_config_file(\n        #     \"/cs/cs?func=outlookaddin.DownloadManifest\",\n        #     MANIFEST_FILE,\n        #     \"DeployedContentServer\",\n        #     self.otcs_settings.public_url,\n        # ):\n        #     logger.error(\"Failed to download M365 Outlook Add-In from Extended ECM!\")\n        # else:\n        #     # THIS IS NOT IMPLEMENTED DUE TO LACK OF M365 GRAPH API SUPPORT!\n        #     # Do it manually for now: https://admin.microsoft.com/#/Settings/IntegratedApps\n        #     logger.info(\"Successfully downloaded M365 Outlook Add-In from Extended ECM to %s\", MANIFEST_FILE)\n        #     self.m365_object.upload_outlook_app(MANIFEST_FILE)\n    else:\n        self.m365_object = None\n\n    # self.log_header(\"Initialize Browser Automation...\")\n\n    # We initialize a Selenium based browser automation for\n    # those die-hard settings that cannot be automated via REST API\n    # nor LLConfig nor Transport:\n    # self.browser_automation_object = self.init_browser_automation()\n    # if not self.browser_automation_object:\n    #     logger.error(\"Failed to initialize Browser Automation - exiting...\")\n    #     sys.exit()\n\n    self.log_header(\"Processing Payload\")\n\n    cust_payload_list = []\n    # Is uncompressed payload provided?\n    if os.path.exists(self.settings.cust_payload):\n        logger.info(\"Found payload file -&gt; %s\", self.settings.cust_payload)\n        cust_payload_list.append(self.settings.cust_payload)\n    # Is compressed payload provided?\n    if os.path.exists(self.settings.cust_payload_gz):\n        logger.info(\n            \"Found compressed payload file -&gt; %s\", self.settings.cust_payload_gz\n        )\n        cust_payload_list.append(self.settings.cust_payload_gz)\n\n    # do we have additional payload as an external file?\n    if os.path.exists(self.settings.cust_payload_external):\n        for filename in os.scandir(self.settings.cust_payload_external):\n            if filename.is_file() and os.path.getsize(filename) &gt; 0:\n                logger.info(\"Found external payload file -&gt; %s\", filename.path)\n                cust_payload_list.append(filename.path)\n    else:\n        logger.info(\n            \"No external payload file -&gt; %s\", self.settings.cust_payload_external\n        )\n\n    for cust_payload in cust_payload_list:\n        # Open the payload file. If this fails we bail out:\n        logger.info(\"Starting processing of payload -&gt; %s\", cust_payload)\n\n        # Set startTime for duration calculation\n        start_time = datetime.now()\n\n        payload_object = Payload(\n            payload_source=cust_payload,\n            custom_settings_dir=self.settings.cust_settings_dir,\n            k8s_object=self.k8s_object,\n            otds_object=self.otds_object,\n            otac_object=self.otac_object,\n            otcs_backend_object=self.otcs_backend_object,\n            otcs_frontend_object=self.otcs_frontend_object,\n            otcs_restart_callback=self.restart_otcs_service,\n            otiv_object=self.otiv_object,\n            m365_object=self.m365_object,\n            browser_automation_object=self.browser_automation_object,\n            placeholder_values=self.settings.placeholder_values,  # this dict includes placeholder replacements for the Ressource IDs of OTAWP and OTCS\n            log_header_callback=self.log_header,\n            stop_on_error=self.settings.stop_on_error,\n            aviator_enabled=self.aviator_settings.enabled,\n        )\n        # Load the payload file and initialize the payload sections:\n        if not payload_object.init_payload():\n            logger.error(\n                \"Failed to initialize payload -&gt; %s - skipping...\", cust_payload\n            )\n            continue\n\n        # Now process the payload in the defined ordering:\n        payload_object.process_payload()\n\n        self.log_header(\"Consolidate OTDS Resources\")\n        self.consolidate_otds()\n\n        # Upload payload file for later review to Enterprise Workspace\n        self.log_header(\"Upload Payload file to Extended ECM\")\n        response = self.otcs_backend_object.get_node_from_nickname(\n            self.settings.cust_target_folder_nickname\n        )\n        target_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\n        if not target_folder_id:\n            target_folder_id = 2000  # use Enterprise Workspace as fallback\n        # Write YAML file with upadated payload (including IDs, etc.).\n        # We need to write to /tmp as initial location is read-only:\n        payload_file = os.path.basename(cust_payload)\n        payload_file = (\n            payload_file[: -len(\".gz.b64\")]\n            if payload_file.endswith(\".gz.b64\")\n            else payload_file\n        )\n        cust_payload = \"/tmp/\" + payload_file\n\n        with open(cust_payload, \"w\", encoding=\"utf-8\") as file:\n            yaml.dump(payload_object.get_payload(), file)\n\n        # Check if the payload file has been uploaded before.\n        # This can happen if we re-run the python container.\n        # In this case we add a version to the existing document:\n        response = self.otcs_backend_object.get_node_by_parent_and_name(\n            int(target_folder_id), os.path.basename(cust_payload)\n        )\n        target_document_id = self.otcs_backend_object.get_result_value(\n            response, \"id\"\n        )\n        if target_document_id:\n            response = self.otcs_backend_object.add_document_version(\n                int(target_document_id),\n                cust_payload,\n                os.path.basename(cust_payload),\n                \"text/plain\",\n                \"Updated payload file after re-run of customization\",\n            )\n        else:\n            response = self.otcs_backend_object.upload_file_to_parent(\n                cust_payload,\n                os.path.basename(cust_payload),\n                \"text/plain\",\n                int(target_folder_id),\n            )\n\n        duration = datetime.now() - start_time\n        self.log_header(\n            \"Customizer completed processing of payload -&gt; {} in {}\".format(\n                cust_payload,\n                duration,\n            )\n        )\n\n    if self.otcs_settings.maintenance_mode:\n        self.set_maintenance_mode(False)\n\n    # Restart AppWorksPlatform pod if it is deployed (to make settings effective):\n    if self.otawp_settings.enabled:  # is AppWorks Platform deployed?\n        otawp_resource = self.otds_object.get_resource(\n            self.otawp_settings.resource_name\n        )\n        if (\n            not \"allowImpersonation\" in otawp_resource\n            or not otawp_resource[\"allowImpersonation\"]\n        ):\n            # Allow impersonation for all users:\n            logger.warning(\n                \"OTAWP impersonation is not correct in OTDS before OTAWP pod restart!\"\n            )\n        else:\n            logger.info(\n                \"OTAWP impersonation is correct in OTDS before OTAWP pod restart!\"\n            )\n        logger.info(\"Restart OTAWP pod...\")\n        self.restart_otawp_pod()\n        # For some reason we need to double-check that the impersonation for OTAWP has been set correctly\n        # and if not set it again:\n        otawp_resource = self.otds_object.get_resource(\n            self.otawp_settings.resource_name\n        )\n        if (\n            not \"allowImpersonation\" in otawp_resource\n            or not otawp_resource[\"allowImpersonation\"]\n        ):\n            # Allow impersonation for all users:\n            logger.warning(\n                \"OTAWP impersonation is not correct in OTDS - set it once more...\"\n            )\n            self.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n\n    # Upload log file for later review to \"Deployment\" folder in \"Administration\" folder\n    if os.path.exists(self.settings.cust_log_file):\n        self.log_header(\"Upload log file to Extended ECM\")\n        #            logger.info(\"========== Upload log file to Extended ECM =============\")\n        response = self.otcs_backend_object.get_node_from_nickname(\n            self.settings.cust_target_folder_nickname\n        )\n        target_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\n        if not target_folder_id:\n            target_folder_id = 2000  # use Enterprise Workspace as fallback\n        # Check if the log file has been uploaded before.\n        # This can happen if we re-run the python container:\n        # In this case we add a version to the existing document:\n        response = self.otcs_backend_object.get_node_by_parent_and_name(\n            int(target_folder_id), os.path.basename(self.settings.cust_log_file)\n        )\n        target_document_id = self.otcs_backend_object.get_result_value(\n            response, \"id\"\n        )\n        if target_document_id:\n            response = self.otcs_backend_object.add_document_version(\n                int(target_document_id),\n                self.settings.cust_log_file,\n                os.path.basename(self.settings.cust_log_file),\n                \"text/plain\",\n                \"Updated Python Log after re-run of customization\",\n            )\n        else:\n            response = self.otcs_backend_object.upload_file_to_parent(\n                self.settings.cust_log_file,\n                os.path.basename(self.settings.cust_log_file),\n                \"text/plain\",\n                int(target_folder_id),\n            )\n\n    self.settings.customizer_end_time = datetime.now()\n    self.log_header(\n        \"Customizer completed in {}\".format(\n            self.settings.customizer_end_time - self.settings.customizer_start_time\n        )\n    )\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.import_powerdocs_configuration","title":"<code>import_powerdocs_configuration(otpd_object)</code>","text":"<p>Import a database export (zip file) into the PowerDocs database</p> <p>Parameters:</p> Name Type Description Default <code>otpd_object</code> <code>object</code> <p>PowerDocs object</p> required Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def import_powerdocs_configuration(self, otpd_object: OTPD):\n    \"\"\"Import a database export (zip file) into the PowerDocs database\n\n    Args:\n        otpd_object (object): PowerDocs object\n    \"\"\"\n\n    if self.otpd_settings.db_importfile.startswith(\"http\"):\n        # Download file from remote location specified by the OTPD_DBIMPORTFILE\n        # this must be a public place without authentication:\n        logger.info(\n            \"Download PowerDocs database file from URL -&gt; %s\",\n            self.otpd_settings.db_importfile,\n        )\n\n        try:\n            package = requests.get(self.otpd_settings.db_importfile, timeout=60)\n            package.raise_for_status()\n            logger.info(\n                \"Successfully downloaded PowerDocs database file -&gt; %s; status code -&gt; %s\",\n                self.otpd_settings.db_importfile,\n                package.status_code,\n            )\n            filename = \"/tmp/otpd_db_import.zip\"\n            with open(filename, mode=\"wb\") as localfile:\n                localfile.write(package.content)\n\n            logger.info(\n                \"Starting import on %s://%s:%s of %s\",\n                self.otpd_settings.protocol,\n                self.otpd_settings.hostname,\n                self.otpd_settings.port,\n                self.otpd_settings.db_importfile,\n            )\n            response = otpd_object.import_database(filename=filename)\n            logger.info(\"Response -&gt; %s\", response)\n\n        except requests.exceptions.HTTPError as err:\n            logger.error(\"Request error -&gt; %s\", err)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_k8s","title":"<code>init_k8s()</code>","text":"<p>Initialize the Kubernetes object we use to talk to the Kubernetes API.</p> <p>Returns:     K8s: K8s object Side effects:     The global variables otcs_replicas_frontend and otcs_replicas_backend are initialized</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_k8s(self) -&gt; K8s:\n    \"\"\"Initialize the Kubernetes object we use to talk to the Kubernetes API.\n\n    Args:\n        None\n    Returns:\n        K8s: K8s object\n    Side effects:\n        The global variables otcs_replicas_frontend and otcs_replicas_backend are initialized\n    \"\"\"\n\n    logger.info(\"Connection parameters Kubernetes (K8s):\")\n    logger.info(\"K8s inCluster -&gt; %s\", self.k8s_settings.in_cluster)\n    logger.info(\"K8s namespace -&gt; %s\", self.k8s_settings.namespace)\n    logger.info(\n        \"K8s kubeconfig file -&gt; %s\",\n        self.k8s_settings.kubeconfig_file,\n    )\n\n    k8s_object = K8s(\n        in_cluster=self.k8s_settings.in_cluster,\n        kubeconfig_file=self.k8s_settings.kubeconfig_file,\n        namespace=self.k8s_settings.namespace,\n    )\n    if k8s_object:\n        logger.info(\"Kubernetes API is ready now.\")\n    else:\n        logger.error(\"Cannot establish connection to Kubernetes.\")\n\n    # Get number of replicas for frontend:\n    otcs_frontend_scale = k8s_object.get_stateful_set_scale(\n        self.otcs_settings.k8s_statefulset_frontend\n    )\n    if not otcs_frontend_scale:\n        logger.error(\n            \"Cannot find Kubernetes Stateful Set for OTCS Frontends -&gt; %s\",\n            self.otcs_settings.k8s_statefulset_frontend,\n        )\n        sys.exit()\n\n    self.otcs_settings.replicas_frontend = otcs_frontend_scale.spec.replicas  # type: ignore\n    logger.info(\n        \"Stateful Set -&gt; %s has -&gt; %s replicas\",\n        self.otcs_settings.k8s_statefulset_frontend,\n        self.otcs_settings.replicas_frontend,\n    )\n\n    # Get number of replicas for backend:\n    otcs_backend_scale = k8s_object.get_stateful_set_scale(\n        self.otcs_settings.k8s_statefulset_backend\n    )\n    if not otcs_backend_scale:\n        logger.error(\n            \"Cannot find Kubernetes Stateful Set for OTCS Backends -&gt; %s\",\n            self.otcs_settings.k8s_statefulset_backend,\n        )\n        sys.exit()\n\n    self.otcs_settings.replicas_backend = otcs_backend_scale.spec.replicas  # type: ignore\n    logger.info(\n        \"Stateful Set -&gt; %s has -&gt; %s replicas\",\n        self.otcs_settings.k8s_statefulset_backend,\n        self.otcs_settings.replicas_backend,\n    )\n\n    return k8s_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_m365","title":"<code>init_m365()</code>","text":"<p>Initialize the M365 object we use to talk to the Microsoft Graph API.</p> <p>Returns:     object: M365 object or None if the object couldn't be created or             the authentication fails.</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_m365(self) -&gt; M365:\n    \"\"\"Initialize the M365 object we use to talk to the Microsoft Graph API.\n\n    Args:\n        None\n    Returns:\n        object: M365 object or None if the object couldn't be created or\n                the authentication fails.\n    \"\"\"\n\n    logger.info(\n        \"Microsoft 365 Tenant ID             = %s\", self.m365_settings.tenant_id\n    )\n    logger.info(\n        \"Microsoft 365 Client ID             = %s\", self.m365_settings.client_id\n    )\n    logger.debug(\n        \"Microsoft 365 Client Secret         = %s\", self.m365_settings.client_secret\n    )\n    logger.info(\n        \"Microsoft 365 User                  = %s\",\n        (\n            self.m365_settings.user\n            if self.m365_settings.user != \"\"\n            else \"&lt;not configured&gt;\"\n        ),\n    )\n    logger.debug(\n        \"Microsoft 365 Password              = %s\",\n        (\n            self.m365_settings.password\n            if self.m365_settings.password != \"\"\n            else \"&lt;not configured&gt;\"\n        ),\n    )\n    logger.info(\n        \"Microsoft 365 Domain                = %s\", self.m365_settings.domain\n    )\n    logger.info(\n        \"Microsoft 365 Default License SKU   = %s\", self.m365_settings.sku_id\n    )\n    logger.info(\n        \"Microsoft 365 Teams App             = %s\",\n        self.m365_settings.teams_app_name,\n    )\n\n    m365_object = M365(\n        tenant_id=self.m365_settings.tenant_id,\n        client_id=self.m365_settings.client_id,\n        client_secret=self.m365_settings.client_secret,\n        domain=self.m365_settings.domain,\n        sku_id=self.m365_settings.sku_id,\n        teams_app_name=self.m365_settings.teams_app_name,\n    )\n\n    if m365_object and m365_object.authenticate():\n        logger.info(\"Connected to Microsoft Graph API.\")\n        return m365_object\n    else:\n        logger.error(\"Failed to connect to Microsoft Graph API.\")\n        return m365_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otac","title":"<code>init_otac()</code>","text":"<p>Initialize the OTAC object and parameters.   Configure the Archive Server as a known server   if environment variable OTAC_KNOWN_SERVER is set.</p> <p>Return:     OTAC object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otac(self) -&gt; OTAC:\n    \"\"\"Initialize the OTAC object and parameters.\n      Configure the Archive Server as a known server\n      if environment variable OTAC_KNOWN_SERVER is set.\n\n    Args: None\n    Return:\n        OTAC object\n    \"\"\"\n\n    logger.info(\"Connection parameters OTAC:\")\n    logger.info(\"OTAC Protocol          = %s\", self.otac_settings.protocol)\n    logger.info(\"OTAC Hostname          = %s\", self.otac_settings.hostname)\n    logger.info(\"OTAC Public URL        = %s\", self.otac_settings.public_url)\n    logger.info(\"OTAC Port              = %s\", str(self.otac_settings.port))\n    logger.info(\"OTAC Admin User        = %s\", self.otac_settings.admin)\n    logger.debug(\"OTAC Admin Password   = %s\", self.otac_settings.password)\n    logger.info(\n        \"OTAC Known Server      = %s\",\n        (\n            self.otac_settings.known_server\n            if self.otac_settings.known_server != \"\"\n            else \"&lt;not configured&gt;\"\n        ),\n    )\n\n    otac_object = OTAC(\n        self.otac_settings.protocol,\n        self.otac_settings.hostname,\n        int(self.otac_settings.port),\n        self.otac_settings.admin,\n        self.otac_settings.password,\n        self.otds_settings.username,\n        self.otds_settings.password,\n    )\n\n    # is there a known server configured for Archive Center (to sync content with)\n    if otac_object and self.otac_settings.known_server != \"\":\n        # wait until the OTAC pod is in ready state\n        logger.info(\"Waiting for Archive Center to become ready...\")\n        self.k8s_object.wait_pod_condition(self.otac_settings.k8s_pod_name, \"Ready\")\n\n        logger.info(\"Configure known host for Archive Center...\")\n        response = otac_object.exec_command(\n            f\"cf_create_host {self.otac_settings.known_server} 0 /archive 8080 8090\"\n        )\n        if not response or not response.ok:\n            logger.error(\"Failed to configure known host for Archive Center!\")\n\n        logger.info(\"Configure host alias for Archive Center...\")\n        response = otac_object.exec_command(\n            f\"cf_set_variable MY_HOST_ALIASES {self.otac_settings.k8s_pod_name},{self.otac_settings.public_url},otac DS\"\n        )\n        if not response or not response.ok:\n            logger.error(\"Failed to configure host alias for Archive Center!\")\n\n        # Restart the spawner in Archive Center:\n        logger.info(\"Restart Archive Center Spawner...\")\n        self.restart_otac_service()\n    else:\n        logger.info(\n            \"Skip configuration of known host for Archive Center (OTAC_KNOWN_SERVER is not set).\"\n        )\n\n    return otac_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otawp","title":"<code>init_otawp()</code>","text":"<p>Initialize OTDS for Appworks Platform Args: Return: None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otawp(self):\n    \"\"\"Initialize OTDS for Appworks Platform\n    Args:\n    Return: None\n    \"\"\"\n\n    logger.info(\"Connection parameters OTAWP:\")\n    logger.info(\"OTAWP Enabled          = %s\", str(self.otawp_settings.enabled))\n    logger.info(\"OTAWP Resource         = %s\", self.otawp_settings.resource_name)\n    logger.info(\"OTAWP Access Role      = %s\", self.otawp_settings.access_role_name)\n    logger.info(\"OTAWP Admin User       = %s\", self.otawp_settings.admin)\n    logger.debug(\"OTAWP Password         = %s\", self.otawp_settings.password)\n    logger.info(\"OTAWP K8s Stateful Set = %s\", self.otawp_settings.k8s_statefulset)\n    logger.info(\"OTAWP K8s Config Map   = %s\", self.otawp_settings.k8s_configmap)\n\n    logger.info(\n        \"Wait for OTCS to create its OTDS resource with name -&gt; %s...\",\n        self.otcs_settings.resource_name,\n    )\n\n    # Loop to wait for OTCS to create its OTDS resource\n    # (we need it to update the AppWorks K8s Config Map):\n    otcs_resource = self.otds_object.get_resource(self.otcs_settings.resource_name)\n    while otcs_resource is None:\n        logger.warning(\n            \"OTDS resource for Content Server with name -&gt; %s does not exist yet. Waiting...\",\n            self.otcs_settings.resource_name,\n        )\n        time.sleep(30)\n        otcs_resource = self.otds_object.get_resource(\n            self.otcs_settings.resource_name\n        )\n\n    otcs_resource_id = otcs_resource[\"resourceID\"]\n\n    logger.info(\"OTDS resource ID for Content Server -&gt; %s\", otcs_resource_id)\n\n    # make sure code is idempotent and only try to add ressource if it doesn't exist already:\n    awp_resource = self.otds_object.get_resource(self.otawp_settings.resource_name)\n    if not awp_resource:\n        logger.info(\n            \"OTDS resource -&gt; %s for AppWorks Platform does not yet exist. Creating...\",\n            self.otawp_settings.resource_name,\n        )\n        # Create a Python dict with the special payload we need for AppWorks:\n        additional_payload = {}\n        additional_payload[\"connectorid\"] = \"rest\"\n        additional_payload[\"resourceType\"] = \"rest\"\n        user_attribute_mapping = [\n            {\n                \"sourceAttr\": [\"oTExternalID1\"],\n                \"destAttr\": \"__NAME__\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"displayname\"],\n                \"destAttr\": \"DisplayName\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\"sourceAttr\": [\"mail\"], \"destAttr\": \"Email\", \"mappingFormat\": \"%s\"},\n            {\n                \"sourceAttr\": [\"oTTelephoneNumber\"],\n                \"destAttr\": \"Telephone\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTMobile\"],\n                \"destAttr\": \"Mobile\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n                \"destAttr\": \"Fax\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTStreetAddress,l,st,postalCode,c\"],\n                \"destAttr\": \"Address\",\n                \"mappingFormat\": \"%s%n%s %s %s%n%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTCompany\"],\n                \"destAttr\": \"Company\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"ds-pwp-account-disabled\"],\n                \"destAttr\": \"AccountDisabled\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTExtraAttr9\"],\n                \"destAttr\": \"IsServiceAccount\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"custom:proxyConfiguration\"],\n                \"destAttr\": \"ProxyConfiguration\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"c\"],\n                \"destAttr\": \"Identity-CountryOrRegion\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"gender\"],\n                \"destAttr\": \"Identity-Gender\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"displayName\"],\n                \"destAttr\": \"Identity-DisplayName\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTStreetAddress\"],\n                \"destAttr\": \"Identity-Address\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"l\"],\n                \"destAttr\": \"Identity-City\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"mail\"],\n                \"destAttr\": \"Identity-Email\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"givenName\"],\n                \"destAttr\": \"Identity-FirstName\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"sn\"],\n                \"destAttr\": \"Identity-LastName\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"initials\"],\n                \"destAttr\": \"Identity-MiddleNames\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTMobile\"],\n                \"destAttr\": \"Identity-Mobile\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"postalCode\"],\n                \"destAttr\": \"Identity-PostalCode\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"st\"],\n                \"destAttr\": \"Identity-StateOrProvince\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"title\"],\n                \"destAttr\": \"Identity-title\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"physicalDeliveryOfficeName\"],\n                \"destAttr\": \"Identity-physicalDeliveryOfficeName\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n                \"destAttr\": \"Identity-oTFacsimileTelephoneNumber\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"notes\"],\n                \"destAttr\": \"Identity-notes\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTCompany\"],\n                \"destAttr\": \"Identity-oTCompany\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTDepartment\"],\n                \"destAttr\": \"Identity-oTDepartment\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"birthDate\"],\n                \"destAttr\": \"Identity-Birthday\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"cn\"],\n                \"destAttr\": \"Identity-UserName\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"Description\"],\n                \"destAttr\": \"Identity-UserDescription\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"oTTelephoneNumber\"],\n                \"destAttr\": \"Identity-Phone\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"displayName\"],\n                \"destAttr\": \"Identity-IdentityDisplayName\",\n                \"mappingFormat\": \"%s\",\n            },\n        ]\n        additional_payload[\"userAttributeMapping\"] = user_attribute_mapping\n        group_attribute_mapping = [\n            {\n                \"sourceAttr\": [\"cn\"],\n                \"destAttr\": \"__NAME__\",\n                \"mappingFormat\": '%js:function format(name) { return name.replace(/&amp;/g,\"-and-\"); }',\n            },\n            {\n                \"sourceAttr\": [\"description\"],\n                \"destAttr\": \"Description\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"description\"],\n                \"destAttr\": \"Identity-Description\",\n                \"mappingFormat\": \"%s\",\n            },\n            {\n                \"sourceAttr\": [\"displayName\"],\n                \"destAttr\": \"Identity-DisplayName\",\n                \"mappingFormat\": \"%s\",\n            },\n        ]\n        additional_payload[\"groupAttributeMapping\"] = group_attribute_mapping\n        additional_payload[\"connectorName\"] = \"REST (Generic)\"\n        additional_payload[\"pcCreatePermissionAllowed\"] = \"true\"\n        additional_payload[\"pcModifyPermissionAllowed\"] = \"true\"\n        additional_payload[\"pcDeletePermissionAllowed\"] = \"false\"\n        additional_payload[\"connectionParamInfo\"] = [\n            {\n                \"name\": \"fBaseURL\",\n                \"value\": \"http://appworks:8080/home/system/app/otdspush\",\n            },\n            {\"name\": \"fUsername\", \"value\": self.otawp_settings.admin},\n            {\"name\": \"fPassword\", \"value\": self.otawp_settings.password},\n        ]\n\n        awp_resource = self.otds_object.add_resource(\n            self.otawp_settings.resource_name,\n            \"AppWorks Platform\",\n            \"AppWorks Platform\",\n            additional_payload,\n        )\n    else:\n        logger.info(\n            \"OTDS resource -&gt; %s for AppWorks Platform does already exist.\",\n            self.otawp_settings.resource_name,\n        )\n\n    awp_resource_id = awp_resource[\"resourceID\"]\n\n    logger.info(\"OTDS resource ID for AppWorks Platform -&gt; %s\", awp_resource_id)\n\n    self.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = str(awp_resource_id)\n\n    logger.debug(\n        \"Placeholder values after OTAWP init = %s\", self.settings.placeholder_values\n    )\n\n    logger.info(\"Update AppWorks Kubernetes Config Map with OTDS resource IDs...\")\n\n    config_map = self.k8s_object.get_config_map(self.otawp_settings.k8s_configmap)\n    if not config_map:\n        logger.error(\n            \"Failed to retrieve AppWorks Kubernetes Config Map -&gt; %s\",\n            self.otawp_settings.k8s_configmap,\n        )\n    else:\n        solution = yaml.safe_load(config_map.data[\"solution.yaml\"])  # type: ignore\n\n        # Change values as required\n        solution[\"platform\"][\"organizations\"][\"system\"][\"otds\"][\n            \"resourceId\"\n        ] = awp_resource_id\n        solution[\"platform\"][\"content\"][\"ContentServer\"][\n            \"contentServerUrl\"\n        ] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cs/cs\"\n        solution[\"platform\"][\"content\"][\"ContentServer\"][\n            \"contentServerSupportDirectoryUrl\"\n        ] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cssupport\"\n        solution[\"platform\"][\"content\"][\"ContentServer\"][\n            \"otdsResourceId\"\n        ] = otcs_resource_id\n        solution[\"platform\"][\"authenticators\"][\"OTDS_auth\"][\"publicLoginUrl\"] = (\n            self.otds_settings.public_protocol\n            + \"://\"\n            + self.otds_settings.public_url\n            + \"/otdsws/login\"\n        )\n        solution[\"platform\"][\"security\"][\"contentSecurityPolicy\"] = (\n            \"frame-ancestors 'self' \"\n            + self.otcs_settings.public_protocol\n            + \"://\"\n            + self.otcs_settings.public_url\n        )\n        data = {\"solution.yaml\": yaml.dump(solution)}\n        result = self.k8s_object.replace_config_map(\n            self.otawp_settings.k8s_configmap, data\n        )\n        if result:\n            logger.info(\"Successfully updated AppWorks Solution YAML.\")\n        else:\n            logger.error(\"Failed to update AppWorks Solution YAML.\")\n        logger.debug(\"Solution YAML for AppWorks -&gt; %s\", solution)\n\n    logger.info(\"Scale AppWorks Kubernetes Stateful Set to 1...\")\n    self.k8s_object.scale_stateful_set(\n        sts_name=self.otawp_settings.k8s_statefulset, scale=1\n    )\n\n    # Add the OTCS Admin user to the AppWorks Access Role in OTDS\n    self.otds_object.add_user_to_access_role(\n        \"Access to \" + self.otawp_settings.resource_name, \"otadmin@otds.admin\"\n    )\n\n    # Loop to wait for OTCS to create its OTDS user partition:\n    otcs_partition = self.otds_object.get_partition(\n        self.otcs_settings.partition, show_error=False\n    )\n    while otcs_partition is None:\n        logger.warning(\n            \"OTDS user partition for Content Server with name -&gt; %s does not exist yet. Waiting...\",\n            self.otcs_settings.partition,\n        )\n\n        time.sleep(30)\n        otcs_partition = self.otds_object.get_partition(\n            self.otcs_settings.partition, show_error=False\n        )\n\n    # Add the OTDS user partition for OTCS to the AppWorks Platform Access Role in OTDS.\n    # This will effectvely sync all OTCS users with AppWorks Platform:\n    self.otds_object.add_partition_to_access_role(\n        self.otawp_settings.access_role_name, self.otcs_settings.partition\n    )\n\n    # Add the OTDS admin partition to the AppWorks Platform Access Role in OTDS.\n    self.otds_object.add_partition_to_access_role(\n        self.otawp_settings.access_role_name, self.otds_settings.admin_partition\n    )\n\n    # Set Group inclusion for Access Role for OTAWP to \"True\":\n    self.otds_object.update_access_role_attributes(\n        self.otawp_settings.access_role_name,\n        [{\"name\": \"pushAllGroups\", \"values\": [\"True\"]}],\n    )\n\n    # Add ResourceID User to OTDSAdmin to allow push\n    self.otds_object.add_user_to_group(\n        user=str(awp_resource_id) + \"@otds.admin\", group=\"otdsadmins@otds.admin\"\n    )\n\n    # Allow impersonation for all users:\n    self.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n\n    # Add SPS license for OTAWP\n    # check if the license file exists, otherwise skip for versions pre 24.1\n    if os.path.isfile(self.otawp_settings.license_file):\n        logger.info(\n            \"OTAWP license file (%s) found, assiging to ressource %s\",\n            self.otawp_settings.license_file,\n            self.otawp_settings.resource_name,\n        )\n\n        otawp_license = self.otds_object.add_license_to_resource(\n            self.otawp_settings.license_file,\n            self.otawp_settings.product_name,\n            self.otawp_settings.product_description,\n            awp_resource[\"resourceID\"],\n        )\n        if not otawp_license:\n            logger.error(\n                \"Couldn't apply license -&gt; %s for product -&gt; %s to OTDS resource -&gt; %s\",\n                self.otawp_settings.license_file,\n                self.otawp_settings.product_name,\n                awp_resource[\"resourceID\"],\n            )\n        else:\n            logger.info(\n                \"Successfully applied license -&gt; %s for product -&gt; %s to OTDS resource -&gt; %s\",\n                self.otawp_settings.license_file,\n                self.otawp_settings.product_name,\n                awp_resource[\"resourceID\"],\n            )\n\n        # Assign AppWorks license to Content Server Members Partiton and otds.admin:\n        for partition_name in [\"otds.admin\", self.otcs_settings.partition]:\n            if self.otds_object.is_partition_licensed(\n                partition_name=partition_name,\n                resource_id=awp_resource[\"resourceID\"],\n                license_feature=\"USERS\",\n                license_name=self.otawp_settings.product_name,\n            ):\n                logger.info(\n                    \"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\n                    partition_name,\n                    self.otawp_settings.product_name,\n                    \"USERS\",\n                )\n            else:\n                assigned_license = self.otds_object.assign_partition_to_license(\n                    partition_name,\n                    awp_resource[\"resourceID\"],\n                    \"USERS\",\n                    self.otawp_settings.product_name,\n                )\n                if not assigned_license:\n                    logger.error(\n                        \"Partition -&gt; %s could not be assigned to license -&gt; %s (%s)\",\n                        partition_name,\n                        self.otawp_settings.product_name,\n                        \"USERS\",\n                    )\n                else:\n                    logger.info(\n                        \"Partition -&gt; %s successfully assigned to license -&gt; %s (%s)\",\n                        partition_name,\n                        self.otawp_settings.product_name,\n                        \"USERS\",\n                    )\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otcs","title":"<code>init_otcs(hostname, port, partition_name, resource_name)</code>","text":"<p>Initialize the OTCS class and parameters and authenticate at OTCS once it is ready.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>OTCS hostname</p> required <code>port</code> <code>int</code> <p>port number of OTCS</p> required <code>partition_name</code> <code>str</code> <p>name of OTDS Partition for Extended ECM users</p> required <code>resource_name</code> <code>str</code> <p>name of OTDS resource for Extended ECM</p> required <p>Returns:     OTCS: OTCS object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otcs(\n    self,\n    hostname: str,\n    port: int,\n    partition_name: str,\n    resource_name: str,\n) -&gt; OTCS:\n    \"\"\"Initialize the OTCS class and parameters and authenticate at OTCS once it is ready.\n\n    Args:\n        hostname (str): OTCS hostname\n        port (int): port number of OTCS\n        partition_name (str): name of OTDS Partition for Extended ECM users\n        resource_name (str): name of OTDS resource for Extended ECM\n    Returns:\n        OTCS: OTCS object\n    \"\"\"\n\n    logger.info(\"Connection parameters OTCS (Extended ECM):\")\n    logger.info(\"OTCS Protocol              = %s\", self.otcs_settings.protocol)\n    logger.info(\n        \"OTCS Public Protocol       = %s\", self.otcs_settings.public_protocol\n    )\n    logger.info(\"OTCS Hostname              = %s\", hostname)\n    logger.info(\"OTCS Public URL            = %s\", self.otcs_settings.public_url)\n    logger.info(\"OTCS Port                  = %s\", str(port))\n    logger.info(\"OTCS Admin User            = %s\", self.otcs_settings.admin)\n    logger.debug(\"OTCS Admin Password        = %s\", self.otcs_settings.password)\n    logger.info(\"OTCS User Partition        = %s\", partition_name)\n    logger.info(\"OTCS Resource Name         = %s\", resource_name)\n    logger.info(\n        \"OTCS User Default License  = %s\", self.otcs_settings.license_feature\n    )\n    logger.info(\n        \"OTCS K8s Frontend Pods     = %s\",\n        self.otcs_settings.k8s_statefulset_frontend,\n    )\n    logger.info(\n        \"OTCS K8s Backend Pods      = %s\",\n        self.otcs_settings.k8s_statefulset_backend,\n    )\n\n    logger.debug(\"Checking if OTCS object has already been initialized\")\n\n    otds_ticket = (\n        self.otds_object.cookie()[\"OTDSTicket\"] if self.otds_object else None\n    )\n    otcs_object = OTCS(\n        self.otcs_settings.protocol,\n        hostname,\n        int(port),\n        self.otcs_settings.public_protocol + \"://\" + self.otcs_settings.public_url,\n        self.otcs_settings.admin,\n        self.otcs_settings.password,\n        partition_name,\n        resource_name,\n        otds_ticket=otds_ticket,\n    )\n\n    # It is important to wait for OTCS to be configured - otherwise we\n    # may interfere with the OTCS container automation and run into errors\n    logger.info(\"Wait for OTCS to be configured...\")\n    otcs_configured = otcs_object.is_configured()\n    while not otcs_configured:\n        logger.warning(\"OTCS is not configured yet. Waiting 30 seconds...\")\n        time.sleep(30)\n        otcs_configured = otcs_object.is_configured()\n    logger.info(\"OTCS is configured now.\")\n\n    logger.info(\"Authenticating to OTCS...\")\n    otcs_cookie = otcs_object.authenticate()\n    while otcs_cookie is None:\n        logger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\n        time.sleep(30)\n        otcs_cookie = otcs_object.authenticate()\n    logger.info(\"OTCS is ready now.\")\n\n    if self.otcs_settings.update_admin_user:\n        # Set first name and last name of Admin user (ID = 1000):\n        otcs_object.update_user(1000, field=\"first_name\", value=\"Terrarium\")\n        otcs_object.update_user(1000, field=\"last_name\", value=\"Admin\")\n\n    if \"OTCS_RESSOURCE_ID\" not in self.settings.placeholder_values:\n        self.settings.placeholder_values[\n            \"OTCS_RESSOURCE_ID\"\n        ] = self.otds_object.get_resource(self.otcs_settings.resource_name)[\n            \"resourceID\"\n        ]\n        logger.debug(\n            \"Placeholder values after OTCS init = %s\",\n            self.settings.placeholder_values,\n        )\n\n    if self.otawp_settings.enabled:\n        otcs_resource = self.otds_object.get_resource(\n            self.otcs_settings.resource_name\n        )\n        otcs_resource[\n            \"logoutURL\"\n        ] = f\"{self.otawp_settings.public_protocol}://{self.otawp_settings.public_url}/home/system/wcp/sso/sso_logout.htm\"\n        otcs_resource[\"logoutMethod\"] = \"GET\"\n\n        self.otds_object.update_resource(name=\"cs\", resource=otcs_resource)\n\n    # Allow impersonation of the resource for all users:\n    self.otds_object.impersonate_resource(resource_name)\n\n    return otcs_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otds","title":"<code>init_otds()</code>","text":"<p>Initialize the OTDS object and parameters and authenticate at OTDS once it is ready.</p> <p>Returns:     object: OTDS object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otds(self) -&gt; OTDS:\n    \"\"\"Initialize the OTDS object and parameters and authenticate at OTDS once it is ready.\n\n    Args:\n        None\n    Returns:\n        object: OTDS object\n    \"\"\"\n\n    logger.info(\"Connection parameters OTDS:\")\n    logger.info(\"OTDS Protocol          = %s\", self.otds_settings.protocol)\n    logger.info(\"OTDS Public Protocol   = %s\", self.otds_settings.public_protocol)\n    logger.info(\"OTDS Hostname          = %s\", self.otds_settings.hostname)\n    logger.info(\"OTDS Public URL        = %s\", self.otds_settings.public_url)\n    logger.info(\"OTDS Port              = %s\", str(self.otds_settings.port))\n    logger.info(\"OTDS Admin User        = %s\", self.otds_settings.username)\n    logger.debug(\"OTDS Admin Password    = %s\", self.otds_settings.password)\n    logger.debug(\"OTDS Ticket            = %s\", self.otds_settings.otds_ticket)\n    logger.info(\"OTDS Admin Partition   = %s\", self.otds_settings.admin_partition)\n\n    otds_object = OTDS(\n        protocol=self.otds_settings.protocol,\n        hostname=self.otds_settings.hostname,\n        port=self.otds_settings.port,\n        username=self.otds_settings.username,\n        password=self.otds_settings.password,\n        otds_ticket=self.otds_settings.otds_ticket,\n    )\n\n    logger.info(\"Authenticating to OTDS...\")\n    otds_cookie = otds_object.authenticate()\n    while otds_cookie is None:\n        logger.warning(\"Waiting 30 seconds for OTDS to become ready...\")\n        time.sleep(30)\n        otds_cookie = otds_object.authenticate()\n    logger.info(\"OTDS is ready now.\")\n\n    logger.info(\"Enable OTDS audit...\")\n\n    if self.otds_settings.enable_audit:\n        otds_object.enable_audit()\n\n    if self.otds_settings.disable_password_policy:\n        logger.info(\"Disable OTDS password expiry...\")\n        # Setting the value to 0 disables password expiry.\n        # The default is 90 days and we may have Terrarium\n        # instances that are running longer than that. This\n        # avoids problems with customerizer re-runs of\n        # instances that are &gt; 90 days old.\n        otds_object.update_password_policy(\n            update_values={\"passwordMaximumDuration\": 0}\n        )\n\n    return otds_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otiv","title":"<code>init_otiv()</code>","text":"<p>Initialize the OTIV (Intelligent Viewing) object and its OTDS settings.</p> <p>Returns:     objects: OTIV object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otiv(self) -&gt; OTIV | None:\n    \"\"\"Initialize the OTIV (Intelligent Viewing) object and its OTDS settings.\n\n    Args:\n    Returns:\n        objects: OTIV object\n    \"\"\"\n\n    logger.info(\"Parameters for OTIV (Intelligent Viewing):\")\n    logger.info(\"OTDS Resource Name       = %s\", self.otiv_settings.resource_name)\n    logger.info(\"OTIV License File        = %s\", self.otiv_settings.license_file)\n    logger.info(\"OTIV Product Name        = %s\", self.otiv_settings.product_name)\n    logger.info(\n        \"OTIV Product Description = %s\", self.otiv_settings.product_description\n    )\n    logger.info(\"OTIV License Feature     = %s\", self.otiv_settings.license_feature)\n\n    otiv_object = OTIV(\n        resource_name=self.otiv_settings.resource_name,\n        product_name=self.otiv_settings.product_name,\n        product_description=self.otiv_settings.product_description,\n        license_file=self.otiv_settings.license_file,\n        default_license=self.otiv_settings.license_feature,\n    )\n\n    otiv_resource = self.otds_object.get_resource(self.otiv_settings.resource_name)\n    while otiv_resource is None:\n        logger.warning(\n            \"OTDS Resource -&gt; %s for Intelligent Viewing not found. OTIV may not be ready. Wait 30 sec...\",\n            self.otiv_settings.resource_name,\n        )\n        time.sleep(30)\n        otiv_resource = self.otds_object.get_resource(\n            self.otiv_settings.resource_name\n        )\n\n    otiv_license = self.otds_object.add_license_to_resource(\n        self.otiv_settings.license_file,\n        self.otiv_settings.product_name,\n        self.otiv_settings.product_description,\n        otiv_resource[\"resourceID\"],\n    )\n    if not otiv_license:\n        logger.info(\n            \"Couldn't apply license -&gt; %s for product -&gt; %s. Intelligent Viewing may not be deployed!\",\n            self.otiv_settings.license_file,\n            self.otiv_settings.product_name,\n        )\n        return None\n\n    return otiv_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otpd","title":"<code>init_otpd()</code>","text":"<p>Initialize the OTPD (PowerDocs) object and parameters.</p> <p>Returns:     object: OTPD (PowerDocs) object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otpd(self) -&gt; OTPD:\n    \"\"\"Initialize the OTPD (PowerDocs) object and parameters.\n\n    Args:\n        None\n    Returns:\n        object: OTPD (PowerDocs) object\n    \"\"\"\n\n    logger.info(\"Connection parameters OTPD (PowerDocs):\")\n    logger.info(\"OTPD Protocol             = %s\", self.otpd_settings.protocol)\n    logger.info(\"OTPD Hostname             = %s\", self.otpd_settings.hostname)\n    logger.info(\"OTPD Port                 = %s\", str(self.otpd_settings.port))\n    logger.info(\"OTPD API User             = %s\", self.otpd_settings.user)\n    logger.info(\"OTPD Tenant               = %s\", self.otpd_settings.tenant)\n    logger.info(\n        \"OTPD Database Import File = %s\",\n        (\n            self.otpd_settings.db_importfile\n            if self.otpd_settings.db_importfile != \"\"\n            else \"&lt;not configured&gt;\"\n        ),\n    )\n    logger.info(\"OTPD K8s Pod Name         = %s\", self.otpd_settings.k8s_pod_name)\n\n    otpd_object = OTPD(\n        self.otpd_settings.protocol,\n        self.otpd_settings.hostname,\n        int(self.otpd_settings.port),\n        self.otpd_settings.user,\n        self.otpd_settings.password,\n    )\n\n    # wait until the OTPD pod is in ready state\n    self.k8s_object.wait_pod_condition(self.otpd_settings.k8s_pod_name, \"Ready\")\n\n    # We have a race condition here. Even if the pod is ready\n    # it may not yet have fully initialized its database.\n    # Then the \"apply_setting()\" calls below may fail with\n    # an error. This should be improved in the future. For now\n    # we just wait a minute hoping that the DB is initialized then.\n    logger.info(\"Wait some time for PowerDocs database to be initialized...\")\n    time.sleep(60)\n    logger.info(\"Configure some basic PowerDocs settings...\")\n\n    # Fix settings for local Kubernetes deployments.\n    # Unclear why this is not the default.\n    if otpd_object:\n        otpd_object.apply_setting(\"LocalOtdsUrl\", \"http://otds/otdsws\")\n        otpd_object.apply_setting(\n            \"LocalApplicationServerUrlForContentManager\",\n            \"http://localhost:8080/c4ApplicationServer\",\n            self.otpd_settings.tenant,\n        )\n\n    return otpd_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.log_header","title":"<code>log_header(text, char='=', length=60)</code>","text":"<p>Helper method to output a section header in the log file</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>description</p> required <code>char</code> <code>str</code> <p>header line character. Defaults to \"=\".</p> <code>'='</code> <code>length</code> <code>int</code> <p>maxium length. Defaults to 60.</p> <code>60</code> <p>Returns:     None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def log_header(self, text: str, char: str = \"=\", length: int = 60):\n    \"\"\"Helper method to output a section header in the log file\n\n    Args:\n        text (str): _description_\n        char (str, optional): header line character. Defaults to \"=\".\n        length (int, optional): maxium length. Defaults to 60.\n    Returns:\n        None\n    \"\"\"\n\n    # Calculate the remaining space for the text after adding spaces\n    available_space = max(\n        0, length - len(text) - 2\n    )  # 2 accounts for the spaces each side of the text\n\n    # Calculate the number of characters needed on each side\n    char_count = available_space // 2\n    extra_char = available_space % 2  # do we have lost 1 char?\n\n    # Ensure there are at least 3 characters on each side\n    char_count = max(3, char_count)\n\n    # Build the header string, extra_char is either 0 or 1\n    logger.info(\n        \"%s %s %s\", char * char_count, text, char * (char_count + extra_char)\n    )\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.restart_otac_service","title":"<code>restart_otac_service()</code>","text":"<p>Restart the Archive Center spawner service in OTAC pod</p> <p>Returns:     bool: True if restart was done, False if error occured</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def restart_otac_service(self) -&gt; bool:\n    \"\"\"Restart the Archive Center spawner service in OTAC pod\n\n    Args:\n        None\n    Returns:\n        bool: True if restart was done, False if error occured\n    \"\"\"\n\n    if not self.otac_settings.enabled:\n        return False\n\n    logger.info(\n        \"Restarting spawner service in Archive Center pod -&gt; %s\",\n        self.otac_settings.k8s_pod_name,\n    )\n    # The Archive Center Spawner needs to be run in \"interactive\" mode - otherwise the command will \"hang\":\n    # The \"-c\" parameter is not required in this case\n    # False is given as parameter as OTAC writes non-errors to stderr\n    response = self.k8s_object.exec_pod_command_interactive(\n        self.otac_settings.k8s_pod_name,\n        [\"/bin/sh\", \"/etc/init.d/spawner restart\"],\n        60,\n        False,\n    )\n\n    if response:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.restart_otawp_pod","title":"<code>restart_otawp_pod()</code>","text":"<p>Delete the AppWorks Platform Pod to make Kubernetes restart it.</p> <p>Returns:     None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def restart_otawp_pod(self):\n    \"\"\"Delete the AppWorks Platform Pod to make Kubernetes restart it.\n\n    Args:\n    Returns:\n        None\n    \"\"\"\n\n    self.k8s_object.delete_pod(self.otawp_settings.k8s_statefulset + \"-0\")\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.restart_otcs_service","title":"<code>restart_otcs_service(otcs_object, extra_wait_time=60)</code>","text":"<p>Restart the Content Server service in all OTCS pods</p> <p>Parameters:</p> Name Type Description Default <code>otcs_object</code> <code>OTCS</code> <p>OTCS class instance (object)</p> required <p>Returns:     None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def restart_otcs_service(self, otcs_object: OTCS, extra_wait_time: int = 60):\n    \"\"\"Restart the Content Server service in all OTCS pods\n\n    Args:\n        otcs_object: OTCS class instance (object)\n    Returns:\n        None\n    \"\"\"\n\n    if not self.k8s_object:\n        logger.warning(\n            \"Kubernetes integration not available, skipping restart of services\"\n        )\n        return\n\n    logger.info(\"Restart OTCS frontend and backend pods...\")\n\n    # Restart all frontends:\n    for x in range(0, self.otcs_settings.replicas_frontend):\n        pod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\n\n        logger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n        )\n        logger.info(\"Restarting pod -&gt; %s\", pod_name)\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n        )\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n        )\n\n    # Restart all backends:\n    for x in range(0, self.otcs_settings.replicas_backend):\n        pod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\n\n        logger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n        )\n        logger.info(\"Restarting pod -&gt; %s\", pod_name)\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n        )\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n        )\n\n    logger.info(\"Re-Authenticating to OTCS after restart of pods...\")\n    otcs_cookie = otcs_object.authenticate(revalidate=True)\n    while otcs_cookie is None:\n        logger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\n        time.sleep(30)\n        otcs_cookie = otcs_object.authenticate(revalidate=True)\n    logger.info(\"OTCS is ready again.\")\n\n    # Reactivate Liveness probes in all pods:\n    for x in range(0, self.otcs_settings.replicas_frontend):\n        pod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\n\n        logger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n        )\n\n    for x in range(0, self.otcs_settings.replicas_backend):\n        pod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\n\n        logger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\n        self.k8s_object.exec_pod_command(\n            pod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n        )\n\n    logger.info(\"Restart OTCS frontend and backend pods has been completed.\")\n\n    # optional, give some additional time to make sure service is responsive\n    if extra_wait_time &gt; 0:\n        logger.info(\n            \"Wait %s seconds to make sure OTCS is responsive again...\",\n            str(extra_wait_time),\n        )\n        time.sleep(extra_wait_time)\n    logger.info(\"Continue customizing...\")\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.set_maintenance_mode","title":"<code>set_maintenance_mode(enable=True)</code>","text":"<p>Enable or Disable Maintenance Mode</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def set_maintenance_mode(self, enable: bool = True):\n    \"\"\"Enable or Disable Maintenance Mode\n\n    Args:\n        enable (bool, optional): _description_. Defaults to True.\n    \"\"\"\n    if enable and self.k8s_settings.enabled:\n        self.log_header(\"Enable Maintenance Mode\")\n        logger.info(\n            \"Put OTCS frontends in Maitenance Mode by changing the Kubernetes Ingress backend service...\"\n        )\n        self.k8s_object.update_ingress_backend_services(\n            self.otcs_settings.k8s_ingress,\n            \"otcs\",\n            self.otcs_settings.maintenance_service_name,\n            self.otcs_settings.mainteance_service_port,\n        )\n        logger.info(\"OTCS frontend is now in Maintenance Mode!\")\n    elif not self.k8s_settings.enabled:\n        logger.warning(\n            \"Kubernetes Integration disabled - Cannot Enable/Disable Maintenance Mode\"\n        )\n        self.k8s_object = None\n    else:\n        # Changing the Ingress backend service to OTCS frontend service:\n        logger.info(\n            \"Put OTCS frontend back in Production Mode by changing the Kubernetes Ingress backend service...\"\n        )\n        self.k8s_object.update_ingress_backend_services(\n            self.otcs_settings.k8s_ingress,\n            \"otcs\",\n            self.otcs_settings.hostname_frontend,\n            self.otcs_settings.port_frontend,\n        )\n        logger.info(\"OTCS frontend is now back in Production Mode!\")\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettings","title":"<code>CustomizerSettings</code>  <code>dataclass</code>","text":"<p>Class to manage settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettings:\n    \"\"\"Class to manage settings\"\"\"\n\n    placeholder_values: dict = field(default_factory=dict)\n    stop_on_error: bool = os.environ.get(\"LOGLEVEL\", \"INFO\") == \"DEBUG\"\n    cust_log_file: str = \"/tmp/customizing.log\"\n    customizer_start_time = customizer_end_time = datetime.now()\n\n    # The following CUST artifacts are created by the main.tf in the python module:\n    cust_settings_dir: str = \"/settings/\"\n    cust_payload_dir: str = \"/payload/\"\n    cust_payload: str = cust_payload_dir + \"payload.yaml\"\n    cust_payload_gz: str = cust_payload_dir + \"payload.yml.gz.b64\"\n    cust_payload_external: str = \"/payload-external/\"\n\n    cust_target_folder_nickname: str = (\n        \"deployment\"  # nickname of folder to upload payload and log files\n    )\n    # CUST_RM_SETTINGS_DIR = \"/opt/opentext/cs/appData/supportasset/Settings/\"\n    cust_rm_settings_dir = cust_settings_dir\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsAviator","title":"<code>CustomizerSettingsAviator</code>  <code>dataclass</code>","text":"<p>Class for Aviator related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsAviator:\n    \"\"\"Class for Aviator related settings\"\"\"\n\n    enabled: bool = os.environ.get(\"AVIATOR_ENABLED\", \"false\").lower() == \"true\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsK8S","title":"<code>CustomizerSettingsK8S</code>  <code>dataclass</code>","text":"<p>Class for K8s related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsK8S:\n    \"\"\"Class for K8s related settings\"\"\"\n\n    enabled: bool = os.environ.get(\"K8S_ENABLED\", \"true\").lower() == \"true\"\n    in_cluster: bool = True\n    kubeconfig_file: str = \"~/.kube/config\"\n    namespace: str = \"default\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsM365","title":"<code>CustomizerSettingsM365</code>  <code>dataclass</code>","text":"<p>Class for O365 related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsM365:\n    \"\"\"Class for O365 related settings\"\"\"\n\n    enabled: bool = os.environ.get(\"O365_ENABLED\", \"false\").lower() == \"true\"\n    tenant_id: str = os.environ.get(\"O365_TENANT_ID\", \"\")\n    client_id: str = os.environ.get(\"O365_CLIENT_ID\", \"\")\n    client_secret: str = os.environ.get(\"O365_CLIENT_SECRET\", \"\")\n    user: str = os.environ.get(\"O365_USER\", \"\")\n    password: str = os.environ.get(\"O365_PASSWORD\", \"\")\n    domain: str = os.environ.get(\"O365_DOMAIN\", \"\")\n    sku_id: str = os.environ.get(\"O365_SKU_ID\", \"c7df2760-2c81-4ef7-b578-5b5392b571df\")\n    teams_app_name: str = \"OpenText Extended ECM\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTAC","title":"<code>CustomizerSettingsOTAC</code>  <code>dataclass</code>","text":"<p>Class for OTAC related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTAC:\n    \"\"\"Class for OTAC related settings\"\"\"\n\n    enabled: bool = os.environ.get(\"OTAC_ENABLED\", \"false\").lower() == \"true\"\n    hostname: str = os.environ.get(\"OTAC_SERVICE_HOST\", \"otac-0\")\n    port: int = os.environ.get(\"OTAC_SERVICE_PORT\", 8080)\n    protocol: str = os.environ.get(\"OTAC_PROTOCOL\", \"http\")\n    public_url: str = os.environ.get(\"OTAC_PUBLIC_URL\")\n    admin: str = os.environ.get(\"OTAC_ADMIN\", \"dsadmin\")\n    password: str = os.environ.get(\"OTAC_PASSWORD\", \"\")\n    known_server: str = os.environ.get(\"OTAC_KNOWN_SERVER\", \"\")\n    k8s_pod_name: str = \"otac-0\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTAWP","title":"<code>CustomizerSettingsOTAWP</code>  <code>dataclass</code>","text":"<p>Class for OTAWP related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTAWP:\n    \"\"\"Class for OTAWP related settings\"\"\"\n\n    enabled: bool = os.environ.get(\"OTAWP_ENABLED\", \"false\").lower() == \"true\"\n    license_file: str = \"/payload/otawp-license.lic\"\n    product_name: str = \"APPWORKS_PLATFORM\"\n    product_description: str = \"OpenText Appworks Platform\"\n    resource_name: str = \"awp\"\n    access_role_name: str = \"Access to \" + resource_name\n    admin: str = os.environ.get(\"OTAWP_ADMIN\", \"sysadmin\")\n    password: str = os.environ.get(\"OTAWP_PASSWORD\")\n    public_protocol: str = os.environ.get(\"OTAWP_PROTOCOL\", \"https\")\n    public_url: str = os.environ.get(\"OTAWP_PUBLIC_URL\")\n    k8s_statefulset: str = \"appworks\"\n    k8s_configmap: str = \"appworks-config-ymls\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTCS","title":"<code>CustomizerSettingsOTCS</code>  <code>dataclass</code>","text":"<p>Class for OTCS related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTCS:\n    \"\"\"Class for OTCS related settings\"\"\"\n\n    # Content Server Constants:\n    protocol: str = os.environ.get(\"OTCS_PROTOCOL\", \"http\")\n    public_protocol: str = os.environ.get(\"OTCS_PUBLIC_PROTOCOL\", \"https\")\n    hostname: str = os.environ.get(\"OTCS_HOSTNAME\", \"otcs-admin-0\")\n    hostname_backend: str = os.environ.get(\"OTCS_HOSTNAME\", \"otcs-admin-0\")\n    hostname_frontend: str = os.environ.get(\"OTCS_HOSTNAME_FRONTEND\", \"otcs-frontend\")\n    public_url: str = os.environ.get(\"OTCS_PUBLIC_URL\", \"otcs.public-url.undefined\")\n    port: int = os.environ.get(\"OTCS_SERVICE_PORT_OTCS\", 8080)\n    port_backend: int = os.environ.get(\"OTCS_SERVICE_PORT_OTCS\", 8080)\n    port_frontend: int = 80\n    admin: str = os.environ.get(\"OTCS_ADMIN\", \"admin\")\n    password: str = os.environ.get(\"OTCS_PASSWORD\")\n    partition: str = os.environ.get(\"OTCS_PARTITION\", \"Content Server Members\")\n    resource_name: str = \"cs\"\n    k8s_statefulset_frontend: str = \"otcs-frontend\"\n    k8s_statefulset_backend: str = \"otcs-admin\"\n    k8s_ingress: str = \"otxecm-ingress\"\n    maintenance_mode: bool = (\n        os.environ.get(\"OTCS_MAINTENANCE_MODE\", \"true\").lower() == \"true\"\n    )\n    license_feature: str = \"X3\"\n\n    # K8s service name and port for maintenance pod\n    maintenance_service_name: str = \"otxecm-customizer\"\n    mainteance_service_port: int = 5555\n\n    replicas_frontend = 0\n    replicas_backend = 0\n\n    update_admin_user: bool = True\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTDS","title":"<code>CustomizerSettingsOTDS</code>  <code>dataclass</code>","text":"<p>Class for OTDS related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTDS:\n    \"\"\"Class for OTDS related settings\"\"\"\n\n    protocol: str = os.environ.get(\"OTDS_PROTOCOL\", \"http\")\n    public_protocol: str = os.environ.get(\"OTDS_PUBLIC_PROTOCOL\", \"https\")\n    hostname: str = os.environ.get(\"OTDS_HOSTNAME\", \"otds\")\n    port: int = os.environ.get(\"OTDS_SERVICE_PORT_OTDS\", 80)\n    username: str = os.environ.get(\"OTDS_ADMIN\", \"admin\")\n    otds_ticket: str | None = None\n    admin_partition: str = \"otds.admin\"\n    public_url: str = os.environ.get(\"OTDS_PUBLIC_URL\")\n    password: str = os.environ.get(\"OTDS_PASSWORD\")\n    disable_password_policy: bool = True\n    enable_audit: bool = True\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTIV","title":"<code>CustomizerSettingsOTIV</code>  <code>dataclass</code>","text":"<p>Class for OTIV related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTIV:\n    \"\"\"Class for OTIV related settings\"\"\"\n\n    enabled: bool = os.environ.get(\"OTIV_ENABLED\", \"false\").lower() == \"true\"\n    license_file: str = \"/payload/otiv-license.lic\"\n    license_feature: str = \"FULLTIME_USERS_REGULAR\"\n    product_name: str = \"Viewing\"\n    product_description: str = \"OpenText Intelligent Viewing\"\n    resource_name: str = \"iv\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTPD","title":"<code>CustomizerSettingsOTPD</code>  <code>dataclass</code>","text":"<p>Class for OTPD related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTPD:\n    \"\"\"Class for OTPD related settings\"\"\"\n\n    enabled: bool = os.environ.get(\"OTPD_ENABLED\", \"false\").lower() == \"true\"\n    hostname: str = os.environ.get(\"OTPD_SERVICE_HOST\", \"otpd\")\n    port: int = os.environ.get(\"OTPD_SERVICE_PORT\", 8080)\n    protocol: str = os.environ.get(\"OTPD_PROTOCOL\", \"http\")\n    db_importfile: str = os.environ.get(\n        \"OTPD_DBIMPORTFILE\", \"URL://url.download.location/file.zip\"\n    )\n    tenant: str = os.environ.get(\"OTPD_TENANT\", \"Successfactors\")\n    user: str = os.environ.get(\"OTPD_USER\", \"powerdocsapiuser\")\n    password: str = os.environ.get(\n        \"OTPD_PASSWORD\",\n    )\n    k8s_pod_name: str = \"otpd-0\"\n</code></pre>"},{"location":"pyxecm/k8s/","title":"K8s","text":"<p>Kubernetes Module to implement functions to read / write Kubernetes objects such as Pods, Stateful Sets, Config Maps, ...</p> <p>https://github.com/kubernetes-client/python  https://github.com/kubernetes-client/python/blob/master/kubernetes/README.md https://github.com/kubernetes-client/python/tree/master/examples</p> <p>Class: K8s Methods:</p> <p>init : class initializer get_core_v1_api: Get Kubernetes API object for Core APIs get_apps_v1_api: Get Kubernetes API object for Applications (e.g. Stateful Sets) get_networking_v1_api: Get Kubernetes API object for Networking (e.g. Ingress) get_namespace: Get the Kubernetes namespace the K8s object is configured for</p> <p>get_pod: Get a Kubernetes Pod based on its name list_pods: Get a list of Kubernetes pods based on field and label selectors exec_pod_command: Execute a list of commands in a Kubernetes Pod exec_pod_command_interactive: Write commands to stdin and wait for response delete_pod: Delete a running pod (e.g. to make Kubernetes restart it)</p> <p>get_config_map: Get a Kubernetes Config Map based on its name list_config_maps: Get a list of Kubernetes Config Maps based on field and label selectors find_config_map: Find a Kubernetes Config Map based on its name replace_config_map: Replace the data body of a Kubernetes Config Map</p> <p>get_stateful_set: Gets a Kubernetes Stateful Set based on its name get_stateful_set_scale: Gets the number of replicas for a Kubernetes Stateful Set patch_stateful_set: Updates the specification of a Kubernetes Stateful Set scale_stateful_set: Changes number of replicas for a Kubernetes Stateful Set</p> <p>get_service: Get a Kubernetes Service based on its name list_services: Get a list of Kubernetes Services based on field and label selectors patch_service: Update the specification of a Kubernetes Service</p> <p>get_ingress: Get a Kubernetes Ingress based on its name patch_ingress: Update the specification of a Kubernetes Ingress update_ingress_backend_services: Replace the backend service and port for an ingress host</p>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s","title":"<code>K8s</code>","text":"<p>Used to automate stettings in Kubernetes.</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>class K8s:\n    \"\"\"Used to automate stettings in Kubernetes.\"\"\"\n\n    _core_v1_api = None\n    _apps_v1_api = None\n    _networking_v1_api = None\n    _namespace = None\n\n    def __init__(\n        self,\n        in_cluster: bool,\n        kubeconfig_file: str = \"~/.kube/config\",\n        namespace: str = \"default\",\n    ):\n        \"\"\"Initialize the Kubernetes object.\"\"\"\n\n        # Configure Kubernetes API authentication to use pod serviceAccount\n        if in_cluster:\n            config.load_incluster_config()\n        else:\n            if kubeconfig_file:\n                config.load_kube_config(config_file=kubeconfig_file)\n            else:\n                logger.warning(\n                    \"Not runnig in cluster but kubeconfig file not specified!\"\n                )\n\n        self._core_v1_api = client.CoreV1Api()\n        self._apps_v1_api = client.AppsV1Api()\n        self._networking_v1_api = client.NetworkingV1Api()\n        if namespace and not in_cluster:\n            self._namespace = namespace\n        else:\n            # Read current namespace\n            with open(\n                \"/var/run/secrets/kubernetes.io/serviceaccount/namespace\",\n                \"r\",\n                encoding=\"utf-8\",\n            ) as namespace_file:\n                self._namespace = namespace_file.read()\n\n    def get_core_v1_api(self):\n        \"\"\"Returns Kubernetes Core V1 API object\n\n        Returns:\n            object: Kubernetes API object\n        \"\"\"\n        return self._core_v1_api\n\n    def get_apps_v1_api(self):\n        \"\"\"Returns Kubernetes Apps V1 API object\n\n        Returns:\n            object: Kubernetes API object\n        \"\"\"\n        return self._apps_v1_api\n\n    def get_networking_v1_api(self):\n        \"\"\"Returns Kubernetes Networking V1 API object\n\n        Returns:\n            object: Kubernetes API object\n        \"\"\"\n        return self._networking_v1_api\n\n    def get_namespace(self):\n        \"\"\"Returns Kubernetes Namespace\n\n        Returns:\n            str: Kubernetes namespace\n        \"\"\"\n        return self._namespace\n\n    def get_pod(self, pod_name: str):\n        \"\"\"Get a pod in the configured namespace (the namespace is defined\n            in the class constructor).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_pod\n\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n        Returns:\n            V1Pod (object) or None if the call fails.\n            - api_version='v1',\n            - kind='Pod',\n            - metadata=V1ObjectMeta(...),\n            - spec=V1PodSpec(...),\n            - status=V1PodStatus(...)\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().read_namespaced_pod(\n                name=pod_name, namespace=self.get_namespace()\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to get Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def list_pods(self, field_selector: str = \"\", label_selector: str = \"\"):\n        \"\"\"List all Kubernetes pods in a given namespace. The list can be further restricted\n            by specifying a field or label selector.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_pod\n\n        Args:\n            field_selector (str): filter result based on fields\n            label_selector (str): filter result based on labels\n        Returns:\n            V1PodList (object) or None if the call fails\n            Properties can be accessed with the \".\" notation (this is an object not a dict!):\n            - api_version: The Kubernetes API version.\n            - items: A list of V1Pod objects, each representing a pod. You can access the fields of a\n                    V1Pod object using dot notation, for example, pod.metadata.name to access the name of the pod\n            - kind: The Kubernetes object kind, which is always \"PodList\".\n            - metadata: Additional metadata about the pod list, such as the resource version.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1PodList.md\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().list_namespaced_pod(\n                field_selector=field_selector,\n                label_selector=label_selector,\n                namespace=self.get_namespace(),\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to list Pods with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\n                field_selector,\n                label_selector,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def wait_pod_condition(\n        self, pod_name: str, condition_name: str, sleep_time: int = 30\n    ):\n        \"\"\"Wait for the pod to reach a defined condition (e.g. \"Ready\").\n\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n            condition_name (str): name of the condition, e.g. \"Ready\"\n        Returns:\n            True once the pod reaches the condition - otherwise wait forever\n        \"\"\"\n\n        ready = False\n        while not ready:\n            try:\n                pod_status = self.get_core_v1_api().read_namespaced_pod_status(\n                    pod_name, self.get_namespace()\n                )\n\n                # Check if the pod has reached the defined condition:\n                for cond in pod_status.status.conditions:\n                    if cond.type == condition_name and cond.status == \"True\":\n                        logger.info(\n                            \"Pod -&gt; %s is in state -&gt; %s!\", pod_name, condition_name\n                        )\n                        ready = True\n                        break\n                else:\n                    logger.info(\n                        \"Pod -&gt; %s is not yet in state -&gt; %s. Waiting...\",\n                        pod_name,\n                        condition_name,\n                    )\n                    time.sleep(sleep_time)\n                    continue\n\n            except ApiException as exception:\n                logger.error(\n                    \"Failed to wait for pod -&gt; %s; error -&gt; %s\",\n                    pod_name,\n                    str(exception),\n                )\n\n    # end method definition\n\n    def exec_pod_command(\n        self, pod_name: str, command: list, max_retry: int = 3, time_retry: int = 10\n    ):\n        \"\"\"Execute a command inside a Kubernetes Pod (similar to kubectl exec on command line).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#connect_get_namespaced_pod_exec\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n            command (list): list of command and its parameters, e.g. [\"/bin/bash\", \"-c\", \"pwd\"]\n                            The \"-c\" is required to make the shell executing the command.\n            max_retry (int): Max amount of attempts to execute the command\n        Returns:\n            Response of the command or None if the call fails\n        \"\"\"\n\n        pod = self.get_pod(pod_name)\n        if not pod:\n            logger.error(\"Pod -&gt; %s does not exist\", pod_name)\n\n        logger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\n\n        retry_counter = 1\n\n        while retry_counter &lt;= max_retry:\n            try:\n                response = stream(\n                    self.get_core_v1_api().connect_get_namespaced_pod_exec,\n                    pod_name,\n                    self.get_namespace(),\n                    command=command,\n                    stderr=True,\n                    stdin=False,\n                    stdout=True,\n                    tty=False,\n                )\n                logger.debug(response)\n                return response\n            except ApiException as exc:\n                logger.warning(\n                    \"Failed to execute command, retry (%s/%s) -&gt; %s in pod -&gt; %s; error -&gt; %s\",\n                    retry_counter,\n                    max_retry,\n                    command,\n                    pod_name,\n                    str(exc),\n                )\n                retry_counter = retry_counter + 1\n                exception = exc\n                logger.info(\"Wait %s seconds before next retry...\", str(time_retry))\n                time.sleep(time_retry)\n                continue\n\n        logger.error(\n            \"Failed to execute command with %s retries -&gt; %s in pod -&gt; %s; error -&gt; %s\",\n            max_retry,\n            command,\n            pod_name,\n            str(exception),\n        )\n\n        return None\n\n    # end method definition\n\n    # Some commands like the OTAC spawner need to run interactive - otherwise the command \"hangs\"\n    def exec_pod_command_interactive(\n        self,\n        pod_name: str,\n        commands: list,\n        timeout: int = 30,\n        write_stderr_to_error_log: bool = True,\n    ):\n        \"\"\"Execute a command inside a Kubernetes pod (similar to kubectl exec on command line).\n            Other than exec_pod_command() method above this is an interactive execution using\n            stdin and reading the output from stdout and stderr. This is required for longer\n            running commands. It is currently used for restarting the spawner of Archive Center.\n            The output of the command is pushed into the logging.\n\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n            commands (list): list of command and its parameters, e.g. [\"/bin/bash\", \"/etc/init.d/spawner restart\"]\n                             Here we should NOT have a \"-c\" parameter!\n            timeout (int): timeout duration that is waited for any response.\n                           Each time a resonse is found in stdout or stderr we wait another timeout duration\n                           to make sure we get the full output of the command.\n            write_stderr_to_error_log (bool): flag to control if output in stderr should be written to info or error log stream.\n                                              Default is write to error log (True)\n        Returns:\n            str: Response of the command or None if the call fails\n        \"\"\"\n\n        pod = self.get_pod(pod_name)\n        if not pod:\n            logger.error(\"Pod -&gt; %s does not exist\", pod_name)\n\n        if not commands:\n            logger.error(\"No commands to execute on Pod -&gt; %s\", pod_name)\n            return None\n\n        # Get first command - this should be the shell:\n        command = commands.pop(0)\n\n        try:\n            response = stream(\n                self.get_core_v1_api().connect_get_namespaced_pod_exec,\n                pod_name,\n                self.get_namespace(),\n                command=command,\n                stderr=True,\n                stdin=True,  # This is important!\n                stdout=True,\n                tty=False,\n                _preload_content=False,  # This is important!\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to execute command -&gt; %s in pod -&gt; %s; error -&gt; %s\",\n                command,\n                pod_name,\n                str(exception),\n            )\n            return None\n\n        while response.is_open():\n            got_response = False\n            response.update(timeout=timeout)\n            if response.peek_stdout():\n                logger.info(response.read_stdout().replace(\"\\n\", \" \"))\n                got_response = True\n            if response.peek_stderr():\n                if write_stderr_to_error_log:\n                    logger.error(response.read_stderr().replace(\"\\n\", \" \"))\n                else:\n                    logger.info(response.read_stderr().replace(\"\\n\", \" \"))\n                got_response = True\n            if commands:\n                command = commands.pop(0)\n                logger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\n                response.write_stdin(command + \"\\n\")\n            else:\n                # We continue as long as we get some response during timeout period\n                if not got_response:\n                    break\n\n        response.close()\n\n        return response\n\n    # end method definition\n\n    def delete_pod(self, pod_name: str):\n        \"\"\"Delete a pod in the configured namespace (the namespace is defined in the class constructor).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#delete_namespaced_pod\n\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n        Return:\n            V1Status (object) or None if the call fails.\n            - api_version: The Kubernetes API version.\n            - kind: The Kubernetes object kind, which is always \"Status\".\n            - metadata: Additional metadata about the status object, such as the resource version.\n            - status: The status of the operation, which is either \"Success\" or an error status.\n            - message: A human-readable message explaining the status.\n            - reason: A short string that describes the reason for the status.\n            - code: An HTTP status code that corresponds to the status.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Status.md\n        \"\"\"\n\n        pod = self.get_pod(pod_name)\n        if not pod:\n            logger.error(\"Pod -&gt; %s does not exist\", pod_name)\n\n        try:\n            response = self.get_core_v1_api().delete_namespaced_pod(\n                pod_name, namespace=self.get_namespace()\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to delete Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def get_config_map(self, config_map_name: str):\n        \"\"\"Get a config map in the configured namespace (the namespace is defined in the class constructor).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_config_map\n\n        Args:\n            config_map_name (str): name of the Kubernetes config map in the current namespace\n        Returns:\n            V1ConfigMap (object): Kubernetes Config Map object that includes these fields:\n            - api_version: The Kubernetes API version.\n            - metadata: A V1ObjectMeta object representing metadata about the V1ConfigMap object,\n                        such as its name, labels, and annotations.\n            - data: A dictionary containing the non-binary data stored in the ConfigMap,\n                    where the keys represent the keys of the data items and the values represent\n                    the values of the data items.\n            - binary_data: A dictionary containing the binary data stored in the ConfigMap,\n                           where the keys represent the keys of the binary data items and the values\n                           represent the values of the binary data items. Binary data is encoded as base64\n                           strings in the dictionary values.\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().read_namespaced_config_map(\n                name=config_map_name, namespace=self.get_namespace()\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to get Config Map -&gt; %s; error -&gt; %s\",\n                config_map_name,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def list_config_maps(self, field_selector: str = \"\", label_selector: str = \"\"):\n        \"\"\"List all Kubernetes Config Maps in the current namespace.\n            The list can be filtered by providing field selectors and label selectors.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_config_map\n\n        Args:\n            field_selector (str): filter result based on fields\n            label_selector (str): filter result based on labels\n        Returns:\n            V1ConfigMapList (object) or None if the call fails\n            Properties can be accessed with the \".\" notation (this is an object not a dict!):\n            - api_version: The Kubernetes API version.\n            - items: A list of V1ConfigMap objects, each representing a config map. You can access the fields of a\n                     V1Pod object using dot notation, for example, cm.metadata.name to access the name of the config map\n            - kind: The Kubernetes object kind, which is always \"ConfigMapList\".\n            - metadata: Additional metadata about the config map list, such as the resource version.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMapList.md\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().list_namespaced_config_map(\n                field_selector=field_selector,\n                label_selector=label_selector,\n                namespace=self.get_namespace(),\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to list Config Maps with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\n                field_selector,\n                label_selector,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def find_config_map(self, config_map_name: str):\n        \"\"\"Find a Kubernetes Config Map based on its name.\n           This is just a wrapper method for list_config_maps()\n           that uses the name as a field selector.\n\n        Args:\n            config_map_name (str): name of the Config Map\n        Returns:\n            object: V1ConfigMapList (object) or None if the call fails\n        \"\"\"\n\n        try:\n            response = self.list_config_maps(\n                field_selector=\"metadata.name={}\".format(config_map_name)\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to find Config Map -&gt; %s; error -&gt; %s\",\n                config_map_name,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def replace_config_map(self, config_map_name: str, config_map_data: dict):\n        \"\"\"Replace a Config Map with a new specification.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#replace_namespaced_config_map\n\n        Args:\n            config_map_name (str): name of the Kubernetes Config Map\n            config_map_data (dict): new specification of the Config Map\n        Returns:\n            V1ConfigMap (object): updated Kubernetes Config Map object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMap.md\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().replace_namespaced_config_map(\n                name=config_map_name,\n                namespace=self.get_namespace(),\n                body=client.V1ConfigMap(\n                    metadata=client.V1ObjectMeta(\n                        name=config_map_name,\n                    ),\n                    data=config_map_data,\n                ),\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to replace Config Map -&gt; %s; error -&gt; %s\",\n                config_map_name,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def get_stateful_set(self, sts_name: str):\n        \"\"\"Get a Kubernetes Stateful Set based on its name.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set\n\n        Args:\n            sts_name (str): name of the Kubernetes stateful set\n        Returns:\n            V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n            See : https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n        \"\"\"\n\n        try:\n            response = self.get_apps_v1_api().read_namespaced_stateful_set(\n                name=sts_name, namespace=self.get_namespace()\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to get Stateful Set -&gt; %s; error -&gt; %s\",\n                sts_name,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def get_stateful_set_scale(self, sts_name: str):\n        \"\"\"Get the number of replicas for a Kubernetes Stateful Set.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set_scale\n\n        Args:\n            sts_name (str): name of the Kubernetes Stateful Set\n        Returns:\n            V1Scale (object): Kubernetes Scale object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Scale.md\n        \"\"\"\n\n        try:\n            response = self.get_apps_v1_api().read_namespaced_stateful_set_scale(\n                name=sts_name, namespace=self.get_namespace()\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to get scaling (replicas) of Stateful Set -&gt; %s; error -&gt; %s\",\n                sts_name,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def patch_stateful_set(self, sts_name: str, sts_body: dict):\n        \"\"\"Patch a Stateful set with new values.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#patch_namespaced_stateful_set\n\n        Args:\n            sts_name (str): name of the Kubernetes stateful set in the current namespace\n            sts_body (str): patch string\n        Returns:\n            V1StatefulSet (object): patched Kubernetes Stateful Set object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n        \"\"\"\n\n        try:\n            response = self.get_apps_v1_api().patch_namespaced_stateful_set(\n                name=sts_name, namespace=self.get_namespace(), body=sts_body\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to patch Stateful Set -&gt; %s with -&gt; %s; error -&gt; %s\",\n                sts_name,\n                sts_body,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def scale_stateful_set(self, sts_name: str, scale: int):\n        \"\"\"Scale a stateful set to a specific number of replicas.\n           It uses the class method patch_stateful_set() above.\n\n        Args:\n            sts_name (str): name of the Kubernetes stateful set in the current namespace\n            scale (int): number of replicas (pods) the stateful set shall be scaled to\n        Returns:\n            V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n        \"\"\"\n\n        try:\n            response = self.patch_stateful_set(\n                sts_name, sts_body={\"spec\": {\"replicas\": scale}}\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to scale Stateful Set -&gt; %s to -&gt; %s replicas; error -&gt; %s\",\n                sts_name,\n                scale,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def get_service(self, service_name: str):\n        \"\"\"Get a Kubernetes Service with a defined name in the current namespace\n\n        Args:\n            service_name (str): name of the Kubernetes Service in the current namespace\n        Returns:\n            V1Service (object): Kubernetes Service object or None if the call fails\n            This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().read_namespaced_service(\n                name=service_name, namespace=self.get_namespace()\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to get Service -&gt; %s; error -&gt; %s\", service_name, str(exception)\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def list_services(self, field_selector: str = \"\", label_selector: str = \"\"):\n        \"\"\"List all Kubernetes Service in the current namespace.\n            The list can be filtered by providing field selectors and label selectors.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_service\n\n        Args:\n            field_selector (str): filter result based on fields\n            label_selector (str): filter result based on labels\n        Returns:\n            V1ServiceList (object): list of Kubernetes Services or None if the call fails\n            Properties can be accessed with the \".\" notation (this is an object not a dict!):\n            - api_version: The Kubernetes API version.\n            - items: A list of V1Service objects, each representing a service.\n                     You can access the fields of a V1Service object using dot notation,\n                     for example, service.metadata.name to access the name of the service\n            - kind: The Kubernetes object kind, which is always \"ServiceList\".\n            - metadata: Additional metadata about the pod list, such as the resource version.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ServiceList.md\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().list_namespaced_service(\n                field_selector=field_selector,\n                label_selector=label_selector,\n                namespace=self.get_namespace(),\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to list Services with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\n                field_selector,\n                label_selector,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def patch_service(self, service_name: str, service_body: dict):\n        \"\"\"Patches a Kubernetes Service with an updated spec\n\n        Args:\n            service_name (str): name of the Kubernetes Ingress in the current namespace\n            service_body (dict): new / updated Service body spec\n                                 (will be merged with existing values)\n        Returns:\n            V1Service (object): patched Kubernetes Service or None if the call fails\n            This is NOT a dict but an object - you have to use the \".\" syntax\n            to access to returned elements\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n        \"\"\"\n\n        try:\n            response = self.get_core_v1_api().patch_namespaced_service(\n                name=service_name, namespace=self.get_namespace(), body=service_body\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to patch Service -&gt; %s with -&gt; %s; error -&gt; %s\",\n                service_name,\n                service_body,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def get_ingress(self, ingress_name: str):\n        \"\"\"Get a Kubernetes Ingress with a defined name in the current namespace\n\n        Args:\n            ingress_name (str): name of the Kubernetes Ingress in the current namespace\n        Returns:\n            V1Ingress (object): Kubernetes Ingress or None if the call fails\n            This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n        \"\"\"\n\n        try:\n            response = self.get_networking_v1_api().read_namespaced_ingress(\n                name=ingress_name, namespace=self.get_namespace()\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to get Ingress -&gt; %s; error -&gt; %s\", ingress_name, str(exception)\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def patch_ingress(self, ingress_name: str, ingress_body: dict):\n        \"\"\"Patch a Kubernetes Ingress with a updated spec.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/NetworkingV1Api.md#patch_namespaced_ingress\n\n        Args:\n            ingress_name (str): name of the Kubernetes Ingress in the current namespace\n            ingress_body (dict): new / updated ingress body spec\n                                 (will be merged with existing values)\n        Returns:\n            V1Ingress (object): patched Kubernetes Ingress object or None if the call fails\n            This is NOT a dict but an object - you have to use the\n            \".\" syntax to access to returned elements\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n        \"\"\"\n\n        try:\n            response = self.get_networking_v1_api().patch_namespaced_ingress(\n                name=ingress_name,\n                namespace=self.get_namespace(),\n                body=ingress_body,\n            )\n        except ApiException as exception:\n            logger.error(\n                \"Failed to patch Ingress -&gt; %s with -&gt; %s; error -&gt; %s\",\n                ingress_name,\n                ingress_body,\n                str(exception),\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def update_ingress_backend_services(\n        self, ingress_name: str, hostname: str, service_name: str, service_port: int\n    ):\n        \"\"\"Updates a backend service and port of an Kubernetes Ingress\n\n        \"spec\": {\n            \"rules\": [\n                {\n                    \"host\": host,\n                    \"http\": {\n                        \"paths\": [\n                            {\n                                \"path\": \"/\",\n                                \"pathType\": \"Prefix\",\n                                \"backend\": {\n                                    \"service\": {\n                                        \"name\": &lt;service_name&gt;,\n                                        \"port\": {\n                                            \"name\": None,\n                                            \"number\": &lt;service_port&gt;,\n                                        },\n                                    },\n                                },\n                            }\n                        ]\n                    },\n                }\n            ]\n        }\n\n        Args:\n            ingress_name (str): name of the Kubernetes Ingress in the current namespace\n            hostname (str): hostname that should get an updated backend service / port\n            service_name (str): new backend service name\n            service_port (int): new backend service port\n        Returns:\n            V1Ingress (object): updated Kubernetes Ingress object or None if the call fails\n            This is NOT a dict but an object - you have to use the \".\" syntax\n            to access to returned elements\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n        \"\"\"\n\n        ingress = self.get_ingress(ingress_name)\n        if not ingress:\n            return None\n\n        host = \"\"\n        rules = ingress.spec.rules\n        rule_index = 0\n        for rule in rules:\n            if hostname in rule.host:\n                host = rule.host\n                path = rule.http.paths[0]\n                backend = path.backend\n                service = backend.service\n\n                logger.info(\n                    \"Replace backend service -&gt; %s (%s) with new backend service -&gt; %s (%s)\",\n                    service.name,\n                    service.port.number,\n                    service_name,\n                    service_port,\n                )\n\n                service.name = service_name\n                service.port.number = service_port\n                break\n            else:\n                rule_index += 1\n\n        if not host:\n            logger.error(\"Cannot find host -&gt; {}.\")\n            return None\n\n        body = [\n            {\n                \"op\": \"replace\",\n                \"path\": \"/spec/rules/{}/http/paths/0/backend/service/name\".format(\n                    rule_index\n                ),\n                \"value\": service_name,\n            },\n            {\n                \"op\": \"replace\",\n                \"path\": \"/spec/rules/{}/http/paths/0/backend/service/port/number\".format(\n                    rule_index\n                ),\n                \"value\": service_port,\n            },\n        ]\n\n        return self.patch_ingress(ingress_name, body)\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.__init__","title":"<code>__init__(in_cluster, kubeconfig_file='~/.kube/config', namespace='default')</code>","text":"<p>Initialize the Kubernetes object.</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def __init__(\n    self,\n    in_cluster: bool,\n    kubeconfig_file: str = \"~/.kube/config\",\n    namespace: str = \"default\",\n):\n    \"\"\"Initialize the Kubernetes object.\"\"\"\n\n    # Configure Kubernetes API authentication to use pod serviceAccount\n    if in_cluster:\n        config.load_incluster_config()\n    else:\n        if kubeconfig_file:\n            config.load_kube_config(config_file=kubeconfig_file)\n        else:\n            logger.warning(\n                \"Not runnig in cluster but kubeconfig file not specified!\"\n            )\n\n    self._core_v1_api = client.CoreV1Api()\n    self._apps_v1_api = client.AppsV1Api()\n    self._networking_v1_api = client.NetworkingV1Api()\n    if namespace and not in_cluster:\n        self._namespace = namespace\n    else:\n        # Read current namespace\n        with open(\n            \"/var/run/secrets/kubernetes.io/serviceaccount/namespace\",\n            \"r\",\n            encoding=\"utf-8\",\n        ) as namespace_file:\n            self._namespace = namespace_file.read()\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.delete_pod","title":"<code>delete_pod(pod_name)</code>","text":"<p>Delete a pod in the configured namespace (the namespace is defined in the class constructor).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#delete_namespaced_pod</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <p>Return:     V1Status (object) or None if the call fails.     - api_version: The Kubernetes API version.     - kind: The Kubernetes object kind, which is always \"Status\".     - metadata: Additional metadata about the status object, such as the resource version.     - status: The status of the operation, which is either \"Success\" or an error status.     - message: A human-readable message explaining the status.     - reason: A short string that describes the reason for the status.     - code: An HTTP status code that corresponds to the status.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Status.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def delete_pod(self, pod_name: str):\n    \"\"\"Delete a pod in the configured namespace (the namespace is defined in the class constructor).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#delete_namespaced_pod\n\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n    Return:\n        V1Status (object) or None if the call fails.\n        - api_version: The Kubernetes API version.\n        - kind: The Kubernetes object kind, which is always \"Status\".\n        - metadata: Additional metadata about the status object, such as the resource version.\n        - status: The status of the operation, which is either \"Success\" or an error status.\n        - message: A human-readable message explaining the status.\n        - reason: A short string that describes the reason for the status.\n        - code: An HTTP status code that corresponds to the status.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Status.md\n    \"\"\"\n\n    pod = self.get_pod(pod_name)\n    if not pod:\n        logger.error(\"Pod -&gt; %s does not exist\", pod_name)\n\n    try:\n        response = self.get_core_v1_api().delete_namespaced_pod(\n            pod_name, namespace=self.get_namespace()\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to delete Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.exec_pod_command","title":"<code>exec_pod_command(pod_name, command, max_retry=3, time_retry=10)</code>","text":"<p>Execute a command inside a Kubernetes Pod (similar to kubectl exec on command line).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#connect_get_namespaced_pod_exec Args:     pod_name (str): name of the Kubernetes pod in the current namespace     command (list): list of command and its parameters, e.g. [\"/bin/bash\", \"-c\", \"pwd\"]                     The \"-c\" is required to make the shell executing the command.     max_retry (int): Max amount of attempts to execute the command Returns:     Response of the command or None if the call fails</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def exec_pod_command(\n    self, pod_name: str, command: list, max_retry: int = 3, time_retry: int = 10\n):\n    \"\"\"Execute a command inside a Kubernetes Pod (similar to kubectl exec on command line).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#connect_get_namespaced_pod_exec\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n        command (list): list of command and its parameters, e.g. [\"/bin/bash\", \"-c\", \"pwd\"]\n                        The \"-c\" is required to make the shell executing the command.\n        max_retry (int): Max amount of attempts to execute the command\n    Returns:\n        Response of the command or None if the call fails\n    \"\"\"\n\n    pod = self.get_pod(pod_name)\n    if not pod:\n        logger.error(\"Pod -&gt; %s does not exist\", pod_name)\n\n    logger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\n\n    retry_counter = 1\n\n    while retry_counter &lt;= max_retry:\n        try:\n            response = stream(\n                self.get_core_v1_api().connect_get_namespaced_pod_exec,\n                pod_name,\n                self.get_namespace(),\n                command=command,\n                stderr=True,\n                stdin=False,\n                stdout=True,\n                tty=False,\n            )\n            logger.debug(response)\n            return response\n        except ApiException as exc:\n            logger.warning(\n                \"Failed to execute command, retry (%s/%s) -&gt; %s in pod -&gt; %s; error -&gt; %s\",\n                retry_counter,\n                max_retry,\n                command,\n                pod_name,\n                str(exc),\n            )\n            retry_counter = retry_counter + 1\n            exception = exc\n            logger.info(\"Wait %s seconds before next retry...\", str(time_retry))\n            time.sleep(time_retry)\n            continue\n\n    logger.error(\n        \"Failed to execute command with %s retries -&gt; %s in pod -&gt; %s; error -&gt; %s\",\n        max_retry,\n        command,\n        pod_name,\n        str(exception),\n    )\n\n    return None\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.exec_pod_command_interactive","title":"<code>exec_pod_command_interactive(pod_name, commands, timeout=30, write_stderr_to_error_log=True)</code>","text":"<p>Execute a command inside a Kubernetes pod (similar to kubectl exec on command line).     Other than exec_pod_command() method above this is an interactive execution using     stdin and reading the output from stdout and stderr. This is required for longer     running commands. It is currently used for restarting the spawner of Archive Center.     The output of the command is pushed into the logging.</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <code>commands</code> <code>list</code> <p>list of command and its parameters, e.g. [\"/bin/bash\", \"/etc/init.d/spawner restart\"]              Here we should NOT have a \"-c\" parameter!</p> required <code>timeout</code> <code>int</code> <p>timeout duration that is waited for any response.            Each time a resonse is found in stdout or stderr we wait another timeout duration            to make sure we get the full output of the command.</p> <code>30</code> <code>write_stderr_to_error_log</code> <code>bool</code> <p>flag to control if output in stderr should be written to info or error log stream.                               Default is write to error log (True)</p> <code>True</code> <p>Returns:     str: Response of the command or None if the call fails</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def exec_pod_command_interactive(\n    self,\n    pod_name: str,\n    commands: list,\n    timeout: int = 30,\n    write_stderr_to_error_log: bool = True,\n):\n    \"\"\"Execute a command inside a Kubernetes pod (similar to kubectl exec on command line).\n        Other than exec_pod_command() method above this is an interactive execution using\n        stdin and reading the output from stdout and stderr. This is required for longer\n        running commands. It is currently used for restarting the spawner of Archive Center.\n        The output of the command is pushed into the logging.\n\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n        commands (list): list of command and its parameters, e.g. [\"/bin/bash\", \"/etc/init.d/spawner restart\"]\n                         Here we should NOT have a \"-c\" parameter!\n        timeout (int): timeout duration that is waited for any response.\n                       Each time a resonse is found in stdout or stderr we wait another timeout duration\n                       to make sure we get the full output of the command.\n        write_stderr_to_error_log (bool): flag to control if output in stderr should be written to info or error log stream.\n                                          Default is write to error log (True)\n    Returns:\n        str: Response of the command or None if the call fails\n    \"\"\"\n\n    pod = self.get_pod(pod_name)\n    if not pod:\n        logger.error(\"Pod -&gt; %s does not exist\", pod_name)\n\n    if not commands:\n        logger.error(\"No commands to execute on Pod -&gt; %s\", pod_name)\n        return None\n\n    # Get first command - this should be the shell:\n    command = commands.pop(0)\n\n    try:\n        response = stream(\n            self.get_core_v1_api().connect_get_namespaced_pod_exec,\n            pod_name,\n            self.get_namespace(),\n            command=command,\n            stderr=True,\n            stdin=True,  # This is important!\n            stdout=True,\n            tty=False,\n            _preload_content=False,  # This is important!\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to execute command -&gt; %s in pod -&gt; %s; error -&gt; %s\",\n            command,\n            pod_name,\n            str(exception),\n        )\n        return None\n\n    while response.is_open():\n        got_response = False\n        response.update(timeout=timeout)\n        if response.peek_stdout():\n            logger.info(response.read_stdout().replace(\"\\n\", \" \"))\n            got_response = True\n        if response.peek_stderr():\n            if write_stderr_to_error_log:\n                logger.error(response.read_stderr().replace(\"\\n\", \" \"))\n            else:\n                logger.info(response.read_stderr().replace(\"\\n\", \" \"))\n            got_response = True\n        if commands:\n            command = commands.pop(0)\n            logger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\n            response.write_stdin(command + \"\\n\")\n        else:\n            # We continue as long as we get some response during timeout period\n            if not got_response:\n                break\n\n    response.close()\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.find_config_map","title":"<code>find_config_map(config_map_name)</code>","text":"<p>Find a Kubernetes Config Map based on its name.    This is just a wrapper method for list_config_maps()    that uses the name as a field selector.</p> <p>Parameters:</p> Name Type Description Default <code>config_map_name</code> <code>str</code> <p>name of the Config Map</p> required <p>Returns:     object: V1ConfigMapList (object) or None if the call fails</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def find_config_map(self, config_map_name: str):\n    \"\"\"Find a Kubernetes Config Map based on its name.\n       This is just a wrapper method for list_config_maps()\n       that uses the name as a field selector.\n\n    Args:\n        config_map_name (str): name of the Config Map\n    Returns:\n        object: V1ConfigMapList (object) or None if the call fails\n    \"\"\"\n\n    try:\n        response = self.list_config_maps(\n            field_selector=\"metadata.name={}\".format(config_map_name)\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to find Config Map -&gt; %s; error -&gt; %s\",\n            config_map_name,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_apps_v1_api","title":"<code>get_apps_v1_api()</code>","text":"<p>Returns Kubernetes Apps V1 API object</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Kubernetes API object</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_apps_v1_api(self):\n    \"\"\"Returns Kubernetes Apps V1 API object\n\n    Returns:\n        object: Kubernetes API object\n    \"\"\"\n    return self._apps_v1_api\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_config_map","title":"<code>get_config_map(config_map_name)</code>","text":"<p>Get a config map in the configured namespace (the namespace is defined in the class constructor).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_config_map</p> <p>Parameters:</p> Name Type Description Default <code>config_map_name</code> <code>str</code> <p>name of the Kubernetes config map in the current namespace</p> required <p>Returns:     V1ConfigMap (object): Kubernetes Config Map object that includes these fields:     - api_version: The Kubernetes API version.     - metadata: A V1ObjectMeta object representing metadata about the V1ConfigMap object,                 such as its name, labels, and annotations.     - data: A dictionary containing the non-binary data stored in the ConfigMap,             where the keys represent the keys of the data items and the values represent             the values of the data items.     - binary_data: A dictionary containing the binary data stored in the ConfigMap,                    where the keys represent the keys of the binary data items and the values                    represent the values of the binary data items. Binary data is encoded as base64                    strings in the dictionary values.</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_config_map(self, config_map_name: str):\n    \"\"\"Get a config map in the configured namespace (the namespace is defined in the class constructor).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_config_map\n\n    Args:\n        config_map_name (str): name of the Kubernetes config map in the current namespace\n    Returns:\n        V1ConfigMap (object): Kubernetes Config Map object that includes these fields:\n        - api_version: The Kubernetes API version.\n        - metadata: A V1ObjectMeta object representing metadata about the V1ConfigMap object,\n                    such as its name, labels, and annotations.\n        - data: A dictionary containing the non-binary data stored in the ConfigMap,\n                where the keys represent the keys of the data items and the values represent\n                the values of the data items.\n        - binary_data: A dictionary containing the binary data stored in the ConfigMap,\n                       where the keys represent the keys of the binary data items and the values\n                       represent the values of the binary data items. Binary data is encoded as base64\n                       strings in the dictionary values.\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().read_namespaced_config_map(\n            name=config_map_name, namespace=self.get_namespace()\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to get Config Map -&gt; %s; error -&gt; %s\",\n            config_map_name,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_core_v1_api","title":"<code>get_core_v1_api()</code>","text":"<p>Returns Kubernetes Core V1 API object</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Kubernetes API object</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_core_v1_api(self):\n    \"\"\"Returns Kubernetes Core V1 API object\n\n    Returns:\n        object: Kubernetes API object\n    \"\"\"\n    return self._core_v1_api\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_ingress","title":"<code>get_ingress(ingress_name)</code>","text":"<p>Get a Kubernetes Ingress with a defined name in the current namespace</p> <p>Parameters:</p> Name Type Description Default <code>ingress_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <p>Returns:     V1Ingress (object): Kubernetes Ingress or None if the call fails     This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_ingress(self, ingress_name: str):\n    \"\"\"Get a Kubernetes Ingress with a defined name in the current namespace\n\n    Args:\n        ingress_name (str): name of the Kubernetes Ingress in the current namespace\n    Returns:\n        V1Ingress (object): Kubernetes Ingress or None if the call fails\n        This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n    \"\"\"\n\n    try:\n        response = self.get_networking_v1_api().read_namespaced_ingress(\n            name=ingress_name, namespace=self.get_namespace()\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to get Ingress -&gt; %s; error -&gt; %s\", ingress_name, str(exception)\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_namespace","title":"<code>get_namespace()</code>","text":"<p>Returns Kubernetes Namespace</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Kubernetes namespace</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_namespace(self):\n    \"\"\"Returns Kubernetes Namespace\n\n    Returns:\n        str: Kubernetes namespace\n    \"\"\"\n    return self._namespace\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_networking_v1_api","title":"<code>get_networking_v1_api()</code>","text":"<p>Returns Kubernetes Networking V1 API object</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Kubernetes API object</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_networking_v1_api(self):\n    \"\"\"Returns Kubernetes Networking V1 API object\n\n    Returns:\n        object: Kubernetes API object\n    \"\"\"\n    return self._networking_v1_api\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_pod","title":"<code>get_pod(pod_name)</code>","text":"<p>Get a pod in the configured namespace (the namespace is defined     in the class constructor).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_pod</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <p>Returns:     V1Pod (object) or None if the call fails.     - api_version='v1',     - kind='Pod',     - metadata=V1ObjectMeta(...),     - spec=V1PodSpec(...),     - status=V1PodStatus(...)</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_pod(self, pod_name: str):\n    \"\"\"Get a pod in the configured namespace (the namespace is defined\n        in the class constructor).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_pod\n\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n    Returns:\n        V1Pod (object) or None if the call fails.\n        - api_version='v1',\n        - kind='Pod',\n        - metadata=V1ObjectMeta(...),\n        - spec=V1PodSpec(...),\n        - status=V1PodStatus(...)\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().read_namespaced_pod(\n            name=pod_name, namespace=self.get_namespace()\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to get Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_service","title":"<code>get_service(service_name)</code>","text":"<p>Get a Kubernetes Service with a defined name in the current namespace</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>name of the Kubernetes Service in the current namespace</p> required <p>Returns:     V1Service (object): Kubernetes Service object or None if the call fails     This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_service(self, service_name: str):\n    \"\"\"Get a Kubernetes Service with a defined name in the current namespace\n\n    Args:\n        service_name (str): name of the Kubernetes Service in the current namespace\n    Returns:\n        V1Service (object): Kubernetes Service object or None if the call fails\n        This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().read_namespaced_service(\n            name=service_name, namespace=self.get_namespace()\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to get Service -&gt; %s; error -&gt; %s\", service_name, str(exception)\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_stateful_set","title":"<code>get_stateful_set(sts_name)</code>","text":"<p>Get a Kubernetes Stateful Set based on its name.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes stateful set</p> required <p>Returns:     V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.     See : https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_stateful_set(self, sts_name: str):\n    \"\"\"Get a Kubernetes Stateful Set based on its name.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set\n\n    Args:\n        sts_name (str): name of the Kubernetes stateful set\n    Returns:\n        V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n        See : https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n    \"\"\"\n\n    try:\n        response = self.get_apps_v1_api().read_namespaced_stateful_set(\n            name=sts_name, namespace=self.get_namespace()\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to get Stateful Set -&gt; %s; error -&gt; %s\",\n            sts_name,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_stateful_set_scale","title":"<code>get_stateful_set_scale(sts_name)</code>","text":"<p>Get the number of replicas for a Kubernetes Stateful Set.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set_scale</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes Stateful Set</p> required <p>Returns:     V1Scale (object): Kubernetes Scale object or None if the call fails.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Scale.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_stateful_set_scale(self, sts_name: str):\n    \"\"\"Get the number of replicas for a Kubernetes Stateful Set.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set_scale\n\n    Args:\n        sts_name (str): name of the Kubernetes Stateful Set\n    Returns:\n        V1Scale (object): Kubernetes Scale object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Scale.md\n    \"\"\"\n\n    try:\n        response = self.get_apps_v1_api().read_namespaced_stateful_set_scale(\n            name=sts_name, namespace=self.get_namespace()\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to get scaling (replicas) of Stateful Set -&gt; %s; error -&gt; %s\",\n            sts_name,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.list_config_maps","title":"<code>list_config_maps(field_selector='', label_selector='')</code>","text":"<p>List all Kubernetes Config Maps in the current namespace.     The list can be filtered by providing field selectors and label selectors.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_config_map</p> <p>Parameters:</p> Name Type Description Default <code>field_selector</code> <code>str</code> <p>filter result based on fields</p> <code>''</code> <code>label_selector</code> <code>str</code> <p>filter result based on labels</p> <code>''</code> <p>Returns:     V1ConfigMapList (object) or None if the call fails     Properties can be accessed with the \".\" notation (this is an object not a dict!):     - api_version: The Kubernetes API version.     - items: A list of V1ConfigMap objects, each representing a config map. You can access the fields of a              V1Pod object using dot notation, for example, cm.metadata.name to access the name of the config map     - kind: The Kubernetes object kind, which is always \"ConfigMapList\".     - metadata: Additional metadata about the config map list, such as the resource version.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMapList.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def list_config_maps(self, field_selector: str = \"\", label_selector: str = \"\"):\n    \"\"\"List all Kubernetes Config Maps in the current namespace.\n        The list can be filtered by providing field selectors and label selectors.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_config_map\n\n    Args:\n        field_selector (str): filter result based on fields\n        label_selector (str): filter result based on labels\n    Returns:\n        V1ConfigMapList (object) or None if the call fails\n        Properties can be accessed with the \".\" notation (this is an object not a dict!):\n        - api_version: The Kubernetes API version.\n        - items: A list of V1ConfigMap objects, each representing a config map. You can access the fields of a\n                 V1Pod object using dot notation, for example, cm.metadata.name to access the name of the config map\n        - kind: The Kubernetes object kind, which is always \"ConfigMapList\".\n        - metadata: Additional metadata about the config map list, such as the resource version.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMapList.md\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().list_namespaced_config_map(\n            field_selector=field_selector,\n            label_selector=label_selector,\n            namespace=self.get_namespace(),\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to list Config Maps with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\n            field_selector,\n            label_selector,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.list_pods","title":"<code>list_pods(field_selector='', label_selector='')</code>","text":"<p>List all Kubernetes pods in a given namespace. The list can be further restricted     by specifying a field or label selector.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_pod</p> <p>Parameters:</p> Name Type Description Default <code>field_selector</code> <code>str</code> <p>filter result based on fields</p> <code>''</code> <code>label_selector</code> <code>str</code> <p>filter result based on labels</p> <code>''</code> <p>Returns:     V1PodList (object) or None if the call fails     Properties can be accessed with the \".\" notation (this is an object not a dict!):     - api_version: The Kubernetes API version.     - items: A list of V1Pod objects, each representing a pod. You can access the fields of a             V1Pod object using dot notation, for example, pod.metadata.name to access the name of the pod     - kind: The Kubernetes object kind, which is always \"PodList\".     - metadata: Additional metadata about the pod list, such as the resource version.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1PodList.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def list_pods(self, field_selector: str = \"\", label_selector: str = \"\"):\n    \"\"\"List all Kubernetes pods in a given namespace. The list can be further restricted\n        by specifying a field or label selector.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_pod\n\n    Args:\n        field_selector (str): filter result based on fields\n        label_selector (str): filter result based on labels\n    Returns:\n        V1PodList (object) or None if the call fails\n        Properties can be accessed with the \".\" notation (this is an object not a dict!):\n        - api_version: The Kubernetes API version.\n        - items: A list of V1Pod objects, each representing a pod. You can access the fields of a\n                V1Pod object using dot notation, for example, pod.metadata.name to access the name of the pod\n        - kind: The Kubernetes object kind, which is always \"PodList\".\n        - metadata: Additional metadata about the pod list, such as the resource version.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1PodList.md\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().list_namespaced_pod(\n            field_selector=field_selector,\n            label_selector=label_selector,\n            namespace=self.get_namespace(),\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to list Pods with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\n            field_selector,\n            label_selector,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.list_services","title":"<code>list_services(field_selector='', label_selector='')</code>","text":"<p>List all Kubernetes Service in the current namespace.     The list can be filtered by providing field selectors and label selectors.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_service</p> <p>Parameters:</p> Name Type Description Default <code>field_selector</code> <code>str</code> <p>filter result based on fields</p> <code>''</code> <code>label_selector</code> <code>str</code> <p>filter result based on labels</p> <code>''</code> <p>Returns:     V1ServiceList (object): list of Kubernetes Services or None if the call fails     Properties can be accessed with the \".\" notation (this is an object not a dict!):     - api_version: The Kubernetes API version.     - items: A list of V1Service objects, each representing a service.              You can access the fields of a V1Service object using dot notation,              for example, service.metadata.name to access the name of the service     - kind: The Kubernetes object kind, which is always \"ServiceList\".     - metadata: Additional metadata about the pod list, such as the resource version.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ServiceList.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def list_services(self, field_selector: str = \"\", label_selector: str = \"\"):\n    \"\"\"List all Kubernetes Service in the current namespace.\n        The list can be filtered by providing field selectors and label selectors.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_service\n\n    Args:\n        field_selector (str): filter result based on fields\n        label_selector (str): filter result based on labels\n    Returns:\n        V1ServiceList (object): list of Kubernetes Services or None if the call fails\n        Properties can be accessed with the \".\" notation (this is an object not a dict!):\n        - api_version: The Kubernetes API version.\n        - items: A list of V1Service objects, each representing a service.\n                 You can access the fields of a V1Service object using dot notation,\n                 for example, service.metadata.name to access the name of the service\n        - kind: The Kubernetes object kind, which is always \"ServiceList\".\n        - metadata: Additional metadata about the pod list, such as the resource version.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ServiceList.md\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().list_namespaced_service(\n            field_selector=field_selector,\n            label_selector=label_selector,\n            namespace=self.get_namespace(),\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to list Services with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\n            field_selector,\n            label_selector,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.patch_ingress","title":"<code>patch_ingress(ingress_name, ingress_body)</code>","text":"<p>Patch a Kubernetes Ingress with a updated spec.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/NetworkingV1Api.md#patch_namespaced_ingress</p> <p>Parameters:</p> Name Type Description Default <code>ingress_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <code>ingress_body</code> <code>dict</code> <p>new / updated ingress body spec                  (will be merged with existing values)</p> required <p>Returns:     V1Ingress (object): patched Kubernetes Ingress object or None if the call fails     This is NOT a dict but an object - you have to use the     \".\" syntax to access to returned elements     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def patch_ingress(self, ingress_name: str, ingress_body: dict):\n    \"\"\"Patch a Kubernetes Ingress with a updated spec.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/NetworkingV1Api.md#patch_namespaced_ingress\n\n    Args:\n        ingress_name (str): name of the Kubernetes Ingress in the current namespace\n        ingress_body (dict): new / updated ingress body spec\n                             (will be merged with existing values)\n    Returns:\n        V1Ingress (object): patched Kubernetes Ingress object or None if the call fails\n        This is NOT a dict but an object - you have to use the\n        \".\" syntax to access to returned elements\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n    \"\"\"\n\n    try:\n        response = self.get_networking_v1_api().patch_namespaced_ingress(\n            name=ingress_name,\n            namespace=self.get_namespace(),\n            body=ingress_body,\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to patch Ingress -&gt; %s with -&gt; %s; error -&gt; %s\",\n            ingress_name,\n            ingress_body,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.patch_service","title":"<code>patch_service(service_name, service_body)</code>","text":"<p>Patches a Kubernetes Service with an updated spec</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <code>service_body</code> <code>dict</code> <p>new / updated Service body spec                  (will be merged with existing values)</p> required <p>Returns:     V1Service (object): patched Kubernetes Service or None if the call fails     This is NOT a dict but an object - you have to use the \".\" syntax     to access to returned elements     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def patch_service(self, service_name: str, service_body: dict):\n    \"\"\"Patches a Kubernetes Service with an updated spec\n\n    Args:\n        service_name (str): name of the Kubernetes Ingress in the current namespace\n        service_body (dict): new / updated Service body spec\n                             (will be merged with existing values)\n    Returns:\n        V1Service (object): patched Kubernetes Service or None if the call fails\n        This is NOT a dict but an object - you have to use the \".\" syntax\n        to access to returned elements\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().patch_namespaced_service(\n            name=service_name, namespace=self.get_namespace(), body=service_body\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to patch Service -&gt; %s with -&gt; %s; error -&gt; %s\",\n            service_name,\n            service_body,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.patch_stateful_set","title":"<code>patch_stateful_set(sts_name, sts_body)</code>","text":"<p>Patch a Stateful set with new values.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#patch_namespaced_stateful_set</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes stateful set in the current namespace</p> required <code>sts_body</code> <code>str</code> <p>patch string</p> required <p>Returns:     V1StatefulSet (object): patched Kubernetes Stateful Set object or None if the call fails.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def patch_stateful_set(self, sts_name: str, sts_body: dict):\n    \"\"\"Patch a Stateful set with new values.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#patch_namespaced_stateful_set\n\n    Args:\n        sts_name (str): name of the Kubernetes stateful set in the current namespace\n        sts_body (str): patch string\n    Returns:\n        V1StatefulSet (object): patched Kubernetes Stateful Set object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n    \"\"\"\n\n    try:\n        response = self.get_apps_v1_api().patch_namespaced_stateful_set(\n            name=sts_name, namespace=self.get_namespace(), body=sts_body\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to patch Stateful Set -&gt; %s with -&gt; %s; error -&gt; %s\",\n            sts_name,\n            sts_body,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.replace_config_map","title":"<code>replace_config_map(config_map_name, config_map_data)</code>","text":"<p>Replace a Config Map with a new specification.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#replace_namespaced_config_map</p> <p>Parameters:</p> Name Type Description Default <code>config_map_name</code> <code>str</code> <p>name of the Kubernetes Config Map</p> required <code>config_map_data</code> <code>dict</code> <p>new specification of the Config Map</p> required <p>Returns:     V1ConfigMap (object): updated Kubernetes Config Map object or None if the call fails.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMap.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def replace_config_map(self, config_map_name: str, config_map_data: dict):\n    \"\"\"Replace a Config Map with a new specification.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#replace_namespaced_config_map\n\n    Args:\n        config_map_name (str): name of the Kubernetes Config Map\n        config_map_data (dict): new specification of the Config Map\n    Returns:\n        V1ConfigMap (object): updated Kubernetes Config Map object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMap.md\n    \"\"\"\n\n    try:\n        response = self.get_core_v1_api().replace_namespaced_config_map(\n            name=config_map_name,\n            namespace=self.get_namespace(),\n            body=client.V1ConfigMap(\n                metadata=client.V1ObjectMeta(\n                    name=config_map_name,\n                ),\n                data=config_map_data,\n            ),\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to replace Config Map -&gt; %s; error -&gt; %s\",\n            config_map_name,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.scale_stateful_set","title":"<code>scale_stateful_set(sts_name, scale)</code>","text":"<p>Scale a stateful set to a specific number of replicas.    It uses the class method patch_stateful_set() above.</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes stateful set in the current namespace</p> required <code>scale</code> <code>int</code> <p>number of replicas (pods) the stateful set shall be scaled to</p> required <p>Returns:     V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def scale_stateful_set(self, sts_name: str, scale: int):\n    \"\"\"Scale a stateful set to a specific number of replicas.\n       It uses the class method patch_stateful_set() above.\n\n    Args:\n        sts_name (str): name of the Kubernetes stateful set in the current namespace\n        scale (int): number of replicas (pods) the stateful set shall be scaled to\n    Returns:\n        V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n    \"\"\"\n\n    try:\n        response = self.patch_stateful_set(\n            sts_name, sts_body={\"spec\": {\"replicas\": scale}}\n        )\n    except ApiException as exception:\n        logger.error(\n            \"Failed to scale Stateful Set -&gt; %s to -&gt; %s replicas; error -&gt; %s\",\n            sts_name,\n            scale,\n            str(exception),\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.update_ingress_backend_services","title":"<code>update_ingress_backend_services(ingress_name, hostname, service_name, service_port)</code>","text":"<p>Updates a backend service and port of an Kubernetes Ingress</p> <p>\"spec\": {     \"rules\": [         {             \"host\": host,             \"http\": {                 \"paths\": [                     {                         \"path\": \"/\",                         \"pathType\": \"Prefix\",                         \"backend\": {                             \"service\": {                                 \"name\": ,                                 \"port\": {                                     \"name\": None,                                     \"number\": ,                                 },                             },                         },                     }                 ]             },         }     ] } <p>Parameters:</p> Name Type Description Default <code>ingress_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <code>hostname</code> <code>str</code> <p>hostname that should get an updated backend service / port</p> required <code>service_name</code> <code>str</code> <p>new backend service name</p> required <code>service_port</code> <code>int</code> <p>new backend service port</p> required <p>Returns:     V1Ingress (object): updated Kubernetes Ingress object or None if the call fails     This is NOT a dict but an object - you have to use the \".\" syntax     to access to returned elements     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def update_ingress_backend_services(\n    self, ingress_name: str, hostname: str, service_name: str, service_port: int\n):\n    \"\"\"Updates a backend service and port of an Kubernetes Ingress\n\n    \"spec\": {\n        \"rules\": [\n            {\n                \"host\": host,\n                \"http\": {\n                    \"paths\": [\n                        {\n                            \"path\": \"/\",\n                            \"pathType\": \"Prefix\",\n                            \"backend\": {\n                                \"service\": {\n                                    \"name\": &lt;service_name&gt;,\n                                    \"port\": {\n                                        \"name\": None,\n                                        \"number\": &lt;service_port&gt;,\n                                    },\n                                },\n                            },\n                        }\n                    ]\n                },\n            }\n        ]\n    }\n\n    Args:\n        ingress_name (str): name of the Kubernetes Ingress in the current namespace\n        hostname (str): hostname that should get an updated backend service / port\n        service_name (str): new backend service name\n        service_port (int): new backend service port\n    Returns:\n        V1Ingress (object): updated Kubernetes Ingress object or None if the call fails\n        This is NOT a dict but an object - you have to use the \".\" syntax\n        to access to returned elements\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n    \"\"\"\n\n    ingress = self.get_ingress(ingress_name)\n    if not ingress:\n        return None\n\n    host = \"\"\n    rules = ingress.spec.rules\n    rule_index = 0\n    for rule in rules:\n        if hostname in rule.host:\n            host = rule.host\n            path = rule.http.paths[0]\n            backend = path.backend\n            service = backend.service\n\n            logger.info(\n                \"Replace backend service -&gt; %s (%s) with new backend service -&gt; %s (%s)\",\n                service.name,\n                service.port.number,\n                service_name,\n                service_port,\n            )\n\n            service.name = service_name\n            service.port.number = service_port\n            break\n        else:\n            rule_index += 1\n\n    if not host:\n        logger.error(\"Cannot find host -&gt; {}.\")\n        return None\n\n    body = [\n        {\n            \"op\": \"replace\",\n            \"path\": \"/spec/rules/{}/http/paths/0/backend/service/name\".format(\n                rule_index\n            ),\n            \"value\": service_name,\n        },\n        {\n            \"op\": \"replace\",\n            \"path\": \"/spec/rules/{}/http/paths/0/backend/service/port/number\".format(\n                rule_index\n            ),\n            \"value\": service_port,\n        },\n    ]\n\n    return self.patch_ingress(ingress_name, body)\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.wait_pod_condition","title":"<code>wait_pod_condition(pod_name, condition_name, sleep_time=30)</code>","text":"<p>Wait for the pod to reach a defined condition (e.g. \"Ready\").</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <code>condition_name</code> <code>str</code> <p>name of the condition, e.g. \"Ready\"</p> required <p>Returns:     True once the pod reaches the condition - otherwise wait forever</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def wait_pod_condition(\n    self, pod_name: str, condition_name: str, sleep_time: int = 30\n):\n    \"\"\"Wait for the pod to reach a defined condition (e.g. \"Ready\").\n\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n        condition_name (str): name of the condition, e.g. \"Ready\"\n    Returns:\n        True once the pod reaches the condition - otherwise wait forever\n    \"\"\"\n\n    ready = False\n    while not ready:\n        try:\n            pod_status = self.get_core_v1_api().read_namespaced_pod_status(\n                pod_name, self.get_namespace()\n            )\n\n            # Check if the pod has reached the defined condition:\n            for cond in pod_status.status.conditions:\n                if cond.type == condition_name and cond.status == \"True\":\n                    logger.info(\n                        \"Pod -&gt; %s is in state -&gt; %s!\", pod_name, condition_name\n                    )\n                    ready = True\n                    break\n            else:\n                logger.info(\n                    \"Pod -&gt; %s is not yet in state -&gt; %s. Waiting...\",\n                    pod_name,\n                    condition_name,\n                )\n                time.sleep(sleep_time)\n                continue\n\n        except ApiException as exception:\n            logger.error(\n                \"Failed to wait for pod -&gt; %s; error -&gt; %s\",\n                pod_name,\n                str(exception),\n            )\n</code></pre>"},{"location":"pyxecm/m365/","title":"Microsoft 365","text":"<p>M365 Module to interact with the MS Graph API See also https://learn.microsoft.com/en-us/graph/ </p> <p>Class: M365 Methods:</p> <p>init : class initializer config : Returns config data set credentials: Returns the token data credentials_user: In some cases MS Graph APIs cannot be called via                   application permissions (client_id, client_secret)                   but requires a token of a user authenticated                   with username + password request_header: Returns the request header for MS Graph API calls request_header_user: Returns the request header used for user specific calls parse_request_response: Parse the REST API responses and convert                         them to Python dict in a safe way exist_result_item: Check if an dict item is in the response                    of the Graph REST API call get_result_value: Check if a defined value (based on a key) is in the Graph API response</p> <p>authenticate : Authenticates at M365 Graph API authenticate_user: Authenticate at M365 Graph API with username and password</p> <p>get_users: Get list all all users in M365 tenant  get_user: Get a M365 User based on its email add_user: Add a M365 User update_user: Update selected properties of an M365 user get_user_licenses: Get the assigned license SKUs of a user assign_license_to_user: Add an M365 license to a user (e.g. to use Office 365) get_user_photo: Get the photo of a M365 user update_user_photo: Update a user with a profile photo (which must be in local file system)</p> <p>get_groups: Get list all all groups in M365 tenant get_group: Get a M365 Group based on its name add_group: Add a M365 Group get_group_members: Get members (users and groups) of the specified group add_group_member: Add a user or group to a target group is_member: Check whether a M365 user is already in a M365 group get_group_owners: Get owners (users) of the specified group add_group_owner: Add a user as owner to a group</p> <p>purge_deleted_items: Purge all deleted users and groups in the organization purge_deleted_item: Help function that purges a single user or group</p> <p>has_team: Check if a M365 Group has a M365 Team connected or not get_team: get a M365 Team based on its name add_team: Add a M365 Team (based on an existing group) delete_team: delete a single M365 Team witha given ID delete_teams: Delete MS teams with a given name delete_all_teams: Delete all teams (groups) that are NOT on the exception list AND                   that are matching at least one of the patterns in the provided pattern list get_team_channels: get a list of channels for a M365 Team get_team_channel_tabs: get tabs of an M365 Team channel based on the team and channel names</p> <p>get_teams_apps: Get a list of MS Teams apps in catalog that match a given filter criterium get_teams_app: get a specific app from the catalog based on its (known) ID get_teams_apps_of_user: Get a list of MS Teams apps of a user that match a given filter criterium get_teams_apps_of_team: Get a list of MS Teams apps of a M365 team that match a given filter criterium extract_version_from_app_manifest: Extract the version number from the MS Teams app manifest file upload_teams_app: Upload a new app package to the catalog of MS Teams apps remove_teams_app: Remove MS Teams App for the app catalog assign_teams_app_to_user: Assign (add) a MS Teams app to a M365 user. upgrade_teams_app_of_user: Upgrade a MS teams app for a user. assign_teams_app_to_team: Assign (add) a MS Teams app to a M365 team                           (so that it afterwards can be added as a Tab in a M365 Teams Channel) upgrade_teams_app_of_team: Upgrade a MS teams app for a specific team. add_teams_app_to_channel: Add tab for Extended ECM app to an M365 Team channel update_teams_app_of_channel: Update in existing teams app (e.g. to change the URLs with new node ID) delete_teams_app_from_channel: Delete an app (and its tab) from a M365 Teams channel</p> Assign a existing sensitivity label to a user. <p>THIS IS CURRENTLY NOT WORKING!</p> <p>assign_sensitivity_label_to_user: Create a new sensitivity label in M365                                   THIS IS CURRENTLY NOT WORKING!</p>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365","title":"<code>M365</code>","text":"<p>             Bases: <code>object</code></p> <p>Used to automate stettings in Microsoft 365 via the Graph API.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>class M365(object):\n    \"\"\"Used to automate stettings in Microsoft 365 via the Graph API.\"\"\"\n\n    _config: dict\n    _access_token = None\n    _user_access_token = None\n\n    def __init__(\n        self,\n        tenant_id: str,\n        client_id: str,\n        client_secret: str,\n        domain: str,\n        sku_id: str,\n        teams_app_name: str,\n    ):\n        \"\"\"Initialize the M365 object\n\n        Args:\n            tenant_id (str): M365 Tenant ID\n            client_id (str): M365 Client ID\n            client_secret (str): M365 Client Secret\n            domain (str): M365 domain\n            sku_id (str): License SKU for M365 users\n            teams_app_name (str): name of the Extended ECM app for MS Teams\n        \"\"\"\n\n        m365_config = {}\n\n        # Set the authentication endpoints and credentials\n        m365_config[\"tenantId\"] = tenant_id\n        m365_config[\"clientId\"] = client_id\n        m365_config[\"clientSecret\"] = client_secret\n        m365_config[\"domain\"] = domain\n        m365_config[\"skuId\"] = sku_id\n        m365_config[\"teamsAppName\"] = teams_app_name\n        m365_config[\n            \"authenticationUrl\"\n        ] = \"https://login.microsoftonline.com/{}/oauth2/v2.0/token\".format(tenant_id)\n        m365_config[\"graphUrl\"] = \"https://graph.microsoft.com/v1.0/\"\n        m365_config[\"betaUrl\"] = \"https://graph.microsoft.com/beta/\"\n        m365_config[\"directoryObjects\"] = m365_config[\"graphUrl\"] + \"directoryObjects\"\n\n        # Set the data for the token request\n        m365_config[\"tokenData\"] = {\n            \"client_id\": client_id,\n            \"scope\": \"https://graph.microsoft.com/.default\",\n            \"client_secret\": client_secret,\n            \"grant_type\": \"client_credentials\",\n        }\n\n        m365_config[\"groupsUrl\"] = m365_config[\"graphUrl\"] + \"groups\"\n        m365_config[\"usersUrl\"] = m365_config[\"graphUrl\"] + \"users\"\n        m365_config[\"teamsUrl\"] = m365_config[\"graphUrl\"] + \"teams\"\n        m365_config[\"teamsTemplatesUrl\"] = m365_config[\"graphUrl\"] + \"teamsTemplates\"\n        m365_config[\"teamsAppsUrl\"] = m365_config[\"graphUrl\"] + \"appCatalogs/teamsApps\"\n        m365_config[\"directoryUrl\"] = m365_config[\"graphUrl\"] + \"directory\"\n        m365_config[\"securityUrl\"] = m365_config[\"betaUrl\"] + \"security\"\n        m365_config[\"applicationsUrl\"] = m365_config[\"graphUrl\"] + \"applications\"\n\n        self._config = m365_config\n\n    def config(self) -&gt; dict:\n        \"\"\"Returns the configuration dictionary\n\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\n        return self._config\n\n    def credentials(self) -&gt; dict:\n        \"\"\"Return the login credentials\n\n        Returns:\n            dict: dictionary with login credentials for M365\n        \"\"\"\n        return self.config()[\"tokenData\"]\n\n    def credentials_user(self, username: str, password: str) -&gt; dict:\n        \"\"\"In some cases MS Graph APIs cannot be called via\n            application permissions (client_id, client_secret)\n            but requires a token of a user authenticated\n            with username + password. This is e.g. the case\n            to upload a MS teams app to the catalog.\n            See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n\n        Args:\n            username (str): username\n            password (str): password\n        Returns:\n            dict: user credentials for M365\n        \"\"\"\n\n        credentials = {\n            \"client_id\": self.config()[\"clientId\"],\n            \"scope\": \"https://graph.microsoft.com/.default\",\n            \"client_secret\": self.config()[\"clientSecret\"],\n            \"grant_type\": \"password\",\n            \"username\": username,\n            \"password\": password,\n        }\n        return credentials\n\n    # end method definition\n\n    def request_header(self, content_type: str = \"application/json\") -&gt; dict:\n        \"\"\"Returns the request header used for Application calls.\n           Consists of Bearer access token and Content Type\n\n        Args:\n            content_type (str, optional): content type for the request\n        Return:\n            dict: request header values\n        \"\"\"\n\n        request_header = {\n            \"Authorization\": \"Bearer {}\".format(self._access_token),\n            \"Content-Type\": content_type,\n        }\n        return request_header\n\n    # end method definition\n\n    def request_header_user(self, content_type: str = \"application/json\") -&gt; dict:\n        \"\"\"Returns the request header used for user specific calls.\n           Consists of Bearer access token and Content Type\n\n        Args:\n            content_type (str, optional): content type for the request\n        Return:\n            dict: request header values\n        \"\"\"\n\n        request_header = {\n            \"Authorization\": \"Bearer {}\".format(self._user_access_token),\n            \"Content-Type\": content_type,\n        }\n        return request_header\n\n    # end method definition\n\n    def parse_request_response(\n        self,\n        response_object: requests.Response,\n        additional_error_message: str = \"\",\n        show_error: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Converts the request response (JSon) to a Python dict in a safe way\n           that also handles exceptions. It first tries to load the response.text\n           via json.loads() that produces a dict output. Only if response.text is\n           not set or is empty it just converts the response_object to a dict using\n           the vars() built-in method.\n\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str, optional): use a more specific error message\n                                                      in case of an error\n            show_error (bool): True: write an error to the log file\n                               False: write a warning to the log file\n        Returns:\n            dict: response information or None in case of an error\n        \"\"\"\n\n        if not response_object:\n            return None\n\n        try:\n            if response_object.text:\n                dict_object = json.loads(response_object.text)\n            else:\n                dict_object = vars(response_object)\n        except json.JSONDecodeError as exception:\n            if additional_error_message:\n                message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                    additional_error_message, exception\n                )\n            else:\n                message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                    exception\n                )\n            if show_error:\n                logger.error(message)\n            else:\n                logger.warning(message)\n            return None\n        else:\n            return dict_object\n\n    # end method definition\n\n    def exist_result_item(\n        self, response: dict, key: str, value: str, sub_dict_name: str = \"\"\n    ) -&gt; bool:\n        \"\"\"Check existence of key / value pair in the response properties of an MS Graph API call.\n\n        Args:\n            response (dict): REST response from an MS Graph REST Call\n            key (str): property name (key)\n            value (str): value to find in the item with the matching key\n            sub_dict_name (str): some MS Graph API calls include nested\n                                 dict structures that can be requested\n                                 with an \"expand\" query parameter. In such\n                                 a case we use the sub_dict_name to access it.\n        Returns:\n            bool: True if the value was found, False otherwise\n        \"\"\"\n\n        if not response:\n            return False\n        if not \"value\" in response:\n            return False\n\n        values = response[\"value\"]\n        if not values or not isinstance(values, list):\n            return False\n\n        if not sub_dict_name:\n            for item in values:\n                if value == item[key]:\n                    return True\n        else:\n            for item in values:\n                if not sub_dict_name in item:\n                    return False\n                if value == item[sub_dict_name][key]:\n                    return True\n        return False\n\n    # end method definition\n\n    def get_result_value(\n        self, response: dict, key: str, index: int = 0, sub_dict_name: str = \"\"\n    ) -&gt; str | None:\n        \"\"\"Get value of a result property with a given key of an MS Graph API call.\n\n        Args:\n            response (dict): REST response from an MS Graph REST Call\n            key (str): property name (key)\n            index (int, optional): Index to use (1st element has index 0).\n                                   Defaults to 0.\n            sub_dict_name (str): some MS Graph API calls include nested\n                                 dict structures that can be requested\n                                 with an \"expand\" query parameter. In such\n                                 a case we use the sub_dict_name to access it.\n        Returns:\n            str: value for the key, None otherwise\n        \"\"\"\n\n        if not response:\n            return None\n        if (\n            not \"value\" in response\n        ):  # If Graph APIs are called with specific IDs (and not name lookups)\n            # they may not return a list of dicts calles \"values\" but a single dict directly\n            if sub_dict_name and sub_dict_name in response:\n                sub_structure = response[sub_dict_name]\n                # also the substructure could be a list\n                if isinstance(sub_structure, list):\n                    sub_structure = sub_structure[index]\n                return sub_structure[key]\n            elif key in response:\n                return response[key]\n            else:\n                return None\n\n        values = response[\"value\"]\n        if not values or not isinstance(values, list) or len(values) - 1 &lt; index:\n            return None\n\n        if not sub_dict_name:\n            return values[index][key]\n        else:\n            sub_structure = values[index][sub_dict_name]\n            if isinstance(sub_structure, list):\n                # here we assume it is the first element of the\n                # substructure. If really required for specific\n                # use cases we may introduce a second index in\n                # the future.\n                sub_structure = sub_structure[0]\n            return sub_structure[key]\n\n    # end method definition\n\n    def authenticate(self, revalidate: bool = False) -&gt; str | None:\n        \"\"\"Authenticate at M365 Graph API with client ID and client secret.\n\n        Args:\n            revalidate (bool, optional): determinse if a re-athentication is enforced\n                                         (e.g. if session has timed out with 401 error)\n        Returns:\n            str: Access token. Also stores access token in self._access_token. None in case of error\n        \"\"\"\n\n        # Already authenticated and session still valid?\n        if self._access_token and not revalidate:\n            logger.info(\n                \"Session still valid - return existing access token -&gt; %s\",\n                str(self._access_token),\n            )\n            return self._access_token\n\n        request_url = self.config()[\"authenticationUrl\"]\n        request_header = request_login_headers\n\n        logger.info(\"Requesting M365 Access Token from -&gt; %s\", request_url)\n\n        authenticate_post_body = self.credentials()\n        authenticate_response = None\n\n        try:\n            authenticate_response = requests.post(\n                request_url,\n                data=authenticate_post_body,\n                headers=request_header,\n                timeout=60,\n            )\n        except requests.exceptions.ConnectionError as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s : %s\",\n                self.config()[\"authenticationUrl\"],\n                exception,\n            )\n            return None\n\n        if authenticate_response.ok:\n            authenticate_dict = self.parse_request_response(authenticate_response)\n            if not authenticate_dict:\n                return None\n            else:\n                access_token = authenticate_dict[\"access_token\"]\n                logger.debug(\"Access Token -&gt; %s\", access_token)\n        else:\n            logger.error(\n                \"Failed to request an M365 Access Token; error -&gt; %s\",\n                authenticate_response.text,\n            )\n            return None\n\n        # Store authentication access_token:\n        self._access_token = access_token\n\n        return self._access_token\n\n    # end method definition\n\n    def authenticate_user(self, username: str, password: str) -&gt; str | None:\n        \"\"\"Authenticate at M365 Graph API with username and password.\n\n        Args:\n            username (str): name (emails) of the M365 user\n            password (str): password of the M365 user\n        Returns:\n            str: Access token. Also stores access token in self._access_token\n        \"\"\"\n\n        request_url = self.config()[\"authenticationUrl\"]\n        request_header = request_login_headers\n\n        logger.info(\n            \"Requesting M365 Access Token for user -&gt; %s from -&gt; %s\",\n            username,\n            request_url,\n        )\n\n        authenticate_post_body = self.credentials_user(username, password)\n        authenticate_response = None\n\n        try:\n            authenticate_response = requests.post(\n                request_url,\n                data=authenticate_post_body,\n                headers=request_header,\n                timeout=60,\n            )\n        except requests.exceptions.ConnectionError as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s with username -&gt; %s: %s\",\n                self.config()[\"authenticationUrl\"],\n                username,\n                exception,\n            )\n            return None\n\n        if authenticate_response.ok:\n            authenticate_dict = self.parse_request_response(authenticate_response)\n            if not authenticate_dict:\n                return None\n            access_token = authenticate_dict[\"access_token\"]\n            logger.debug(\"User Access Token -&gt; %s\", access_token)\n        else:\n            logger.error(\n                \"Failed to request an M365 Access Token for user -&gt; %s; error -&gt; %s\",\n                username,\n                authenticate_response.text,\n            )\n            return None\n\n        # Store authentication access_token:\n        self._user_access_token = access_token\n\n        return self._user_access_token\n\n    # end method definition\n\n    def get_users(self) -&gt; dict | None:\n        \"\"\"Get list all all users in M365 tenant\n\n        Returns:\n            dict: Dictionary of all users.\n        \"\"\"\n\n        request_url = self.config()[\"usersUrl\"]\n        request_header = self.request_header()\n\n        logger.info(\"Get list of all users; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of users; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_user(self, user_email: str, show_error: bool = False) -&gt; dict | None:\n        \"\"\"Get a M365 User based on its email\n\n        Args:\n            user_email (str): M365 user email\n            show_error (bool): whether or not an error should be displayed if the\n                               user is not found.\n        Returns:\n            dict: User information or None if the user couldn't be retrieved (e.g. because it doesn't exist\n                  or if there is a permission problem).\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#users/$entity',\n                'businessPhones': [],\n                'displayName': 'Bob Davis',\n                'givenName': 'Bob',\n                'id': '72c80809-094f-4e6e-98d4-25a736385d10',\n                'jobTitle': None,\n                'mail': 'bdavis@M365x61936377.onmicrosoft.com',\n                'mobilePhone': None,\n                'officeLocation': None,\n                'preferredLanguage': None,\n                'surname': 'Davis',\n                'userPrincipalName': 'bdavis@M365x61936377.onmicrosoft.com'\n            }\n        \"\"\"\n\n        request_url = self.config()[\"usersUrl\"] + \"/\" + user_email\n        request_header = self.request_header()\n\n        logger.info(\"Get M365 user -&gt; %s; calling -&gt; %s\", user_email, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        user_email,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"M365 User -&gt; %s not found.\", user_email)\n                return None\n\n    # end method definition\n\n    def add_user(\n        self,\n        email: str,\n        password: str,\n        first_name: str,\n        last_name: str,\n        location: str = \"US\",\n        department: str = \"\",\n        company_name: str = \"Innovate\",\n    ) -&gt; dict | None:\n        \"\"\"Add a M365 user.\n\n        Args:\n            email (str): email address of the user. This is also the unique identifier\n            password (str): password of the user\n            first_name (str): first name of the user\n            last_name (str): last name of the user\n            location (str, optional): country ISO 3166-1 alpha-2 format (e.g. US, CA, FR, DE, CN, ...)\n            department (str, optional): department of the user\n            company_name (str): name of the company\n        Returns:\n            dict: User information or None if the user couldn't be created (e.g. because it exisits already\n                  or if a permission problem occurs).\n        \"\"\"\n\n        user_post_body = {\n            \"accountEnabled\": True,\n            \"displayName\": first_name + \" \" + last_name,\n            \"givenName\": first_name,\n            \"surname\": last_name,\n            \"mailNickname\": email.split(\"@\")[0],\n            \"userPrincipalName\": email,\n            \"passwordProfile\": {\n                \"forceChangePasswordNextSignIn\": False,\n                \"password\": password,\n            },\n            \"usageLocation\": location,\n        }\n        if department:\n            user_post_body[\"department\"] = department\n        if company_name:\n            user_post_body[\"companyName\"] = company_name\n\n        request_url = self.config()[\"usersUrl\"]\n        request_header = self.request_header()\n\n        logger.info(\"Adding M365 user -&gt; %s; calling -&gt; %s\", email, request_url)\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                data=json.dumps(user_post_body),\n                headers=request_header,\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    email,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def update_user(self, user_id: str, updated_settings: dict) -&gt; dict | None:\n        \"\"\"Update selected properties of an M365 user. Documentation\n           on user properties is here: https://learn.microsoft.com/en-us/graph/api/user-update\n\n        Returns:\n            dict | None: Response of the M365 Graph API  or None if the call fails.\n        \"\"\"\n\n        request_url = self.config()[\"usersUrl\"] + \"/\" + user_id\n        request_header = self.request_header()\n\n        logger.info(\n            \"Updating M365 user -&gt; %s with -&gt; %s; calling -&gt; %s\",\n            user_id,\n            str(updated_settings),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.patch(\n                request_url,\n                json=updated_settings,\n                headers=request_header,\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update M365 user -&gt; %s with -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    user_id,\n                    str(updated_settings),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_user_licenses(self, user_id: str) -&gt; dict | None:\n        \"\"\"Get the assigned license SKUs of a user\n\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        Returns:\n            dict: List of user licenses or None if request fails.\n\n            Example return data:\n            {\n                '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#users('a5875311-f0a5-486d-a746-bd7372b91115')/licenseDetails\",\n                'value': [\n                    {\n                        'id': '8DRPYHK6IUOra-Nq6L0A7GAn38eBLPdOtXhbU5K1cd8',\n                        'skuId': 'c7df2760-2c81-4ef7-b578-5b5392b571df',\n                        'skuPartNumber': 'ENTERPRISEPREMIUM',\n                        'servicePlans': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n                    }\n                ]\n            }\n        \"\"\"\n\n        request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/licenseDetails\"\n        request_header = self.request_header()\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get M365 licenses of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    user_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def assign_license_to_user(self, user_id: str, sku_id: str) -&gt; dict | None:\n        \"\"\"Add an M365 license to a user (e.g. to use Office 365)\n\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            sku_id (str): M365 GUID of the SKU\n                          (e.g. c7df2760-2c81-4ef7-b578-5b5392b571df for E5 and\n                                6fd2c87f-b296-42f0-b197-1e91e994b900 for E3)\n\n        Returns:\n            dict: response or None if request fails\n        \"\"\"\n\n        request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/assignLicense\"\n        request_header = self.request_header()\n\n        # Construct the request body for assigning the E5 license\n        license_post_body = {\n            \"addLicenses\": [\n                {\n                    \"disabledPlans\": [],\n                    \"skuId\": sku_id,  # \"c42b9cae-ea4f-4a69-9ca5-c53bd8779c42\"\n                }\n            ],\n            \"removeLicenses\": [],\n        }\n\n        logger.info(\n            \"Assign M365 license -&gt; %s to M365 user -&gt; %s; calling -&gt; %s\",\n            sku_id,\n            user_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url, json=license_post_body, headers=request_header, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add M365 license -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    sku_id,\n                    user_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_user_photo(self, user_id: str, show_error: bool = True) -&gt; bytes | None:\n        \"\"\"Get the photo of a M365 user\n\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            show_error (bool): whether or not an error should be logged if the user\n                                  does not have a photo in M365\n        Returns:\n            bytes: Image of the user photo or None if the user photo couldn't be retrieved.\n        \"\"\"\n\n        request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n        # Set image as content type:\n        request_header = self.request_header(\"image/*\")\n\n        logger.info(\"Get photo of user -&gt; %s; calling -&gt; %s\", user_id, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return response.content  # this is the actual image - not json!\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get photo of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        user_id,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"User -&gt; %s does not yet have a photo.\", user_id)\n                return None\n\n    # end method definition\n\n    def update_user_photo(self, user_id: str, photo_path: str) -&gt; dict | None:\n        \"\"\"Update the M365 user photo\n\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            photo_path (str): file system path with the location of the photo\n        Returns:\n            dict: Response of Graph REST API or None if the user photo couldn't be updated.\n        \"\"\"\n\n        request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n        # Set image as content type:\n        request_header = self.request_header(\"image/*\")\n\n        # Check if the photo file exists\n        if not os.path.isfile(photo_path):\n            logger.error(\"Photo file -&gt; %s not found!\", photo_path)\n            return None\n\n        try:\n            # Read the photo file as binary data\n            with open(photo_path, \"rb\") as image_file:\n                photo_data = image_file.read()\n        except OSError as exception:\n            # Handle any errors that occurred while reading the photo file\n            logger.error(\n                \"Error reading photo file -&gt; %s; error -&gt; %s\", photo_path, exception\n            )\n            return None\n\n        data = photo_data\n\n        logger.info(\n            \"Update M365 user -&gt; %s with photo -&gt; %s; calling -&gt; %s\",\n            user_id,\n            photo_path,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                request_url, headers=request_header, data=data, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update user -&gt; %s with photo -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    user_id,\n                    photo_path,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_groups(self, max_number: int = 250) -&gt; dict | None:\n        \"\"\"Get list all all groups in M365 tenant\n\n        Args:\n            max_number (int, optional): maximum result values (limit)\n        Returns:\n            dict: dictionary of all groups or None in case of an error.\n        \"\"\"\n\n        request_url = self.config()[\"groupsUrl\"]\n        request_header = self.request_header()\n\n        logger.info(\"Get list of all M365 groups; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                request_url,\n                headers=request_header,\n                params={\"$top\": str(max_number)},\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of M365 groups; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_group(self, group_name: str, show_error: bool = False) -&gt; dict | None:\n        \"\"\"Get a M365 Group based on its name\n\n        Args:\n            group_name (str): M365 Group name\n            show_error (bool): should an error be logged if group is not found.\n        Returns:\n            dict: Group information or None if the group doesn't exist.\n\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups',\n                'value': [\n                    {\n                        'id': 'b65f7dba-3ed1-49df-91bf-2bf99affcc8d',\n                        'deletedDateTime': None,\n                        'classification': None,\n                        'createdDateTime': '2023-04-01T13:46:26Z',\n                        'creationOptions': [],\n                        'description': 'Engineering &amp; Construction',\n                        'displayName': 'Engineering &amp; Construction',\n                        'expirationDateTime': None,\n                        'groupTypes': ['Unified'],\n                        'isAssignableToRole': None,\n                        'mail': 'Engineering&amp;Construction@M365x61936377.onmicrosoft.com',\n                        'mailEnabled': True,\n                        'mailNickname': 'Engineering&amp;Construction',\n                        'membershipRule': None,\n                        'membershipRuleProcessingState': None,\n                        'onPremisesDomainName': None,\n                        'onPremisesLastSyncDateTime': None,\n                        'onPremisesNetBiosName': None,\n                        'onPremisesSamAccountName': None,\n                        'onPremisesSecurityIdentifier': None,\n                        'onPremisesSyncEnabled': None,\n                        'preferredDataLocation': None,\n                        'preferredLanguage': None,\n                        'proxyAddresses': ['SPO:SPO_d9deb3e7-c72f-4e8d-80fb-5d9411ca1458@SPO_604f34f0-ba72-4321-ab6b-e36ae8bd00ec', 'SMTP:Engineering&amp;Construction@M365x61936377.onmicrosoft.com'],\n                        'renewedDateTime': '2023-04-01T13:46:26Z',\n                        'resourceBehaviorOptions': [],\n                        'resourceProvisioningOptions': [],\n                        'securityEnabled': False,\n                        'securityIdentifier': 'S-1-12-1-3059711418-1239367377-4180393873-2379022234',\n                        'theme': None,\n                        'visibility': 'Public',\n                        'onPremisesProvisioningErrors': []\n                    },\n                    {\n                        'id': '61359860-302e-4016-b5cc-abff2293dff1',\n                        ...\n                    }\n                ]\n            }\n        \"\"\"\n\n        query = {\"$filter\": \"displayName eq '\" + group_name + \"'\"}\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = self.config()[\"groupsUrl\"] + \"?\" + encoded_query\n        request_header = self.request_header()\n\n        logger.info(\"Get M365 group -&gt; %s; calling -&gt; %s\", group_name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        group_name,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"M365 Group -&gt; %s not found.\", group_name)\n                return None\n\n    # end method definition\n\n    def add_group(\n        self, name: str, security_enabled: bool = False, mail_enabled: bool = True\n    ) -&gt; dict | None:\n        \"\"\"Add a M365 Group.\n\n        Args:\n            name (str): name of the group\n            security_enabled (bool, optional): whether or not this group is used for permission management\n            mail_enabled (bool, optional): whether or not this group is email enabled\n        Returns:\n            dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups/$entity',\n                'id': '28906460-a69c-439e-84ca-c70becf37655',\n                'deletedDateTime': None,\n                'classification': None,\n                'createdDateTime': '2023-04-01T11:40:13Z',\n                'creationOptions': [],\n                'description': None,\n                'displayName': 'Test',\n                'expirationDateTime': None,\n                'groupTypes': ['Unified'],\n                'isAssignableToRole': None,\n                'mail': 'Diefenbruch@M365x61936377.onmicrosoft.com',\n                'mailEnabled': True,\n                'mailNickname': 'Test',\n                'membershipRule': None,\n                'membershipRuleProcessingState': None,\n                'onPremisesDomainName': None,\n                'onPremisesLastSyncDateTime': None,\n                'onPremisesNetBiosName': None,\n                'onPremisesSamAccountName': None,\n                'onPremisesSecurityIdentifier': None,\n                'onPremisesSyncEnabled': None,\n                'onPremisesProvisioningErrors': [],\n                'preferredDataLocation': None,\n                'preferredLanguage': None,\n                'proxyAddresses': ['SMTP:Test@M365x61936377.onmicrosoft.com'],\n                'renewedDateTime': '2023-04-01T11:40:13Z',\n                'resourceBehaviorOptions': [],\n                'resourceProvisioningOptions': [],\n                'securityEnabled': True,\n                'securityIdentifier': 'S-1-12-1-680551520-1134470812-197642884-1433859052',\n                'theme': None,\n                'visibility': 'Public'\n            }\n        \"\"\"\n\n        group_post_body = {\n            \"displayName\": name,\n            \"mailEnabled\": mail_enabled,\n            \"mailNickname\": name.replace(\" \", \"\"),\n            \"securityEnabled\": security_enabled,\n            \"groupTypes\": [\"Unified\"],\n        }\n\n        request_url = self.config()[\"groupsUrl\"]\n        request_header = self.request_header()\n\n        logger.info(\"Adding M365 group -&gt; %s; calling -&gt; %s\", name, request_url)\n        logger.debug(\"M365 group attributes -&gt; %s\", group_post_body)\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                data=json.dumps(group_post_body),\n                headers=request_header,\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_group_members(self, group_name: str) -&gt; dict | None:\n        \"\"\"Get members (users and groups) of the specified group.\n\n        Args:\n            group_name (str): name of the group\n        Returns:\n            dict: Response of Graph REST API or None if the REST call fails.\n        \"\"\"\n\n        response = self.get_group(group_name)\n        group_id = self.get_result_value(response, \"id\", 0)\n        if not group_id:\n            logger.error(\n                \"M365 Group -&gt; %s does not exist! Cannot retrieve group members.\",\n                group_name,\n            )\n            return None\n\n        query = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = (\n            self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members?\" + encoded_query\n        )\n        request_header = self.request_header()\n\n        logger.info(\n            \"Get members of M365 group -&gt; %s (%s); calling -&gt; %s\",\n            group_name,\n            group_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get members of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                    group_name,\n                    group_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_group_member(self, group_id: str, member_id: str) -&gt; dict | None:\n        \"\"\"Add a member (user or group) to a (parent) group\n\n        Args:\n            group_id (str): M365 GUID of the group\n            member_id (str): M365 GUID of the new member\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        request_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members/$ref\"\n        request_header = self.request_header()\n\n        group_member_post_body = {\n            \"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + member_id\n        }\n\n        logger.info(\n            \"Adding member -&gt; %s to group -&gt; %s; calling -&gt; %s\",\n            member_id,\n            group_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(group_member_post_body),\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n\n            # Check if Session has expired - then re-authenticate and try once more\n            if response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add member -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    member_id,\n                    group_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def is_member(self, group_id: str, member_id: str, show_error: bool = True) -&gt; bool:\n        \"\"\"Checks whether a M365 user is already in a M365 group\n\n        Args:\n            group_id (str): M365 GUID of the group\n            member_id (str): M365 GUID of the user (member)\n            show_error (bool): whether or not an error should be logged if the user\n                                  is not a member of the group\n        Returns:\n            bool: True if the user is in the group. False otherwise.\n        \"\"\"\n\n        # don't encode this URL - this has not been working!!\n        request_url = (\n            self.config()[\"groupsUrl\"]\n            + f\"/{group_id}/members?$filter=id eq '{member_id}'\"\n        )\n        request_header = self.request_header()\n\n        logger.info(\n            \"Check if user -&gt; %s is in group -&gt; %s; calling -&gt; %s\",\n            member_id,\n            group_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                response = self.parse_request_response(response)\n                if not \"value\" in response or len(response[\"value\"]) == 0:\n                    return False\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                # MS Graph API returns an error if the member is not in the\n                # group. This is typically not what we want. We just return False.\n                if show_error:\n                    logger.error(\n                        \"Failed to check if user -&gt; %s is in group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        member_id,\n                        group_id,\n                        response.status_code,\n                        response.text,\n                    )\n                return False\n\n    # end method definition\n\n    def get_group_owners(self, group_name: str) -&gt; dict | None:\n        \"\"\"Get owners (users) of the specified group.\n\n        Args:\n            group_name (str): name of the group\n        Returns:\n            dict: Response of Graph REST API or None if the REST call fails.\n        \"\"\"\n\n        response = self.get_group(group_name)\n        group_id = self.get_result_value(response, \"id\", 0)\n        if not group_id:\n            logger.error(\n                \"M365 Group -&gt; %s does not exist! Cannot retrieve group owners.\",\n                group_name,\n            )\n            return None\n\n        query = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = (\n            self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners?\" + encoded_query\n        )\n        request_header = self.request_header()\n\n        logger.info(\n            \"Get owners of M365 group -&gt; %s (%s); calling -&gt; %s\",\n            group_name,\n            group_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get owners of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                    group_name,\n                    group_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_group_owner(self, group_id: str, owner_id: str) -&gt; dict | None:\n        \"\"\"Add an owner (user) to a group\n\n        Args:\n            group_id (str): M365 GUID of the group\n            owner_id (str): M365 GUID of the new member\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        request_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners/$ref\"\n        request_header = self.request_header()\n\n        group_member_post_body = {\n            \"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + owner_id\n        }\n\n        logger.info(\n            \"Adding owner -&gt; %s to M365 group -&gt; %s; calling -&gt; %s\",\n            owner_id,\n            group_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(group_member_post_body),\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add owner -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    owner_id,\n                    group_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def purge_deleted_items(self):\n        \"\"\"Purge all deleted users and groups.\n        Purging users and groups requires administrative rights that typically\n        are not provided in Contoso example org.\n        \"\"\"\n\n        request_header = self.request_header()\n\n        request_url = (\n            self.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.group\"\n        )\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        deleted_groups = self.parse_request_response(response)\n\n        for group in deleted_groups[\"value\"]:\n            group_id = group[\"id\"]\n            response = self.purge_deleted_item(group_id)\n\n        request_url = (\n            self.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.user\"\n        )\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        deleted_users = self.parse_request_response(response)\n\n        for user in deleted_users[\"value\"]:\n            user_id = user[\"id\"]\n            response = self.purge_deleted_item(user_id)\n\n    # end method definition\n\n    def purge_deleted_item(self, item_id: str) -&gt; dict | None:\n        \"\"\"Helper method to purge a single deleted user or group.\n           This requires elevated permissions that are typically\n           not available via Graph API.\n\n        Args:\n            item_id (str): M365 GUID of the user or group to purge\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        request_url = self.config()[\"directoryUrl\"] + \"/deletedItems/\" + item_id\n        request_header = self.request_header()\n\n        logger.info(\"Purging deleted item -&gt; %s; calling -&gt; %s\", item_id, request_url)\n\n        retries = 0\n        while True:\n            response = requests.delete(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to purge deleted item -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    item_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def has_team(self, group_name: str) -&gt; bool:\n        \"\"\"Check if a M365 Group has a M365 Team connected or not\n\n        Args:\n            group_name (str): name of the M365 group\n        Returns:\n            bool: Returns True if a Team is assigned and False otherwise\n        \"\"\"\n\n        response = self.get_group(group_name)\n        group_id = self.get_result_value(response, \"id\", 0)\n        if not group_id:\n            logger.error(\n                \"M365 Group -&gt; %s not found. Cannot check if it has a M365 Team.\",\n                group_name,\n            )\n            return False\n\n        request_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/team\"\n        request_header = self.request_header()\n\n        logger.info(\n            \"Check if M365 Group -&gt; %s has a M365 Team connected; calling -&gt; %s\",\n            group_name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n\n            if response.status_code == 200:  # Group has a Team assigned!\n                logger.info(\"Group -&gt; %s has a M365 Team connected.\", group_name)\n                return True\n            elif response.status_code == 404:  # Group does not have a Team assigned!\n                logger.info(\"Group -&gt; %s has no M365 Team connected.\", group_name)\n                return False\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to check if M365 Group -&gt; %s has a M365 Team connected; status -&gt; %s; error -&gt; %s\",\n                    group_name,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def get_team(self, name: str) -&gt; dict | None:\n        \"\"\"Get a M365 Team based on its name\n\n        Args:\n            name (str): name of the M365 Team\n        Returns:\n            dict: teams data structure (dictionary) or None if the request fails.\n\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#teams',\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '951bd036-c6fc-4da4-bb80-1860f5472a2f',\n                        'createdDateTime': None,\n                        'displayName': 'Procurement',\n                        'description': 'Procurement',\n                        'internalId': None,\n                        'classification': None,\n                        'specialization': None,\n                        'visibility': 'public',\n                        'webUrl': None, ...}]}\n                        'isArchived': None,\n                        'isMembershipLimitedToOwners': None,\n                        'memberSettings': None,\n                        'guestSettings': None,\n                        'messagingSettings': None,\n                        ...\n                    }\n                ]\n            }\n        \"\"\"\n\n        # The M365 Teams API has an issues with ampersand characters in team names (like \"Engineering &amp; Construction\")\n        # So we do a work-around here to first get the Team ID via the Group endpoint of the Graph API and\n        # then fetch the M365 Team via its ID (which is identical to the underlying M365 Group ID)\n        response = self.get_group(name)\n        team_id = self.get_result_value(response, \"id\", 0)\n        if not team_id:\n            logger.error(\n                \"Failed to get the ID of the M365 Team -&gt; %s via the M365 Group API\",\n                name,\n            )\n            return None\n\n        request_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id)\n\n        request_header = self.request_header()\n\n        logger.info(\n            \"Lookup Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\n            name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_team(self, name: str, template_name: str = \"standard\") -&gt; dict | None:\n        \"\"\"Add M365 Team based on an existing M365 Group.\n\n        Args:\n            name (str): name of the team. It is assumed that a group with the same name does already exist!\n            template_name (str, optional): name of the team template. \"standard\" is the default value.\n        Returns:\n            dict: Team information (json - empty text!) or None if the team couldn't be created\n                  (e.g. because it exisits already).\n        \"\"\"\n\n        response = self.get_group(name)\n        group_id = self.get_result_value(response, \"id\", 0)\n        if not group_id:\n            logger.error(\n                \"M365 Group -&gt; %s not found. It is required for creating a corresponding M365 Team.\",\n                name,\n            )\n            return None\n\n        response = self.get_group_owners(name)\n        if response is None or not \"value\" in response or not response[\"value\"]:\n            logger.warning(\n                \"M365 Group -&gt; %s has no owners. This is required for creating a corresponding M365 Team.\",\n                name,\n            )\n            return None\n\n        team_post_body = {\n            \"template@odata.bind\": \"{}('{}')\".format(\n                self.config()[\"teamsTemplatesUrl\"], template_name\n            ),\n            \"group@odata.bind\": \"{}('{}')\".format(self.config()[\"groupsUrl\"], group_id),\n        }\n\n        request_url = self.config()[\"teamsUrl\"]\n        request_header = self.request_header()\n\n        logger.info(\"Adding M365 Team -&gt; %s; calling -&gt; %s\", name, request_url)\n        logger.debug(\"M365 Team attributes -&gt; %s\", team_post_body)\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                data=json.dumps(team_post_body),\n                headers=request_header,\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def delete_team(self, team_id: str) -&gt; dict | None:\n        \"\"\"Delete Microsoft 365 Team with a specific ID.\n\n        Args:\n            team_id (str): ID of the Microsoft 365 Team to delete\n        Returns:\n            dict | None: Response dictionary if the team has been deleted, False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"groupsUrl\"] + \"/\" + team_id\n\n        request_header = self.request_header()\n\n        logger.info(\n            \"Delete Microsoft 365 Teams with ID -&gt; %s; calling -&gt; %s\",\n            team_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.delete(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\"Failed to delete M365 Team with ID -&gt; %s\", team_id)\n                return None\n\n    # end method definition\n\n    def delete_teams(self, name: str) -&gt; bool:\n        \"\"\"Delete Microsoft 365 Teams with a specific name. Microsoft 365 allows\n            to have multiple teams with the same name. So this method may delete\n            multiple teams if the have the same name. The Graph API we use here\n            is the M365 Group API as deleting the group also deletes the associated team.\n\n        Args:\n            name (str): name of the Microsoft 365 Team\n        Returns:\n            bool: True if teams have been deleted, False otherwise.\n        \"\"\"\n\n        # We need a special handling of team names with single quotes:\n        escaped_group_name = name.replace(\"'\", \"''\")\n        encoded_group_name = quote(escaped_group_name, safe=\"\")\n        request_url = self.config()[\n            \"groupsUrl\"\n        ] + \"?$filter=displayName eq '{}'\".format(encoded_group_name)\n\n        request_header = self.request_header()\n\n        logger.info(\n            \"Delete all Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\n            name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                existing_teams = self.parse_request_response(response)\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of M365 Teams to delete; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                existing_teams = None\n                break\n\n        if existing_teams:\n            data = existing_teams.get(\"value\")\n            if data:\n                counter = 0\n                for team in data:\n                    team_id = team.get(\"id\")\n                    response = self.delete_team(team_id)\n\n                    if not response:\n                        logger.error(\n                            \"Failed to delete M365 Team -&gt; %s (%s)\", name, team_id\n                        )\n                        continue\n                    counter += 1\n\n                logger.info(\n                    \"%s M365 Teams with name -&gt; %s have been deleted.\",\n                    str(counter),\n                    name,\n                )\n                return True\n            else:\n                logger.info(\"No M365 Teams with name -&gt; %s found.\", name)\n                return False\n        else:\n            logger.error(\"Failed to retrieve M365 Teams with name -&gt; %s\", name)\n            return False\n\n    # end method definition\n\n    def delete_all_teams(self, exception_list: list, pattern_list: list) -&gt; bool:\n        \"\"\"Delete all teams (groups) that are NOT on the exception list AND\n           that are matching at least one of the patterns in the provided pattern list.\n           This method is used for general cleanup of teams. Be aware that deleted teams\n           are still listed under https://admin.microsoft.com/#/deletedgroups\n\n        Args:\n            exception_list (list): list of group names that should not be deleted\n            pattern_list (list): list of patterns for group names to be deleted\n                                 (regular expression)\n        Returns:\n            bool: True if teams have been deleted, False otherwise.\n        \"\"\"\n\n        # Get list of all existing M365 groups/teams:\n        response = self.get_groups(max_number=500)\n        if not \"value\" in response or not response[\"value\"]:\n            return False\n        groups = response[\"value\"]\n        logger.info(\n            \"Found -&gt; %s existing M365 groups. Checking which ones should be deleted...\",\n            len(groups),\n        )\n\n        # Process all groups and check if the&lt; should be\n        # deleted:\n        for group in groups:\n            group_name = group[\"displayName\"]\n            # Check if group is in exception list:\n            if group_name in exception_list:\n                logger.info(\n                    \"M365 Group name -&gt; %s is on the exception list. Skipping...\",\n                    group_name,\n                )\n                continue\n            # Check that at least one pattern is found that matches the group:\n            for pattern in pattern_list:\n                result = re.search(pattern, group_name)\n                if result:\n                    logger.info(\n                        \"M365 Group name -&gt; %s is matching pattern -&gt; %s. Delete it now...\",\n                        group_name,\n                        pattern,\n                    )\n                    self.delete_teams(group_name)\n                    break\n            else:\n                logger.info(\n                    \"M365 Group name -&gt; %s is not matching any delete pattern. Skipping...\",\n                    group_name,\n                )\n        return True\n\n    # end method definition\n\n    def get_team_channels(self, name: str) -&gt; dict | None:\n        \"\"\"Get channels of a M365 Team based on the team name\n\n        Args:\n            name (str): name of the team\n        Returns:\n            dict: channel data structure (dictionary) or None if the request fails.\n\n            Example return data:\n            {\n                '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels\",\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '19:yPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1@thread.tacv2',\n                        'createdDateTime': '2023-08-11T14:11:35.986Z',\n                        'displayName': 'General',\n                        'description': 'Procurement',\n                        'isFavoriteByDefault': None,\n                        'email': None,\n                        'tenantId': '417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                        'webUrl': 'https://teams.microsoft.com/l/channel/19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2/Procurement?groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea&amp;allowXTenantAccess=False',\n                        'membershipType': 'standard'\n                    }\n                ]\n            }\n        \"\"\"\n\n        response = self.get_team(name)\n        team_id = self.get_result_value(response, \"id\", 0)\n        if not team_id:\n            return None\n\n        request_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id) + \"/channels\"\n\n        request_header = self.request_header()\n\n        logger.info(\n            \"Retrieve channels of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\n            name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get Channels for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_team_channel_tabs(self, team_name: str, channel_name: str) -&gt; dict | None:\n        \"\"\"Get tabs of an M365 Team channel based on the team and channel names\n\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n        Returns:\n            dict: tabs data structure (dictionary) or None if the request fails.\n\n            Example return data:\n            {\n                '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels('19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2')/tabs\",\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '66f44e9a-0741-49a4-9500-ec82cc120115',\n                        'displayName': 'Procurement',\n                        'webUrl': 'https://teams.microsoft.com/l/entity/2851980b-95dc-4118-a1f5-5ae1894eaaaf/_djb2_msteams_prefix_66f44e9a-0741-49a4-9500-ec82cc120115?webUrl=https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%26showBW%3dtrue%26title%3dProcurement&amp;label=Procurement&amp;context=%7b%0d%0a++%22canvasUrl%22%3a+%22https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%22%2c%0d%0a++%22channelId%22%3a+%2219%3ayPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2%22%2c%0d%0a++%22subEntityId%22%3a+null%0d%0a%7d&amp;groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                        'configuration':\n                        {\n                            'entityId': '13178',\n                            'contentUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed',\n                            'removeUrl': None,\n                            'websiteUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed&amp;showBW=true&amp;title=Procurement',\n                            'dateAdded': '2023-08-12T08:57:35.895Z'\n                        }\n                    }\n                ]\n            }\n        \"\"\"\n\n        response = self.get_team(team_name)\n        team_id = self.get_result_value(response, \"id\", 0)\n        if not team_id:\n            return None\n\n        # Get the channels of the M365 Team:\n        response = self.get_team_channels(team_name)\n        if not response or not response[\"value\"] or not response[\"value\"][0]:\n            return None\n\n        # Look the channel by name and then retrieve its ID:\n        channel = next(\n            (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n            None,\n        )\n        if not channel:\n            logger.erro(\n                \"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n            )\n            return None\n        channel_id = channel[\"id\"]\n\n        request_url = (\n            self.config()[\"teamsUrl\"]\n            + \"/\"\n            + str(team_id)\n            + \"/channels/\"\n            + str(channel_id)\n            + \"/tabs\"\n        )\n\n        request_header = self.request_header()\n\n        logger.info(\n            \"Retrieve Tabs of Microsoft 365 Teams -&gt; %s and Channel -&gt; %s; calling -&gt; %s\",\n            team_name,\n            channel_name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get Tabs for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                    team_name,\n                    team_id,\n                    channel_name,\n                    channel_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_teams_apps(self, filter_expression: str = \"\") -&gt; dict | None:\n        \"\"\"Get a list of MS Teams apps in catalog that match a given filter criterium\n\n        Args:\n            filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps(appDefinitions())',\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                        'externalId': 'dd4af790-d8ff-47a0-87ad-486318272c7a',\n                        'displayName': 'OpenText Extended ECM',\n                        'distributionMethod': 'organization',\n                        'appDefinitions@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps('2851980b-95dc-4118-a1f5-5ae1894eaaaf')/appDefinitions\",\n                        'appDefinitions': [\n                            {\n                                'id': 'Mjg1MTk4MGItOTVkYy00MTE4LWExZjUtNWFlMTg5NGVhYWFmIyMyMi40IyNQdWJsaXNoZWQ=',\n                                'teamsAppId': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                                'displayName': 'OpenText Extended ECM',\n                                'version': '22.4',\n                                'publishingState': 'published',\n                                'shortDescription': 'Add a tab for an Extended ECM business workspace.',\n                                'description': 'View and interact with OpenText Extended ECM business workspaces',\n                                'lastModifiedDateTime': None,\n                                'createdBy': None,\n                                'authorization': {\n                                    'requiredPermissionSet': {...}\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }\n        \"\"\"\n\n        query = {\"$expand\": \"AppDefinitions\"}\n\n        if filter_expression:\n            query[\"$filter\"] = filter_expression\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n        request_url = self.config()[\"teamsAppsUrl\"] + \"?\" + encoded_query\n\n        if filter_expression:\n            logger.info(\n                \"Get list of MS Teams Apps using filter -&gt; %s; calling -&gt; %s\",\n                filter_expression,\n                request_url,\n            )\n        else:\n            logger.info(\"Get list of all MS Teams Apps; calling -&gt; %s\", request_url)\n\n        request_header = self.request_header()\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_teams_app(self, app_id: str) -&gt; dict | None:\n        \"\"\"Get a specific MS Teams app in catalog based on the known app ID\n\n        Args:\n            app_id (str): ID of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        query = {\"$expand\": \"AppDefinitions\"}\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n        request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id + \"?\" + encoded_query\n\n        #        request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n\n        logger.info(\n            \"Get MS Teams App with ID -&gt; %s; calling -&gt; %s\", app_id, request_url\n        )\n\n        request_header = self.request_header()\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_teams_apps_of_user(\n        self, user_id: str, filter_expression: str = \"\"\n    ) -&gt; dict | None:\n        \"\"\"Get a list of MS Teams apps of a user that match a given filter criterium\n\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        query = {\"$expand\": \"teamsAppDefinition\"}\n        if filter_expression:\n            query[\"$filter\"] = filter_expression\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n        request_url = (\n            self.config()[\"usersUrl\"]\n            + \"/\"\n            + user_id\n            + \"/teamwork/installedApps?\"\n            + encoded_query\n        )\n        logger.info(\n            \"Get list of M365 Teams Apps for user -&gt; %s using query -&gt; %s; calling -&gt; %s\",\n            user_id,\n            query,\n            request_url,\n        )\n\n        request_header = self.request_header()\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of M365 Teams Apps for user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    user_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_teams_apps_of_team(\n        self, team_id: str, filter_expression: str = \"\"\n    ) -&gt; dict | None:\n        \"\"\"Get a list of MS Teams apps of a M365 team that match a given filter criterium\n\n        Args:\n            team_id (str): M365 ID of the team\n            filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        query = {\"$expand\": \"teamsAppDefinition\"}\n        if filter_expression:\n            query[\"$filter\"] = filter_expression\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n        request_url = (\n            self.config()[\"teamsUrl\"]\n            + \"/\"\n            + team_id\n            + \"/installedApps?\"\n            + encoded_query\n        )\n        logger.info(\n            \"Get list of M365 Teams Apps for M365 Team -&gt; %s using query -&gt; %s; calling -&gt; %s\",\n            team_id,\n            query,\n            request_url,\n        )\n\n        request_header = self.request_header()\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of M365 Teams Apps for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    team_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def extract_version_from_app_manifest(self, app_path: str) -&gt; str | None:\n        \"\"\"Extract the version number from the MS Teams app manifest file.\n           This can be used to check if the app package includes a newer\n           app version then the already installed one.\n\n        Args:\n            app_path (str): file path (with directory) to the app package to extract\n                            the version from\n        Returns:\n            str: version number or None in case of an error\n        \"\"\"\n\n        with zipfile.ZipFile(app_path, \"r\") as zip_ref:\n            manifest_data = zip_ref.read(\"manifest.json\")\n            manifest_json = json.loads(manifest_data)\n            version = manifest_json.get(\"version\")\n\n            return version\n\n    # end method definition\n\n    def upload_teams_app(\n        self, app_path: str, update_existing_app: bool = False, app_catalog_id: str = \"\"\n    ) -&gt; dict | None:\n        \"\"\"Upload a new app package to the catalog of MS Teams apps.\n            This is not possible with client secret credentials\n            but requires a token of a user authenticated with username + password.\n            See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n            (permissions table on that page)\n\n        Args:\n            app_path (str): file path (with directory) to the app package to upload\n            update_existing_app (bool): whether or not to update an existing app with\n                                        the same name\n            app_catalog_id (str): the unique ID of the app. It is the ID the app has in\n                                  the catalog - which is different from ID an app gets\n                                  after installation (which is tenant specific)\n        Returns:\n            dict: Response of the MS GRAPH API REST call or None if the request fails\n        \"\"\"\n\n        if update_existing_app and not app_catalog_id:\n            logger.error(\n                \"To update an existing M365 Teams app in the app catalog you need to provide the existing App catalog ID!\"\n            )\n            return None\n\n        if not os.path.exists(app_path):\n            logger.error(\"M365 Teams app file -&gt; {} does not exist!\")\n            return None\n\n        # Ensure that the app file is a zip file\n        if not app_path.endswith(\".zip\"):\n            logger.error(\"M365 Teams app file -&gt; {} must be a zip file!\")\n            return None\n\n        request_url = self.config()[\"teamsAppsUrl\"]\n        # If we want to upgrade an existing app we add the app ID and\n        # the specific endpoint:\n        if update_existing_app:\n            request_url += \"/\" + app_catalog_id + \"/appDefinitions\"\n\n        # Here we need the credentials of an authenticated user!\n        # (not the application credentials (client_id, client_secret))\n        request_header = self.request_header_user(\"application/zip\")\n\n        with open(app_path, \"rb\") as f:\n            app_data = f.read()\n\n        with zipfile.ZipFile(app_path) as z:\n            # Ensure that the app file contains a manifest.json file\n            if \"manifest.json\" not in z.namelist():\n                logger.error(\n                    \"M365 Teams app file -&gt; {} does not contain a manifest.json file!\"\n                )\n                return None\n\n        logger.info(\n            \"Upload M365 Teams app -&gt; %s to the MS Teams catalog; calling -&gt; %s\",\n            app_path,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url, headers=request_header, data=app_data, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n\n            # Check if Session has expired - then re-authenticate and try once more\n            if response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                if update_existing_app:\n                    logger.warning(\n                        \"Failed to update existing M365 Teams app -&gt; %s (may be because it is not a new version); status -&gt; %s; error -&gt; %s\",\n                        app_path,\n                        response.status_code,\n                        response.text,\n                    )\n\n                else:\n                    logger.error(\n                        \"Failed to upload new M365 Teams app -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        app_path,\n                        response.status_code,\n                        response.text,\n                    )\n                return None\n\n    # end method definition\n\n    def remove_teams_app(self, app_id: str):\n        \"\"\"Remove MS Teams App from the app catalog\n\n        Args:\n            app_id (str): Microsoft 365 GUID of the MS Teams app\n        \"\"\"\n\n        request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n        # Here we need the credentials of an authenticated user!\n        # (not the application credentials (client_id, client_secret))\n        request_header = self.request_header_user()\n\n        # Make the DELETE request to remove the app from the app catalog\n        response = requests.delete(request_url, headers=request_header, timeout=60)\n\n        # Check the status code of the response\n        if response.status_code == 204:\n            logger.info(\n                \"The M365 Teams app with ID -&gt; %s has been successfully removed from the app catalog.\",\n                app_id,\n            )\n        else:\n            logger.error(\n                \"An error occurred while removing the M365 Teams app from the M365 app catalog. Status code -&gt; %s. Error message -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n\n    # end method definition\n\n    def assign_teams_app_to_user(self, user_id: str, app_name: str) -&gt; dict | None:\n        \"\"\"Assigns (adds) a M365 Teams app to a M365 user.\n\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            app_name (str): exact name of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        response = self.get_teams_apps(f\"contains(displayName, '{app_name}')\")\n        app_id = self.get_result_value(response, \"id\", 0)\n        if not app_id:\n            logger.error(\"M365 Teams App -&gt; %s not found!\", app_name)\n            return None\n\n        request_url = (\n            self.config()[\"usersUrl\"] + \"/\" + user_id + \"/teamwork/installedApps\"\n        )\n        request_header = self.request_header()\n\n        post_body = {\n            \"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n        }\n\n        logger.info(\n            \"Assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; calling -&gt; %s\",\n            app_name,\n            app_id,\n            user_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url, json=post_body, headers=request_header, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    app_name,\n                    app_id,\n                    user_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def upgrade_teams_app_of_user(self, user_id: str, app_name: str) -&gt; dict | None:\n        \"\"\"Upgrade a MS teams app for a user. The call will fail if the user does not\n            already have the app assigned. So this needs to be checked before\n            calling this method.\n\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            app_name (str): exact name of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        response = self.get_teams_apps_of_user(\n            user_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n        )\n        # Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\n        app_installation_id = self.get_result_value(response, \"id\", 0)\n        if not app_installation_id:\n            logger.error(\n                \"M365 Teams app -&gt; %s not found for user with ID -&gt; %s. Cannot upgrade app for this user!\",\n                app_name,\n                user_id,\n            )\n            return None\n\n        request_url = (\n            self.config()[\"usersUrl\"]\n            + \"/\"\n            + user_id\n            + \"/teamwork/installedApps/\"\n            + app_installation_id\n            + \"/upgrade\"\n        )\n        request_header = self.request_header()\n\n        logger.info(\n            \"Upgrade M365 Teams app -&gt; %s (%s) of M365 user with ID -&gt; %s; calling -&gt; %s\",\n            app_name,\n            app_installation_id,\n            user_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to upgrade M365 Teams app -&gt; %s (%s) of M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    app_name,\n                    app_installation_id,\n                    user_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def assign_teams_app_to_team(self, team_id: str, app_id: str) -&gt; dict | None:\n        \"\"\"Assign (add) a MS Teams app to a M365 team\n           (so that it afterwards can be added as a Tab in a M365 Teams Channel)\n\n        Args:\n            team_id (str): ID of the Microsoft 365 Team\n            app_id (str): ID of the M365 Team App\n\n        Returns:\n            dict | None: API response or None if the Graph API call fails.\n        \"\"\"\n\n        request_url = self.config()[\"teamsUrl\"] + \"/\" + team_id + \"/installedApps\"\n        request_header = self.request_header()\n\n        post_body = {\n            \"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n        }\n\n        logger.info(\n            \"Assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; calling -&gt; %s\",\n            app_id,\n            team_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url, json=post_body, headers=request_header, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    app_id,\n                    team_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def upgrade_teams_app_of_team(self, team_id: str, app_name: str) -&gt; dict | None:\n        \"\"\"Upgrade a MS teams app for a specific team. The call will fail if the team does not\n            already have the app assigned. So this needs to be checked before\n            calling this method.\n            THIS IS CURRENTLY NOT WORKING AS EXPECTED.\n\n        Args:\n            team_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            app_name (str): exact name of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\n\n        response = self.get_teams_apps_of_team(\n            team_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n        )\n        # Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\n        app_installation_id = self.get_result_value(response, \"id\", 0)\n        if not app_installation_id:\n            logger.error(\n                \"M365 Teams app -&gt; %s not found for M365 Team with ID -&gt; %s. Cannot upgrade app for this team!\",\n                app_name,\n                team_id,\n            )\n            return None\n\n        request_url = (\n            self.config()[\"teamsUrl\"]\n            + \"/\"\n            + team_id\n            + \"/installedApps/\"\n            + app_installation_id\n            + \"/upgrade\"\n        )\n        request_header = self.request_header()\n\n        logger.info(\n            \"Upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; calling -&gt; %s\",\n            app_name,\n            app_installation_id,\n            team_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    app_name,\n                    app_installation_id,\n                    team_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_teams_app_to_channel(\n        self,\n        team_name: str,\n        channel_name: str,\n        app_id: str,\n        tab_name: str,\n        app_url: str,\n        cs_node_id: int,\n    ) -&gt; dict | None:\n        \"\"\"Add tab for Extended ECM app to an M365 Team channel\n\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n            app_id (str): ID of the MS Teams Application (e.g. the Extended ECM Teams App)\n            tab_name (str): name of the tab\n            app_url (str) web URL of the app\n            cs_node_id (int): node ID of the target workspace or container in Extended ECM\n        Returns:\n            dict: return data structure (dictionary) or None if the request fails.\n\n            Example return data:\n\n        \"\"\"\n\n        response = self.get_team(team_name)\n        team_id = self.get_result_value(response, \"id\", 0)\n        if not team_id:\n            return None\n\n        # Get the channels of the M365 Team:\n        response = self.get_team_channels(team_name)\n        if not response or not response[\"value\"] or not response[\"value\"][0]:\n            return None\n\n        # Look the channel by name and then retrieve its ID:\n        channel = next(\n            (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n            None,\n        )\n        if not channel:\n            logger.erro(\n                \"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n            )\n            return None\n        channel_id = channel[\"id\"]\n\n        request_url = (\n            self.config()[\"teamsUrl\"]\n            + \"/\"\n            + str(team_id)\n            + \"/channels/\"\n            + str(channel_id)\n            + \"/tabs\"\n        )\n\n        request_header = self.request_header()\n\n        # Create tab configuration payload:\n        tab_config = {\n            \"teamsApp@odata.bind\": f\"https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/{app_id}\",\n            \"displayName\": tab_name,\n            \"configuration\": {\n                \"entityId\": cs_node_id,  # Unique identifier for the tab\n                \"contentUrl\": app_url,\n                \"removeUrl\": \"\",\n                \"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n            },\n        }\n\n        logger.info(\n            \"Add Tab -&gt; %s with App ID -&gt; %s to Channel -&gt; %s of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\n            tab_name,\n            app_id,\n            channel_name,\n            team_name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url, headers=request_header, json=tab_config, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Tab for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s; tab config -&gt; %s\",\n                    team_name,\n                    team_id,\n                    channel_name,\n                    channel_id,\n                    response.status_code,\n                    response.text,\n                    str(tab_config),\n                )\n                return None\n\n    # end method definition\n\n    def update_teams_app_of_channel(\n        self,\n        team_name: str,\n        channel_name: str,\n        tab_name: str,\n        app_url: str,\n        cs_node_id: int,\n    ) -&gt; dict | None:\n        \"\"\"Update an existing tab for Extended ECM app in an M365 Team channel\n\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n            tab_name (str): name of the tab\n            app_url (str) web URL of the app\n            cs_node_id (int): node ID of the target workspace or container in Extended ECM\n        Returns:\n            dict: return data structure (dictionary) or None if the request fails.\n\n            Example return data:\n\n        \"\"\"\n\n        response = self.get_team(team_name)\n        team_id = self.get_result_value(response, \"id\", 0)\n        if not team_id:\n            return None\n\n        # Get the channels of the M365 Team:\n        response = self.get_team_channels(team_name)\n        if not response or not response[\"value\"] or not response[\"value\"][0]:\n            return None\n\n        # Look the channel by name and then retrieve its ID:\n        channel = next(\n            (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n            None,\n        )\n        if not channel:\n            logger.erro(\n                \"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n            )\n            return None\n        channel_id = channel[\"id\"]\n\n        # Get the tabs of the M365 Team channel:\n        response = self.get_team_channel_tabs(team_name, channel_name)\n        if not response or not response[\"value\"] or not response[\"value\"][0]:\n            return None\n\n        # Look the tab by name and then retrieve its ID:\n        tab = next(\n            (item for item in response[\"value\"] if item[\"displayName\"] == tab_name),\n            None,\n        )\n        if not tab:\n            logger.erro(\n                \"Cannot find Tab -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\n                tab_name,\n                team_name,\n                team_id,\n                channel_name,\n                channel_id,\n            )\n            return None\n        tab_id = tab[\"id\"]\n\n        request_url = (\n            self.config()[\"teamsUrl\"]\n            + \"/\"\n            + str(team_id)\n            + \"/channels/\"\n            + str(channel_id)\n            + \"/tabs/\"\n            + str(tab_id)\n        )\n\n        request_header = self.request_header()\n\n        # Create tab configuration payload:\n        tab_config = {\n            \"configuration\": {\n                \"entityId\": cs_node_id,  # Unique identifier for the tab\n                \"contentUrl\": app_url,\n                \"removeUrl\": \"\",\n                \"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n            },\n        }\n\n        logger.info(\n            \"Update Tab -&gt; %s (%s) of Channel -&gt; %s (%s) for Microsoft 365 Teams -&gt; %s (%s) with configuration -&gt; %s; calling -&gt; %s\",\n            tab_name,\n            tab_id,\n            channel_name,\n            channel_id,\n            team_name,\n            team_id,\n            str(tab_config),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.patch(\n                request_url, headers=request_header, json=tab_config, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                    tab_name,\n                    tab_id,\n                    team_name,\n                    team_id,\n                    channel_name,\n                    channel_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def delete_teams_app_from_channel(\n        self,\n        team_name: str,\n        channel_name: str,\n        tab_name: str,\n    ) -&gt; bool:\n        \"\"\"Delete an existing tab for Extended ECM app from an M365 Team channel\n\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n            tab_name (str): name of the tab\n        Returns:\n            bool: True = success, False = Error.\n        \"\"\"\n\n        response = self.get_team(team_name)\n        team_id = self.get_result_value(response, \"id\", 0)\n        if not team_id:\n            return False\n\n        # Get the channels of the M365 Team:\n        response = self.get_team_channels(team_name)\n        if not response or not response[\"value\"] or not response[\"value\"][0]:\n            return False\n\n        # Look the channel by name and then retrieve its ID:\n        channel = next(\n            (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n            None,\n        )\n        if not channel:\n            logger.erro(\n                \"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n            )\n            return False\n        channel_id = channel[\"id\"]\n\n        # Get the tabs of the M365 Team channel:\n        response = self.get_team_channel_tabs(team_name, channel_name)\n        if not response or not response[\"value\"] or not response[\"value\"][0]:\n            return False\n\n        # Lookup the tabs by name and then retrieve their IDs (in worst case it can\n        # be multiple tabs / apps with same name if former cleanups did not work):\n        tab_list = [\n            item for item in response[\"value\"] if item[\"displayName\"] == tab_name\n        ]\n        if not tab_list:\n            logger.erro(\n                \"Cannot find Tabs with name -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\n                tab_name,\n                team_name,\n                team_id,\n                channel_name,\n                channel_id,\n            )\n            return False\n\n        for tab in tab_list:\n            tab_id = tab[\"id\"]\n\n            request_url = (\n                self.config()[\"teamsUrl\"]\n                + \"/\"\n                + str(team_id)\n                + \"/channels/\"\n                + str(channel_id)\n                + \"/tabs/\"\n                + str(tab_id)\n            )\n\n            request_header = self.request_header()\n\n            logger.info(\n                \"Delete Tab -&gt; %s (%s) from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s); calling -&gt; %s\",\n                tab_name,\n                tab_id,\n                channel_name,\n                channel_id,\n                team_name,\n                team_id,\n                request_url,\n            )\n\n            retries = 0\n            while True:\n                response = requests.delete(\n                    request_url, headers=request_header, timeout=60\n                )\n                if response.ok:\n                    logger.info(\n                        \"Tab -&gt; %s (%s) has been deleted from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s)\",\n                        tab_name,\n                        tab_id,\n                        channel_name,\n                        channel_id,\n                        team_name,\n                        team_id,\n                    )\n                    break\n                # Check if Session has expired - then re-authenticate and try once more\n                elif response.status_code == 401 and retries == 0:\n                    logger.warning(\"Session has expired - try to re-authenticate...\")\n                    self.authenticate(revalidate=True)\n                    request_header = self.request_header()\n                    retries += 1\n                elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                    logger.warning(\n                        \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                        response.status_code,\n                        (retries + 1) * 60,\n                    )\n                    time.sleep((retries + 1) * 60)\n                    retries += 1\n                else:\n                    logger.error(\n                        \"Failed to delete Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                        tab_name,\n                        tab_id,\n                        team_name,\n                        team_id,\n                        channel_name,\n                        channel_id,\n                        response.status_code,\n                        response.text,\n                    )\n                    return False\n        return True\n\n    # end method definition\n\n    def add_sensitivity_label(\n        self,\n        name: str,\n        display_name: str,\n        description: str = \"\",\n        color: str = \"red\",\n        enabled: bool = True,\n        admin_description: str = \"\",\n        user_description: str = \"\",\n        enable_encryption: bool = False,\n        enable_marking: bool = False,\n    ):\n        \"\"\"Create a new sensitivity label in M365\n            THIS IS CURRENTLY NOT WORKING!\n\n        Args:\n            name (str): name of the label\n            display_name (str): display name of the label\n            description (str, optional): Description of the label. Defaults to \"\".\n            color (str, optional): Color of the label. Defaults to \"red\".\n            enabled (bool, optional): Whether this label is enabled. Defaults to True.\n            admin_description (str, optional): Description for administrators. Defaults to \"\".\n            user_description (str, optional): Description for users. Defaults to \"\".\n            enable_encryption (bool, optional): Enable encryption. Defaults to False.\n            enable_marking (bool, optional): _description_. Defaults to False.\n\n        Returns:\n            Request reponse or None if the request fails.\n        \"\"\"\n\n        # Prepare the request body\n        payload = {\n            \"displayName\": display_name,\n            \"description\": description,\n            \"isEnabled\": enabled,\n            \"labelColor\": color,\n            \"adminDescription\": admin_description,\n            \"userDescription\": user_description,\n            \"encryptContent\": enable_encryption,\n            \"contentMarking\": enable_marking,\n        }\n\n        request_url = self.config()[\"securityUrl\"] + \"/sensitivityLabels\"\n        request_header = self.request_header()\n\n        logger.info(\n            \"Create M365 sensitivity label -&gt; %s; calling -&gt; %s\", name, request_url\n        )\n\n        # Send the POST request to create the label\n        response = requests.post(\n            request_url, headers=request_header, data=json.dumps(payload), timeout=60\n        )\n\n        # Check the response status code\n        if response.status_code == 201:\n            logger.info(\"Label -&gt; %s has been created successfully!\", name)\n            return response\n        else:\n            logger.error(\n                \"Failed to create the M365 label -&gt; %s! Response status code -&gt; %s\",\n                name,\n                response.status_code,\n            )\n            return None\n\n    # end method definition\n\n    def assign_sensitivity_label_to_user(self, user_email: str, label_name: str):\n        \"\"\"Assigns a existing sensitivity label to a user.\n            THIS IS CURRENTLY NOT WORKING!\n\n        Args:\n            user_email (str): email address of the user (as unique identifier)\n            label_name (str): name of the label (need to exist)\n\n        Returns:\n            Return the request response or None if the request fails.\n        \"\"\"\n\n        # Set up the request body with the label name\n        body = {\"labelName\": label_name}\n\n        request_url = (\n            self.config()[\"usersUrl\"] + \"/\" + user_email + \"/assignSensitivityLabels\"\n        )\n        request_header = self.request_header()\n\n        logger.info(\n            \"Assign label -&gt; %s to user -&gt; %s; calling -&gt; %s\",\n            label_name,\n            user_email,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url, headers=request_header, json=body, timeout=60\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign label -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    label_name,\n                    user_email,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def upload_outlook_app(\n        self,\n        app_path: str,\n    ) -&gt; dict | None:\n        \"\"\"Upload the M365 Outlook Add-In as \"Integrated\" App to M365 Admin Center.\n           THIS IS CURRENTLY NOT IMPLEMENTED DUE TO MISSING MS GRAPH API SUPPORT!\n\n           https://admin.microsoft.com/#/Settings/IntegratedApps\n\n        Args:\n            app_path (str): path to manifest file in local file system. Needs to be\n                            downloaded before.\n\n        Returns:\n            dict | None: response of the MS Graph API or None if the request fails.\n        \"\"\"\n\n        #        request_url = self.config()[\"teamsAppsUrl\"]\n\n        #        request_header = self.request_header()\n\n        logger.info(\"Install Outlook Add-in from %s (NOT IMPLEMENTED)\", app_path)\n\n        response = None\n\n        return response\n\n    # end method definition\n\n    def get_app_registration(\n        self,\n        app_registration_name: str,\n    ) -&gt; dict:\n        \"\"\"Find an Azure App Registration based on its name\n\n        Args:\n            app_registration_name (str): name of the App Registration\n\n        Returns:\n            dict: App Registration data or None of the request fails.\n        \"\"\"\n\n        request_url = self.config()[\n            \"applicationsUrl\"\n        ] + \"?$filter=displayName eq '{}'\".format(app_registration_name)\n        request_header = self.request_header()\n\n        logger.info(\n            \"Get Azure App Registration -&gt; %s; calling -&gt; %s\",\n            app_registration_name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=60)\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Cannot find Azure App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    app_registration_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_app_registration(\n        self,\n        app_registration_name: str,\n        description: str = \"\",\n        api_permissions: list | None = None,\n        supported_account_type: str = \"AzureADMyOrg\",\n    ) -&gt; dict:\n        \"\"\"Add an Azure App Registration\n\n        Args:\n            app_registration_name (str): name of the App Registration\n            api_permissions (list): API permissions\n            supported_account_type (str): type of account that is supposed to use\n                                          the App Registration\n\n        Returns:\n            dict: App Registration data or None of the request fails.\n\n            Example data:\n            {\n                'id': 'd70bee91-3689-4239-a626-30756968e99c',\n                'deletedDateTime': None,\n                'appId': 'd288ba5f-9313-4b38-b4a4-d7edcce089b0',\n                'applicationTemplateId': None,\n                'disabledByMicrosoftStatus': None,\n                'createdDateTime': '2023-09-06T21:06:05Z',\n                'displayName': 'Test 1',\n                'description': None,\n                'groupMembershipClaims': None,\n                'identifierUris': [],\n                'isDeviceOnlyAuthSupported': None,\n                'isFallbackPublicClient': None,\n                'notes': None,\n                'publisherDomain': 'M365x41497014.onmicrosoft.com',\n                'signInAudience': 'AzureADMyOrg',\n                ...\n                'requiredResourceAccess': [\n                    {\n                        'resourceAppId': '00000003-0000-0ff1-ce00-000000000000',\n                        'resourceAccess': [\n                            {\n                                'id': '741f803b-c850-494e-b5df-cde7c675a1ca',\n                                'type': 'Role'\n                            },\n                            {\n                                'id': 'c8e3537c-ec53-43b9-bed3-b2bd3617ae97',\n                                'type': 'Role'\n                            },\n                        ]\n                    },\n                ]\n            }\n        \"\"\"\n\n        # Define the request body to create the App Registration\n        app_registration_data = {\n            \"displayName\": app_registration_name,\n            \"signInAudience\": supported_account_type,\n        }\n        if api_permissions:\n            app_registration_data[\"requiredResourceAccess\"] = api_permissions\n        if description:\n            app_registration_data[\"description\"] = description\n\n        request_url = self.config()[\"applicationsUrl\"]\n        request_header = self.request_header()\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                json=app_registration_data,\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Cannot add App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    app_registration_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def update_app_registration(\n        self,\n        app_registration_id: str,\n        app_registration_name: str,\n        api_permissions: list,\n        supported_account_type: str = \"AzureADMyOrg\",\n    ) -&gt; dict:\n        \"\"\"Update an Azure App Registration\n\n        Args:\n            app_registration_id (str): ID of the existing App Registration\n            app_registration_name (str): name of the App Registration\n            api_permissions (list): API permissions\n            supported_account_type (str): type of account that is supposed to use\n                                          the App Registration\n\n        Returns:\n            dict: App Registration data or None of the request fails.\n        \"\"\"\n\n        # Define the request body to create the App Registration\n        app_registration_data = {\n            \"displayName\": app_registration_name,\n            \"requiredResourceAccess\": api_permissions,\n            \"signInAudience\": supported_account_type,\n        }\n\n        request_url = self.config()[\"applicationsUrl\"] + \"/\" + app_registration_id\n        request_header = self.request_header()\n\n        logger.info(\n            \"Update App Registration -&gt; %s (%s); calling -&gt; %s\",\n            app_registration_name,\n            app_registration_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.patch(\n                request_url,\n                headers=request_header,\n                json=app_registration_data,\n                timeout=60,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Cannot update App Registration -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                    app_registration_name,\n                    app_registration_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.__init__","title":"<code>__init__(tenant_id, client_id, client_secret, domain, sku_id, teams_app_name)</code>","text":"<p>Initialize the M365 object</p> <p>Parameters:</p> Name Type Description Default <code>tenant_id</code> <code>str</code> <p>M365 Tenant ID</p> required <code>client_id</code> <code>str</code> <p>M365 Client ID</p> required <code>client_secret</code> <code>str</code> <p>M365 Client Secret</p> required <code>domain</code> <code>str</code> <p>M365 domain</p> required <code>sku_id</code> <code>str</code> <p>License SKU for M365 users</p> required <code>teams_app_name</code> <code>str</code> <p>name of the Extended ECM app for MS Teams</p> required Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def __init__(\n    self,\n    tenant_id: str,\n    client_id: str,\n    client_secret: str,\n    domain: str,\n    sku_id: str,\n    teams_app_name: str,\n):\n    \"\"\"Initialize the M365 object\n\n    Args:\n        tenant_id (str): M365 Tenant ID\n        client_id (str): M365 Client ID\n        client_secret (str): M365 Client Secret\n        domain (str): M365 domain\n        sku_id (str): License SKU for M365 users\n        teams_app_name (str): name of the Extended ECM app for MS Teams\n    \"\"\"\n\n    m365_config = {}\n\n    # Set the authentication endpoints and credentials\n    m365_config[\"tenantId\"] = tenant_id\n    m365_config[\"clientId\"] = client_id\n    m365_config[\"clientSecret\"] = client_secret\n    m365_config[\"domain\"] = domain\n    m365_config[\"skuId\"] = sku_id\n    m365_config[\"teamsAppName\"] = teams_app_name\n    m365_config[\n        \"authenticationUrl\"\n    ] = \"https://login.microsoftonline.com/{}/oauth2/v2.0/token\".format(tenant_id)\n    m365_config[\"graphUrl\"] = \"https://graph.microsoft.com/v1.0/\"\n    m365_config[\"betaUrl\"] = \"https://graph.microsoft.com/beta/\"\n    m365_config[\"directoryObjects\"] = m365_config[\"graphUrl\"] + \"directoryObjects\"\n\n    # Set the data for the token request\n    m365_config[\"tokenData\"] = {\n        \"client_id\": client_id,\n        \"scope\": \"https://graph.microsoft.com/.default\",\n        \"client_secret\": client_secret,\n        \"grant_type\": \"client_credentials\",\n    }\n\n    m365_config[\"groupsUrl\"] = m365_config[\"graphUrl\"] + \"groups\"\n    m365_config[\"usersUrl\"] = m365_config[\"graphUrl\"] + \"users\"\n    m365_config[\"teamsUrl\"] = m365_config[\"graphUrl\"] + \"teams\"\n    m365_config[\"teamsTemplatesUrl\"] = m365_config[\"graphUrl\"] + \"teamsTemplates\"\n    m365_config[\"teamsAppsUrl\"] = m365_config[\"graphUrl\"] + \"appCatalogs/teamsApps\"\n    m365_config[\"directoryUrl\"] = m365_config[\"graphUrl\"] + \"directory\"\n    m365_config[\"securityUrl\"] = m365_config[\"betaUrl\"] + \"security\"\n    m365_config[\"applicationsUrl\"] = m365_config[\"graphUrl\"] + \"applications\"\n\n    self._config = m365_config\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_app_registration","title":"<code>add_app_registration(app_registration_name, description='', api_permissions=None, supported_account_type='AzureADMyOrg')</code>","text":"<p>Add an Azure App Registration</p> <p>Parameters:</p> Name Type Description Default <code>app_registration_name</code> <code>str</code> <p>name of the App Registration</p> required <code>api_permissions</code> <code>list</code> <p>API permissions</p> <code>None</code> <code>supported_account_type</code> <code>str</code> <p>type of account that is supposed to use                           the App Registration</p> <code>'AzureADMyOrg'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>App Registration data or None of the request fails.</p> <code>dict</code> <p>Example data:</p> <code>dict</code> <p>{ 'id': 'd70bee91-3689-4239-a626-30756968e99c', 'deletedDateTime': None, 'appId': 'd288ba5f-9313-4b38-b4a4-d7edcce089b0', 'applicationTemplateId': None, 'disabledByMicrosoftStatus': None, 'createdDateTime': '2023-09-06T21:06:05Z', 'displayName': 'Test 1', 'description': None, 'groupMembershipClaims': None, 'identifierUris': [], 'isDeviceOnlyAuthSupported': None, 'isFallbackPublicClient': None, 'notes': None, 'publisherDomain': 'M365x41497014.onmicrosoft.com', 'signInAudience': 'AzureADMyOrg', ... 'requiredResourceAccess': [     {         'resourceAppId': '00000003-0000-0ff1-ce00-000000000000',         'resourceAccess': [             {                 'id': '741f803b-c850-494e-b5df-cde7c675a1ca',                 'type': 'Role'             },             {                 'id': 'c8e3537c-ec53-43b9-bed3-b2bd3617ae97',                 'type': 'Role'             },         ]     }, ]</p> <code>dict</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_app_registration(\n    self,\n    app_registration_name: str,\n    description: str = \"\",\n    api_permissions: list | None = None,\n    supported_account_type: str = \"AzureADMyOrg\",\n) -&gt; dict:\n    \"\"\"Add an Azure App Registration\n\n    Args:\n        app_registration_name (str): name of the App Registration\n        api_permissions (list): API permissions\n        supported_account_type (str): type of account that is supposed to use\n                                      the App Registration\n\n    Returns:\n        dict: App Registration data or None of the request fails.\n\n        Example data:\n        {\n            'id': 'd70bee91-3689-4239-a626-30756968e99c',\n            'deletedDateTime': None,\n            'appId': 'd288ba5f-9313-4b38-b4a4-d7edcce089b0',\n            'applicationTemplateId': None,\n            'disabledByMicrosoftStatus': None,\n            'createdDateTime': '2023-09-06T21:06:05Z',\n            'displayName': 'Test 1',\n            'description': None,\n            'groupMembershipClaims': None,\n            'identifierUris': [],\n            'isDeviceOnlyAuthSupported': None,\n            'isFallbackPublicClient': None,\n            'notes': None,\n            'publisherDomain': 'M365x41497014.onmicrosoft.com',\n            'signInAudience': 'AzureADMyOrg',\n            ...\n            'requiredResourceAccess': [\n                {\n                    'resourceAppId': '00000003-0000-0ff1-ce00-000000000000',\n                    'resourceAccess': [\n                        {\n                            'id': '741f803b-c850-494e-b5df-cde7c675a1ca',\n                            'type': 'Role'\n                        },\n                        {\n                            'id': 'c8e3537c-ec53-43b9-bed3-b2bd3617ae97',\n                            'type': 'Role'\n                        },\n                    ]\n                },\n            ]\n        }\n    \"\"\"\n\n    # Define the request body to create the App Registration\n    app_registration_data = {\n        \"displayName\": app_registration_name,\n        \"signInAudience\": supported_account_type,\n    }\n    if api_permissions:\n        app_registration_data[\"requiredResourceAccess\"] = api_permissions\n    if description:\n        app_registration_data[\"description\"] = description\n\n    request_url = self.config()[\"applicationsUrl\"]\n    request_header = self.request_header()\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            json=app_registration_data,\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Cannot add App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                app_registration_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_group","title":"<code>add_group(name, security_enabled=False, mail_enabled=True)</code>","text":"<p>Add a M365 Group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the group</p> required <code>security_enabled</code> <code>bool</code> <p>whether or not this group is used for permission management</p> <code>False</code> <code>mail_enabled</code> <code>bool</code> <p>whether or not this group is email enabled</p> <code>True</code> <p>Returns:     dict: Group information or None if the group couldn't be created (e.g. because it exisits already).</p> <pre><code>Example return data:\n{\n    '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups/$entity',\n    'id': '28906460-a69c-439e-84ca-c70becf37655',\n    'deletedDateTime': None,\n    'classification': None,\n    'createdDateTime': '2023-04-01T11:40:13Z',\n    'creationOptions': [],\n    'description': None,\n    'displayName': 'Test',\n    'expirationDateTime': None,\n    'groupTypes': ['Unified'],\n    'isAssignableToRole': None,\n    'mail': 'Diefenbruch@M365x61936377.onmicrosoft.com',\n    'mailEnabled': True,\n    'mailNickname': 'Test',\n    'membershipRule': None,\n    'membershipRuleProcessingState': None,\n    'onPremisesDomainName': None,\n    'onPremisesLastSyncDateTime': None,\n    'onPremisesNetBiosName': None,\n    'onPremisesSamAccountName': None,\n    'onPremisesSecurityIdentifier': None,\n    'onPremisesSyncEnabled': None,\n    'onPremisesProvisioningErrors': [],\n    'preferredDataLocation': None,\n    'preferredLanguage': None,\n    'proxyAddresses': ['SMTP:Test@M365x61936377.onmicrosoft.com'],\n    'renewedDateTime': '2023-04-01T11:40:13Z',\n    'resourceBehaviorOptions': [],\n    'resourceProvisioningOptions': [],\n    'securityEnabled': True,\n    'securityIdentifier': 'S-1-12-1-680551520-1134470812-197642884-1433859052',\n    'theme': None,\n    'visibility': 'Public'\n}\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_group(\n    self, name: str, security_enabled: bool = False, mail_enabled: bool = True\n) -&gt; dict | None:\n    \"\"\"Add a M365 Group.\n\n    Args:\n        name (str): name of the group\n        security_enabled (bool, optional): whether or not this group is used for permission management\n        mail_enabled (bool, optional): whether or not this group is email enabled\n    Returns:\n        dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups/$entity',\n            'id': '28906460-a69c-439e-84ca-c70becf37655',\n            'deletedDateTime': None,\n            'classification': None,\n            'createdDateTime': '2023-04-01T11:40:13Z',\n            'creationOptions': [],\n            'description': None,\n            'displayName': 'Test',\n            'expirationDateTime': None,\n            'groupTypes': ['Unified'],\n            'isAssignableToRole': None,\n            'mail': 'Diefenbruch@M365x61936377.onmicrosoft.com',\n            'mailEnabled': True,\n            'mailNickname': 'Test',\n            'membershipRule': None,\n            'membershipRuleProcessingState': None,\n            'onPremisesDomainName': None,\n            'onPremisesLastSyncDateTime': None,\n            'onPremisesNetBiosName': None,\n            'onPremisesSamAccountName': None,\n            'onPremisesSecurityIdentifier': None,\n            'onPremisesSyncEnabled': None,\n            'onPremisesProvisioningErrors': [],\n            'preferredDataLocation': None,\n            'preferredLanguage': None,\n            'proxyAddresses': ['SMTP:Test@M365x61936377.onmicrosoft.com'],\n            'renewedDateTime': '2023-04-01T11:40:13Z',\n            'resourceBehaviorOptions': [],\n            'resourceProvisioningOptions': [],\n            'securityEnabled': True,\n            'securityIdentifier': 'S-1-12-1-680551520-1134470812-197642884-1433859052',\n            'theme': None,\n            'visibility': 'Public'\n        }\n    \"\"\"\n\n    group_post_body = {\n        \"displayName\": name,\n        \"mailEnabled\": mail_enabled,\n        \"mailNickname\": name.replace(\" \", \"\"),\n        \"securityEnabled\": security_enabled,\n        \"groupTypes\": [\"Unified\"],\n    }\n\n    request_url = self.config()[\"groupsUrl\"]\n    request_header = self.request_header()\n\n    logger.info(\"Adding M365 group -&gt; %s; calling -&gt; %s\", name, request_url)\n    logger.debug(\"M365 group attributes -&gt; %s\", group_post_body)\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            data=json.dumps(group_post_body),\n            headers=request_header,\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_group_member","title":"<code>add_group_member(group_id, member_id)</code>","text":"<p>Add a member (user or group) to a (parent) group</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>M365 GUID of the group</p> required <code>member_id</code> <code>str</code> <p>M365 GUID of the new member</p> required <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_group_member(self, group_id: str, member_id: str) -&gt; dict | None:\n    \"\"\"Add a member (user or group) to a (parent) group\n\n    Args:\n        group_id (str): M365 GUID of the group\n        member_id (str): M365 GUID of the new member\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    request_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members/$ref\"\n    request_header = self.request_header()\n\n    group_member_post_body = {\n        \"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + member_id\n    }\n\n    logger.info(\n        \"Adding member -&gt; %s to group -&gt; %s; calling -&gt; %s\",\n        member_id,\n        group_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(group_member_post_body),\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n\n        # Check if Session has expired - then re-authenticate and try once more\n        if response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add member -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                member_id,\n                group_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_group_owner","title":"<code>add_group_owner(group_id, owner_id)</code>","text":"<p>Add an owner (user) to a group</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>M365 GUID of the group</p> required <code>owner_id</code> <code>str</code> <p>M365 GUID of the new member</p> required <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_group_owner(self, group_id: str, owner_id: str) -&gt; dict | None:\n    \"\"\"Add an owner (user) to a group\n\n    Args:\n        group_id (str): M365 GUID of the group\n        owner_id (str): M365 GUID of the new member\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    request_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners/$ref\"\n    request_header = self.request_header()\n\n    group_member_post_body = {\n        \"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + owner_id\n    }\n\n    logger.info(\n        \"Adding owner -&gt; %s to M365 group -&gt; %s; calling -&gt; %s\",\n        owner_id,\n        group_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(group_member_post_body),\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add owner -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                owner_id,\n                group_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_sensitivity_label","title":"<code>add_sensitivity_label(name, display_name, description='', color='red', enabled=True, admin_description='', user_description='', enable_encryption=False, enable_marking=False)</code>","text":"<p>Create a new sensitivity label in M365     THIS IS CURRENTLY NOT WORKING!</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the label</p> required <code>display_name</code> <code>str</code> <p>display name of the label</p> required <code>description</code> <code>str</code> <p>Description of the label. Defaults to \"\".</p> <code>''</code> <code>color</code> <code>str</code> <p>Color of the label. Defaults to \"red\".</p> <code>'red'</code> <code>enabled</code> <code>bool</code> <p>Whether this label is enabled. Defaults to True.</p> <code>True</code> <code>admin_description</code> <code>str</code> <p>Description for administrators. Defaults to \"\".</p> <code>''</code> <code>user_description</code> <code>str</code> <p>Description for users. Defaults to \"\".</p> <code>''</code> <code>enable_encryption</code> <code>bool</code> <p>Enable encryption. Defaults to False.</p> <code>False</code> <code>enable_marking</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>Request reponse or None if the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_sensitivity_label(\n    self,\n    name: str,\n    display_name: str,\n    description: str = \"\",\n    color: str = \"red\",\n    enabled: bool = True,\n    admin_description: str = \"\",\n    user_description: str = \"\",\n    enable_encryption: bool = False,\n    enable_marking: bool = False,\n):\n    \"\"\"Create a new sensitivity label in M365\n        THIS IS CURRENTLY NOT WORKING!\n\n    Args:\n        name (str): name of the label\n        display_name (str): display name of the label\n        description (str, optional): Description of the label. Defaults to \"\".\n        color (str, optional): Color of the label. Defaults to \"red\".\n        enabled (bool, optional): Whether this label is enabled. Defaults to True.\n        admin_description (str, optional): Description for administrators. Defaults to \"\".\n        user_description (str, optional): Description for users. Defaults to \"\".\n        enable_encryption (bool, optional): Enable encryption. Defaults to False.\n        enable_marking (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        Request reponse or None if the request fails.\n    \"\"\"\n\n    # Prepare the request body\n    payload = {\n        \"displayName\": display_name,\n        \"description\": description,\n        \"isEnabled\": enabled,\n        \"labelColor\": color,\n        \"adminDescription\": admin_description,\n        \"userDescription\": user_description,\n        \"encryptContent\": enable_encryption,\n        \"contentMarking\": enable_marking,\n    }\n\n    request_url = self.config()[\"securityUrl\"] + \"/sensitivityLabels\"\n    request_header = self.request_header()\n\n    logger.info(\n        \"Create M365 sensitivity label -&gt; %s; calling -&gt; %s\", name, request_url\n    )\n\n    # Send the POST request to create the label\n    response = requests.post(\n        request_url, headers=request_header, data=json.dumps(payload), timeout=60\n    )\n\n    # Check the response status code\n    if response.status_code == 201:\n        logger.info(\"Label -&gt; %s has been created successfully!\", name)\n        return response\n    else:\n        logger.error(\n            \"Failed to create the M365 label -&gt; %s! Response status code -&gt; %s\",\n            name,\n            response.status_code,\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_team","title":"<code>add_team(name, template_name='standard')</code>","text":"<p>Add M365 Team based on an existing M365 Group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the team. It is assumed that a group with the same name does already exist!</p> required <code>template_name</code> <code>str</code> <p>name of the team template. \"standard\" is the default value.</p> <code>'standard'</code> <p>Returns:     dict: Team information (json - empty text!) or None if the team couldn't be created           (e.g. because it exisits already).</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_team(self, name: str, template_name: str = \"standard\") -&gt; dict | None:\n    \"\"\"Add M365 Team based on an existing M365 Group.\n\n    Args:\n        name (str): name of the team. It is assumed that a group with the same name does already exist!\n        template_name (str, optional): name of the team template. \"standard\" is the default value.\n    Returns:\n        dict: Team information (json - empty text!) or None if the team couldn't be created\n              (e.g. because it exisits already).\n    \"\"\"\n\n    response = self.get_group(name)\n    group_id = self.get_result_value(response, \"id\", 0)\n    if not group_id:\n        logger.error(\n            \"M365 Group -&gt; %s not found. It is required for creating a corresponding M365 Team.\",\n            name,\n        )\n        return None\n\n    response = self.get_group_owners(name)\n    if response is None or not \"value\" in response or not response[\"value\"]:\n        logger.warning(\n            \"M365 Group -&gt; %s has no owners. This is required for creating a corresponding M365 Team.\",\n            name,\n        )\n        return None\n\n    team_post_body = {\n        \"template@odata.bind\": \"{}('{}')\".format(\n            self.config()[\"teamsTemplatesUrl\"], template_name\n        ),\n        \"group@odata.bind\": \"{}('{}')\".format(self.config()[\"groupsUrl\"], group_id),\n    }\n\n    request_url = self.config()[\"teamsUrl\"]\n    request_header = self.request_header()\n\n    logger.info(\"Adding M365 Team -&gt; %s; calling -&gt; %s\", name, request_url)\n    logger.debug(\"M365 Team attributes -&gt; %s\", team_post_body)\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            data=json.dumps(team_post_body),\n            headers=request_header,\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_teams_app_to_channel","title":"<code>add_teams_app_to_channel(team_name, channel_name, app_id, tab_name, app_url, cs_node_id)</code>","text":"<p>Add tab for Extended ECM app to an M365 Team channel</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <code>app_id</code> <code>str</code> <p>ID of the MS Teams Application (e.g. the Extended ECM Teams App)</p> required <code>tab_name</code> <code>str</code> <p>name of the tab</p> required <code>cs_node_id</code> <code>int</code> <p>node ID of the target workspace or container in Extended ECM</p> required <p>Returns:     dict: return data structure (dictionary) or None if the request fails.</p> <pre><code>Example return data:\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_teams_app_to_channel(\n    self,\n    team_name: str,\n    channel_name: str,\n    app_id: str,\n    tab_name: str,\n    app_url: str,\n    cs_node_id: int,\n) -&gt; dict | None:\n    \"\"\"Add tab for Extended ECM app to an M365 Team channel\n\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n        app_id (str): ID of the MS Teams Application (e.g. the Extended ECM Teams App)\n        tab_name (str): name of the tab\n        app_url (str) web URL of the app\n        cs_node_id (int): node ID of the target workspace or container in Extended ECM\n    Returns:\n        dict: return data structure (dictionary) or None if the request fails.\n\n        Example return data:\n\n    \"\"\"\n\n    response = self.get_team(team_name)\n    team_id = self.get_result_value(response, \"id\", 0)\n    if not team_id:\n        return None\n\n    # Get the channels of the M365 Team:\n    response = self.get_team_channels(team_name)\n    if not response or not response[\"value\"] or not response[\"value\"][0]:\n        return None\n\n    # Look the channel by name and then retrieve its ID:\n    channel = next(\n        (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n        None,\n    )\n    if not channel:\n        logger.erro(\n            \"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n        )\n        return None\n    channel_id = channel[\"id\"]\n\n    request_url = (\n        self.config()[\"teamsUrl\"]\n        + \"/\"\n        + str(team_id)\n        + \"/channels/\"\n        + str(channel_id)\n        + \"/tabs\"\n    )\n\n    request_header = self.request_header()\n\n    # Create tab configuration payload:\n    tab_config = {\n        \"teamsApp@odata.bind\": f\"https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/{app_id}\",\n        \"displayName\": tab_name,\n        \"configuration\": {\n            \"entityId\": cs_node_id,  # Unique identifier for the tab\n            \"contentUrl\": app_url,\n            \"removeUrl\": \"\",\n            \"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n        },\n    }\n\n    logger.info(\n        \"Add Tab -&gt; %s with App ID -&gt; %s to Channel -&gt; %s of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\n        tab_name,\n        app_id,\n        channel_name,\n        team_name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url, headers=request_header, json=tab_config, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Tab for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s; tab config -&gt; %s\",\n                team_name,\n                team_id,\n                channel_name,\n                channel_id,\n                response.status_code,\n                response.text,\n                str(tab_config),\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_user","title":"<code>add_user(email, password, first_name, last_name, location='US', department='', company_name='Innovate')</code>","text":"<p>Add a M365 user.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>email address of the user. This is also the unique identifier</p> required <code>password</code> <code>str</code> <p>password of the user</p> required <code>first_name</code> <code>str</code> <p>first name of the user</p> required <code>last_name</code> <code>str</code> <p>last name of the user</p> required <code>location</code> <code>str</code> <p>country ISO 3166-1 alpha-2 format (e.g. US, CA, FR, DE, CN, ...)</p> <code>'US'</code> <code>department</code> <code>str</code> <p>department of the user</p> <code>''</code> <code>company_name</code> <code>str</code> <p>name of the company</p> <code>'Innovate'</code> <p>Returns:     dict: User information or None if the user couldn't be created (e.g. because it exisits already           or if a permission problem occurs).</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_user(\n    self,\n    email: str,\n    password: str,\n    first_name: str,\n    last_name: str,\n    location: str = \"US\",\n    department: str = \"\",\n    company_name: str = \"Innovate\",\n) -&gt; dict | None:\n    \"\"\"Add a M365 user.\n\n    Args:\n        email (str): email address of the user. This is also the unique identifier\n        password (str): password of the user\n        first_name (str): first name of the user\n        last_name (str): last name of the user\n        location (str, optional): country ISO 3166-1 alpha-2 format (e.g. US, CA, FR, DE, CN, ...)\n        department (str, optional): department of the user\n        company_name (str): name of the company\n    Returns:\n        dict: User information or None if the user couldn't be created (e.g. because it exisits already\n              or if a permission problem occurs).\n    \"\"\"\n\n    user_post_body = {\n        \"accountEnabled\": True,\n        \"displayName\": first_name + \" \" + last_name,\n        \"givenName\": first_name,\n        \"surname\": last_name,\n        \"mailNickname\": email.split(\"@\")[0],\n        \"userPrincipalName\": email,\n        \"passwordProfile\": {\n            \"forceChangePasswordNextSignIn\": False,\n            \"password\": password,\n        },\n        \"usageLocation\": location,\n    }\n    if department:\n        user_post_body[\"department\"] = department\n    if company_name:\n        user_post_body[\"companyName\"] = company_name\n\n    request_url = self.config()[\"usersUrl\"]\n    request_header = self.request_header()\n\n    logger.info(\"Adding M365 user -&gt; %s; calling -&gt; %s\", email, request_url)\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            data=json.dumps(user_post_body),\n            headers=request_header,\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                email,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_license_to_user","title":"<code>assign_license_to_user(user_id, sku_id)</code>","text":"<p>Add an M365 license to a user (e.g. to use Office 365)</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>sku_id</code> <code>str</code> <p>M365 GUID of the SKU           (e.g. c7df2760-2c81-4ef7-b578-5b5392b571df for E5 and                 6fd2c87f-b296-42f0-b197-1e91e994b900 for E3)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response or None if request fails</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_license_to_user(self, user_id: str, sku_id: str) -&gt; dict | None:\n    \"\"\"Add an M365 license to a user (e.g. to use Office 365)\n\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        sku_id (str): M365 GUID of the SKU\n                      (e.g. c7df2760-2c81-4ef7-b578-5b5392b571df for E5 and\n                            6fd2c87f-b296-42f0-b197-1e91e994b900 for E3)\n\n    Returns:\n        dict: response or None if request fails\n    \"\"\"\n\n    request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/assignLicense\"\n    request_header = self.request_header()\n\n    # Construct the request body for assigning the E5 license\n    license_post_body = {\n        \"addLicenses\": [\n            {\n                \"disabledPlans\": [],\n                \"skuId\": sku_id,  # \"c42b9cae-ea4f-4a69-9ca5-c53bd8779c42\"\n            }\n        ],\n        \"removeLicenses\": [],\n    }\n\n    logger.info(\n        \"Assign M365 license -&gt; %s to M365 user -&gt; %s; calling -&gt; %s\",\n        sku_id,\n        user_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url, json=license_post_body, headers=request_header, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add M365 license -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                sku_id,\n                user_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_sensitivity_label_to_user","title":"<code>assign_sensitivity_label_to_user(user_email, label_name)</code>","text":"<p>Assigns a existing sensitivity label to a user.     THIS IS CURRENTLY NOT WORKING!</p> <p>Parameters:</p> Name Type Description Default <code>user_email</code> <code>str</code> <p>email address of the user (as unique identifier)</p> required <code>label_name</code> <code>str</code> <p>name of the label (need to exist)</p> required <p>Returns:</p> Type Description <p>Return the request response or None if the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_sensitivity_label_to_user(self, user_email: str, label_name: str):\n    \"\"\"Assigns a existing sensitivity label to a user.\n        THIS IS CURRENTLY NOT WORKING!\n\n    Args:\n        user_email (str): email address of the user (as unique identifier)\n        label_name (str): name of the label (need to exist)\n\n    Returns:\n        Return the request response or None if the request fails.\n    \"\"\"\n\n    # Set up the request body with the label name\n    body = {\"labelName\": label_name}\n\n    request_url = (\n        self.config()[\"usersUrl\"] + \"/\" + user_email + \"/assignSensitivityLabels\"\n    )\n    request_header = self.request_header()\n\n    logger.info(\n        \"Assign label -&gt; %s to user -&gt; %s; calling -&gt; %s\",\n        label_name,\n        user_email,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url, headers=request_header, json=body, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign label -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                label_name,\n                user_email,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_teams_app_to_team","title":"<code>assign_teams_app_to_team(team_id, app_id)</code>","text":"<p>Assign (add) a MS Teams app to a M365 team    (so that it afterwards can be added as a Tab in a M365 Teams Channel)</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>ID of the Microsoft 365 Team</p> required <code>app_id</code> <code>str</code> <p>ID of the M365 Team App</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: API response or None if the Graph API call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_teams_app_to_team(self, team_id: str, app_id: str) -&gt; dict | None:\n    \"\"\"Assign (add) a MS Teams app to a M365 team\n       (so that it afterwards can be added as a Tab in a M365 Teams Channel)\n\n    Args:\n        team_id (str): ID of the Microsoft 365 Team\n        app_id (str): ID of the M365 Team App\n\n    Returns:\n        dict | None: API response or None if the Graph API call fails.\n    \"\"\"\n\n    request_url = self.config()[\"teamsUrl\"] + \"/\" + team_id + \"/installedApps\"\n    request_header = self.request_header()\n\n    post_body = {\n        \"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n    }\n\n    logger.info(\n        \"Assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; calling -&gt; %s\",\n        app_id,\n        team_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url, json=post_body, headers=request_header, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                app_id,\n                team_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_teams_app_to_user","title":"<code>assign_teams_app_to_user(user_id, app_name)</code>","text":"<p>Assigns (adds) a M365 Teams app to a M365 user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>app_name</code> <code>str</code> <p>exact name of the app</p> required <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_teams_app_to_user(self, user_id: str, app_name: str) -&gt; dict | None:\n    \"\"\"Assigns (adds) a M365 Teams app to a M365 user.\n\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        app_name (str): exact name of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    response = self.get_teams_apps(f\"contains(displayName, '{app_name}')\")\n    app_id = self.get_result_value(response, \"id\", 0)\n    if not app_id:\n        logger.error(\"M365 Teams App -&gt; %s not found!\", app_name)\n        return None\n\n    request_url = (\n        self.config()[\"usersUrl\"] + \"/\" + user_id + \"/teamwork/installedApps\"\n    )\n    request_header = self.request_header()\n\n    post_body = {\n        \"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n    }\n\n    logger.info(\n        \"Assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; calling -&gt; %s\",\n        app_name,\n        app_id,\n        user_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url, json=post_body, headers=request_header, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                app_name,\n                app_id,\n                user_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticate at M365 Graph API with client ID and client secret.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determinse if a re-athentication is enforced                          (e.g. if session has timed out with 401 error)</p> <code>False</code> <p>Returns:     str: Access token. Also stores access token in self._access_token. None in case of error</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; str | None:\n    \"\"\"Authenticate at M365 Graph API with client ID and client secret.\n\n    Args:\n        revalidate (bool, optional): determinse if a re-athentication is enforced\n                                     (e.g. if session has timed out with 401 error)\n    Returns:\n        str: Access token. Also stores access token in self._access_token. None in case of error\n    \"\"\"\n\n    # Already authenticated and session still valid?\n    if self._access_token and not revalidate:\n        logger.info(\n            \"Session still valid - return existing access token -&gt; %s\",\n            str(self._access_token),\n        )\n        return self._access_token\n\n    request_url = self.config()[\"authenticationUrl\"]\n    request_header = request_login_headers\n\n    logger.info(\"Requesting M365 Access Token from -&gt; %s\", request_url)\n\n    authenticate_post_body = self.credentials()\n    authenticate_response = None\n\n    try:\n        authenticate_response = requests.post(\n            request_url,\n            data=authenticate_post_body,\n            headers=request_header,\n            timeout=60,\n        )\n    except requests.exceptions.ConnectionError as exception:\n        logger.warning(\n            \"Unable to connect to -&gt; %s : %s\",\n            self.config()[\"authenticationUrl\"],\n            exception,\n        )\n        return None\n\n    if authenticate_response.ok:\n        authenticate_dict = self.parse_request_response(authenticate_response)\n        if not authenticate_dict:\n            return None\n        else:\n            access_token = authenticate_dict[\"access_token\"]\n            logger.debug(\"Access Token -&gt; %s\", access_token)\n    else:\n        logger.error(\n            \"Failed to request an M365 Access Token; error -&gt; %s\",\n            authenticate_response.text,\n        )\n        return None\n\n    # Store authentication access_token:\n    self._access_token = access_token\n\n    return self._access_token\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.authenticate_user","title":"<code>authenticate_user(username, password)</code>","text":"<p>Authenticate at M365 Graph API with username and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>name (emails) of the M365 user</p> required <code>password</code> <code>str</code> <p>password of the M365 user</p> required <p>Returns:     str: Access token. Also stores access token in self._access_token</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def authenticate_user(self, username: str, password: str) -&gt; str | None:\n    \"\"\"Authenticate at M365 Graph API with username and password.\n\n    Args:\n        username (str): name (emails) of the M365 user\n        password (str): password of the M365 user\n    Returns:\n        str: Access token. Also stores access token in self._access_token\n    \"\"\"\n\n    request_url = self.config()[\"authenticationUrl\"]\n    request_header = request_login_headers\n\n    logger.info(\n        \"Requesting M365 Access Token for user -&gt; %s from -&gt; %s\",\n        username,\n        request_url,\n    )\n\n    authenticate_post_body = self.credentials_user(username, password)\n    authenticate_response = None\n\n    try:\n        authenticate_response = requests.post(\n            request_url,\n            data=authenticate_post_body,\n            headers=request_header,\n            timeout=60,\n        )\n    except requests.exceptions.ConnectionError as exception:\n        logger.warning(\n            \"Unable to connect to -&gt; %s with username -&gt; %s: %s\",\n            self.config()[\"authenticationUrl\"],\n            username,\n            exception,\n        )\n        return None\n\n    if authenticate_response.ok:\n        authenticate_dict = self.parse_request_response(authenticate_response)\n        if not authenticate_dict:\n            return None\n        access_token = authenticate_dict[\"access_token\"]\n        logger.debug(\"User Access Token -&gt; %s\", access_token)\n    else:\n        logger.error(\n            \"Failed to request an M365 Access Token for user -&gt; %s; error -&gt; %s\",\n            username,\n            authenticate_response.text,\n        )\n        return None\n\n    # Store authentication access_token:\n    self._user_access_token = access_token\n\n    return self._user_access_token\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Returns the configuration dictionary\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    return self._config\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.credentials","title":"<code>credentials()</code>","text":"<p>Return the login credentials</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with login credentials for M365</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def credentials(self) -&gt; dict:\n    \"\"\"Return the login credentials\n\n    Returns:\n        dict: dictionary with login credentials for M365\n    \"\"\"\n    return self.config()[\"tokenData\"]\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.credentials_user","title":"<code>credentials_user(username, password)</code>","text":"<p>In some cases MS Graph APIs cannot be called via     application permissions (client_id, client_secret)     but requires a token of a user authenticated     with username + password. This is e.g. the case     to upload a MS teams app to the catalog.     See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>username</p> required <code>password</code> <code>str</code> <p>password</p> required <p>Returns:     dict: user credentials for M365</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def credentials_user(self, username: str, password: str) -&gt; dict:\n    \"\"\"In some cases MS Graph APIs cannot be called via\n        application permissions (client_id, client_secret)\n        but requires a token of a user authenticated\n        with username + password. This is e.g. the case\n        to upload a MS teams app to the catalog.\n        See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n\n    Args:\n        username (str): username\n        password (str): password\n    Returns:\n        dict: user credentials for M365\n    \"\"\"\n\n    credentials = {\n        \"client_id\": self.config()[\"clientId\"],\n        \"scope\": \"https://graph.microsoft.com/.default\",\n        \"client_secret\": self.config()[\"clientSecret\"],\n        \"grant_type\": \"password\",\n        \"username\": username,\n        \"password\": password,\n    }\n    return credentials\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_all_teams","title":"<code>delete_all_teams(exception_list, pattern_list)</code>","text":"<p>Delete all teams (groups) that are NOT on the exception list AND    that are matching at least one of the patterns in the provided pattern list.    This method is used for general cleanup of teams. Be aware that deleted teams    are still listed under https://admin.microsoft.com/#/deletedgroups</p> <p>Parameters:</p> Name Type Description Default <code>exception_list</code> <code>list</code> <p>list of group names that should not be deleted</p> required <code>pattern_list</code> <code>list</code> <p>list of patterns for group names to be deleted                  (regular expression)</p> required <p>Returns:     bool: True if teams have been deleted, False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_all_teams(self, exception_list: list, pattern_list: list) -&gt; bool:\n    \"\"\"Delete all teams (groups) that are NOT on the exception list AND\n       that are matching at least one of the patterns in the provided pattern list.\n       This method is used for general cleanup of teams. Be aware that deleted teams\n       are still listed under https://admin.microsoft.com/#/deletedgroups\n\n    Args:\n        exception_list (list): list of group names that should not be deleted\n        pattern_list (list): list of patterns for group names to be deleted\n                             (regular expression)\n    Returns:\n        bool: True if teams have been deleted, False otherwise.\n    \"\"\"\n\n    # Get list of all existing M365 groups/teams:\n    response = self.get_groups(max_number=500)\n    if not \"value\" in response or not response[\"value\"]:\n        return False\n    groups = response[\"value\"]\n    logger.info(\n        \"Found -&gt; %s existing M365 groups. Checking which ones should be deleted...\",\n        len(groups),\n    )\n\n    # Process all groups and check if the&lt; should be\n    # deleted:\n    for group in groups:\n        group_name = group[\"displayName\"]\n        # Check if group is in exception list:\n        if group_name in exception_list:\n            logger.info(\n                \"M365 Group name -&gt; %s is on the exception list. Skipping...\",\n                group_name,\n            )\n            continue\n        # Check that at least one pattern is found that matches the group:\n        for pattern in pattern_list:\n            result = re.search(pattern, group_name)\n            if result:\n                logger.info(\n                    \"M365 Group name -&gt; %s is matching pattern -&gt; %s. Delete it now...\",\n                    group_name,\n                    pattern,\n                )\n                self.delete_teams(group_name)\n                break\n        else:\n            logger.info(\n                \"M365 Group name -&gt; %s is not matching any delete pattern. Skipping...\",\n                group_name,\n            )\n    return True\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_team","title":"<code>delete_team(team_id)</code>","text":"<p>Delete Microsoft 365 Team with a specific ID.</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>ID of the Microsoft 365 Team to delete</p> required <p>Returns:     dict | None: Response dictionary if the team has been deleted, False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_team(self, team_id: str) -&gt; dict | None:\n    \"\"\"Delete Microsoft 365 Team with a specific ID.\n\n    Args:\n        team_id (str): ID of the Microsoft 365 Team to delete\n    Returns:\n        dict | None: Response dictionary if the team has been deleted, False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"groupsUrl\"] + \"/\" + team_id\n\n    request_header = self.request_header()\n\n    logger.info(\n        \"Delete Microsoft 365 Teams with ID -&gt; %s; calling -&gt; %s\",\n        team_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.delete(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\"Failed to delete M365 Team with ID -&gt; %s\", team_id)\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_teams","title":"<code>delete_teams(name)</code>","text":"<p>Delete Microsoft 365 Teams with a specific name. Microsoft 365 allows     to have multiple teams with the same name. So this method may delete     multiple teams if the have the same name. The Graph API we use here     is the M365 Group API as deleting the group also deletes the associated team.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Microsoft 365 Team</p> required <p>Returns:     bool: True if teams have been deleted, False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_teams(self, name: str) -&gt; bool:\n    \"\"\"Delete Microsoft 365 Teams with a specific name. Microsoft 365 allows\n        to have multiple teams with the same name. So this method may delete\n        multiple teams if the have the same name. The Graph API we use here\n        is the M365 Group API as deleting the group also deletes the associated team.\n\n    Args:\n        name (str): name of the Microsoft 365 Team\n    Returns:\n        bool: True if teams have been deleted, False otherwise.\n    \"\"\"\n\n    # We need a special handling of team names with single quotes:\n    escaped_group_name = name.replace(\"'\", \"''\")\n    encoded_group_name = quote(escaped_group_name, safe=\"\")\n    request_url = self.config()[\n        \"groupsUrl\"\n    ] + \"?$filter=displayName eq '{}'\".format(encoded_group_name)\n\n    request_header = self.request_header()\n\n    logger.info(\n        \"Delete all Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\n        name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            existing_teams = self.parse_request_response(response)\n            break\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of M365 Teams to delete; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            existing_teams = None\n            break\n\n    if existing_teams:\n        data = existing_teams.get(\"value\")\n        if data:\n            counter = 0\n            for team in data:\n                team_id = team.get(\"id\")\n                response = self.delete_team(team_id)\n\n                if not response:\n                    logger.error(\n                        \"Failed to delete M365 Team -&gt; %s (%s)\", name, team_id\n                    )\n                    continue\n                counter += 1\n\n            logger.info(\n                \"%s M365 Teams with name -&gt; %s have been deleted.\",\n                str(counter),\n                name,\n            )\n            return True\n        else:\n            logger.info(\"No M365 Teams with name -&gt; %s found.\", name)\n            return False\n    else:\n        logger.error(\"Failed to retrieve M365 Teams with name -&gt; %s\", name)\n        return False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_teams_app_from_channel","title":"<code>delete_teams_app_from_channel(team_name, channel_name, tab_name)</code>","text":"<p>Delete an existing tab for Extended ECM app from an M365 Team channel</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <code>tab_name</code> <code>str</code> <p>name of the tab</p> required <p>Returns:     bool: True = success, False = Error.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_teams_app_from_channel(\n    self,\n    team_name: str,\n    channel_name: str,\n    tab_name: str,\n) -&gt; bool:\n    \"\"\"Delete an existing tab for Extended ECM app from an M365 Team channel\n\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n        tab_name (str): name of the tab\n    Returns:\n        bool: True = success, False = Error.\n    \"\"\"\n\n    response = self.get_team(team_name)\n    team_id = self.get_result_value(response, \"id\", 0)\n    if not team_id:\n        return False\n\n    # Get the channels of the M365 Team:\n    response = self.get_team_channels(team_name)\n    if not response or not response[\"value\"] or not response[\"value\"][0]:\n        return False\n\n    # Look the channel by name and then retrieve its ID:\n    channel = next(\n        (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n        None,\n    )\n    if not channel:\n        logger.erro(\n            \"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n        )\n        return False\n    channel_id = channel[\"id\"]\n\n    # Get the tabs of the M365 Team channel:\n    response = self.get_team_channel_tabs(team_name, channel_name)\n    if not response or not response[\"value\"] or not response[\"value\"][0]:\n        return False\n\n    # Lookup the tabs by name and then retrieve their IDs (in worst case it can\n    # be multiple tabs / apps with same name if former cleanups did not work):\n    tab_list = [\n        item for item in response[\"value\"] if item[\"displayName\"] == tab_name\n    ]\n    if not tab_list:\n        logger.erro(\n            \"Cannot find Tabs with name -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\n            tab_name,\n            team_name,\n            team_id,\n            channel_name,\n            channel_id,\n        )\n        return False\n\n    for tab in tab_list:\n        tab_id = tab[\"id\"]\n\n        request_url = (\n            self.config()[\"teamsUrl\"]\n            + \"/\"\n            + str(team_id)\n            + \"/channels/\"\n            + str(channel_id)\n            + \"/tabs/\"\n            + str(tab_id)\n        )\n\n        request_header = self.request_header()\n\n        logger.info(\n            \"Delete Tab -&gt; %s (%s) from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s); calling -&gt; %s\",\n            tab_name,\n            tab_id,\n            channel_name,\n            channel_id,\n            team_name,\n            team_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.delete(\n                request_url, headers=request_header, timeout=60\n            )\n            if response.ok:\n                logger.info(\n                    \"Tab -&gt; %s (%s) has been deleted from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s)\",\n                    tab_name,\n                    tab_id,\n                    channel_name,\n                    channel_id,\n                    team_name,\n                    team_id,\n                )\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            elif response.status_code in [502, 503, 504] and retries &lt; 3:\n                logger.warning(\n                    \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                    response.status_code,\n                    (retries + 1) * 60,\n                )\n                time.sleep((retries + 1) * 60)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to delete Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                    tab_name,\n                    tab_id,\n                    team_name,\n                    team_id,\n                    channel_name,\n                    channel_id,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n    return True\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.exist_result_item","title":"<code>exist_result_item(response, key, value, sub_dict_name='')</code>","text":"<p>Check existence of key / value pair in the response properties of an MS Graph API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an MS Graph REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>value</code> <code>str</code> <p>value to find in the item with the matching key</p> required <code>sub_dict_name</code> <code>str</code> <p>some MS Graph API calls include nested                  dict structures that can be requested                  with an \"expand\" query parameter. In such                  a case we use the sub_dict_name to access it.</p> <code>''</code> <p>Returns:     bool: True if the value was found, False otherwise</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def exist_result_item(\n    self, response: dict, key: str, value: str, sub_dict_name: str = \"\"\n) -&gt; bool:\n    \"\"\"Check existence of key / value pair in the response properties of an MS Graph API call.\n\n    Args:\n        response (dict): REST response from an MS Graph REST Call\n        key (str): property name (key)\n        value (str): value to find in the item with the matching key\n        sub_dict_name (str): some MS Graph API calls include nested\n                             dict structures that can be requested\n                             with an \"expand\" query parameter. In such\n                             a case we use the sub_dict_name to access it.\n    Returns:\n        bool: True if the value was found, False otherwise\n    \"\"\"\n\n    if not response:\n        return False\n    if not \"value\" in response:\n        return False\n\n    values = response[\"value\"]\n    if not values or not isinstance(values, list):\n        return False\n\n    if not sub_dict_name:\n        for item in values:\n            if value == item[key]:\n                return True\n    else:\n        for item in values:\n            if not sub_dict_name in item:\n                return False\n            if value == item[sub_dict_name][key]:\n                return True\n    return False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.extract_version_from_app_manifest","title":"<code>extract_version_from_app_manifest(app_path)</code>","text":"<p>Extract the version number from the MS Teams app manifest file.    This can be used to check if the app package includes a newer    app version then the already installed one.</p> <p>Parameters:</p> Name Type Description Default <code>app_path</code> <code>str</code> <p>file path (with directory) to the app package to extract             the version from</p> required <p>Returns:     str: version number or None in case of an error</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def extract_version_from_app_manifest(self, app_path: str) -&gt; str | None:\n    \"\"\"Extract the version number from the MS Teams app manifest file.\n       This can be used to check if the app package includes a newer\n       app version then the already installed one.\n\n    Args:\n        app_path (str): file path (with directory) to the app package to extract\n                        the version from\n    Returns:\n        str: version number or None in case of an error\n    \"\"\"\n\n    with zipfile.ZipFile(app_path, \"r\") as zip_ref:\n        manifest_data = zip_ref.read(\"manifest.json\")\n        manifest_json = json.loads(manifest_data)\n        version = manifest_json.get(\"version\")\n\n        return version\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_app_registration","title":"<code>get_app_registration(app_registration_name)</code>","text":"<p>Find an Azure App Registration based on its name</p> <p>Parameters:</p> Name Type Description Default <code>app_registration_name</code> <code>str</code> <p>name of the App Registration</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>App Registration data or None of the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_app_registration(\n    self,\n    app_registration_name: str,\n) -&gt; dict:\n    \"\"\"Find an Azure App Registration based on its name\n\n    Args:\n        app_registration_name (str): name of the App Registration\n\n    Returns:\n        dict: App Registration data or None of the request fails.\n    \"\"\"\n\n    request_url = self.config()[\n        \"applicationsUrl\"\n    ] + \"?$filter=displayName eq '{}'\".format(app_registration_name)\n    request_header = self.request_header()\n\n    logger.info(\n        \"Get Azure App Registration -&gt; %s; calling -&gt; %s\",\n        app_registration_name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Cannot find Azure App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                app_registration_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_group","title":"<code>get_group(group_name, show_error=False)</code>","text":"<p>Get a M365 Group based on its name</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>M365 Group name</p> required <code>show_error</code> <code>bool</code> <p>should an error be logged if group is not found.</p> <code>False</code> <p>Returns:     dict: Group information or None if the group doesn't exist.</p> <pre><code>Example return data:\n{\n    '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups',\n    'value': [\n        {\n            'id': 'b65f7dba-3ed1-49df-91bf-2bf99affcc8d',\n            'deletedDateTime': None,\n            'classification': None,\n            'createdDateTime': '2023-04-01T13:46:26Z',\n            'creationOptions': [],\n            'description': 'Engineering &amp; Construction',\n            'displayName': 'Engineering &amp; Construction',\n            'expirationDateTime': None,\n            'groupTypes': ['Unified'],\n            'isAssignableToRole': None,\n            'mail': 'Engineering&amp;Construction@M365x61936377.onmicrosoft.com',\n            'mailEnabled': True,\n            'mailNickname': 'Engineering&amp;Construction',\n            'membershipRule': None,\n            'membershipRuleProcessingState': None,\n            'onPremisesDomainName': None,\n            'onPremisesLastSyncDateTime': None,\n            'onPremisesNetBiosName': None,\n            'onPremisesSamAccountName': None,\n            'onPremisesSecurityIdentifier': None,\n            'onPremisesSyncEnabled': None,\n            'preferredDataLocation': None,\n            'preferredLanguage': None,\n            'proxyAddresses': ['SPO:SPO_d9deb3e7-c72f-4e8d-80fb-5d9411ca1458@SPO_604f34f0-ba72-4321-ab6b-e36ae8bd00ec', 'SMTP:Engineering&amp;Construction@M365x61936377.onmicrosoft.com'],\n            'renewedDateTime': '2023-04-01T13:46:26Z',\n            'resourceBehaviorOptions': [],\n            'resourceProvisioningOptions': [],\n            'securityEnabled': False,\n            'securityIdentifier': 'S-1-12-1-3059711418-1239367377-4180393873-2379022234',\n            'theme': None,\n            'visibility': 'Public',\n            'onPremisesProvisioningErrors': []\n        },\n        {\n            'id': '61359860-302e-4016-b5cc-abff2293dff1',\n            ...\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_group(self, group_name: str, show_error: bool = False) -&gt; dict | None:\n    \"\"\"Get a M365 Group based on its name\n\n    Args:\n        group_name (str): M365 Group name\n        show_error (bool): should an error be logged if group is not found.\n    Returns:\n        dict: Group information or None if the group doesn't exist.\n\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups',\n            'value': [\n                {\n                    'id': 'b65f7dba-3ed1-49df-91bf-2bf99affcc8d',\n                    'deletedDateTime': None,\n                    'classification': None,\n                    'createdDateTime': '2023-04-01T13:46:26Z',\n                    'creationOptions': [],\n                    'description': 'Engineering &amp; Construction',\n                    'displayName': 'Engineering &amp; Construction',\n                    'expirationDateTime': None,\n                    'groupTypes': ['Unified'],\n                    'isAssignableToRole': None,\n                    'mail': 'Engineering&amp;Construction@M365x61936377.onmicrosoft.com',\n                    'mailEnabled': True,\n                    'mailNickname': 'Engineering&amp;Construction',\n                    'membershipRule': None,\n                    'membershipRuleProcessingState': None,\n                    'onPremisesDomainName': None,\n                    'onPremisesLastSyncDateTime': None,\n                    'onPremisesNetBiosName': None,\n                    'onPremisesSamAccountName': None,\n                    'onPremisesSecurityIdentifier': None,\n                    'onPremisesSyncEnabled': None,\n                    'preferredDataLocation': None,\n                    'preferredLanguage': None,\n                    'proxyAddresses': ['SPO:SPO_d9deb3e7-c72f-4e8d-80fb-5d9411ca1458@SPO_604f34f0-ba72-4321-ab6b-e36ae8bd00ec', 'SMTP:Engineering&amp;Construction@M365x61936377.onmicrosoft.com'],\n                    'renewedDateTime': '2023-04-01T13:46:26Z',\n                    'resourceBehaviorOptions': [],\n                    'resourceProvisioningOptions': [],\n                    'securityEnabled': False,\n                    'securityIdentifier': 'S-1-12-1-3059711418-1239367377-4180393873-2379022234',\n                    'theme': None,\n                    'visibility': 'Public',\n                    'onPremisesProvisioningErrors': []\n                },\n                {\n                    'id': '61359860-302e-4016-b5cc-abff2293dff1',\n                    ...\n                }\n            ]\n        }\n    \"\"\"\n\n    query = {\"$filter\": \"displayName eq '\" + group_name + \"'\"}\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = self.config()[\"groupsUrl\"] + \"?\" + encoded_query\n    request_header = self.request_header()\n\n    logger.info(\"Get M365 group -&gt; %s; calling -&gt; %s\", group_name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    group_name,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\"M365 Group -&gt; %s not found.\", group_name)\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_group_members","title":"<code>get_group_members(group_name)</code>","text":"<p>Get members (users and groups) of the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the group</p> required <p>Returns:     dict: Response of Graph REST API or None if the REST call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_group_members(self, group_name: str) -&gt; dict | None:\n    \"\"\"Get members (users and groups) of the specified group.\n\n    Args:\n        group_name (str): name of the group\n    Returns:\n        dict: Response of Graph REST API or None if the REST call fails.\n    \"\"\"\n\n    response = self.get_group(group_name)\n    group_id = self.get_result_value(response, \"id\", 0)\n    if not group_id:\n        logger.error(\n            \"M365 Group -&gt; %s does not exist! Cannot retrieve group members.\",\n            group_name,\n        )\n        return None\n\n    query = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = (\n        self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members?\" + encoded_query\n    )\n    request_header = self.request_header()\n\n    logger.info(\n        \"Get members of M365 group -&gt; %s (%s); calling -&gt; %s\",\n        group_name,\n        group_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get members of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                group_name,\n                group_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_group_owners","title":"<code>get_group_owners(group_name)</code>","text":"<p>Get owners (users) of the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the group</p> required <p>Returns:     dict: Response of Graph REST API or None if the REST call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_group_owners(self, group_name: str) -&gt; dict | None:\n    \"\"\"Get owners (users) of the specified group.\n\n    Args:\n        group_name (str): name of the group\n    Returns:\n        dict: Response of Graph REST API or None if the REST call fails.\n    \"\"\"\n\n    response = self.get_group(group_name)\n    group_id = self.get_result_value(response, \"id\", 0)\n    if not group_id:\n        logger.error(\n            \"M365 Group -&gt; %s does not exist! Cannot retrieve group owners.\",\n            group_name,\n        )\n        return None\n\n    query = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = (\n        self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners?\" + encoded_query\n    )\n    request_header = self.request_header()\n\n    logger.info(\n        \"Get owners of M365 group -&gt; %s (%s); calling -&gt; %s\",\n        group_name,\n        group_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get owners of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                group_name,\n                group_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_groups","title":"<code>get_groups(max_number=250)</code>","text":"<p>Get list all all groups in M365 tenant</p> <p>Parameters:</p> Name Type Description Default <code>max_number</code> <code>int</code> <p>maximum result values (limit)</p> <code>250</code> <p>Returns:     dict: dictionary of all groups or None in case of an error.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_groups(self, max_number: int = 250) -&gt; dict | None:\n    \"\"\"Get list all all groups in M365 tenant\n\n    Args:\n        max_number (int, optional): maximum result values (limit)\n    Returns:\n        dict: dictionary of all groups or None in case of an error.\n    \"\"\"\n\n    request_url = self.config()[\"groupsUrl\"]\n    request_header = self.request_header()\n\n    logger.info(\"Get list of all M365 groups; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            request_url,\n            headers=request_header,\n            params={\"$top\": str(max_number)},\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of M365 groups; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_result_value","title":"<code>get_result_value(response, key, index=0, sub_dict_name='')</code>","text":"<p>Get value of a result property with a given key of an MS Graph API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an MS Graph REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>index</code> <code>int</code> <p>Index to use (1st element has index 0).                    Defaults to 0.</p> <code>0</code> <code>sub_dict_name</code> <code>str</code> <p>some MS Graph API calls include nested                  dict structures that can be requested                  with an \"expand\" query parameter. In such                  a case we use the sub_dict_name to access it.</p> <code>''</code> <p>Returns:     str: value for the key, None otherwise</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_result_value(\n    self, response: dict, key: str, index: int = 0, sub_dict_name: str = \"\"\n) -&gt; str | None:\n    \"\"\"Get value of a result property with a given key of an MS Graph API call.\n\n    Args:\n        response (dict): REST response from an MS Graph REST Call\n        key (str): property name (key)\n        index (int, optional): Index to use (1st element has index 0).\n                               Defaults to 0.\n        sub_dict_name (str): some MS Graph API calls include nested\n                             dict structures that can be requested\n                             with an \"expand\" query parameter. In such\n                             a case we use the sub_dict_name to access it.\n    Returns:\n        str: value for the key, None otherwise\n    \"\"\"\n\n    if not response:\n        return None\n    if (\n        not \"value\" in response\n    ):  # If Graph APIs are called with specific IDs (and not name lookups)\n        # they may not return a list of dicts calles \"values\" but a single dict directly\n        if sub_dict_name and sub_dict_name in response:\n            sub_structure = response[sub_dict_name]\n            # also the substructure could be a list\n            if isinstance(sub_structure, list):\n                sub_structure = sub_structure[index]\n            return sub_structure[key]\n        elif key in response:\n            return response[key]\n        else:\n            return None\n\n    values = response[\"value\"]\n    if not values or not isinstance(values, list) or len(values) - 1 &lt; index:\n        return None\n\n    if not sub_dict_name:\n        return values[index][key]\n    else:\n        sub_structure = values[index][sub_dict_name]\n        if isinstance(sub_structure, list):\n            # here we assume it is the first element of the\n            # substructure. If really required for specific\n            # use cases we may introduce a second index in\n            # the future.\n            sub_structure = sub_structure[0]\n        return sub_structure[key]\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_team","title":"<code>get_team(name)</code>","text":"<p>Get a M365 Team based on its name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the M365 Team</p> required <p>Returns:     dict: teams data structure (dictionary) or None if the request fails.</p> <pre><code>Example return data:\n{\n    '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#teams',\n    '@odata.count': 1,\n    'value': [\n        {\n            'id': '951bd036-c6fc-4da4-bb80-1860f5472a2f',\n            'createdDateTime': None,\n            'displayName': 'Procurement',\n            'description': 'Procurement',\n            'internalId': None,\n            'classification': None,\n            'specialization': None,\n            'visibility': 'public',\n            'webUrl': None, ...}]}\n            'isArchived': None,\n            'isMembershipLimitedToOwners': None,\n            'memberSettings': None,\n            'guestSettings': None,\n            'messagingSettings': None,\n            ...\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_team(self, name: str) -&gt; dict | None:\n    \"\"\"Get a M365 Team based on its name\n\n    Args:\n        name (str): name of the M365 Team\n    Returns:\n        dict: teams data structure (dictionary) or None if the request fails.\n\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#teams',\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '951bd036-c6fc-4da4-bb80-1860f5472a2f',\n                    'createdDateTime': None,\n                    'displayName': 'Procurement',\n                    'description': 'Procurement',\n                    'internalId': None,\n                    'classification': None,\n                    'specialization': None,\n                    'visibility': 'public',\n                    'webUrl': None, ...}]}\n                    'isArchived': None,\n                    'isMembershipLimitedToOwners': None,\n                    'memberSettings': None,\n                    'guestSettings': None,\n                    'messagingSettings': None,\n                    ...\n                }\n            ]\n        }\n    \"\"\"\n\n    # The M365 Teams API has an issues with ampersand characters in team names (like \"Engineering &amp; Construction\")\n    # So we do a work-around here to first get the Team ID via the Group endpoint of the Graph API and\n    # then fetch the M365 Team via its ID (which is identical to the underlying M365 Group ID)\n    response = self.get_group(name)\n    team_id = self.get_result_value(response, \"id\", 0)\n    if not team_id:\n        logger.error(\n            \"Failed to get the ID of the M365 Team -&gt; %s via the M365 Group API\",\n            name,\n        )\n        return None\n\n    request_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id)\n\n    request_header = self.request_header()\n\n    logger.info(\n        \"Lookup Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\n        name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_team_channel_tabs","title":"<code>get_team_channel_tabs(team_name, channel_name)</code>","text":"<p>Get tabs of an M365 Team channel based on the team and channel names</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <p>Returns:     dict: tabs data structure (dictionary) or None if the request fails.</p> <pre><code>Example return data:\n{\n    '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels('19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2')/tabs\",\n    '@odata.count': 1,\n    'value': [\n        {\n            'id': '66f44e9a-0741-49a4-9500-ec82cc120115',\n            'displayName': 'Procurement',\n            'webUrl': 'https://teams.microsoft.com/l/entity/2851980b-95dc-4118-a1f5-5ae1894eaaaf/_djb2_msteams_prefix_66f44e9a-0741-49a4-9500-ec82cc120115?webUrl=https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%26showBW%3dtrue%26title%3dProcurement&amp;label=Procurement&amp;context=%7b%0d%0a++%22canvasUrl%22%3a+%22https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%22%2c%0d%0a++%22channelId%22%3a+%2219%3ayPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2%22%2c%0d%0a++%22subEntityId%22%3a+null%0d%0a%7d&amp;groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n            'configuration':\n            {\n                'entityId': '13178',\n                'contentUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed',\n                'removeUrl': None,\n                'websiteUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed&amp;showBW=true&amp;title=Procurement',\n                'dateAdded': '2023-08-12T08:57:35.895Z'\n            }\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_team_channel_tabs(self, team_name: str, channel_name: str) -&gt; dict | None:\n    \"\"\"Get tabs of an M365 Team channel based on the team and channel names\n\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n    Returns:\n        dict: tabs data structure (dictionary) or None if the request fails.\n\n        Example return data:\n        {\n            '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels('19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2')/tabs\",\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '66f44e9a-0741-49a4-9500-ec82cc120115',\n                    'displayName': 'Procurement',\n                    'webUrl': 'https://teams.microsoft.com/l/entity/2851980b-95dc-4118-a1f5-5ae1894eaaaf/_djb2_msteams_prefix_66f44e9a-0741-49a4-9500-ec82cc120115?webUrl=https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%26showBW%3dtrue%26title%3dProcurement&amp;label=Procurement&amp;context=%7b%0d%0a++%22canvasUrl%22%3a+%22https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%22%2c%0d%0a++%22channelId%22%3a+%2219%3ayPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2%22%2c%0d%0a++%22subEntityId%22%3a+null%0d%0a%7d&amp;groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                    'configuration':\n                    {\n                        'entityId': '13178',\n                        'contentUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed',\n                        'removeUrl': None,\n                        'websiteUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed&amp;showBW=true&amp;title=Procurement',\n                        'dateAdded': '2023-08-12T08:57:35.895Z'\n                    }\n                }\n            ]\n        }\n    \"\"\"\n\n    response = self.get_team(team_name)\n    team_id = self.get_result_value(response, \"id\", 0)\n    if not team_id:\n        return None\n\n    # Get the channels of the M365 Team:\n    response = self.get_team_channels(team_name)\n    if not response or not response[\"value\"] or not response[\"value\"][0]:\n        return None\n\n    # Look the channel by name and then retrieve its ID:\n    channel = next(\n        (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n        None,\n    )\n    if not channel:\n        logger.erro(\n            \"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n        )\n        return None\n    channel_id = channel[\"id\"]\n\n    request_url = (\n        self.config()[\"teamsUrl\"]\n        + \"/\"\n        + str(team_id)\n        + \"/channels/\"\n        + str(channel_id)\n        + \"/tabs\"\n    )\n\n    request_header = self.request_header()\n\n    logger.info(\n        \"Retrieve Tabs of Microsoft 365 Teams -&gt; %s and Channel -&gt; %s; calling -&gt; %s\",\n        team_name,\n        channel_name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get Tabs for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                team_name,\n                team_id,\n                channel_name,\n                channel_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_team_channels","title":"<code>get_team_channels(name)</code>","text":"<p>Get channels of a M365 Team based on the team name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the team</p> required <p>Returns:     dict: channel data structure (dictionary) or None if the request fails.</p> <pre><code>Example return data:\n{\n    '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels\",\n    '@odata.count': 1,\n    'value': [\n        {\n            'id': '19:yPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1@thread.tacv2',\n            'createdDateTime': '2023-08-11T14:11:35.986Z',\n            'displayName': 'General',\n            'description': 'Procurement',\n            'isFavoriteByDefault': None,\n            'email': None,\n            'tenantId': '417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n            'webUrl': 'https://teams.microsoft.com/l/channel/19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2/Procurement?groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea&amp;allowXTenantAccess=False',\n            'membershipType': 'standard'\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_team_channels(self, name: str) -&gt; dict | None:\n    \"\"\"Get channels of a M365 Team based on the team name\n\n    Args:\n        name (str): name of the team\n    Returns:\n        dict: channel data structure (dictionary) or None if the request fails.\n\n        Example return data:\n        {\n            '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels\",\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '19:yPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1@thread.tacv2',\n                    'createdDateTime': '2023-08-11T14:11:35.986Z',\n                    'displayName': 'General',\n                    'description': 'Procurement',\n                    'isFavoriteByDefault': None,\n                    'email': None,\n                    'tenantId': '417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                    'webUrl': 'https://teams.microsoft.com/l/channel/19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2/Procurement?groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea&amp;allowXTenantAccess=False',\n                    'membershipType': 'standard'\n                }\n            ]\n        }\n    \"\"\"\n\n    response = self.get_team(name)\n    team_id = self.get_result_value(response, \"id\", 0)\n    if not team_id:\n        return None\n\n    request_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id) + \"/channels\"\n\n    request_header = self.request_header()\n\n    logger.info(\n        \"Retrieve channels of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\n        name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get Channels for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_app","title":"<code>get_teams_app(app_id)</code>","text":"<p>Get a specific MS Teams app in catalog based on the known app ID</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>ID of the app</p> required <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_app(self, app_id: str) -&gt; dict | None:\n    \"\"\"Get a specific MS Teams app in catalog based on the known app ID\n\n    Args:\n        app_id (str): ID of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    query = {\"$expand\": \"AppDefinitions\"}\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n    request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id + \"?\" + encoded_query\n\n    #        request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n\n    logger.info(\n        \"Get MS Teams App with ID -&gt; %s; calling -&gt; %s\", app_id, request_url\n    )\n\n    request_header = self.request_header()\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_apps","title":"<code>get_teams_apps(filter_expression='')</code>","text":"<p>Get a list of MS Teams apps in catalog that match a given filter criterium</p> <p>Parameters:</p> Name Type Description Default <code>filter_expression</code> <code>str</code> <p>filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter</p> <code>''</code> <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> <pre><code>Example return data:\n{\n    '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps(appDefinitions())',\n    '@odata.count': 1,\n    'value': [\n        {\n            'id': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n            'externalId': 'dd4af790-d8ff-47a0-87ad-486318272c7a',\n            'displayName': 'OpenText Extended ECM',\n            'distributionMethod': 'organization',\n            'appDefinitions@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps('2851980b-95dc-4118-a1f5-5ae1894eaaaf')/appDefinitions\",\n            'appDefinitions': [\n                {\n                    'id': 'Mjg1MTk4MGItOTVkYy00MTE4LWExZjUtNWFlMTg5NGVhYWFmIyMyMi40IyNQdWJsaXNoZWQ=',\n                    'teamsAppId': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                    'displayName': 'OpenText Extended ECM',\n                    'version': '22.4',\n                    'publishingState': 'published',\n                    'shortDescription': 'Add a tab for an Extended ECM business workspace.',\n                    'description': 'View and interact with OpenText Extended ECM business workspaces',\n                    'lastModifiedDateTime': None,\n                    'createdBy': None,\n                    'authorization': {\n                        'requiredPermissionSet': {...}\n                    }\n                }\n            ]\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_apps(self, filter_expression: str = \"\") -&gt; dict | None:\n    \"\"\"Get a list of MS Teams apps in catalog that match a given filter criterium\n\n    Args:\n        filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps(appDefinitions())',\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                    'externalId': 'dd4af790-d8ff-47a0-87ad-486318272c7a',\n                    'displayName': 'OpenText Extended ECM',\n                    'distributionMethod': 'organization',\n                    'appDefinitions@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps('2851980b-95dc-4118-a1f5-5ae1894eaaaf')/appDefinitions\",\n                    'appDefinitions': [\n                        {\n                            'id': 'Mjg1MTk4MGItOTVkYy00MTE4LWExZjUtNWFlMTg5NGVhYWFmIyMyMi40IyNQdWJsaXNoZWQ=',\n                            'teamsAppId': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                            'displayName': 'OpenText Extended ECM',\n                            'version': '22.4',\n                            'publishingState': 'published',\n                            'shortDescription': 'Add a tab for an Extended ECM business workspace.',\n                            'description': 'View and interact with OpenText Extended ECM business workspaces',\n                            'lastModifiedDateTime': None,\n                            'createdBy': None,\n                            'authorization': {\n                                'requiredPermissionSet': {...}\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    \"\"\"\n\n    query = {\"$expand\": \"AppDefinitions\"}\n\n    if filter_expression:\n        query[\"$filter\"] = filter_expression\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n    request_url = self.config()[\"teamsAppsUrl\"] + \"?\" + encoded_query\n\n    if filter_expression:\n        logger.info(\n            \"Get list of MS Teams Apps using filter -&gt; %s; calling -&gt; %s\",\n            filter_expression,\n            request_url,\n        )\n    else:\n        logger.info(\"Get list of all MS Teams Apps; calling -&gt; %s\", request_url)\n\n    request_header = self.request_header()\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_apps_of_team","title":"<code>get_teams_apps_of_team(team_id, filter_expression='')</code>","text":"<p>Get a list of MS Teams apps of a M365 team that match a given filter criterium</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>M365 ID of the team</p> required <code>filter_expression</code> <code>str</code> <p>filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter</p> <code>''</code> <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_apps_of_team(\n    self, team_id: str, filter_expression: str = \"\"\n) -&gt; dict | None:\n    \"\"\"Get a list of MS Teams apps of a M365 team that match a given filter criterium\n\n    Args:\n        team_id (str): M365 ID of the team\n        filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    query = {\"$expand\": \"teamsAppDefinition\"}\n    if filter_expression:\n        query[\"$filter\"] = filter_expression\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n    request_url = (\n        self.config()[\"teamsUrl\"]\n        + \"/\"\n        + team_id\n        + \"/installedApps?\"\n        + encoded_query\n    )\n    logger.info(\n        \"Get list of M365 Teams Apps for M365 Team -&gt; %s using query -&gt; %s; calling -&gt; %s\",\n        team_id,\n        query,\n        request_url,\n    )\n\n    request_header = self.request_header()\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of M365 Teams Apps for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                team_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_apps_of_user","title":"<code>get_teams_apps_of_user(user_id, filter_expression='')</code>","text":"<p>Get a list of MS Teams apps of a user that match a given filter criterium</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>filter_expression</code> <code>str</code> <p>filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter</p> <code>''</code> <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_apps_of_user(\n    self, user_id: str, filter_expression: str = \"\"\n) -&gt; dict | None:\n    \"\"\"Get a list of MS Teams apps of a user that match a given filter criterium\n\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    query = {\"$expand\": \"teamsAppDefinition\"}\n    if filter_expression:\n        query[\"$filter\"] = filter_expression\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n    request_url = (\n        self.config()[\"usersUrl\"]\n        + \"/\"\n        + user_id\n        + \"/teamwork/installedApps?\"\n        + encoded_query\n    )\n    logger.info(\n        \"Get list of M365 Teams Apps for user -&gt; %s using query -&gt; %s; calling -&gt; %s\",\n        user_id,\n        query,\n        request_url,\n    )\n\n    request_header = self.request_header()\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of M365 Teams Apps for user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                user_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_user","title":"<code>get_user(user_email, show_error=False)</code>","text":"<p>Get a M365 User based on its email</p> <p>Parameters:</p> Name Type Description Default <code>user_email</code> <code>str</code> <p>M365 user email</p> required <code>show_error</code> <code>bool</code> <p>whether or not an error should be displayed if the                user is not found.</p> <code>False</code> <p>Returns:     dict: User information or None if the user couldn't be retrieved (e.g. because it doesn't exist           or if there is a permission problem).     Example return data:     {         '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#users/$entity',         'businessPhones': [],         'displayName': 'Bob Davis',         'givenName': 'Bob',         'id': '72c80809-094f-4e6e-98d4-25a736385d10',         'jobTitle': None,         'mail': 'bdavis@M365x61936377.onmicrosoft.com',         'mobilePhone': None,         'officeLocation': None,         'preferredLanguage': None,         'surname': 'Davis',         'userPrincipalName': 'bdavis@M365x61936377.onmicrosoft.com'     }</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_user(self, user_email: str, show_error: bool = False) -&gt; dict | None:\n    \"\"\"Get a M365 User based on its email\n\n    Args:\n        user_email (str): M365 user email\n        show_error (bool): whether or not an error should be displayed if the\n                           user is not found.\n    Returns:\n        dict: User information or None if the user couldn't be retrieved (e.g. because it doesn't exist\n              or if there is a permission problem).\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#users/$entity',\n            'businessPhones': [],\n            'displayName': 'Bob Davis',\n            'givenName': 'Bob',\n            'id': '72c80809-094f-4e6e-98d4-25a736385d10',\n            'jobTitle': None,\n            'mail': 'bdavis@M365x61936377.onmicrosoft.com',\n            'mobilePhone': None,\n            'officeLocation': None,\n            'preferredLanguage': None,\n            'surname': 'Davis',\n            'userPrincipalName': 'bdavis@M365x61936377.onmicrosoft.com'\n        }\n    \"\"\"\n\n    request_url = self.config()[\"usersUrl\"] + \"/\" + user_email\n    request_header = self.request_header()\n\n    logger.info(\"Get M365 user -&gt; %s; calling -&gt; %s\", user_email, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    user_email,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\"M365 User -&gt; %s not found.\", user_email)\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_user_licenses","title":"<code>get_user_licenses(user_id)</code>","text":"<p>Get the assigned license SKUs of a user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <p>Returns:     dict: List of user licenses or None if request fails.</p> <pre><code>Example return data:\n{\n    '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#users('a5875311-f0a5-486d-a746-bd7372b91115')/licenseDetails\",\n    'value': [\n        {\n            'id': '8DRPYHK6IUOra-Nq6L0A7GAn38eBLPdOtXhbU5K1cd8',\n            'skuId': 'c7df2760-2c81-4ef7-b578-5b5392b571df',\n            'skuPartNumber': 'ENTERPRISEPREMIUM',\n            'servicePlans': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_user_licenses(self, user_id: str) -&gt; dict | None:\n    \"\"\"Get the assigned license SKUs of a user\n\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n    Returns:\n        dict: List of user licenses or None if request fails.\n\n        Example return data:\n        {\n            '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#users('a5875311-f0a5-486d-a746-bd7372b91115')/licenseDetails\",\n            'value': [\n                {\n                    'id': '8DRPYHK6IUOra-Nq6L0A7GAn38eBLPdOtXhbU5K1cd8',\n                    'skuId': 'c7df2760-2c81-4ef7-b578-5b5392b571df',\n                    'skuPartNumber': 'ENTERPRISEPREMIUM',\n                    'servicePlans': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n                }\n            ]\n        }\n    \"\"\"\n\n    request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/licenseDetails\"\n    request_header = self.request_header()\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get M365 licenses of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                user_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_user_photo","title":"<code>get_user_photo(user_id, show_error=True)</code>","text":"<p>Get the photo of a M365 user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>show_error</code> <code>bool</code> <p>whether or not an error should be logged if the user                   does not have a photo in M365</p> <code>True</code> <p>Returns:     bytes: Image of the user photo or None if the user photo couldn't be retrieved.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_user_photo(self, user_id: str, show_error: bool = True) -&gt; bytes | None:\n    \"\"\"Get the photo of a M365 user\n\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        show_error (bool): whether or not an error should be logged if the user\n                              does not have a photo in M365\n    Returns:\n        bytes: Image of the user photo or None if the user photo couldn't be retrieved.\n    \"\"\"\n\n    request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n    # Set image as content type:\n    request_header = self.request_header(\"image/*\")\n\n    logger.info(\"Get photo of user -&gt; %s; calling -&gt; %s\", user_id, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return response.content  # this is the actual image - not json!\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get photo of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    user_id,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\"User -&gt; %s does not yet have a photo.\", user_id)\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_users","title":"<code>get_users()</code>","text":"<p>Get list all all users in M365 tenant</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Dictionary of all users.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_users(self) -&gt; dict | None:\n    \"\"\"Get list all all users in M365 tenant\n\n    Returns:\n        dict: Dictionary of all users.\n    \"\"\"\n\n    request_url = self.config()[\"usersUrl\"]\n    request_header = self.request_header()\n\n    logger.info(\"Get list of all users; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of users; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.has_team","title":"<code>has_team(group_name)</code>","text":"<p>Check if a M365 Group has a M365 Team connected or not</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the M365 group</p> required <p>Returns:     bool: Returns True if a Team is assigned and False otherwise</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def has_team(self, group_name: str) -&gt; bool:\n    \"\"\"Check if a M365 Group has a M365 Team connected or not\n\n    Args:\n        group_name (str): name of the M365 group\n    Returns:\n        bool: Returns True if a Team is assigned and False otherwise\n    \"\"\"\n\n    response = self.get_group(group_name)\n    group_id = self.get_result_value(response, \"id\", 0)\n    if not group_id:\n        logger.error(\n            \"M365 Group -&gt; %s not found. Cannot check if it has a M365 Team.\",\n            group_name,\n        )\n        return False\n\n    request_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/team\"\n    request_header = self.request_header()\n\n    logger.info(\n        \"Check if M365 Group -&gt; %s has a M365 Team connected; calling -&gt; %s\",\n        group_name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n\n        if response.status_code == 200:  # Group has a Team assigned!\n            logger.info(\"Group -&gt; %s has a M365 Team connected.\", group_name)\n            return True\n        elif response.status_code == 404:  # Group does not have a Team assigned!\n            logger.info(\"Group -&gt; %s has no M365 Team connected.\", group_name)\n            return False\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to check if M365 Group -&gt; %s has a M365 Team connected; status -&gt; %s; error -&gt; %s\",\n                group_name,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.is_member","title":"<code>is_member(group_id, member_id, show_error=True)</code>","text":"<p>Checks whether a M365 user is already in a M365 group</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>M365 GUID of the group</p> required <code>member_id</code> <code>str</code> <p>M365 GUID of the user (member)</p> required <code>show_error</code> <code>bool</code> <p>whether or not an error should be logged if the user                   is not a member of the group</p> <code>True</code> <p>Returns:     bool: True if the user is in the group. False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def is_member(self, group_id: str, member_id: str, show_error: bool = True) -&gt; bool:\n    \"\"\"Checks whether a M365 user is already in a M365 group\n\n    Args:\n        group_id (str): M365 GUID of the group\n        member_id (str): M365 GUID of the user (member)\n        show_error (bool): whether or not an error should be logged if the user\n                              is not a member of the group\n    Returns:\n        bool: True if the user is in the group. False otherwise.\n    \"\"\"\n\n    # don't encode this URL - this has not been working!!\n    request_url = (\n        self.config()[\"groupsUrl\"]\n        + f\"/{group_id}/members?$filter=id eq '{member_id}'\"\n    )\n    request_header = self.request_header()\n\n    logger.info(\n        \"Check if user -&gt; %s is in group -&gt; %s; calling -&gt; %s\",\n        member_id,\n        group_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            response = self.parse_request_response(response)\n            if not \"value\" in response or len(response[\"value\"]) == 0:\n                return False\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            # MS Graph API returns an error if the member is not in the\n            # group. This is typically not what we want. We just return False.\n            if show_error:\n                logger.error(\n                    \"Failed to check if user -&gt; %s is in group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    member_id,\n                    group_id,\n                    response.status_code,\n                    response.text,\n                )\n            return False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the request response (JSon) to a Python dict in a safe way    that also handles exceptions. It first tries to load the response.text    via json.loads() that produces a dict output. Only if response.text is    not set or is empty it just converts the response_object to a dict using    the vars() built-in method.</p> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>use a more specific error message                                       in case of an error</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>True: write an error to the log file                False: write a warning to the log file</p> <code>True</code> <p>Returns:     dict: response information or None in case of an error</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def parse_request_response(\n    self,\n    response_object: requests.Response,\n    additional_error_message: str = \"\",\n    show_error: bool = True,\n) -&gt; dict | None:\n    \"\"\"Converts the request response (JSon) to a Python dict in a safe way\n       that also handles exceptions. It first tries to load the response.text\n       via json.loads() that produces a dict output. Only if response.text is\n       not set or is empty it just converts the response_object to a dict using\n       the vars() built-in method.\n\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str, optional): use a more specific error message\n                                                  in case of an error\n        show_error (bool): True: write an error to the log file\n                           False: write a warning to the log file\n    Returns:\n        dict: response information or None in case of an error\n    \"\"\"\n\n    if not response_object:\n        return None\n\n    try:\n        if response_object.text:\n            dict_object = json.loads(response_object.text)\n        else:\n            dict_object = vars(response_object)\n    except json.JSONDecodeError as exception:\n        if additional_error_message:\n            message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                additional_error_message, exception\n            )\n        else:\n            message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                exception\n            )\n        if show_error:\n            logger.error(message)\n        else:\n            logger.warning(message)\n        return None\n    else:\n        return dict_object\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.purge_deleted_item","title":"<code>purge_deleted_item(item_id)</code>","text":"<p>Helper method to purge a single deleted user or group.    This requires elevated permissions that are typically    not available via Graph API.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>str</code> <p>M365 GUID of the user or group to purge</p> required <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def purge_deleted_item(self, item_id: str) -&gt; dict | None:\n    \"\"\"Helper method to purge a single deleted user or group.\n       This requires elevated permissions that are typically\n       not available via Graph API.\n\n    Args:\n        item_id (str): M365 GUID of the user or group to purge\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    request_url = self.config()[\"directoryUrl\"] + \"/deletedItems/\" + item_id\n    request_header = self.request_header()\n\n    logger.info(\"Purging deleted item -&gt; %s; calling -&gt; %s\", item_id, request_url)\n\n    retries = 0\n    while True:\n        response = requests.delete(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to purge deleted item -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                item_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.purge_deleted_items","title":"<code>purge_deleted_items()</code>","text":"<p>Purge all deleted users and groups. Purging users and groups requires administrative rights that typically are not provided in Contoso example org.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def purge_deleted_items(self):\n    \"\"\"Purge all deleted users and groups.\n    Purging users and groups requires administrative rights that typically\n    are not provided in Contoso example org.\n    \"\"\"\n\n    request_header = self.request_header()\n\n    request_url = (\n        self.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.group\"\n    )\n    response = requests.get(request_url, headers=request_header, timeout=60)\n    deleted_groups = self.parse_request_response(response)\n\n    for group in deleted_groups[\"value\"]:\n        group_id = group[\"id\"]\n        response = self.purge_deleted_item(group_id)\n\n    request_url = (\n        self.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.user\"\n    )\n    response = requests.get(request_url, headers=request_header, timeout=60)\n    deleted_users = self.parse_request_response(response)\n\n    for user in deleted_users[\"value\"]:\n        user_id = user[\"id\"]\n        response = self.purge_deleted_item(user_id)\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.remove_teams_app","title":"<code>remove_teams_app(app_id)</code>","text":"<p>Remove MS Teams App from the app catalog</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>Microsoft 365 GUID of the MS Teams app</p> required Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def remove_teams_app(self, app_id: str):\n    \"\"\"Remove MS Teams App from the app catalog\n\n    Args:\n        app_id (str): Microsoft 365 GUID of the MS Teams app\n    \"\"\"\n\n    request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n    # Here we need the credentials of an authenticated user!\n    # (not the application credentials (client_id, client_secret))\n    request_header = self.request_header_user()\n\n    # Make the DELETE request to remove the app from the app catalog\n    response = requests.delete(request_url, headers=request_header, timeout=60)\n\n    # Check the status code of the response\n    if response.status_code == 204:\n        logger.info(\n            \"The M365 Teams app with ID -&gt; %s has been successfully removed from the app catalog.\",\n            app_id,\n        )\n    else:\n        logger.error(\n            \"An error occurred while removing the M365 Teams app from the M365 app catalog. Status code -&gt; %s. Error message -&gt; %s\",\n            response.status_code,\n            response.text,\n        )\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.request_header","title":"<code>request_header(content_type='application/json')</code>","text":"<p>Returns the request header used for Application calls.    Consists of Bearer access token and Content Type</p> <p>Parameters:</p> Name Type Description Default <code>content_type</code> <code>str</code> <p>content type for the request</p> <code>'application/json'</code> <p>Return:     dict: request header values</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def request_header(self, content_type: str = \"application/json\") -&gt; dict:\n    \"\"\"Returns the request header used for Application calls.\n       Consists of Bearer access token and Content Type\n\n    Args:\n        content_type (str, optional): content type for the request\n    Return:\n        dict: request header values\n    \"\"\"\n\n    request_header = {\n        \"Authorization\": \"Bearer {}\".format(self._access_token),\n        \"Content-Type\": content_type,\n    }\n    return request_header\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.request_header_user","title":"<code>request_header_user(content_type='application/json')</code>","text":"<p>Returns the request header used for user specific calls.    Consists of Bearer access token and Content Type</p> <p>Parameters:</p> Name Type Description Default <code>content_type</code> <code>str</code> <p>content type for the request</p> <code>'application/json'</code> <p>Return:     dict: request header values</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def request_header_user(self, content_type: str = \"application/json\") -&gt; dict:\n    \"\"\"Returns the request header used for user specific calls.\n       Consists of Bearer access token and Content Type\n\n    Args:\n        content_type (str, optional): content type for the request\n    Return:\n        dict: request header values\n    \"\"\"\n\n    request_header = {\n        \"Authorization\": \"Bearer {}\".format(self._user_access_token),\n        \"Content-Type\": content_type,\n    }\n    return request_header\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_app_registration","title":"<code>update_app_registration(app_registration_id, app_registration_name, api_permissions, supported_account_type='AzureADMyOrg')</code>","text":"<p>Update an Azure App Registration</p> <p>Parameters:</p> Name Type Description Default <code>app_registration_id</code> <code>str</code> <p>ID of the existing App Registration</p> required <code>app_registration_name</code> <code>str</code> <p>name of the App Registration</p> required <code>api_permissions</code> <code>list</code> <p>API permissions</p> required <code>supported_account_type</code> <code>str</code> <p>type of account that is supposed to use                           the App Registration</p> <code>'AzureADMyOrg'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>App Registration data or None of the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_app_registration(\n    self,\n    app_registration_id: str,\n    app_registration_name: str,\n    api_permissions: list,\n    supported_account_type: str = \"AzureADMyOrg\",\n) -&gt; dict:\n    \"\"\"Update an Azure App Registration\n\n    Args:\n        app_registration_id (str): ID of the existing App Registration\n        app_registration_name (str): name of the App Registration\n        api_permissions (list): API permissions\n        supported_account_type (str): type of account that is supposed to use\n                                      the App Registration\n\n    Returns:\n        dict: App Registration data or None of the request fails.\n    \"\"\"\n\n    # Define the request body to create the App Registration\n    app_registration_data = {\n        \"displayName\": app_registration_name,\n        \"requiredResourceAccess\": api_permissions,\n        \"signInAudience\": supported_account_type,\n    }\n\n    request_url = self.config()[\"applicationsUrl\"] + \"/\" + app_registration_id\n    request_header = self.request_header()\n\n    logger.info(\n        \"Update App Registration -&gt; %s (%s); calling -&gt; %s\",\n        app_registration_name,\n        app_registration_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.patch(\n            request_url,\n            headers=request_header,\n            json=app_registration_data,\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Cannot update App Registration -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                app_registration_name,\n                app_registration_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_teams_app_of_channel","title":"<code>update_teams_app_of_channel(team_name, channel_name, tab_name, app_url, cs_node_id)</code>","text":"<p>Update an existing tab for Extended ECM app in an M365 Team channel</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <code>tab_name</code> <code>str</code> <p>name of the tab</p> required <code>cs_node_id</code> <code>int</code> <p>node ID of the target workspace or container in Extended ECM</p> required <p>Returns:     dict: return data structure (dictionary) or None if the request fails.</p> <pre><code>Example return data:\n</code></pre> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_teams_app_of_channel(\n    self,\n    team_name: str,\n    channel_name: str,\n    tab_name: str,\n    app_url: str,\n    cs_node_id: int,\n) -&gt; dict | None:\n    \"\"\"Update an existing tab for Extended ECM app in an M365 Team channel\n\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n        tab_name (str): name of the tab\n        app_url (str) web URL of the app\n        cs_node_id (int): node ID of the target workspace or container in Extended ECM\n    Returns:\n        dict: return data structure (dictionary) or None if the request fails.\n\n        Example return data:\n\n    \"\"\"\n\n    response = self.get_team(team_name)\n    team_id = self.get_result_value(response, \"id\", 0)\n    if not team_id:\n        return None\n\n    # Get the channels of the M365 Team:\n    response = self.get_team_channels(team_name)\n    if not response or not response[\"value\"] or not response[\"value\"][0]:\n        return None\n\n    # Look the channel by name and then retrieve its ID:\n    channel = next(\n        (item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\n        None,\n    )\n    if not channel:\n        logger.erro(\n            \"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n        )\n        return None\n    channel_id = channel[\"id\"]\n\n    # Get the tabs of the M365 Team channel:\n    response = self.get_team_channel_tabs(team_name, channel_name)\n    if not response or not response[\"value\"] or not response[\"value\"][0]:\n        return None\n\n    # Look the tab by name and then retrieve its ID:\n    tab = next(\n        (item for item in response[\"value\"] if item[\"displayName\"] == tab_name),\n        None,\n    )\n    if not tab:\n        logger.erro(\n            \"Cannot find Tab -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\n            tab_name,\n            team_name,\n            team_id,\n            channel_name,\n            channel_id,\n        )\n        return None\n    tab_id = tab[\"id\"]\n\n    request_url = (\n        self.config()[\"teamsUrl\"]\n        + \"/\"\n        + str(team_id)\n        + \"/channels/\"\n        + str(channel_id)\n        + \"/tabs/\"\n        + str(tab_id)\n    )\n\n    request_header = self.request_header()\n\n    # Create tab configuration payload:\n    tab_config = {\n        \"configuration\": {\n            \"entityId\": cs_node_id,  # Unique identifier for the tab\n            \"contentUrl\": app_url,\n            \"removeUrl\": \"\",\n            \"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n        },\n    }\n\n    logger.info(\n        \"Update Tab -&gt; %s (%s) of Channel -&gt; %s (%s) for Microsoft 365 Teams -&gt; %s (%s) with configuration -&gt; %s; calling -&gt; %s\",\n        tab_name,\n        tab_id,\n        channel_name,\n        channel_id,\n        team_name,\n        team_id,\n        str(tab_config),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.patch(\n            request_url, headers=request_header, json=tab_config, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\n                tab_name,\n                tab_id,\n                team_name,\n                team_id,\n                channel_name,\n                channel_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_user","title":"<code>update_user(user_id, updated_settings)</code>","text":"<p>Update selected properties of an M365 user. Documentation    on user properties is here: https://learn.microsoft.com/en-us/graph/api/user-update</p> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Response of the M365 Graph API  or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_user(self, user_id: str, updated_settings: dict) -&gt; dict | None:\n    \"\"\"Update selected properties of an M365 user. Documentation\n       on user properties is here: https://learn.microsoft.com/en-us/graph/api/user-update\n\n    Returns:\n        dict | None: Response of the M365 Graph API  or None if the call fails.\n    \"\"\"\n\n    request_url = self.config()[\"usersUrl\"] + \"/\" + user_id\n    request_header = self.request_header()\n\n    logger.info(\n        \"Updating M365 user -&gt; %s with -&gt; %s; calling -&gt; %s\",\n        user_id,\n        str(updated_settings),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.patch(\n            request_url,\n            json=updated_settings,\n            headers=request_header,\n            timeout=60,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update M365 user -&gt; %s with -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                user_id,\n                str(updated_settings),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_user_photo","title":"<code>update_user_photo(user_id, photo_path)</code>","text":"<p>Update the M365 user photo</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>photo_path</code> <code>str</code> <p>file system path with the location of the photo</p> required <p>Returns:     dict: Response of Graph REST API or None if the user photo couldn't be updated.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_user_photo(self, user_id: str, photo_path: str) -&gt; dict | None:\n    \"\"\"Update the M365 user photo\n\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        photo_path (str): file system path with the location of the photo\n    Returns:\n        dict: Response of Graph REST API or None if the user photo couldn't be updated.\n    \"\"\"\n\n    request_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n    # Set image as content type:\n    request_header = self.request_header(\"image/*\")\n\n    # Check if the photo file exists\n    if not os.path.isfile(photo_path):\n        logger.error(\"Photo file -&gt; %s not found!\", photo_path)\n        return None\n\n    try:\n        # Read the photo file as binary data\n        with open(photo_path, \"rb\") as image_file:\n            photo_data = image_file.read()\n    except OSError as exception:\n        # Handle any errors that occurred while reading the photo file\n        logger.error(\n            \"Error reading photo file -&gt; %s; error -&gt; %s\", photo_path, exception\n        )\n        return None\n\n    data = photo_data\n\n    logger.info(\n        \"Update M365 user -&gt; %s with photo -&gt; %s; calling -&gt; %s\",\n        user_id,\n        photo_path,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            request_url, headers=request_header, data=data, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update user -&gt; %s with photo -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                user_id,\n                photo_path,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upgrade_teams_app_of_team","title":"<code>upgrade_teams_app_of_team(team_id, app_name)</code>","text":"<p>Upgrade a MS teams app for a specific team. The call will fail if the team does not     already have the app assigned. So this needs to be checked before     calling this method.     THIS IS CURRENTLY NOT WORKING AS EXPECTED.</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>app_name</code> <code>str</code> <p>exact name of the app</p> required <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upgrade_teams_app_of_team(self, team_id: str, app_name: str) -&gt; dict | None:\n    \"\"\"Upgrade a MS teams app for a specific team. The call will fail if the team does not\n        already have the app assigned. So this needs to be checked before\n        calling this method.\n        THIS IS CURRENTLY NOT WORKING AS EXPECTED.\n\n    Args:\n        team_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        app_name (str): exact name of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    response = self.get_teams_apps_of_team(\n        team_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n    )\n    # Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\n    app_installation_id = self.get_result_value(response, \"id\", 0)\n    if not app_installation_id:\n        logger.error(\n            \"M365 Teams app -&gt; %s not found for M365 Team with ID -&gt; %s. Cannot upgrade app for this team!\",\n            app_name,\n            team_id,\n        )\n        return None\n\n    request_url = (\n        self.config()[\"teamsUrl\"]\n        + \"/\"\n        + team_id\n        + \"/installedApps/\"\n        + app_installation_id\n        + \"/upgrade\"\n    )\n    request_header = self.request_header()\n\n    logger.info(\n        \"Upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; calling -&gt; %s\",\n        app_name,\n        app_installation_id,\n        team_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                app_name,\n                app_installation_id,\n                team_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upgrade_teams_app_of_user","title":"<code>upgrade_teams_app_of_user(user_id, app_name)</code>","text":"<p>Upgrade a MS teams app for a user. The call will fail if the user does not     already have the app assigned. So this needs to be checked before     calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>app_name</code> <code>str</code> <p>exact name of the app</p> required <p>Returns:     dict: response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upgrade_teams_app_of_user(self, user_id: str, app_name: str) -&gt; dict | None:\n    \"\"\"Upgrade a MS teams app for a user. The call will fail if the user does not\n        already have the app assigned. So this needs to be checked before\n        calling this method.\n\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        app_name (str): exact name of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\n\n    response = self.get_teams_apps_of_user(\n        user_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n    )\n    # Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\n    app_installation_id = self.get_result_value(response, \"id\", 0)\n    if not app_installation_id:\n        logger.error(\n            \"M365 Teams app -&gt; %s not found for user with ID -&gt; %s. Cannot upgrade app for this user!\",\n            app_name,\n            user_id,\n        )\n        return None\n\n    request_url = (\n        self.config()[\"usersUrl\"]\n        + \"/\"\n        + user_id\n        + \"/teamwork/installedApps/\"\n        + app_installation_id\n        + \"/upgrade\"\n    )\n    request_header = self.request_header()\n\n    logger.info(\n        \"Upgrade M365 Teams app -&gt; %s (%s) of M365 user with ID -&gt; %s; calling -&gt; %s\",\n        app_name,\n        app_installation_id,\n        user_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(request_url, headers=request_header, timeout=60)\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to upgrade M365 Teams app -&gt; %s (%s) of M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                app_name,\n                app_installation_id,\n                user_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upload_outlook_app","title":"<code>upload_outlook_app(app_path)</code>","text":"<p>Upload the M365 Outlook Add-In as \"Integrated\" App to M365 Admin Center.    THIS IS CURRENTLY NOT IMPLEMENTED DUE TO MISSING MS GRAPH API SUPPORT!</p> <p>https://admin.microsoft.com/#/Settings/IntegratedApps</p> <p>Parameters:</p> Name Type Description Default <code>app_path</code> <code>str</code> <p>path to manifest file in local file system. Needs to be             downloaded before.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: response of the MS Graph API or None if the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upload_outlook_app(\n    self,\n    app_path: str,\n) -&gt; dict | None:\n    \"\"\"Upload the M365 Outlook Add-In as \"Integrated\" App to M365 Admin Center.\n       THIS IS CURRENTLY NOT IMPLEMENTED DUE TO MISSING MS GRAPH API SUPPORT!\n\n       https://admin.microsoft.com/#/Settings/IntegratedApps\n\n    Args:\n        app_path (str): path to manifest file in local file system. Needs to be\n                        downloaded before.\n\n    Returns:\n        dict | None: response of the MS Graph API or None if the request fails.\n    \"\"\"\n\n    #        request_url = self.config()[\"teamsAppsUrl\"]\n\n    #        request_header = self.request_header()\n\n    logger.info(\"Install Outlook Add-in from %s (NOT IMPLEMENTED)\", app_path)\n\n    response = None\n\n    return response\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upload_teams_app","title":"<code>upload_teams_app(app_path, update_existing_app=False, app_catalog_id='')</code>","text":"<p>Upload a new app package to the catalog of MS Teams apps.     This is not possible with client secret credentials     but requires a token of a user authenticated with username + password.     See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish     (permissions table on that page)</p> <p>Parameters:</p> Name Type Description Default <code>app_path</code> <code>str</code> <p>file path (with directory) to the app package to upload</p> required <code>update_existing_app</code> <code>bool</code> <p>whether or not to update an existing app with                         the same name</p> <code>False</code> <code>app_catalog_id</code> <code>str</code> <p>the unique ID of the app. It is the ID the app has in                   the catalog - which is different from ID an app gets                   after installation (which is tenant specific)</p> <code>''</code> <p>Returns:     dict: Response of the MS GRAPH API REST call or None if the request fails</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upload_teams_app(\n    self, app_path: str, update_existing_app: bool = False, app_catalog_id: str = \"\"\n) -&gt; dict | None:\n    \"\"\"Upload a new app package to the catalog of MS Teams apps.\n        This is not possible with client secret credentials\n        but requires a token of a user authenticated with username + password.\n        See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n        (permissions table on that page)\n\n    Args:\n        app_path (str): file path (with directory) to the app package to upload\n        update_existing_app (bool): whether or not to update an existing app with\n                                    the same name\n        app_catalog_id (str): the unique ID of the app. It is the ID the app has in\n                              the catalog - which is different from ID an app gets\n                              after installation (which is tenant specific)\n    Returns:\n        dict: Response of the MS GRAPH API REST call or None if the request fails\n    \"\"\"\n\n    if update_existing_app and not app_catalog_id:\n        logger.error(\n            \"To update an existing M365 Teams app in the app catalog you need to provide the existing App catalog ID!\"\n        )\n        return None\n\n    if not os.path.exists(app_path):\n        logger.error(\"M365 Teams app file -&gt; {} does not exist!\")\n        return None\n\n    # Ensure that the app file is a zip file\n    if not app_path.endswith(\".zip\"):\n        logger.error(\"M365 Teams app file -&gt; {} must be a zip file!\")\n        return None\n\n    request_url = self.config()[\"teamsAppsUrl\"]\n    # If we want to upgrade an existing app we add the app ID and\n    # the specific endpoint:\n    if update_existing_app:\n        request_url += \"/\" + app_catalog_id + \"/appDefinitions\"\n\n    # Here we need the credentials of an authenticated user!\n    # (not the application credentials (client_id, client_secret))\n    request_header = self.request_header_user(\"application/zip\")\n\n    with open(app_path, \"rb\") as f:\n        app_data = f.read()\n\n    with zipfile.ZipFile(app_path) as z:\n        # Ensure that the app file contains a manifest.json file\n        if \"manifest.json\" not in z.namelist():\n            logger.error(\n                \"M365 Teams app file -&gt; {} does not contain a manifest.json file!\"\n            )\n            return None\n\n    logger.info(\n        \"Upload M365 Teams app -&gt; %s to the MS Teams catalog; calling -&gt; %s\",\n        app_path,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url, headers=request_header, data=app_data, timeout=60\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n\n        # Check if Session has expired - then re-authenticate and try once more\n        if response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        elif response.status_code in [502, 503, 504] and retries &lt; 3:\n            logger.warning(\n                \"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\n                response.status_code,\n                (retries + 1) * 60,\n            )\n            time.sleep((retries + 1) * 60)\n            retries += 1\n        else:\n            if update_existing_app:\n                logger.warning(\n                    \"Failed to update existing M365 Teams app -&gt; %s (may be because it is not a new version); status -&gt; %s; error -&gt; %s\",\n                    app_path,\n                    response.status_code,\n                    response.text,\n                )\n\n            else:\n                logger.error(\n                    \"Failed to upload new M365 Teams app -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    app_path,\n                    response.status_code,\n                    response.text,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otac/","title":"Archive Center (OTAC)","text":"<p>OTAC Module to implement functions to apply Archive Center settings</p> <p>Class: OTAC Methods:</p> <p>init : class initializer config : returns config data set hostname: returns the Archive Center hostname set_hostname: sets the Archive Center hostname exec_command: exec a command on Archive Center put_cert: put Certificate on Archive Center enable_cert: enables Certitificate on Archive Center</p>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC","title":"<code>OTAC</code>","text":"<p>Used to automate stettings in OpenText Archive Center.</p> Source code in <code>pyxecm/otac.py</code> <pre><code>class OTAC:\n    \"\"\"Used to automate stettings in OpenText Archive Center.\"\"\"\n\n    _config = None\n    _soap_token: str = \"\"\n\n    def __init__(\n        self,\n        protocol: str,\n        hostname: str,\n        port: int,\n        ds_username: str,\n        ds_password: str,\n        admin_username: str,\n        admin_password: str,\n    ):\n        \"\"\"Initialize the OTAC object\n\n        Args:\n            protocol (str): Either http or https.\n            hostname (str): The hostname of the Archive Center  to communicate with.\n            port (int): The port number used to talk to the Archive Center .\n            ds_username (str): The admin user name of Archive Center (dsadmin).\n            ds_password (str): The admin password of Archive Center (dsadmin).\n            admin_username (str): The admin user name of Archive Center (otadmin@otds.admin).\n            admin_password (str): The admin password of Archive Center (otadmin@otds.admin).\n        \"\"\"\n\n        otac_config = {}\n\n        if hostname:\n            otac_config[\"hostname\"] = hostname\n        else:\n            otac_config[\"hostname\"] = \"\"\n\n        if protocol:\n            otac_config[\"protocol\"] = protocol\n        else:\n            otac_config[\"protocol\"] = \"http\"\n\n        if port:\n            otac_config[\"port\"] = port\n        else:\n            otac_config[\"port\"] = 80\n\n        if ds_username:\n            otac_config[\"ds_username\"] = ds_username\n        else:\n            otac_config[\"ds_username\"] = \"dsadmin\"\n\n        if ds_password:\n            otac_config[\"ds_password\"] = ds_password\n        else:\n            otac_config[\"ds_password\"] = \"\"\n\n        if admin_username:\n            otac_config[\"admin_username\"] = admin_username\n        else:\n            otac_config[\"admin_username\"] = \"admin\"\n\n        if admin_password:\n            otac_config[\"admin_password\"] = admin_password\n        else:\n            otac_config[\"admin_password\"] = \"\"\n\n        otac_base_url = protocol + \"://\" + otac_config[\"hostname\"]\n        if str(port) not in [\"80\", \"443\"]:\n            otac_base_url += \":{}\".format(port)\n        otac_exec_url = otac_base_url + \"/archive/admin/exec\"\n        otac_config[\"execUrl\"] = otac_exec_url\n        otac_config[\"baseUrl\"] = otac_base_url\n\n        self._config = otac_config\n\n    def config(self) -&gt; dict:\n        \"\"\"Returns the configuration dictionary\n\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\n        return self._config\n\n    def hostname(self) -&gt; str:\n        \"\"\"Returns the Archive Center hostname\n\n        Returns:\n            str: Archive Center hostname\n        \"\"\"\n        return self.config()[\"hostname\"]\n\n    def set_hostname(self, hostname: str):\n        \"\"\"Sets the Archive Center hostname\n\n        Args:\n            hostname (str): new Archive Center hostname\n        \"\"\"\n        self.config()[\"hostname\"] = hostname\n\n    def set_credentials(\n        self,\n        ds_username: str = \"\",\n        ds_password: str = \"\",\n        admin_username: str = \"\",\n        admin_password: str = \"\",\n    ):\n        \"\"\"Set the credentials for Archive Center for the \"ds\" and \"admin\" users.\n\n        Args:\n            ds_username (str, optional): non-default user name of the \"ds\" user. Defaults to \"\".\n            ds_password (str, optional): non-default password of the \"ds\" user. Defaults to \"\".\n            admin_username (str, optional): non-default user name of the \"admin\" user. Defaults to \"\".\n            admin_password (str, optional): non-default password of the \"admin\" user. Defaults to \"\".\n        \"\"\"\n        if ds_username:\n            self.config()[\"ds_username\"] = ds_username\n        else:\n            self.config()[\"ds_username\"] = \"dsadmin\"\n\n        if ds_password:\n            self.config()[\"ds_password\"] = ds_password\n        else:\n            self.config()[\"ds_password\"] = \"\"\n\n        if admin_username:\n            self.config()[\"admin_username\"] = admin_username\n        else:\n            self.config()[\"admin_username\"] = \"admin\"\n\n        if admin_password:\n            self.config()[\"admin_password\"] = admin_password\n        else:\n            self.config()[\"admin_password\"] = \"\"\n\n    def base_url(self) -&gt; str:\n        \"\"\"Returns the Archive Center base URL\n\n        Returns:\n            str: Archive Center base URL\n        \"\"\"\n        return self.config()[\"baseUrl\"]\n\n    def exec_url(self) -&gt; str:\n        \"\"\"Returns the Archive Center URL to execute commands\n\n        Returns:\n            str: Archive Center exec URL\n        \"\"\"\n        return self.config()[\"execUrl\"]\n\n    def _soap_login(self):\n        \"\"\"Authenticate via SOAP with admin User\n\n        Args:\n            None\n        Returns:\n            string: soap_token\n        \"\"\"\n\n        url = self.base_url() + \"/archive/services/Authentication?wsdl\"\n        client = Client(url)\n        self._soap_token = client.service.Authenticate(\n            username=self.config()[\"admin_username\"],\n            password=self.config()[\"admin_password\"],\n        )\n\n        return self._soap_token\n\n    # end method definition\n\n    def exec_command(self, command: str):\n        \"\"\"Execute a command on Archive Center\n\n        Args:\n            command (str): command to execute\n        Returns:\n            _type_: _description_\n        \"\"\"\n\n        payload = {\n            \"command\": command,\n            \"user\": self.config()[\"ds_username\"],\n            \"passwd\": self.config()[\"ds_password\"],\n        }\n\n        request_url = self.exec_url()\n        logger.info(\n            \"Execute command -&gt; %s on Archive Center (user -&gt; %s); calling -&gt; %s\",\n            command,\n            payload[\"user\"],\n            request_url,\n        )\n        response = requests.post(\n            url=request_url, data=payload, headers=requestHeaders, timeout=None\n        )\n        if not response.ok:\n            logger.error(\n                \"Failed to execute command -&gt; %s on Archive Center; error -&gt; %s\",\n                command,\n                response.text.replace(\"\\n\", \" \"),  # avoid multi-line log entries\n            )\n\n        return response\n\n    # end method definition\n\n    def put_cert(\n        self,\n        auth_id: str,\n        logical_archive: str,\n        cert_path: str,\n        permissions: str = \"rcud\",\n    ):\n        \"\"\"Put Certificate on Archive Center\n\n        Args:\n            auth_id (str): ID of Certification\n            logical_archive (str): Archive ID\n            cert_path (str): local path to certificate (base64)\n            permissions (str, optional): Permissions of the certificate.\n                                         Defaults to \"rcud\" (read-create-update-delete).\n        Returns:\n            response or None if the request fails\n        \"\"\"\n\n        # Check if the photo file exists\n        if not os.path.isfile(cert_path):\n            logger.error(\"Certificate file -&gt; %s not found!\", cert_path)\n            return None\n\n        with open(file=cert_path, mode=\"r\", encoding=\"utf-8\") as cert_file:\n            cert_content = cert_file.read().strip()\n\n        # Check that we have the pem certificate file - this is what OTAC expects.\n        # If the file content is base64 encoded we will decode it\n        if \"BEGIN CERTIFICATE\" in cert_content:\n            logger.info(\"Certificate file -&gt; %s is not base64 encoded\", cert_path)\n        elif \"BEGIN CERTIFICATE\" in base64.b64decode(\n            cert_content, validate=True\n        ).decode(\"utf-8\"):\n            logger.info(\"Certificate file -&gt; %s is base64 encoded\", cert_path)\n            cert_content = base64.b64decode(cert_content, validate=True).decode(\"utf-8\")\n        else:\n            logger.error(\"Certificate file -&gt; %s is not in the right format\", cert_path)\n            return None\n\n        request_url = (\n            self.base_url()\n            + \"/archive?putCert&amp;pVersion=0046&amp;authId=\"\n            + auth_id\n            + \"&amp;contRep=\"\n            + logical_archive\n            + \"&amp;permissions=\"\n            + permissions\n        )\n        logger.info(\n            \"Putting certificate -&gt; %s on Archive -&gt; %s; calling -&gt; %s\",\n            cert_path,\n            logical_archive,\n            request_url,\n        )\n        response = requests.put(\n            url=request_url, data=cert_content, headers=requestHeaders, timeout=None\n        )\n\n        if not response.ok:\n            message = response.text.split(\n                '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN'\n            )[0]\n            logger.error(\n                \"Failed to put certificate -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\n                cert_path,\n                logical_archive,\n                message,\n            )\n\n        return response\n\n    # end method definition\n\n    def enable_cert(self, auth_id: str, logical_archive: str, enable: bool = True):\n        \"\"\"Enables Certitificate on Archive Center\n\n        Args:\n            auth_id (str): Client ID\n            logical_archive (str): Archive ID\n            enable (bool, optional): Enable or Disable certificate. Defaults to True.\n        Returns:\n            response or None if request fails.\n        \"\"\"\n\n        if not self._soap_token:\n            self._soap_login()\n\n        if enable:\n            enabled: int = 1\n        else:\n            enabled: int = 0\n\n        url = self.base_url() + \"/ot-admin/services/ArchiveAdministration?wsdl\"\n        client = Client(url)\n\n        token_header = client.factory.create(\"ns0:OTAuthentication\")\n        token_header.AuthenticationToken = self._soap_token\n        client.set_options(soapheaders=token_header)\n\n        try:\n            response = client.service.invokeCommand(\n                command=\"SetCertificateFlags\",\n                parameters=[\n                    {\"key\": \"CERT_TYPE\", \"data\": \"@{}\".format(logical_archive)},\n                    {\"key\": \"CERT_NAME\", \"data\": auth_id},\n                    {\"key\": \"CERT_FLAGS\", \"data\": enabled},\n                ],\n            )\n            return response\n\n        except WebFault as exception:\n            logger.error(\n                \"Failed to execute SetCertificateFlags for Client -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\n                auth_id,\n                logical_archive,\n                exception,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.__init__","title":"<code>__init__(protocol, hostname, port, ds_username, ds_password, admin_username, admin_password)</code>","text":"<p>Initialize the OTAC object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>Either http or https.</p> required <code>hostname</code> <code>str</code> <p>The hostname of the Archive Center  to communicate with.</p> required <code>port</code> <code>int</code> <p>The port number used to talk to the Archive Center .</p> required <code>ds_username</code> <code>str</code> <p>The admin user name of Archive Center (dsadmin).</p> required <code>ds_password</code> <code>str</code> <p>The admin password of Archive Center (dsadmin).</p> required <code>admin_username</code> <code>str</code> <p>The admin user name of Archive Center (otadmin@otds.admin).</p> required <code>admin_password</code> <code>str</code> <p>The admin password of Archive Center (otadmin@otds.admin).</p> required Source code in <code>pyxecm/otac.py</code> <pre><code>def __init__(\n    self,\n    protocol: str,\n    hostname: str,\n    port: int,\n    ds_username: str,\n    ds_password: str,\n    admin_username: str,\n    admin_password: str,\n):\n    \"\"\"Initialize the OTAC object\n\n    Args:\n        protocol (str): Either http or https.\n        hostname (str): The hostname of the Archive Center  to communicate with.\n        port (int): The port number used to talk to the Archive Center .\n        ds_username (str): The admin user name of Archive Center (dsadmin).\n        ds_password (str): The admin password of Archive Center (dsadmin).\n        admin_username (str): The admin user name of Archive Center (otadmin@otds.admin).\n        admin_password (str): The admin password of Archive Center (otadmin@otds.admin).\n    \"\"\"\n\n    otac_config = {}\n\n    if hostname:\n        otac_config[\"hostname\"] = hostname\n    else:\n        otac_config[\"hostname\"] = \"\"\n\n    if protocol:\n        otac_config[\"protocol\"] = protocol\n    else:\n        otac_config[\"protocol\"] = \"http\"\n\n    if port:\n        otac_config[\"port\"] = port\n    else:\n        otac_config[\"port\"] = 80\n\n    if ds_username:\n        otac_config[\"ds_username\"] = ds_username\n    else:\n        otac_config[\"ds_username\"] = \"dsadmin\"\n\n    if ds_password:\n        otac_config[\"ds_password\"] = ds_password\n    else:\n        otac_config[\"ds_password\"] = \"\"\n\n    if admin_username:\n        otac_config[\"admin_username\"] = admin_username\n    else:\n        otac_config[\"admin_username\"] = \"admin\"\n\n    if admin_password:\n        otac_config[\"admin_password\"] = admin_password\n    else:\n        otac_config[\"admin_password\"] = \"\"\n\n    otac_base_url = protocol + \"://\" + otac_config[\"hostname\"]\n    if str(port) not in [\"80\", \"443\"]:\n        otac_base_url += \":{}\".format(port)\n    otac_exec_url = otac_base_url + \"/archive/admin/exec\"\n    otac_config[\"execUrl\"] = otac_exec_url\n    otac_config[\"baseUrl\"] = otac_base_url\n\n    self._config = otac_config\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.base_url","title":"<code>base_url()</code>","text":"<p>Returns the Archive Center base URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Archive Center base URL</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def base_url(self) -&gt; str:\n    \"\"\"Returns the Archive Center base URL\n\n    Returns:\n        str: Archive Center base URL\n    \"\"\"\n    return self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Returns the configuration dictionary\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    return self._config\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.enable_cert","title":"<code>enable_cert(auth_id, logical_archive, enable=True)</code>","text":"<p>Enables Certitificate on Archive Center</p> <p>Parameters:</p> Name Type Description Default <code>auth_id</code> <code>str</code> <p>Client ID</p> required <code>logical_archive</code> <code>str</code> <p>Archive ID</p> required <code>enable</code> <code>bool</code> <p>Enable or Disable certificate. Defaults to True.</p> <code>True</code> <p>Returns:     response or None if request fails.</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def enable_cert(self, auth_id: str, logical_archive: str, enable: bool = True):\n    \"\"\"Enables Certitificate on Archive Center\n\n    Args:\n        auth_id (str): Client ID\n        logical_archive (str): Archive ID\n        enable (bool, optional): Enable or Disable certificate. Defaults to True.\n    Returns:\n        response or None if request fails.\n    \"\"\"\n\n    if not self._soap_token:\n        self._soap_login()\n\n    if enable:\n        enabled: int = 1\n    else:\n        enabled: int = 0\n\n    url = self.base_url() + \"/ot-admin/services/ArchiveAdministration?wsdl\"\n    client = Client(url)\n\n    token_header = client.factory.create(\"ns0:OTAuthentication\")\n    token_header.AuthenticationToken = self._soap_token\n    client.set_options(soapheaders=token_header)\n\n    try:\n        response = client.service.invokeCommand(\n            command=\"SetCertificateFlags\",\n            parameters=[\n                {\"key\": \"CERT_TYPE\", \"data\": \"@{}\".format(logical_archive)},\n                {\"key\": \"CERT_NAME\", \"data\": auth_id},\n                {\"key\": \"CERT_FLAGS\", \"data\": enabled},\n            ],\n        )\n        return response\n\n    except WebFault as exception:\n        logger.error(\n            \"Failed to execute SetCertificateFlags for Client -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\n            auth_id,\n            logical_archive,\n            exception,\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.exec_command","title":"<code>exec_command(command)</code>","text":"<p>Execute a command on Archive Center</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>command to execute</p> required <p>Returns:     type: description</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def exec_command(self, command: str):\n    \"\"\"Execute a command on Archive Center\n\n    Args:\n        command (str): command to execute\n    Returns:\n        _type_: _description_\n    \"\"\"\n\n    payload = {\n        \"command\": command,\n        \"user\": self.config()[\"ds_username\"],\n        \"passwd\": self.config()[\"ds_password\"],\n    }\n\n    request_url = self.exec_url()\n    logger.info(\n        \"Execute command -&gt; %s on Archive Center (user -&gt; %s); calling -&gt; %s\",\n        command,\n        payload[\"user\"],\n        request_url,\n    )\n    response = requests.post(\n        url=request_url, data=payload, headers=requestHeaders, timeout=None\n    )\n    if not response.ok:\n        logger.error(\n            \"Failed to execute command -&gt; %s on Archive Center; error -&gt; %s\",\n            command,\n            response.text.replace(\"\\n\", \" \"),  # avoid multi-line log entries\n        )\n\n    return response\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.exec_url","title":"<code>exec_url()</code>","text":"<p>Returns the Archive Center URL to execute commands</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Archive Center exec URL</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def exec_url(self) -&gt; str:\n    \"\"\"Returns the Archive Center URL to execute commands\n\n    Returns:\n        str: Archive Center exec URL\n    \"\"\"\n    return self.config()[\"execUrl\"]\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.hostname","title":"<code>hostname()</code>","text":"<p>Returns the Archive Center hostname</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Archive Center hostname</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def hostname(self) -&gt; str:\n    \"\"\"Returns the Archive Center hostname\n\n    Returns:\n        str: Archive Center hostname\n    \"\"\"\n    return self.config()[\"hostname\"]\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.put_cert","title":"<code>put_cert(auth_id, logical_archive, cert_path, permissions='rcud')</code>","text":"<p>Put Certificate on Archive Center</p> <p>Parameters:</p> Name Type Description Default <code>auth_id</code> <code>str</code> <p>ID of Certification</p> required <code>logical_archive</code> <code>str</code> <p>Archive ID</p> required <code>cert_path</code> <code>str</code> <p>local path to certificate (base64)</p> required <code>permissions</code> <code>str</code> <p>Permissions of the certificate.                          Defaults to \"rcud\" (read-create-update-delete).</p> <code>'rcud'</code> <p>Returns:     response or None if the request fails</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def put_cert(\n    self,\n    auth_id: str,\n    logical_archive: str,\n    cert_path: str,\n    permissions: str = \"rcud\",\n):\n    \"\"\"Put Certificate on Archive Center\n\n    Args:\n        auth_id (str): ID of Certification\n        logical_archive (str): Archive ID\n        cert_path (str): local path to certificate (base64)\n        permissions (str, optional): Permissions of the certificate.\n                                     Defaults to \"rcud\" (read-create-update-delete).\n    Returns:\n        response or None if the request fails\n    \"\"\"\n\n    # Check if the photo file exists\n    if not os.path.isfile(cert_path):\n        logger.error(\"Certificate file -&gt; %s not found!\", cert_path)\n        return None\n\n    with open(file=cert_path, mode=\"r\", encoding=\"utf-8\") as cert_file:\n        cert_content = cert_file.read().strip()\n\n    # Check that we have the pem certificate file - this is what OTAC expects.\n    # If the file content is base64 encoded we will decode it\n    if \"BEGIN CERTIFICATE\" in cert_content:\n        logger.info(\"Certificate file -&gt; %s is not base64 encoded\", cert_path)\n    elif \"BEGIN CERTIFICATE\" in base64.b64decode(\n        cert_content, validate=True\n    ).decode(\"utf-8\"):\n        logger.info(\"Certificate file -&gt; %s is base64 encoded\", cert_path)\n        cert_content = base64.b64decode(cert_content, validate=True).decode(\"utf-8\")\n    else:\n        logger.error(\"Certificate file -&gt; %s is not in the right format\", cert_path)\n        return None\n\n    request_url = (\n        self.base_url()\n        + \"/archive?putCert&amp;pVersion=0046&amp;authId=\"\n        + auth_id\n        + \"&amp;contRep=\"\n        + logical_archive\n        + \"&amp;permissions=\"\n        + permissions\n    )\n    logger.info(\n        \"Putting certificate -&gt; %s on Archive -&gt; %s; calling -&gt; %s\",\n        cert_path,\n        logical_archive,\n        request_url,\n    )\n    response = requests.put(\n        url=request_url, data=cert_content, headers=requestHeaders, timeout=None\n    )\n\n    if not response.ok:\n        message = response.text.split(\n            '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN'\n        )[0]\n        logger.error(\n            \"Failed to put certificate -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\n            cert_path,\n            logical_archive,\n            message,\n        )\n\n    return response\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.set_credentials","title":"<code>set_credentials(ds_username='', ds_password='', admin_username='', admin_password='')</code>","text":"<p>Set the credentials for Archive Center for the \"ds\" and \"admin\" users.</p> <p>Parameters:</p> Name Type Description Default <code>ds_username</code> <code>str</code> <p>non-default user name of the \"ds\" user. Defaults to \"\".</p> <code>''</code> <code>ds_password</code> <code>str</code> <p>non-default password of the \"ds\" user. Defaults to \"\".</p> <code>''</code> <code>admin_username</code> <code>str</code> <p>non-default user name of the \"admin\" user. Defaults to \"\".</p> <code>''</code> <code>admin_password</code> <code>str</code> <p>non-default password of the \"admin\" user. Defaults to \"\".</p> <code>''</code> Source code in <code>pyxecm/otac.py</code> <pre><code>def set_credentials(\n    self,\n    ds_username: str = \"\",\n    ds_password: str = \"\",\n    admin_username: str = \"\",\n    admin_password: str = \"\",\n):\n    \"\"\"Set the credentials for Archive Center for the \"ds\" and \"admin\" users.\n\n    Args:\n        ds_username (str, optional): non-default user name of the \"ds\" user. Defaults to \"\".\n        ds_password (str, optional): non-default password of the \"ds\" user. Defaults to \"\".\n        admin_username (str, optional): non-default user name of the \"admin\" user. Defaults to \"\".\n        admin_password (str, optional): non-default password of the \"admin\" user. Defaults to \"\".\n    \"\"\"\n    if ds_username:\n        self.config()[\"ds_username\"] = ds_username\n    else:\n        self.config()[\"ds_username\"] = \"dsadmin\"\n\n    if ds_password:\n        self.config()[\"ds_password\"] = ds_password\n    else:\n        self.config()[\"ds_password\"] = \"\"\n\n    if admin_username:\n        self.config()[\"admin_username\"] = admin_username\n    else:\n        self.config()[\"admin_username\"] = \"admin\"\n\n    if admin_password:\n        self.config()[\"admin_password\"] = admin_password\n    else:\n        self.config()[\"admin_password\"] = \"\"\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.set_hostname","title":"<code>set_hostname(hostname)</code>","text":"<p>Sets the Archive Center hostname</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>new Archive Center hostname</p> required Source code in <code>pyxecm/otac.py</code> <pre><code>def set_hostname(self, hostname: str):\n    \"\"\"Sets the Archive Center hostname\n\n    Args:\n        hostname (str): new Archive Center hostname\n    \"\"\"\n    self.config()[\"hostname\"] = hostname\n</code></pre>"},{"location":"pyxecm/otcs/","title":"Content Server (OTCS)","text":"<p>OTCS Module to implement functions to read / write Content Server objects such as Users, Groups, Nodes, Workspaces, ...</p> <p>Class: OTCS Methods:</p> <p>init : class initializer config : returns config data set cookie : returns cookie information credentials: Get credentials (username and password) set_credentials: Set new credentials hostname: Get the configured OTCS hostname set_hostname: Set the hostname of OTCS base_url : Get OTCS base URL cs_url: Get the Extended ECM (OTCS) URL rest_url : Get OTCS REST base URL</p> <p>request_form_header: Deliver the request header used for the CRUD REST API calls. request_json_header: Deliver the request header for REST calls that require content type application/json. request_download_header: Deliver the request header used for download REST API calls.                          These calls accept application/octet-stream.</p> Converts the text property of a request response object <p>to a Python dict in a safe way</p> <p>lookup_result_value: Lookup a property value based on a provided key / value pair in the response                      properties of an Extended ECM REST API call exist_result_item: Check existence of key / value pair in the response properties of an Extended ECM REST API call. get_result_value: Read an item value from the REST API response. This is considering the most typical structures                   delivered by V2 REST API of Extended ECM</p> <p>is_configured: returns true if the OTCS pod is ready to serve requests authenticate : Authenticates at Content Server and retrieve OTCS Ticket.</p> <p>get_server_info: return OTCS server information</p> <p>apply_config: Apply Content Server administration settings from XML file</p> <p>get_user: Lookup Content Server user add_user: Add Content Server user search_user: Find a user based on search criteria update_user: Update a defined field for a user get_user_profile: Get the profile (settings) for the current user update_user_profile: Update a defined field of the user profile (settings)                      for the current user. update_user_photo: Update a user with a profile photo (which must be an existing node) is_proxy: Check if a user (login name) is a proxy of the current user get_user_proxies: Get the list of proxy users for the current user add_user_proxy: Add a proxy to the current (authenticated) user add_favorite: Add a favorite for the current (authenticated) user add_favorite_tab: Add a favorite tab for the current (authenticated) user</p> <p>get_group: Lookup Content Server group add_group: Add Content Server group get_group_members: Get Content Server group members add_group_member: Add a user or group to a target group</p> <p>get_node: Get a node based on the node ID get_node_by_parent_and_name: Get a node based on the parent ID and name get_node_by_workspace_and_path: Get a node based on the workspace ID and path (list of folder names) get_node_by_volume_and_path: Get a node based on the volume ID and path get_node_from_nickname: Get a node based on the nickname set_node_nickname: Assign a nickname to an Extended ECM node (e.g. workspace) get_subnodes: get children nodes of a parent node get_node_actions: get possible actions for a node rename_node: Change the name and description of a node get_volumes: Get all Volumes get_volume: Get Volume information based on the volume type ID check_node_name: Check if a a node name in a parent location has a name collision upload_file_to_volume: Fetch a file from a URL or local filesystem and upload                     it to a Extended ECM volume upload_file_to_parent: Upload a document to a parent folder add_document_version: Add a version to an Extended ECM document get_latest_document_version: Get latest version of a document node based on the node ID. get_document_content: get content of a document version download_document: Download a document download_config_file: Download a config file from a given OTCS URL.                       This is NOT for downloading documents from within the OTCS repository</p> <p>search: search for a search term using Extended ECM search engine</p> <p>get_external_system_connection: Get Extended ECM external system connection add_external_system_connection: Add Extended ECM external system connection</p> <p>create_transport_workbench: Create a Workbench in the Transport Volume unpack_transport_package: Unpack an existing Transport Package into an existing Workbench deploy_workbench: Deploy an existing Workbench deploy_transport: Main method to deploy a transport. This uses subfunctions to upload,                  unpackage and deploy the transport, and creates the required workbench replace_transport_placeholders: Search and replace strings in the XML files of the transport packlage</p> <p>get_business_object_types: Get information for all configured business object types get_business_object_type: Get information for a specific business object type get_business_objects: Get all business objects for an external system and a given business object type.</p> <p>get_workspace_types: Get all workspace types configured in Extended ECM get_workspace_create_form: Get the Workspace create form get_workspace: Get a workspace node get_workspace_instances: Get all instances of a given workspace type  get_workspace_by_type_and_name: Lookup workspace based on workspace type name and workspace name get_workspace_by_business_object: Lookup workspace based by an business object of an external system create_workspace: Create a new business workspace create_workspace_relationship: Create a relationship between two workspaces get_workspace_relationships: get a list of related workspaces get_workspace_roles: Get the Workspace roles add_member_to_workspace: Add member to workspace role. Check that the user is not yet a member remove_member_from_workspace: Remove member from workspace role assign_workspace_permissions: Update workspace permissions for a given role update_workspace_icon: Update a workspace with a with a new icon (which is uploaded)</p> <p>get_unique_names: Get information on definition of Unique Names.</p> <p>create_item: Create an item in Extended ECM (e.g. folder or URL item) update_item: Update an item in Extended ECM (e.g. folder or URL item) get_document_templates: Get all document templates for a given target location create_document_from_template: Create a document based on a document template</p> <p>get_web_report_parameters: Get parameters of a Web Report run_web_report: Run a Web Report that is identified by its nick name</p> <p>install_cs_application: Install a CS Application (based on WebReports)</p> <p>assign_item_to_user_group: Assign an item (e.g. Workspace or document) to a list of users or groups</p> <p>convert_permission_string_to_permission_value: Convert a list of permission names to a permission value convert_permission_value_to_permission_string: Convert a permission value to a list of permission strings assign_permission: Assign permissions to an item for a defined user or group</p> <p>get_node_categories: Get categories assigned to a node get_node_category: Get a specific category assigned to a node get_node_category_ids: Get list of all category definition IDs that are assign to the node. get_node_category_definition: Get category definition (category id and attribute IDs and types) assign_category: Assign a category to a node set_category_value: Set a value for a specific category attribute to a node</p> <p>assign_classification: Assign a classification to an item assign_rm_classification: Assign a Records management classification to an item</p> <p>register_workspace_template: Register a workspace template for Extended ECM for Engineering</p> <p>get_records_management_rsis: Get the ist of RSIs together with their RSI schedules get_records_management_codes: Get Records Management Codes update_records_management_codes: Update the Records Management Codes create_records_management_rsi: Create a new Records Management RSI item create_records_management_rsi_schedule: Create a schedule for an existing RSI item create_records_management_hold: Create a Records Management Hold get_records_management_holds: Get a list of all Records Management Holds in the system. import_records_management_codes: Import RM codes from a config file import_records_management_rsis: Import RM RSIs from a config file import_records_management_settings: Import Records Management settings from a config file import_physical_objects_codes: Import Physical Objects codes from a config file import_physical_objects_settings: Import Physical Objects settings from a config file import_physical_objects_locators: Import Physical Objects locators from a config file import_security_clearance_codes: Import Securioty Clearance codes from a config file</p> <p>assign_user_security_clearance: Assign a Security Clearance level to a user assign_user_supplemental_markings: Assign a list of Supplemental Markings to a user</p> <p>check_workspace_aviator: Check if Content Aviator is enabled for a workspace update_workspace_aviator: Enable or disable the Content Aviator for a workspace</p>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS","title":"<code>OTCS</code>","text":"<p>Used to automate stettings in OpenText Extended ECM.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>class OTCS:\n    \"\"\"Used to automate stettings in OpenText Extended ECM.\"\"\"\n\n    _config: dict\n    _cookie = None\n    _otcs_ticket = None\n    _otds_ticket = None\n\n    def __init__(\n        self,\n        protocol: str,\n        hostname: str,\n        port: int,\n        public_url: str,\n        username: str | None = None,\n        password: str | None = None,\n        user_partition: str = \"Content Server Members\",\n        resource_name: str = \"cs\",\n        default_license: str = \"X3\",\n        otds_ticket: str | None = None,\n        base_path: str = \"/cs/cs\",\n    ):\n        \"\"\"Initialize the OTCS object\n\n        Args:\n            protocol (str): Either http or https.\n            hostname (str): The hostname of Extended ECM server to communicate with.\n            port (int): The port number used to talk to the Extended ECM server.\n            public_url (str): public (external) URL\n            username (str, optional): The admin user name of Extended ECM. Optional if otds_ticket is provided.\n            password (str, optional): The admin password of Extended ECM. Optional if otds_ticket is provided.\n            user_partition (str): Name of the OTDS partition for OTCS users. Default is \"Content Server Members\".\n            resource_name (str, optional): Name of the OTDS resource for OTCS. Dault is \"cs\".\n            default_license (str, optional): name of the default user license. Default is \"X3\".\n            otds_ticket (str, optional): Authentication ticket of OTDS\n            base_path (str, optional): Base Path of OTCS. Default is \"/cs/cs\".\n        \"\"\"\n\n        # Initialize otcs_config as an empty dictionary\n        otcs_config = {}\n\n        if hostname:\n            otcs_config[\"hostname\"] = hostname\n        else:\n            otcs_config[\"hostname\"] = \"otcs-admin-0\"\n\n        if protocol:\n            otcs_config[\"protocol\"] = protocol\n        else:\n            otcs_config[\"protocol\"] = \"http\"\n\n        if port:\n            otcs_config[\"port\"] = port\n        else:\n            otcs_config[\"port\"] = 8080\n\n        otcs_config[\"publicUrl\"] = public_url\n\n        if username:\n            otcs_config[\"username\"] = username\n        else:\n            otcs_config[\"username\"] = \"admin\"\n\n        if password:\n            otcs_config[\"password\"] = password\n        else:\n            otcs_config[\"password\"] = \"\"\n\n        if user_partition:\n            otcs_config[\"partition\"] = user_partition\n        else:\n            otcs_config[\"partition\"] = \"\"\n\n        if resource_name:\n            otcs_config[\"resource\"] = resource_name\n        else:\n            otcs_config[\"resource\"] = \"\"\n\n        if default_license:\n            otcs_config[\"license\"] = default_license\n        else:\n            otcs_config[\"license\"] = \"\"\n\n        otcs_base_url = protocol + \"://\" + otcs_config[\"hostname\"]\n        if str(port) not in [\"80\", \"443\"]:\n            otcs_base_url += \":{}\".format(port)\n        otcs_config[\"baseUrl\"] = otcs_base_url\n        otcs_support_url = otcs_base_url + \"/cssupport\"\n        otcs_config[\"supportUrl\"] = otcs_support_url\n        otcs_public_support_url = public_url + \"/cssupport\"\n        otcs_config[\"supportPublicUrl\"] = otcs_public_support_url\n\n        otcs_config[\"configuredUrl\"] = otcs_support_url + \"/csconfigured\"\n\n        otcs_url = otcs_base_url + base_path\n        otcs_config[\"csUrl\"] = otcs_url\n        otcs_public_url = public_url + base_path\n        otcs_config[\"csPublicUrl\"] = otcs_public_url\n\n        otcs_rest_url = otcs_url + \"/api\"\n        otcs_config[\"restUrl\"] = otcs_rest_url\n\n        otcs_config[\"isReady\"] = otcs_rest_url + \"/v1/ping\"\n        otcs_config[\"authenticationUrl\"] = otcs_rest_url + \"/v1/auth\"\n        otcs_config[\"serverInfoUrl\"] = otcs_rest_url + \"/v1/serverinfo\"\n        otcs_config[\"membersUrl\"] = otcs_rest_url + \"/v1/members\"\n        otcs_config[\"membersUrlv2\"] = otcs_rest_url + \"/v2/members\"\n        otcs_config[\"nodesUrl\"] = otcs_rest_url + \"/v1/nodes\"\n        otcs_config[\"nodesUrlv2\"] = otcs_rest_url + \"/v2/nodes\"\n        otcs_config[\"doctemplatesUrl\"] = otcs_rest_url + \"/v2/doctemplates\"\n        otcs_config[\"nicknameUrl\"] = otcs_rest_url + \"/v2/nicknames\"\n        otcs_config[\"importSettingsUrl\"] = otcs_rest_url + \"/v2/import/settings/admin\"\n        otcs_config[\"searchUrl\"] = otcs_rest_url + \"/v2/search\"\n        otcs_config[\"volumeUrl\"] = otcs_rest_url + \"/v2/volumes\"\n        otcs_config[\"externalSystemUrl\"] = otcs_rest_url + \"/v2/externalsystems\"\n        otcs_config[\"businessObjectsUrl\"] = otcs_rest_url + \"/v2/businessobjects\"\n        otcs_config[\"businessObjectTypesUrl\"] = (\n            otcs_rest_url + \"/v2/businessobjecttypes\"\n        )\n        otcs_config[\"businessObjectsSearchUrl\"] = (\n            otcs_rest_url + \"/v2/forms/businessobjects/search\"\n        )\n        otcs_config[\"businessWorkspaceTypesUrl\"] = (\n            otcs_rest_url + \"/v2/businessworkspacetypes\"\n        )\n        otcs_config[\"businessworkspacecreateform\"] = (\n            otcs_rest_url + \"/v2/forms/businessworkspaces/create\"\n        )\n        otcs_config[\"businessWorkspacesUrl\"] = otcs_rest_url + \"/v2/businessworkspaces\"\n        otcs_config[\"uniqueNamesUrl\"] = otcs_rest_url + \"/v2/uniquenames\"\n        otcs_config[\"favoritesUrl\"] = otcs_rest_url + \"/v2/members/favorites\"\n        otcs_config[\"webReportsUrl\"] = otcs_rest_url + \"/v1/webreports\"\n        otcs_config[\"csApplicationsUrl\"] = otcs_rest_url + \"/v2/csapplications\"\n        otcs_config[\"xEngProjectTemplateUrl\"] = (\n            otcs_rest_url + \"/v2/xengcrt/projecttemplate\"\n        )\n        otcs_config[\"rsisUrl\"] = otcs_rest_url + \"/v2/rsis\"\n        otcs_config[\"rsiSchedulesUrl\"] = otcs_rest_url + \"/v2/rsischedules\"\n        otcs_config[\"recordsManagementUrl\"] = otcs_rest_url + \"/v1/recordsmanagement\"\n        otcs_config[\"recordsManagementUrlv2\"] = otcs_rest_url + \"/v2/recordsmanagement\"\n        otcs_config[\"userSecurityUrl\"] = otcs_rest_url + \"/v2/members/usersecurity\"\n        otcs_config[\"physicalObjectsUrl\"] = otcs_rest_url + \"/v1/physicalobjects\"\n        otcs_config[\"securityClearancesUrl\"] = otcs_rest_url + \"/v1/securityclearances\"\n        otcs_config[\"holdsUrl\"] = otcs_rest_url + \"/v1/holds\"\n        otcs_config[\"holdsUrlv2\"] = otcs_rest_url + \"/v2/holds\"\n        otcs_config[\"validationUrl\"] = otcs_rest_url + \"/v1/validation/nodes/names\"\n        otcs_config[\"aiUrl\"] = otcs_rest_url + \"/v2/ai/nodes\"\n\n        self._config = otcs_config\n        self._otds_ticket = otds_ticket\n\n    def config(self) -&gt; dict:\n        \"\"\"Returns the configuration dictionary\n\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\n        return self._config\n\n    def cookie(self) -&gt; dict:\n        \"\"\"Returns the login cookie of Extended ECM.\n           This is set by the authenticate() method\n\n        Returns:\n            dict: Estended ECM cookie\n        \"\"\"\n        return self._cookie\n\n    def credentials(self) -&gt; dict:\n        \"\"\"Get credentials (username + password)\n\n        Returns:\n            dict: dictionary with username and password\n        \"\"\"\n        return {\n            \"username\": self.config()[\"username\"],\n            \"password\": self.config()[\"password\"],\n        }\n\n    def set_credentials(self, username: str = \"admin\", password: str = \"\"):\n        \"\"\"Set the credentials for Extended ECM for the based on user name and password.\n\n        Args:\n            username (str, optional): Username. Defaults to \"admin\".\n            password (str, optional): Password of the user. Defaults to \"\".\n        \"\"\"\n        self.config()[\"username\"] = username\n        self.config()[\"password\"] = password\n\n    def hostname(self) -&gt; str:\n        \"\"\"Returns the hostname of Extended ECM (e.g. \"otcs\")\n\n        Returns:\n            str: hostname\n        \"\"\"\n        return self.config()[\"hostname\"]\n\n    def set_hostname(self, hostname: str):\n        \"\"\"Sets the hostname of Extended ECM\n\n        Args:\n            hostname (str): new hostname\n        \"\"\"\n        self.config()[\"hostname\"] = hostname\n\n    def base_url(self) -&gt; str:\n        \"\"\"Returns the base URL of Extended ECM\n\n        Returns:\n            str: base URL\n        \"\"\"\n        return self.config()[\"baseUrl\"]\n\n    def cs_url(self) -&gt; str:\n        \"\"\"Returns the Extended ECM URL\n\n        Returns:\n            str: Extended ECM URL\n        \"\"\"\n        return self.config()[\"csUrl\"]\n\n    def cs_public_url(self) -&gt; str:\n        \"\"\"Returns the public (external) Extended ECM URL (incl. base_path /cs/cs )\n\n        Returns:\n            str: Extended ECM Public URL\n        \"\"\"\n        return self.config()[\"csPublicUrl\"]\n\n    def cs_support_url(self) -&gt; str:\n        \"\"\"Returns the Extended ECM Support URL\n\n        Returns:\n            str: Extended ECM Support URL\n        \"\"\"\n        return self.config()[\"supportUrl\"]\n\n    def cs_support_public_url(self) -&gt; str:\n        \"\"\"Returns the Extended ECM Public Support URL\n\n        Returns:\n            str: Extended ECM Public Support URL\n        \"\"\"\n        return self.config()[\"supportPublicUrl\"]\n\n    def rest_url(self) -&gt; str:\n        \"\"\"Returns the REST URL of Extended ECM\n\n        Returns:\n            str: REST URL\n        \"\"\"\n        return self.config()[\"restUrl\"]\n\n    def request_form_header(self) -&gt; dict:\n        \"\"\"Deliver the request header used for the CRUD REST API calls.\n           Consists of Cookie + Form Headers (see global variable)\n\n        Args:\n            None.\n        Return:\n            dict: request header values\n        \"\"\"\n\n        # create union of two dicts: cookie and headers\n        # (with Python 3.9 this would be easier with the \"|\" operator)\n        request_header = {}\n        request_header.update(self.cookie())\n        request_header.update(REQUEST_FORM_HEADERS)\n\n        return request_header\n\n    # end method definition\n\n    def request_json_header(self) -&gt; dict:\n        \"\"\"Deliver the request header for REST calls that require content type application/json.\n           Consists of Cookie + Json Headers (see global variable)\n\n        Args:\n            None.\n        Return:\n            dict: request header values\n        \"\"\"\n\n        # create union of two dicts: cookie and headers\n        # (with Python 3.9 this would be easier with the \"|\" operator)\n        request_header = {}\n        request_header.update(self.cookie())\n        request_header.update(REQUEST_JSON_HEADERS)\n\n        return request_header\n\n    # end method definition\n\n    def request_download_header(self) -&gt; dict:\n        \"\"\"Deliver the request header used for the CRUD REST API calls.\n           Consists of Cookie + Form Headers (see global vasriable)\n\n        Args:\n            None.\n        Return:\n            dict: request header values\n        \"\"\"\n\n        # create union of two dicts: cookie and headers\n        # (with Python 3.9 this would be easier with the \"|\" operator)\n        request_header = {}\n        request_header.update(self.cookie())\n        request_header.update(REQUEST_DOWNLOAD_HEADERS)\n\n        return request_header\n\n    # end method definition\n\n    def parse_request_response(\n        self,\n        response_object: object,\n        additional_error_message: str = \"\",\n        show_error: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Converts the text property of a request response object to a Python dict in a safe way\n            that also handles exceptions.\n\n            Content Server may produce corrupt response when it gets restarted\n            or hitting resource limits. So we try to avoid a fatal error and bail\n            out more gracefully.\n\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str): print a custom error message\n            show_error (bool): if True log an error, if False log a warning\n\n        Returns:\n            dict: response or None in case of an error\n        \"\"\"\n\n        if not response_object:\n            return None\n\n        try:\n            dict_object = json.loads(response_object.text)\n        except json.JSONDecodeError as exception:\n            if additional_error_message:\n                message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                    additional_error_message, exception\n                )\n            else:\n                message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                    exception\n                )\n            if show_error:\n                logger.error(message)\n            else:\n                logger.warning(message)\n            return None\n        else:\n            return dict_object\n\n    # end method definition\n\n    def lookup_result_value(\n        self, response: dict, key: str, value: str, return_key: str\n    ) -&gt; str | None:\n        \"\"\"Lookup a property value based on a provided key / value pair in the\n           response properties of an Extended ECM REST API call.\n\n        Args:\n            response (dict): REST response from an OTCS REST Call\n            key (str): property name (key)\n            value (str): value to find in the item with the matching key\n            return_key (str): determines which value to return based on the name of the dict key\n        Returns:\n            str: value of the property with the key defined in \"return_key\"\n                 or None if the lookup fails\n        \"\"\"\n\n        if not response:\n            return None\n        if not \"results\" in response:\n            return None\n\n        results = response[\"results\"]\n        # check if results is a list or a dict (both is possible -\n        # dependent on the actual REST API):\n        if isinstance(results, dict):\n            # result is a dict - we don't need index value:\n            data = results[\"data\"]\n            if isinstance(data, dict):\n                # data is a dict - we don't need index value:\n                properties = data[\"properties\"]\n                if (\n                    key in properties\n                    and properties[key] == value\n                    and return_key in properties\n                ):\n                    return properties[return_key]\n                else:\n                    return None\n            elif isinstance(data, list):\n                # data is a list - this has typically just one item, so we use 0 as index\n                for item in data:\n                    properties = item[\"properties\"]\n                    if (\n                        key in properties\n                        and properties[key] == value\n                        and return_key in properties\n                    ):\n                        return properties[return_key]\n                return None\n            else:\n                logger.error(\n                    \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n                )\n                return None\n        elif isinstance(results, list):\n            # result is a list - we need index value\n            for result in results:\n                data = result[\"data\"]\n                if isinstance(data, dict):\n                    # data is a dict - we don't need index value:\n                    properties = data[\"properties\"]\n                    if (\n                        key in properties\n                        and properties[key] == value\n                        and return_key in properties\n                    ):\n                        return properties[return_key]\n                elif isinstance(data, list):\n                    # data is a list we iterate through the list and try to find the key:\n                    for item in data:\n                        properties = item[\"properties\"]\n                        if (\n                            key in properties\n                            and properties[key] == value\n                            and return_key in properties\n                        ):\n                            return properties[return_key]\n                else:\n                    logger.error(\n                        \"Data needs to be a list or dict but it is -&gt; %s\",\n                        str(type(data)),\n                    )\n                    return None\n            return None\n        else:\n            logger.error(\n                \"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n            )\n            return None\n\n    # end method definition\n\n    def exist_result_item(\n        self, response: dict, key: str, value: str, property_name: str = \"properties\"\n    ) -&gt; bool:\n        \"\"\"Check existence of key / value pair in the response properties of an Extended ECM REST API call.\n\n        Args:\n            response (dict): REST response from an OTCS REST Call\n            key (str): property name (key)\n            value (str): value to find in the item with the matching key\n            property_name (str, optional): name of the substructure that includes the values\n        Returns:\n            bool: True if the value was found, False otherwise\n        \"\"\"\n\n        if not response:\n            return False\n        if not \"results\" in response:\n            return False\n\n        results = response[\"results\"]\n        # check if results is a list or a dict (both is possible - dependent on the actual REST API):\n        if isinstance(results, dict):\n            # result is a dict - we don't need index value:\n            if not \"data\" in results:\n                return False\n            data = results[\"data\"]\n            if isinstance(data, dict):\n                # data is a dict - we don't need index value:\n                if property_name and not property_name in data:\n                    logger.error(\n                        \"There's no -&gt; %s dictionary in data -&gt; %s\", property_name, data\n                    )\n                    return False\n                properties = data[property_name]\n                if isinstance(properties, dict):\n                    if key in properties:\n                        return properties[key] == value\n                    else:\n                        return False\n                elif isinstance(properties, list):\n                    # properties is a list we iterate through the list and try to find the key:\n                    for item in properties:\n                        if key in item and item[key] == value:\n                            return True\n                else:\n                    logger.error(\n                        \"Properties needs to be a list or dict but it is -&gt; %s\",\n                        str(type(properties)),\n                    )\n                    return False\n            elif isinstance(data, list):\n                # data is a list\n                for item in data:\n                    if property_name and not property_name in item:\n                        logger.error(\n                            \"There's no -&gt; %s dictionary in the data list item -&gt; %s\",\n                            property_name,\n                            item,\n                        )\n                        continue\n                    # if properties if passed as empty string then we assume that\n                    # the key fields are directly in the item dictionary. This is\n                    # the case e.g. with the V2 Proxy APIs\n                    if not property_name:\n                        properties = item\n                    else:\n                        properties = item[property_name]\n                    if key in properties and properties[key] == value:\n                        return True\n                return False\n            else:\n                logger.error(\n                    \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n                )\n                return False\n        elif isinstance(results, list):\n            # result is a list - we need index value\n            for result in results:\n                if not \"data\" in result:\n                    continue\n                data = result[\"data\"]\n                if isinstance(data, dict):\n                    # data is a dict - we don't need index value:\n                    properties = data[property_name]\n                    if key in properties and properties[key] == value:\n                        return True\n                elif isinstance(data, list):\n                    # data is a list we iterate through the list and try to find the key:\n                    for item in data:\n                        properties = item[property_name]\n                        if key in properties and properties[key] == value:\n                            return True\n                else:\n                    logger.error(\n                        \"Data needs to be a list or dict but it is -&gt; %s\",\n                        str(type(data)),\n                    )\n                    return False\n            return False\n        else:\n            logger.error(\n                \"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n            )\n            return False\n\n    # end method definition\n\n    def get_result_value(\n        self,\n        response: dict,\n        key: str,\n        index: int = 0,\n        property_name: str = \"properties\",\n    ) -&gt; str | None:\n        \"\"\"Read an item value from the REST API response. This is considering\n           the most typical structures delivered by V2 REST API of Extended ECM.\n           See developer.opentext.com for more details.\n\n        Args:\n            response (dict): REST API response object\n            key (str): key to find (e.g. \"id\", \"name\", ...)\n            index (int, optional): In case a list of results is delivered the index\n                                   to use (1st element has index  0). Defaults to 0.\n            property_name (str, optional): name of the sub dictionary holding the actual values.\n                                           Default is \"properties\".\n        Returns:\n            str: value of the item with the given key for None if no value is found for the given key.\n        \"\"\"\n\n        # First do some sanity checks:\n        if not response:\n            logger.info(\"Empty REST response - returning None\")\n            return None\n        if not \"results\" in response:\n            logger.error(\"No 'results' key in REST response - returning None\")\n            return None\n\n        results = response[\"results\"]\n        if not results:\n            logger.info(\"No results found!\")\n            return None\n\n        # check if results is a list or a dict (both is possible - dependent on the actual REST API):\n        if isinstance(results, dict):\n            # result is a dict - we don't need index value\n\n            # this is a special treatment for the businessworkspaces REST API - it returns\n            # for \"Create business workspace\" the ID directly in the results dict (without data substructure)\n            if key in results:\n                return results[key]\n            data = results[\"data\"]\n            if isinstance(data, dict):\n                # data is a dict - we don't need index value:\n                properties = data[property_name]\n            elif isinstance(data, list):\n                # data is a list - this has typically just one item, so we use 0 as index\n                properties = data[0][property_name]\n            else:\n                logger.error(\n                    \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n                )\n                return None\n            logger.debug(\"Properties of results (dict) -&gt; %s\", str(properties))\n            # For nearly all OTCS REST Calls perperties is a dict:\n            if isinstance(properties, dict):\n                if not key in properties:\n                    logger.error(\"Key -&gt; %s is not in result properties!\", key)\n                    return None\n                return properties[key]\n            # but there are some strange ones that have other names for\n            # properties and may use a list - see e.g. /v2/holds\n            elif isinstance(properties, list):\n                if index &gt; len(properties) - 1:\n                    logger.error(\n                        \"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\n                        str(index),\n                        str(len(properties)),\n                    )\n                    return None\n                return properties[index][key]\n            else:\n                logger.error(\n                    \"Properties needs to be a list or dict but it is -&gt; %s\",\n                    str(type(properties)),\n                )\n                return False\n        elif isinstance(results, list):\n            # result is a list - we need a valid index:\n            if index &gt; len(results) - 1:\n                logger.error(\n                    \"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\n                    str(index),\n                    str(len(results)),\n                )\n                return None\n            data = results[index][\"data\"]\n            if isinstance(data, dict):\n                # data is a dict - we don't need index value:\n                properties = data[property_name]\n            elif isinstance(data, list):\n                # data is a list - this has typically just one item, so we use 0 as index\n                properties = data[0][property_name]\n            else:\n                logger.error(\n                    \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n                )\n                return None\n            logger.debug(\n                \"Properties of results (list, index -&gt; %s) -&gt; %s\",\n                str(index),\n                properties,\n            )\n            if not key in properties:\n                logger.error(\"Key -&gt; %s is not in result properties!\", key)\n                return None\n            return properties[key]\n        else:\n            logger.error(\n                \"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n            )\n            return None\n\n    # end method definition\n\n    def is_configured(self) -&gt; bool:\n        \"\"\"Checks if the Content Server pod is configured to receive requests.\n\n        Args:\n            None.\n        Returns:\n            bool: True if pod is ready. False if pod is not yet ready.\n        \"\"\"\n\n        request_url = self.config()[\"configuredUrl\"]\n\n        logger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\n\n        try:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_JSON_HEADERS,\n                timeout=REQUEST_TIMEOUT,\n            )\n        except requests.exceptions.RequestException as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s; warning -&gt; %s\",\n                request_url,\n                exception.strerror,\n            )\n            logger.warning(\"OTCS service may not be ready yet.\")\n            return False\n\n        if not response.ok:\n            logger.warning(\n                \"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\n                request_url,\n                response.status_code,\n                response.text,\n            )\n            return False\n\n        return True\n\n    # end method definition\n\n    def is_ready(self) -&gt; bool:\n        \"\"\"Checks if the Content Server pod is ready to receive requests.\n\n        Args:\n            None.\n        Returns:\n            bool: True if pod is ready. False if pod is not yet ready.\n        \"\"\"\n\n        request_url = self.config()[\"isReady\"]\n\n        logger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\n\n        try:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_JSON_HEADERS,\n                timeout=2,\n            )\n        except requests.exceptions.RequestException as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s; warning -&gt; %s\",\n                request_url,\n                exception.strerror,\n            )\n            logger.warning(\"OTCS service may not be ready yet.\")\n            return False\n\n        if not response.status_code == 200:\n            logger.warning(\n                \"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\n                request_url,\n                response.status_code,\n                response.text,\n            )\n            return False\n\n        return True\n\n    # end method definition\n\n    def authenticate(self, revalidate: bool = False) -&gt; dict | None:\n        \"\"\"Authenticates at Content Server and retrieve OTCS Ticket.\n\n        Args:\n            revalidate (bool, optional): determinse if a re-athentication is enforced\n                                         (e.g. if session has timed out with 401 error)\n                                         By default we use the OTDS ticket (if exists) for the authentication with OTCS.\n                                         This switch allows the forced usage of username / password for the authentication.\n        Returns:\n            dict: Cookie information of None in case of an error.\n                  Also stores cookie information in self._cookie\n        \"\"\"\n\n        # Already authenticated and session still valid?\n        if self._cookie and not revalidate:\n            logger.info(\n                \"Session still valid - return existing cookie -&gt; %s\",\n                str(self._cookie),\n            )\n            return self._cookie\n\n        otcs_ticket = None\n\n        logger.info(\"Wait for OTCS to be ready...\")\n        while not self.is_ready():\n            logger.warning(\n                \"OTCS is not ready to receive requests yet. Waiting 30 seconds...\"\n            )\n            time.sleep(30)\n\n        request_url = self.config()[\"authenticationUrl\"]\n\n        if self._otds_ticket and not revalidate:\n            logger.info(\n                \"Requesting OTCS ticket with OTDS ticket; calling -&gt; %s\",\n                request_url,\n            )\n            request_header = {\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"Accept\": \"application/json\",\n                \"OTDSTicket\": self._otds_ticket,\n            }\n\n            try:\n                response = requests.get(\n                    url=request_url, headers=request_header, timeout=10\n                )\n                if response.ok:\n                    otcs_ticket = response.headers.get(\"OTCSTicket\")\n\n            except requests.exceptions.RequestException as exception:\n                logger.warning(\n                    \"Unable to connect to -&gt; %s; error -&gt; %s\",\n                    request_url,\n                    exception.strerror,\n                )\n\n        # Check if previous authentication was not successful.\n        # Then we do the normal username + password authentication:\n        if not otcs_ticket:\n            logger.info(\n                \"Requesting OTCS ticket with User/Password; calling -&gt; %s\",\n                request_url,\n            )\n\n            response = None\n            try:\n                response = requests.post(\n                    url=request_url,\n                    data=self.credentials(),  # this includes username + password\n                    headers=REQUEST_FORM_HEADERS,\n                    timeout=REQUEST_TIMEOUT,\n                )\n            except requests.exceptions.RequestException as exception:\n                logger.warning(\n                    \"Unable to connect to -&gt; %s; error -&gt; %s\",\n                    request_url,\n                    exception.strerror,\n                )\n                logger.warning(\"OTCS service may not be ready yet.\")\n                return None\n\n            if response.ok:\n                authenticate_dict = self.parse_request_response(\n                    response, \"This can be normal during restart\", False\n                )\n                if not authenticate_dict:\n                    return None\n                else:\n                    otcs_ticket = authenticate_dict[\"ticket\"]\n                    logger.info(\"Ticket -&gt; %s\", otcs_ticket)\n            else:\n                logger.error(\n                    \"Failed to request an OTCS ticket; error -&gt; %s\", response.text\n                )\n                return None\n\n        # Store authentication ticket:\n        self._cookie = {\"otcsticket\": otcs_ticket, \"LLCookie\": otcs_ticket}\n        self._otcs_ticket = otcs_ticket\n\n        return self._cookie\n\n    # end method definition\n\n    def get_server_info(self) -&gt; dict | None:\n        \"\"\"Get Content Server information (server info)\n\n        Args:\n            None\n        Returns:\n            dict: server information or None if the call fails\n\n            Example response:\n            {\n                'mobile': {\n                    'cs_viewer_support': False,\n                    'offline_use': True\n                },\n                'server': {\n                    'advanced_versioning': True,\n                    'character_encoding': 1,\n                    'current_date': '2023-09-05T17:09:41',\n                    'current_locale_suffix': '_en_US',\n                    'domain_access_enabled': False,\n                    'enhanced_advanced_versioning': False,\n                    'force_download_for_mime_types': [...],\n                    'language_code': 'USA',\n                    'languages': [...],\n                    'metadata_languages: [...],\n                    'url': 'https://otcs.dev.idea-te.eimdemo.com/cs/cs'\n                    'version': '23.3'\n                    ...\n                },\n                'sessions': {\n                    'enabled': True,\n                    'expire_after_last_login': False,\n                    'expire_after_last_request': True,\n                    'logout_url': '?func=ll.DoLogout&amp;secureRequestToken=LUAQSY%2BJs4KnlwoVgxLtxQFYrov2XefJQM9ShyhOK93Mzp3ymCxX6IGMTtUgNvTH7AYVt%2BbWLEw%3D',\n                    'session_inactivity': 7020000,\n                    'session_reaction_time': 180000,\n                    'session_timeout': 7200000\n                },\n                'viewer': {\n                    'content_suite': {...}\n                }\n            }\n        \"\"\"\n\n        request_url = self.config()[\"serverInfoUrl\"]\n        request_header = self._cookie\n\n        logger.info(\n            \"Retrieve Extended ECM server information; calling -&gt; %s\", request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to retrieve Extended ECM server information; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_server_version(self) -&gt; str | None:\n        \"\"\"Get Content Server version\n\n        Args:\n            None\n        Returns:\n            str: server version number like 23.4\n        \"\"\"\n\n        response = self.get_server_info()\n        if not response:\n            return None\n\n        server_info = response.get(\"server\")\n        if not server_info:\n            return None\n\n        return server_info.get(\"version\")\n\n    # end method definition\n\n    def apply_config(self, xml_file_path: str) -&gt; dict | None:\n        \"\"\"Apply Content Server administration settings from XML file\n\n        Args:\n            xml_file_path (str): name + path of the XML settings file\n        Returns:\n            dict: Import response or None if the import fails.\n                  The field response[\"results\"][\"data\"][\"restart\"] indicates if the settings\n                  require a restart of the OTCS services.\n        \"\"\"\n\n        filename = os.path.basename(xml_file_path)\n\n        if not os.path.exists(xml_file_path):\n            logger.error(\n                \"The admin settings file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(xml_file_path),\n            )\n            return None\n\n        llconfig_file = {\n            \"file\": (filename, open(file=xml_file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        request_url = self.config()[\"importSettingsUrl\"]\n        request_header = self._cookie\n\n        logger.info(\n            \"Applying admin settings from file -&gt; %s; calling -&gt; %s\",\n            xml_file_path,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                files=llconfig_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                logger.debug(\n                    \"Admin settings in file -&gt; %s have been applied\", xml_file_path\n                )\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import settings file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    xml_file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_user(self, name: str, show_error: bool = False) -&gt; dict | None:\n        \"\"\"Lookup Extended ECM user based on the name.\n\n        Args:\n            name (str): name of the user\n            show_error (bool): treat as error if user is not found\n        Returns:\n            dict: User information or None if the user is not found.\n            The returned information has a structure like this:\n\n            {\n                'collection':\n                {\n                    'paging': {...},\n                    'sorting': {...}\n                },\n                'links':\n                {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data':\n                        {\n                            {\n                                'birth_date': None,\n                                'business_email': 'pramos@M365x61936377.onmicrosoft.com',\n                                'business_fax': None,\n                                'business_phone': None,\n                                'cell_phone': None,\n                                'deleted': False,\n                                'display_language': None,\n                                'first_name': 'Peter',\n                                'gender': None,\n                                'group_id': 8006,\n                                'home_address_1': None,\n                                'home_address_2': None,\n                                'home_fax': None,\n                                'home_phone': None,\n                                'id': 8123,\n                                'initials': None,\n                                'last_name': 'Ramos',\n                                'middle_name': None,\n                                'name': 'pramos',\n                                'name_formatted': 'Peter Ramos',\n                                ...\n                                'photo_id': 13981,\n                                'photo_url': 'api/v1/members/8123/photo?v=13981.1'\n                                ...\n                                'type'; 0,\n                                'type_name': 'User'\n                                }\n                        }\n                    }\n                ]\n            }\n            To access the (login) name of the first user found use [\"results\"][0][\"data\"][\"properties\"][\"name\"].\n            It is easier to use the method get_result_value(response, \"name\", 0)\n        \"\"\"\n\n        # Add query parameters (these are NOT passed via JSon body!)\n        # type = 0 ==&gt; User\n        request_url = self.config()[\"membersUrlv2\"] + \"?where_type=0&amp;query={}\".format(\n            name\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\"Get user with name -&gt; %s; calling -&gt; %s\", name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        name,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"User -&gt; %s not found.\", name)\n                return None\n\n    # end method definition\n\n    def add_user(\n        self,\n        name: str,\n        password: str,\n        first_name: str,\n        last_name: str,\n        email: str,\n        title: str,\n        base_group: int,\n        privileges: list | None = None,\n    ) -&gt; dict | None:\n        \"\"\"Add Content Server user.\n\n        Args:\n            name (str): login name of the user\n            password (str): password of the user\n            first_name (str): first name of the user\n            last_name (str): last name of the user\n            email (str): email address of the user\n            title (str): title of the user\n            base_group (int): base group id of the user (e.g. department)\n            privileges (list, optional): values are Login, Public Access, Content Manager,\n                                         Modify Users, Modify Groups, User Admin Rights,\n                                         Grant Discovery, System Admin Rights\n        Returns:\n            dict: User information or None if the user couldn't be created (e.g. because it exisits already).\n        \"\"\"\n\n        if privileges is None:\n            privileges = [\"Login\", \"Public Access\"]\n\n        user_post_body = {\n            \"type\": 0,\n            \"name\": name,\n            \"password\": password,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"business_email\": email,\n            \"title\": title,\n            \"group_id\": base_group,\n            \"privilege_login\": (\"Login\" in privileges),\n            \"privilege_public_access\": (\"Public Access\" in privileges),\n            \"privilege_content_manager\": (\"Content Manager\" in privileges),\n            \"privilege_modify_users\": (\"Modify Users\" in privileges),\n            \"privilege_modify_groups\": (\"Modify Groups\" in privileges),\n            \"privilege_user_admin_rights\": (\"User Admin Rights\" in privileges),\n            \"privilege_grant_discovery\": (\"Grant Discovery\" in privileges),\n            \"privilege_system_admin_rights\": (\"System Admin Rights\" in privileges),\n        }\n\n        request_url = self.config()[\"membersUrlv2\"]\n        request_header = self.request_form_header()\n\n        logger.info(\"Adding user -&gt; %s; calling -&gt; %s\", name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=user_post_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def search_user(self, value: str, field: str = \"where_name\") -&gt; dict | None:\n        \"\"\"Find a user based on search criteria.\n\n        Args:\n            value (str): field value\n            field (str): user field to search with (where_name, where_first_name, where_last_name)\n        Returns:\n            dict: User information or None if the user couldn't be found (e.g. because it doesn't exist).\n\n            Example response:\n            {\n                'collection': {\n                    'paging': {...},\n                    'sorting': {...}\n                },\n                'links': {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data': {\n                            'properties': {\n                                'birth_date': None,\n                                'business_email': 'dfoxhoven@M365x61936377.onmicrosoft.com',\n                                'business_fax': None,\n                                'business_phone': None,\n                                'cell_phone': None,\n                                'deleted': False,\n                                'display_language': None,\n                                'first_name': 'Deke',\n                                'gender': None,\n                                'group_id': 8005,\n                                'home_address_1': None,\n                                'home_address_2': None,\n                                'home_fax': None,\n                                'home_phone': None,\n                                'id': 8562,\n                                'initials': 'DF',\n                                'last_name': 'Foxhoven',\n                                'middle_name': None,\n                                'name': 'dfoxhoven',\n                                'name_formatted': 'Deke Foxhoven',\n                                ...\n                            }\n                        }\n                    }\n                ]\n            }\n        \"\"\"\n\n        request_url = self.config()[\"membersUrlv2\"] + \"?\" + field + \"=\" + value\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Searching user by field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\n            field,\n            value,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Cannot find user with -&gt; %s = %s; status -&gt; %s; error -&gt; %s\",\n                    field,\n                    value,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def update_user(self, user_id: int, field: str, value: str) -&gt; dict | None:\n        \"\"\"Update a defined field for a user.\n\n        Args:\n            user_id (int): ID of the user\n            value (str): field value\n            field (str): user field\n        Returns:\n            dict: User information or None if the user couldn't be updated (e.g. because it doesn't exist).\n        \"\"\"\n\n        user_put_body = {field: value}\n\n        request_url = self.config()[\"membersUrlv2\"] + \"/\" + str(user_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Updating user with ID -&gt; %s, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\n            str(user_id),\n            field,\n            value,\n            request_url,\n        )\n        logger.debug(\"User Attributes -&gt; %s\", str(user_put_body))\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                data=user_put_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(user_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_user_profile(self) -&gt; dict | None:\n        \"\"\"Update a defined field for a user profile.\n           IMPORTANT: this method needs to be called by the authenticated user\n\n        Args:\n            field (str): user profile field\n            value (str): new field value\n        Returns:\n            dict: User information or None if the user couldn't be updated\n                  (e.g. because it doesn't exist).\n        \"\"\"\n\n        request_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get profile (settings) for current user; calling -&gt; %s\",\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get profile of current user; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def update_user_profile(\n        self, field: str, value: str, config_section: str = \"SmartUI\"\n    ) -&gt; dict | None:\n        \"\"\"Update a defined field for a user profile.\n           IMPORTANT: this method needs to be called by the authenticated user\n\n        Args:\n            field (str): user profile field\n            value (str): new field value\n            config_section (str, optional): name of the config section. Possible config_section values:\n                                            * SmartUI\n                                            * General\n                                            * Colors\n                                            * ContentIntelligence\n                                            * Discussion\n                                            * Follow Up\n                                            * Template Workspaces\n                                            * Workflow\n                                            * XECMGOVSettings\n                                            * CommunitySettings\n                                            * RecMan\n                                            * PhysObj\n        Returns:\n            dict: User information or None if the user couldn't be updated\n                  (e.g. because it doesn't exist).\n        \"\"\"\n\n        user_profile_put_body = {config_section: {field: value}}\n\n        request_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Updating profile for current user, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\n            field,\n            value,\n            request_url,\n        )\n        logger.debug(\"User Attributes -&gt; %s\", str(user_profile_put_body))\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            response = requests.put(\n                url=request_url,\n                data={\"body\": json.dumps(user_profile_put_body)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update profile of current user; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def update_user_photo(self, user_id: int, photo_id: int) -&gt; dict | None:\n        \"\"\"Update a user with a profile photo (which must be an existing node).\n\n        Args:\n            user_id (int): ID of the user\n            photo_id (int): Node ID of the photo\n        Returns:\n            dict: Node information or None if photo node is not found.\n        \"\"\"\n\n        update_user_put_body = {\"photo_id\": photo_id}\n\n        request_url = self.config()[\"membersUrl\"] + \"/\" + str(user_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Update user ID -&gt; %s with photo ID -&gt; %s; calling -&gt; %s\",\n            user_id,\n            photo_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                data=update_user_put_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(user_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def is_proxy(self, user_name: str) -&gt; bool:\n        \"\"\"Check if a user is defined as proxy of the current user.\n           This method differentiates between the old (xGov) based\n           implementation and the new Extended ECM platform one\n           that was introduced with version 23.4.\n\n        Args:\n            user_name (str): user  to test (login name)\n        Returns:\n            bool: True is user is proxy of current user. False if not.\n        \"\"\"\n\n        version_number = self.get_server_version()\n        # Split the version number by dot\n        parts = version_number.split(\".\")\n        # Take the first two parts and join them back with a dot\n        stripped_version = \".\".join(parts[:2])\n\n        try:\n            version_number = float(stripped_version)\n        except ValueError:\n            version_number = 99.99  # Set to version 99.99 for \"main\"\n\n        if version_number &gt;= 23.4:\n            response = self.get_user_proxies(use_v2=True)\n            if self.exist_result_item(\n                response=response, key=\"name\", value=user_name, property_name=\"\"\n            ):\n                return True\n            else:\n                return False\n        else:\n            response = self.get_user_proxies(use_v2=False)\n            if not response or not \"proxies\" in response:\n                return False\n            proxies = response[\"proxies\"]\n\n            for proxy in proxies:\n                if proxy[\"name\"] == user_name:\n                    return True\n            return False\n\n    # end method definition\n\n    def get_user_proxies(self, use_v2: bool = False) -&gt; dict | None:\n        \"\"\"Get list of user proxies.\n           This method needs to be called as the user the proxy is acting for.\n        Args:\n            None\n        Returns:\n            dict: Node information or None if REST call fails.\n        \"\"\"\n\n        if use_v2:\n            request_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\n        else:\n            request_url = self.config()[\"membersUrl\"] + \"/proxies\"\n        request_header = self.request_form_header()\n\n        logger.info(\"Get proxy users for current user; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get proxy users for current user; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_user_proxy(\n        self,\n        proxy_user_id: int,\n        from_date: str = None,\n        to_date: str = None,\n    ) -&gt; dict | None:\n        \"\"\"Add a user as a proxy user to the current user.\n           IMPORTANT: This method needs to be called as the user the proxy is acting for.\n           Optional this method can be provided with a time span the proxy should be active.\n           This method differentiates between the old (xGov) based\n           implementation and the new Extended ECM platform one\n           that was introduced with version 23.4.\n\n           Example payload for proxy user 19340 without time span:\n           {\"id\":2545, \"from_date\": None, \"to_date\": None}\n\n           Example payload for proxy user 19340 with time span:\n           {\"id\":2545, \"from_date\":\"2023-03-15\", \"to_date\":\"2023-03-31\"}\n\n        Args:\n            user_id (int): ID of the user\n            from_date (str, optional): start date for proxy (format YYYY-MM-DD)\n            to_date (str, optional): end date for proxy (format YYYY-MM-DD)\n        Returns:\n            dict: Request response or None if call fails.\n        \"\"\"\n\n        version_number = self.get_server_version()\n        # Split the version number by dot\n        parts = version_number.split(\".\")\n        # Take the first two parts and join them back with a dot\n        stripped_version = \".\".join(parts[:2])\n        version_number = float(stripped_version)\n\n        # for versions older than 23.4 we need to use\n        # the egacy Extended ECM for Government Proxy\n        # implementation:\n        if version_number &gt;= 23.4:\n            post_dict = {}\n            post_dict[\"id\"] = proxy_user_id\n            post_dict[\"from_date\"] = from_date\n            post_dict[\"to_date\"] = to_date\n            post_data = {\"body\": json.dumps(post_dict)}\n            request_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\n            logger.info(\n                \"Assign proxy user with ID -&gt; %s to current user; calling -&gt; %s\",\n                proxy_user_id,\n                request_url,\n            )\n        else:\n            post_dict = {}\n            if from_date and to_date:\n                post_dict[\"from_date\"] = from_date\n                post_dict[\"to_date\"] = to_date\n            post_dict = {str(proxy_user_id): post_dict}\n            post_data = {\"add_proxy\": json.dumps(post_dict)}\n            request_url = self.config()[\"membersUrl\"] + \"/proxies\"\n            logger.info(\n                \"Assign proxy user with ID -&gt; %s to current user (legacy xGov); calling -&gt; %s\",\n                proxy_user_id,\n                request_url,\n            )\n\n        request_header = self.request_form_header()\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            response = requests.post(\n                url=request_url,\n                data=post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign proxy user with ID -&gt; %s to current user; status -&gt; %s; error -&gt; %s\",\n                    proxy_user_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_favorite(self, node_id: int) -&gt; dict | None:\n        \"\"\"Add a favorite for the current (authenticated) user.\n\n        Args:\n            node_id (int): ID of the node.\n        Returns:\n            dict: Request response or None if the favorite creation has failed.\n        \"\"\"\n\n        request_url = self.config()[\"favoritesUrl\"] + \"/\" + str(node_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Adding favorite for node ID -&gt; %s; calling -&gt; %s\", node_id, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add favorite for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_favorite_tab(self, tab_name: str, order: int) -&gt; dict | None:\n        \"\"\"Add a favorite tab for the current (authenticated) user.\n\n        Args:\n            tab_name (str): Name of the new tab.\n            order (int): The order of the tab.\n        Returns:\n            dict: Request response or None if the favorite tab creation has failed.\n        \"\"\"\n\n        favorite_tab_post_body = {\"name\": tab_name, \"order\": str(order)}\n\n        request_url = self.config()[\"favoritesUrl\"] + \"/tabs\"\n        request_header = self.request_form_header()\n\n        logger.info(\"Adding favorite tab -&gt; %s; calling -&gt; %s\", tab_name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=favorite_tab_post_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add favorite tab -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    tab_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_group(self, name: str, show_error: bool = False) -&gt; dict | None:\n        \"\"\"Lookup Content Server group.\n\n        Args:\n            name (str): name of the group\n            show_error (bool): if True, treat as error if group is not found\n        Returns:\n            dict: Group information or None if the group is not found.\n            The returned information has a structure like this:\n            \"data\": [\n                {\n                    \"id\": 0,\n                    \"name\": \"string\",\n                    ...\n                }\n            ]\n            To access the id of the first group found use [\"data\"][0][\"id\"]\n        \"\"\"\n\n        # Add query parameters (these are NOT passed via JSon body!)\n        # type = 1 ==&gt; Group\n        request_url = self.config()[\"membersUrlv2\"] + \"?where_type=1&amp;query={}\".format(\n            name\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\"Get group with name -&gt; %s; calling -&gt; %s\", name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        name,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"Group -&gt; %s not found.\", name)\n                return None\n\n    # end method definition\n\n    def add_group(self, name: str) -&gt; dict | None:\n        \"\"\"Add Content Server group.\n\n        Args:\n            name (str): name of the group\n        Returns:\n            dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n        \"\"\"\n\n        group_post_body = {\"type\": 1, \"name\": name}\n\n        request_url = self.config()[\"membersUrlv2\"]\n        request_header = self.request_form_header()\n\n        logger.info(\"Adding group -&gt; %s; calling -&gt; %s\", name, request_url)\n        logger.debug(\"Group Attributes -&gt; %s\", str(group_post_body))\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=group_post_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_group_members(\n        self, group: int, member_type: int, limit: int = 100\n    ) -&gt; dict | None:\n        \"\"\"Get Content Server group members.\n\n        Args:\n            group (int): ID of the group.\n            member_type (int): users = 0, groups = 1\n            limit (int, optional): max number of results (internal default is 25)\n        Returns:\n            dict: Group members or None if the group members couldn't be found.\n        \"\"\"\n\n        # default limit is 25 which may not be enough for groups with many members\n        # where_type = 1 makes sure we just get groups and not users\n        request_url = (\n            self.config()[\"membersUrlv2\"]\n            + \"/\"\n            + str(group)\n            + \"/members?where_type=\"\n            + str(member_type)\n            + \"&amp;limit=\"\n            + str(limit)\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Getting members of group with ID -&gt; %s; calling -&gt; %s\",\n            str(group),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get members of group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(group),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_group_member(self, member_id: int, group_id: int) -&gt; dict | None:\n        \"\"\"Add a user or group to a target group.\n\n        Args:\n            member_id (int): ID of the user or group to add.\n            group_id (int): ID of the target group.\n        Returns:\n            dict: Response or None if adding a the member fails.\n        \"\"\"\n\n        group_member_post_body = {\"member_id\": member_id}\n\n        request_url = self.config()[\"membersUrlv2\"] + \"/\" + str(group_id) + \"/members\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Adding member with ID -&gt; %s to group with ID -&gt; %s; calling -&gt; %s\",\n            str(member_id),\n            str(group_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=group_member_post_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add member with ID -&gt; %s to group with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(member_id),\n                    str(group_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_node(self, node_id: int, timeout: int = REQUEST_TIMEOUT) -&gt; dict | None:\n        \"\"\"Get a node based on the node ID.\n\n        Args:\n            node_id (int) is the node Id of the node\n            timeout (int, optional): timeout for the request in seconds\n        Returns:\n            dict: Node information or None if no node with this ID is found.\n            \"results\": [\n                {\n                    \"data\": [\n                        {\n                            \"columns\": [\n                                {\n                                \"data_type\": 0,\n                                \"key\": \"string\",\n                                \"name\": \"string\",\n                                \"sort_key\": \"string\"\n                                }\n                            ],\n                            \"properties\": [\n                                {\n                                    \"advanced_versioning\": true,\n                                    \"container\": true,\n                                    \"container_size\": 0,\n                                    \"create_date\": \"string\",\n                                    \"create_user_id\": 0,\n                                    \"description\": \"string\",\n                                    \"description_multilingual\": {\n                                        \"en\": \"string\",\n                                        \"de\": \"string\"\n                                    },\n                                    \"external_create_date\": \"2019-08-24\",\n                                    \"external_identity\": \"string\",\n                                    \"external_identity_type\": \"string\",\n                                    \"external_modify_date\": \"2019-08-24\",\n                                    \"external_source\": \"string\",\n                                    \"favorite\": true,\n                                    \"guid\": \"string\",\n                                    \"hidden\": true,\n                                    \"icon\": \"string\",\n                                    \"icon_large\": \"string\",\n                                    \"id\": 0,\n                                    \"modify_date\": \"2019-08-24\",\n                                    \"modify_user_id\": 0,\n                                    \"name\": \"string\",\n                                    \"name_multilingual\": {\n                                        \"en\": \"string\",\n                                        \"de\": \"string\"\n                                    },\n                                    \"owner\": \"string\",\n                                    \"owner_group_id\": 0,\n                                    \"owner_user_id\": 0,\n                                    \"parent_id\": 0,\n                                    \"reserved\": true,\n                                    \"reserved_date\": \"string\",\n                                    \"reserved_user_id\": 0,\n                                    \"status\": 0,\n                                    \"type\": 0,\n                                    \"type_name\": \"string\",\n                                    \"versionable\": true,\n                                    \"versions_control_advanced\": true,\n                                    \"volume_id\": 0\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        \"\"\"\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\n        request_header = self.request_form_header()\n\n        logger.info(\"Get node with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url)\n\n        retries = 0\n        while True:\n            try:\n                response = requests.get(\n                    url=request_url,\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=timeout,\n                )\n                if response.ok:\n                    return self.parse_request_response(response)\n                # Check if Session has expired - then re-authenticate and try once more\n                elif response.status_code == 401 and retries == 0:\n                    logger.warning(\"Session has expired - try to re-authenticate...\")\n                    self.authenticate(revalidate=True)\n                    retries += 1\n                else:\n                    logger.error(\n                        \"Failed to get node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        str(node_id),\n                        response.status_code,\n                        response.text,\n                    )\n                    return None\n            except requests.exceptions.Timeout:\n                if retries &lt;= REQUEST_MAX_RETRIES:\n                    logger.warning(\n                        \"Request timed out. Retrying in %s seconds...\",\n                        str(REQUEST_RETRY_DELAY),\n                    )\n                    retries += 1\n                    time.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\n                else:\n                    logger.error(\n                        \"Failed to get node with ID -&gt; %s; timeout error\", str(node_id)\n                    )\n                    # If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\n                    logger.warning(\"Turn timeouts off and wait forever...\")\n                    timeout = None\n\n    # end method definition\n\n    def get_node_by_parent_and_name(\n        self,\n        parent_id: int,\n        name: str,\n        fields: str = \"properties\",\n        show_error: bool = False,\n    ) -&gt; dict | None:\n        \"\"\"Get a node based on the parent ID and name. This method does basically\n           a query with \"where_name\" and the \"result\" is a list.\n\n        Args:\n            parent_id (int) is the node Id of the parent node\n            name (str) is the name of the node to get\n            fields (str, optional): which fields to retrieve. This can have a big impact on performance!\n            show_error (bool, optional): treat as error if node is not found\n        Returns:\n            dict: Node information or None if no node with this name is found in parent.\n                        Access to node ID with: response[\"results\"][0][\"data\"][\"properties\"][\"id\"]\n        \"\"\"\n\n        # Add query parameters (these are NOT passed via JSon body!)\n        query = {\"where_name\": name}\n        if fields:\n            query[\"fields\"] = fields\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(parent_id)\n            + \"/nodes?{}\".format(encoded_query)\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get node with name -&gt; %s and parent ID -&gt; %s; calling -&gt; %s\",\n            name,\n            str(parent_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get node with name -&gt; %s and parent ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        name,\n                        str(parent_id),\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\n                        \"Node with name -&gt; %s and parent ID -&gt; %s not found.\",\n                        name,\n                        str(parent_id),\n                    )\n                return None\n\n    # end method definition\n\n    def get_node_by_workspace_and_path(\n        self, workspace_id: int, path: list, show_error: bool = False\n    ) -&gt; dict | None:\n        \"\"\"Get a node based on the workspace ID (= node ID) and path (list of folder names).\n\n        Args:\n            workspace_id (int): node ID of the workspace\n            path (list): list of container items (top down), last item is name of to be retrieved item.\n                         If path is empty the node of the volume is returned.\n            show_error (bool, optional): treat as error if node is not found\n        Returns:\n            dict: Node information or None if no node with this path is found.\n        \"\"\"\n\n        current_item_id = workspace_id\n\n        # in case the path is an empty list\n        # we will have the node of the workspace:\n        node = self.get_node(current_item_id)\n\n        for path_element in path:\n            node = self.get_node_by_parent_and_name(current_item_id, path_element)\n            current_item_id = self.get_result_value(node, \"id\")\n            if not current_item_id:\n                if show_error:\n                    logger.error(\"Cannot find path element -&gt; %s!\", path_element)\n                else:\n                    logger.info(\"Cannot find path element -&gt; %s.\", path_element)\n                return None\n            logger.debug(\n                \"Traversing path element -&gt; %s (%s)\", path_element, str(current_item_id)\n            )\n\n        return node\n\n    # end method definition\n\n    def get_node_by_volume_and_path(\n        self, volume_type: int, path: list | None = None\n    ) -&gt; dict | None:\n        \"\"\"Get a node based on the volume and path (list of container items).\n\n        Args:\n            volume_type (int): Volume type ID (default is 141 = Enterprise Workspace)\n                \"Records Management\"                = 550\n                \"Content Server Document Templates\" = 20541\n                \"O365 Office Online Volume\"         = 1296\n                \"Categories Volume\"                 = 133\n                \"Perspectives\"                      = 908\n                \"Perspective Assets\"                = 954\n                \"Facets Volume\"                     = 901\n                \"Transport Warehouse\"               = 525\n                \"Transport Warehouse Workbench\"     = 528\n                \"Transport Warehouse Package\"       = 531\n                \"Event Action Center Configuration\" = 898\n                \"Classification Volume\"             = 198\n                \"Support Asset Volume\"              = 1309\n                \"Physical Objects Workspace\"        = 413\n                \"Extended ECM\"                      = 882\n                \"Enterprise Workspace\"              = 141\n                \"Personal Workspace\"                = 142\n                \"Business Workspaces\"               = 862\n            path (list): list of container items (top down), last item is name of to be retrieved item.\n                         If path is empty the node of the volume is returned.\n        Returns:\n            dict: Node information or None if no node with this path is found.\n        \"\"\"\n\n        # If path is not given we use empty list to make the for loop below working in this case as well\n        if path is None:\n            path = []\n\n        # Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\n        response = self.get_volume(volume_type)\n        if not response:\n            logger.error(\"Volume type -&gt; %s not found!\", str(volume_type))\n            return None\n\n        volume_id = self.get_result_value(response, \"id\")\n        logger.info(\n            \"Volume type -&gt; %s has node ID -&gt; %s\", str(volume_type), str(volume_id)\n        )\n\n        current_item_id = volume_id\n\n        # in case the path is an empty list\n        # we will have the node of the volume:\n        node = self.get_node(current_item_id)\n\n        for path_element in path:\n            node = self.get_node_by_parent_and_name(current_item_id, path_element)\n            path_item_id = self.get_result_value(node, \"id\")\n            if not path_item_id:\n                logger.error(\n                    \"Cannot find path element -&gt; %s in container with ID -&gt; %s.\",\n                    path_element,\n                    str(current_item_id),\n                )\n                return None\n            current_item_id = path_item_id\n            logger.debug(\"Traversing path element with ID -&gt; %s\", str(current_item_id))\n\n        return node\n\n    # end method definition\n\n    def get_node_from_nickname(\n        self, nickname: str, show_error: bool = False\n    ) -&gt; dict | None:\n        \"\"\"Get a node based on the nickname.\n\n        Args:\n            nickname (str): Nickname of the node.\n            show_error (bool): treat as error if node is not found\n        Returns:\n            dict: Node information or None if no node with this nickname is found.\n        \"\"\"\n\n        request_url = self.config()[\"nicknameUrl\"] + \"/\" + nickname + \"/nodes\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get node with nickname -&gt; %s; calling -&gt; %s\", nickname, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get node with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        nickname,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"Node with nickname -&gt; %s not found.\", nickname)\n                return None\n\n    def set_node_nickname(\n        self, node_id: int, nickname: str, show_error: bool = False\n    ) -&gt; dict | None:\n        \"\"\"Assign a nickname to an Extended ECM node (e.g. workspace)\n\n        Args:\n            nickname (str): Nickname of the node.\n            show_error (bool): treat as error if node is not found\n        Returns:\n            dict: Node information or None if no node with this nickname is found.\n        \"\"\"\n\n        nickname_put_body = {\"nickname\": nickname}\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/nicknames\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Assign nickname -&gt; %s to node with ID -&gt; %s; calling -&gt; %s\",\n            nickname,\n            node_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                data=nickname_put_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to assign nickname -&gt; %s to node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        nickname,\n                        node_id,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\n                        \"Cannot assign nickname -&gt; %s to node ID -&gt; %s. Maybe the nickname is already in use or the node does not exist.\",\n                        nickname,\n                        node_id,\n                    )\n                return None\n\n    # end method definition\n\n    def get_subnodes(\n        self,\n        parent_node_id: int,\n        filter_node_types: int = -2,\n        filter_name: str = \"\",\n        show_hidden: bool = False,\n        limit: int = 100,\n        page: int = 1,\n        fields: str = \"properties\",  # per default we just get the most important information\n    ) -&gt; dict | None:\n        \"\"\"Get a subnodes of a parent node ID.\n\n        Args:\n            parent_node_id (int) is the node Id of the node\n            filter_node_types (int, optional):\n                -1 get all containers\n                -2 get all searchable objects (default)\n                -3 get all non-containers\n            filter_name (str, optional): filter nodes for specific name (dfault = no filter)\n            show_hidden (bool, optional): list also hidden items (default = False)\n            limit (int, optional): maximum number of results (default = 100)\n            page (int, optional): number of result page (default = 1 = 1st page)\n            fields (str): which fields to retrieve. This can have a big impact on performance!\n        Returns:\n            dict: Subnodes information or None if no node with this parent ID is found.\n        \"\"\"\n\n        # Add query parameters (these are NOT passed via JSon body!)\n        query = {\n            \"where_type\": filter_node_types,\n            \"limit\": limit,\n        }\n        if filter_name:\n            query[\"where_name\"] = filter_name\n        if show_hidden:\n            query[\"show_hidden\"] = show_hidden\n        if page &gt; 1:\n            query[\"page\"] = page\n        if fields:\n            query[\"fields\"] = fields\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(parent_node_id)\n            + \"/nodes\"\n            + \"?{}\".format(encoded_query)\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get subnodes of parent node with ID -&gt; %s; calling -&gt; %s\",\n            str(parent_node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get subnodes for parent node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    parent_node_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_node_actions(self, node_id: int, filter_actions: list = None) -&gt; dict:\n        \"\"\"Get allowed actions for a node.\n\n        Args:\n            node_id (int): _description_\n            filter_actions (list, optional): _description_\n\n        Returns:\n            dict: _description_\n        \"\"\"\n\n        actions_post_body = {\"ids\": [node_id], \"actions\": filter_actions}\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/actions\"\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get actions for node with ID -&gt; %s; calling -&gt; %s\",\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=actions_post_body,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get actions for node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    node_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def rename_node(\n        self,\n        node_id: int,\n        name: str,\n        description: str,\n        name_multilingual: dict | None = None,\n        description_multilingual: dict | None = None,\n    ) -&gt; dict | None:\n        \"\"\"Change the name and description of a node.\n\n        Args:\n            node_id (int): ID of the node. You can use the get_volume() function below to\n                               to the node id for a volume.\n            name (str): New name of the node.\n            description (str): New description of the node.\n            name_multilingual (dict, optional): multi-lingual node names\n            description_multilingual (dict, optional): multi-lingual description\n        Returns:\n            dict: Request response or None if the renaming fails.\n        \"\"\"\n\n        rename_node_put_body = {\"name\": name, \"description\": description}\n\n        if name_multilingual:\n            rename_node_put_body[\"name_multilingual\"] = name_multilingual\n        if description_multilingual:\n            rename_node_put_body[\"description_multilingual\"] = description_multilingual\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Renaming node with ID -&gt; %s to -&gt; %s; calling -&gt; %s\",\n            str(node_id),\n            name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                data={\"body\": json.dumps(rename_node_put_body)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to rename node with ID -&gt; %s to -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_volumes(self) -&gt; dict | None:\n        \"\"\"Get all Volumes.\n\n        Args:\n            None\n        Returns:\n            dict: Volume Details or None if an error occured.\n            {\n                'links': {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data': {\n                            'properties': {\n                                'advanced_versioning': None,\n                                'container': True,\n                                'container_size': 16,\n                                'create_date': '2023-05-07T23:18:50Z',\n                                'create_user_id': 1000,\n                                'description': '',\n                                'description_multilingual': {'de': '', 'en': '', 'fr': '', 'it': '', 'ja': ''},\n                                'external_create_date': None,\n                                'external_identity': '',\n                                'external_identity_type': '',\n                                'external_modify_date': None,\n                                'external_source': '',\n                                'favorite': False,\n                                'hidden': False,\n                                ...\n                                'id': 2000,\n                                ...\n                                'name': 'Enterprise',\n                                'name_multilingual': {'de': '', 'en': 'Enterprise', 'fr': '', 'it': '', 'ja': ''},\n                                ...\n                                'parent_id': -1,\n                                'type': 141,\n                                'volume_id': -2000,\n                                ...\n                            }\n                            ...\n                        }\n                    },\n                    ...\n                ]\n            }\n            Example:\n            [\"results\"][0][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n        \"\"\"\n\n        request_url = self.config()[\"volumeUrl\"]\n        request_header = self.request_form_header()\n\n        logger.info(\"Get volumes; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get volumes; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_volume(\n        self, volume_type: int, timeout: int = REQUEST_TIMEOUT\n    ) -&gt; dict | None:\n        \"\"\"Get Volume information based on the volume type ID.\n\n        Args:\n            volume_type (int): ID of the volume type\n            timeout (int, optional): timeout for the request in seconds\n        Returns:\n            dict: Volume Details or None if volume is not found.\n            [\"results\"][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n        \"\"\"\n\n        request_url = self.config()[\"volumeUrl\"] + \"/\" + str(volume_type)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get volume type -&gt; %s; calling -&gt; %s\", str(volume_type), request_url\n        )\n\n        retries = 0\n        while True:\n            try:\n                response = requests.get(\n                    url=request_url,\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=timeout,\n                )\n                if response.ok:\n                    return self.parse_request_response(response)\n                # Check if Session has expired - then re-authenticate and try once more\n                elif response.status_code == 401 and retries == 0:\n                    logger.warning(\"Session has expired - try to re-authenticate...\")\n                    self.authenticate(revalidate=True)\n                    retries += 1\n                else:\n                    logger.error(\n                        \"Failed to get volume type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        str(volume_type),\n                        response.status_code,\n                        response.text,\n                    )\n                    return None\n            except requests.exceptions.Timeout:\n                if retries &lt;= REQUEST_MAX_RETRIES:\n                    logger.warning(\n                        \"Request timed out. Retrying in %s seconds...\",\n                        str(REQUEST_RETRY_DELAY),\n                    )\n                    retries += 1\n                    time.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\n                else:\n                    logger.error(\n                        \"Failed to get volume type -&gt; %s; timeout error\",\n                        str(volume_type),\n                    )\n                    # If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\n                    logger.warning(\"Turn timeouts off and wait forever...\")\n                    timeout = None\n\n    # end method definition\n\n    def check_node_name(self, parent_id: int, node_name: str) -&gt; dict | None:\n        \"\"\"Check if a node with a given name does already exist under a given parent node.\n\n        Args:\n            parent_id (int): ID of the parent location\n            node_name (str): name of the new node\n        Returns:\n            dict | None: if response[\"results\"] contains an element then the node with the name does exist.\n                         if not response[\"results\"] then the node with the given name does not exist\n                         None in case an error occured\n        \"\"\"\n\n        request_url = self.config()[\"validationUrl\"]\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Check if node with name -&gt; %s can be created in parent with ID -&gt; %s; calling -&gt; %s\",\n            node_name,\n            str(parent_id),\n            request_url,\n        )\n\n        check_node_name_post_data = {\"parent_id\": parent_id, \"names\": [node_name]}\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data={\"body\": json.dumps(check_node_name_post_data)},\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to check if node name -&gt; %s can be created in parent with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    node_name,\n                    str(parent_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def upload_file_to_volume(\n        self, package_url: str, file_name: str, mime_type: str, volume_type: int\n    ) -&gt; dict | None:\n        \"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server volume.\n\n        Args:\n            package_url (str): URL to download file\n            file_name (str): name of the file\n            mime_type (str): mimeType of the file\n            volume_type (int): type (ID) of the volume\n        Returns:\n            dict: Upload response or None if the upload fails.\n        \"\"\"\n\n        if package_url.startswith(\"http\"):\n            # Download file from remote location specified by the packageUrl\n            # this must be a public place without authentication:\n            logger.info(\"Download transport package from URL -&gt; %s\", package_url)\n\n            try:\n                package = requests.get(url=package_url, timeout=1200)\n                package.raise_for_status()\n            except requests.exceptions.HTTPError as errh:\n                logger.error(\"Http Error -&gt; %s\", errh.strerror)\n                return None\n            except requests.exceptions.ConnectionError as errc:\n                logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n                return None\n            except requests.exceptions.Timeout as errt:\n                logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n                return None\n            except requests.exceptions.RequestException as err:\n                logger.error(\"Request error -&gt; %s\", err.strerror)\n                return None\n\n            logger.info(\n                \"Successfully downloaded package -&gt; %s; status code -&gt; %s\",\n                package_url,\n                package.status_code,\n            )\n            file = package.content\n\n        elif os.path.exists(package_url):\n            logger.info(\"Using local package -&gt; %s\", package_url)\n            file = open(file=package_url, mode=\"rb\")\n\n        else:\n            logger.warning(\"Cannot access -&gt; %s\", package_url)\n            return None\n\n        upload_post_data = {\"type\": str(volume_type), \"name\": file_name}\n        upload_post_files = [(\"file\", (f\"{file_name}\", file, mime_type))]\n\n        request_url = self.config()[\"nodesUrlv2\"]\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\n\n        logger.info(\n            \"Uploading package -&gt; %s with mime type -&gt; %s; calling -&gt; %s\",\n            file_name,\n            mime_type,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=upload_post_data,\n                files=upload_post_files,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to upload file -&gt; %s to volume of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    package_url,\n                    str(volume_type),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def upload_file_to_parent(\n        self, file_url: str, file_name: str, mime_type: str, parent_id: int\n    ) -&gt; dict | None:\n        \"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server parent (folder).\n\n        Args:\n            file_url (str): URL to download file or local file\n            file_name (str): name of the file\n            mime_type (str): mimeType of the file\n            parent_id (int): parent (ID) of the file to upload\n        Returns:\n            dict: Upload response or None if the upload fails.\n        \"\"\"\n\n        if file_url.startswith(\"http\"):\n            # Download file from remote location specified by the file_url parameter\n            # this must be a public place without authentication:\n            logger.info(\"Download file from URL -&gt; %s\", file_url)\n\n            try:\n                response = requests.get(url=file_url, timeout=1200)\n                response.raise_for_status()\n            except requests.exceptions.HTTPError as errh:\n                logger.error(\"Http Error -&gt; %s\", errh.strerror)\n                return None\n            except requests.exceptions.ConnectionError as errc:\n                logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n                return None\n            except requests.exceptions.Timeout as errt:\n                logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n                return None\n            except requests.exceptions.RequestException as err:\n                logger.error(\"Request error -&gt; %s\", err.strerror)\n                return None\n\n            logger.info(\n                \"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\n                file_url,\n                response.status_code,\n            )\n            file_content = response.content\n\n        elif os.path.exists(file_url):\n            logger.info(\"Uploading local file -&gt; %s\", file_url)\n            file_content = open(file=file_url, mode=\"rb\")\n\n        else:\n            logger.warning(\"Cannot access -&gt; %s\", file_url)\n            return None\n\n        upload_post_data = {\n            \"type\": str(144),\n            \"name\": file_name,\n            \"parent_id\": str(parent_id),\n        }\n        upload_post_files = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\n\n        request_url = self.config()[\"nodesUrlv2\"]\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\n\n        logger.info(\n            \"Uploading file -&gt; %s with mime type -&gt; %s to parent with ID -&gt; %s; calling -&gt; %s\",\n            file_name,\n            mime_type,\n            str(parent_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=upload_post_data,\n                files=upload_post_files,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to upload file -&gt; %s to parent -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_url,\n                    str(parent_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_document_version(\n        self,\n        node_id: int,\n        file_url: str,\n        file_name: str,\n        mime_type: str = \"text/plain\",\n        description: str = \"\",\n    ) -&gt; dict | None:\n        \"\"\"Fetch a file from a URL or local filesystem and upload it as a new document version.\n\n        Args:\n            node_id (int): ID of the document to add add version to\n            file_url (str): URL to download file or local file\n            file_name (str): name of the file\n            mime_type (str, optional): mimeType of the file (default = text/plain)\n            description (str, optional): description of the version (default = no description)\n        Returns:\n            dict: Add version response or None if the upload fails.\n        \"\"\"\n\n        if file_url.startswith(\"http\"):\n            # Download file from remote location specified by the file_url parameter\n            # this must be a public place without authentication:\n            logger.info(\"Download file from URL -&gt; %s\", file_url)\n\n            try:\n                response = requests.get(\n                    url=file_url,\n                    timeout=None,\n                )\n                response.raise_for_status()\n            except requests.exceptions.HTTPError as errh:\n                logger.error(\"Http Error -&gt; %s\", errh.strerror)\n                return None\n            except requests.exceptions.ConnectionError as errc:\n                logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n                return None\n            except requests.exceptions.Timeout as errt:\n                logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n                return None\n            except requests.exceptions.RequestException as err:\n                logger.error(\"Request error -&gt; %s\", err.strerror)\n                return None\n\n            logger.info(\n                \"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\n                file_url,\n                response.status_code,\n            )\n            file_content = response.content\n\n        elif os.path.exists(file_url):\n            logger.info(\"Uploading local file -&gt; %s\", file_url)\n            file_content = open(file=file_url, mode=\"rb\")\n\n        else:\n            logger.warning(\"Cannot access -&gt; %s\", file_url)\n            return None\n\n        upload_post_data = {\"description\": description}\n        upload_post_files = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/versions\"\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\n\n        logger.info(\n            \"Uploading file -&gt; %s with mime type -&gt; %s as new version to document node with ID -&gt; %s; calling -&gt; %s\",\n            file_name,\n            mime_type,\n            node_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=upload_post_data,\n                files=upload_post_files,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add file -&gt; %s as new version to document with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_url,\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_latest_document_version(self, node_id: int) -&gt; dict | None:\n        \"\"\"Get latest version of a document node based on the node ID.\n\n        Args:\n            node_id (int) is the node Id of the node\n        Returns:\n            dict: Node information or None if no node with this ID is found.\n        \"\"\"\n\n        request_url = (\n            self.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/versions/latest\"\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get latest version of document with node ID -&gt; %s; calling -&gt; %s\",\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get latest version of document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_document_content(self, node_id: int, version_number: str = \"\") -&gt; bytes:\n        \"\"\"Get document content from Extended ECM.\n\n        Args:\n            node_id (int): node ID of the document to download\n            version_number (str, optional): version of the document to download.\n                                            If version = \"\" then download the latest\n                                            version.\n        Returns:\n            bytes: content of the file or None in case of an error.\n        \"\"\"\n\n        if not version_number:\n            response = self.get_latest_document_version(node_id)\n            if not response:\n                logger.error(\n                    \"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n                )\n            version_number = response[\"data\"][\"version_number\"]\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(node_id)\n            + \"/versions/\"\n            + str(version_number)\n            + \"/content\"\n        )\n        request_header = self.request_download_header()\n\n        logger.info(\n            \"Retrieve document with node ID -&gt; %s and version -&gt; %s; calling -&gt; %s\",\n            str(node_id),\n            str(version_number),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                content = response.content\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n        return content\n\n        # end method definition\n\n    def download_document(\n        self, node_id: int, file_path: str, version_number: str = \"\"\n    ) -&gt; bool:\n        \"\"\"Download a document from Extended ECM to local file system.\n\n        Args:\n            node_id (int): node ID of the document to download\n            file_path (str): local file path (directory)\n            version_number (str): version of the document to download.\n                                     If version = \"\" then download the latest\n                                     version.\n        Returns:\n            bool: True if the document has been download to the specified file.\n                     False otherwise.\n        \"\"\"\n\n        directory = os.path.dirname(file_path)\n        if not os.path.exists(directory):\n            logger.error(\"Directory -&gt; %s does not exist\", directory)\n            return False\n\n        if not version_number:\n            response = self.get_latest_document_version(node_id)\n            if not response:\n                logger.error(\n                    \"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n                )\n            version_number = response[\"data\"][\"version_number\"]\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(node_id)\n            + \"/versions/\"\n            + str(version_number)\n            + \"/content\"\n        )\n        request_header = self.request_download_header()\n\n        logger.info(\n            \"Download document with node ID -&gt; %s; calling -&gt; %s\",\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                content = response.content\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n        logger.info(\"Writing document content to file -&gt; %s\", file_path)\n\n        # Open file in write binary mode\n        with open(file=file_path, mode=\"wb\") as file:\n            # Write the content to the file\n            file.write(content)\n\n        return True\n\n        # end method definition\n\n    def download_config_file(\n        self, otcs_url_suffix: str, file_path: str, search: str = \"\", replace: str = \"\"\n    ) -&gt; bool:\n        \"\"\"Download a config file from a given OTCS URL. This is NOT\n            for downloading documents from within the OTCS repository\n            but for configuration files such as app packages for MS Teams.\n\n        Args:\n            otcs_url_suffix (str): OTCS URL suffix starting typically starting\n                                      with /cs/cs?func=,\n                                      e.g. /cs/cs?func=officegroups.DownloadTeamsPackage\n            file_path (str): local path to save the file (direcotry + filename)\n            search (str, optional): optional string to search for a replacement\n            replace (str, optional): optional replacement\n        Returns:\n            bool: True if the download succeeds, False otherwise\n        \"\"\"\n\n        request_url = self.config()[\"baseUrl\"] + otcs_url_suffix\n        # request_header = self.cookie()\n        request_header = self.request_download_header()\n\n        logger.info(\"Download config file from URL -&gt; %s\", request_url)\n\n        try:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=REQUEST_TIMEOUT,\n            )\n            response.raise_for_status()\n        except requests.exceptions.HTTPError as errh:\n            logger.error(\"Http Error -&gt; %s\", errh.strerror)\n            return False\n        except requests.exceptions.ConnectionError as errc:\n            logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n            return False\n        except requests.exceptions.Timeout as errt:\n            logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n            return False\n        except requests.exceptions.RequestException as err:\n            logger.error(\"Request error -&gt; %s\", err.strerror)\n            return False\n\n        content = response.content\n\n        if search:\n            logger.info(\n                \"Search for all occurances of %s in the config file and replace them with %s\",\n                search,\n                replace,\n            )\n            content = content.replace(search.encode(\"utf-8\"), replace.encode(\"utf-8\"))\n\n        # Open file in write binary mode\n        with open(file=file_path, mode=\"wb\") as file:\n            # Write the content to the file\n            file.write(content)\n\n        logger.info(\n            \"Successfully downloaded config file -&gt; %s to -&gt; %s; status code -&gt; %s\",\n            request_url,\n            file_path,\n            response.status_code,\n        )\n\n        return True\n\n    # end method definition\n\n    def search(\n        self,\n        search_term: str,\n        look_for: str = \"complexQuery\",\n        modifier: str = \"\",\n        slice_id: int = 0,\n        query_id: int = 0,\n        template_id: int = 0,\n        limit: int = 100,\n        page: int = 1,\n    ) -&gt; dict | None:\n        \"\"\"Search for a search term.\n\n        Args:\n            search_term (str), e.g. \"test or OTSubType: 189\"\n            look_for (str, optional): 'allwords', 'anywords', 'exactphrase', and 'complexquery'.\n                                      If not specified, it defaults to 'complexQuery'.\n            modifier (str, optional): 'synonymsof', 'relatedto', 'soundslike', 'wordbeginswith',\n                                      and 'wordendswith'.\n                                      If not specified or specify any value other than the available options,\n                                      it will be ignored.\n            slice_id (int, optional): ID of an existing search slice\n            query_id (int, optional): ID of an saved search query\n            template_id (int, optional): ID of an saved search template\n            limit (int, optional): maximum number of results (default = 100)\n            page (int, optional): number of result page (default = 1 = 1st page)\n        Returns:\n            dict: search response or None if the search fails.\n        \"\"\"\n\n        search_post_body = {\n            \"where\": search_term,\n            \"lookfor\": look_for,\n            \"page\": page,\n            \"limit\": limit,\n        }\n\n        if modifier:\n            search_post_body[\"modifier\"] = modifier\n        if slice_id &gt; 0:\n            search_post_body[\"slice_id\"] = slice_id\n        if query_id &gt; 0:\n            search_post_body[\"query_id\"] = query_id\n        if template_id &gt; 0:\n            search_post_body[\"template_id\"] = template_id\n\n        request_url = self.config()[\"searchUrl\"]\n        request_header = self.request_form_header()\n\n        logger.info(\"Search for term -&gt; %s; calling -&gt; %s\", search_term, request_url)\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=search_post_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to search for term -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    search_term,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_external_system_connection(\n        self, connection_name: str, show_error: bool = False\n    ) -&gt; dict | None:\n        \"\"\"Get Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n\n        Args:\n            connection_name (str): Name of the connection\n            show_error (bool, optional): If True, treat as error if connection is not found.\n        Returns:\n            dict: External system Details or None if the REST call fails.\n        \"\"\"\n\n        request_url = (\n            self.config()[\"externalSystemUrl\"] + \"/\" + connection_name + \"/config\"\n        )\n        request_header = self.cookie()\n\n        logger.info(\n            \"Get external system connection -&gt; %s; calling -&gt; %s\",\n            connection_name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        connection_name,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"External system -&gt; %s not found.\", connection_name)\n                return None\n\n    # end method definition\n\n    def add_external_system_connection(\n        self,\n        connection_name: str,\n        connection_type: str,\n        as_url: str,\n        base_url: str,\n        username: str,\n        password: str,\n        authentication_method: str = \"BASIC\",  # either BASIC or OAUTH\n        client_id: str = None,\n        client_secret: str = None,\n    ) -&gt; dict | None:\n        \"\"\"Add Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n\n        Args:\n            connection_name (str): Name of the connection\n            connection_type (str): Type of the connection (HTTP, SF, SFInstance)\n            as_url (str): Application URL of the external system\n            base_url (str): Base URL of the external system\n            username (str): username (used for BASIC authentication)\n            password (str): password (used for BASIC authentication)\n            authentication_method (str, optional): either BASIC (using username and password) or OAUTH\n            client_id (str, optional): OAUTH Client ID (only required if authenticationMethod = OAUTH)\n            client_secret (str, optional): OAUTH Client Secret (only required if authenticationMethod = OAUTH)\n        Returns:\n            dict: External system Details or None if the REST call fails.\n        \"\"\"\n\n        external_system_post_body = {\n            \"external_system_name\": connection_name,\n            \"conn_type\": connection_type,\n            \"asurl\": as_url,\n            \"baseurl\": base_url,\n            \"username\": username,\n            \"password\": password,\n        }\n\n        if authentication_method == \"OAUTH\" and client_id and client_secret:\n            external_system_post_body[\"authentication_method\"] = str(\n                authentication_method\n            )\n            external_system_post_body[\"client_id\"] = str(client_id)\n            external_system_post_body[\"client_secret\"] = str(client_secret)\n\n        request_url = self.config()[\"externalSystemUrl\"]\n        request_header = self.cookie()\n\n        logger.info(\n            \"Creating external system connection -&gt; %s of type -&gt; %s with URL -&gt; %s; calling -&gt; %s\",\n            connection_name,\n            connection_type,\n            as_url,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=external_system_post_body,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    connection_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def create_transport_workbench(self, workbench_name: str) -&gt; dict | None:\n        \"\"\"Create a Workbench in the Transport Volume.\n\n        Args:\n            workbench_name (str): Name of the workbench to be created\n        Returns:\n            dict: Create response or None if the creation fails.\n        \"\"\"\n\n        create_worbench_post_data = {\"type\": \"528\", \"name\": workbench_name}\n\n        request_url = self.config()[\"nodesUrlv2\"]\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create transport workbench -&gt; %s; calling -&gt; %s\",\n            workbench_name,\n            request_url,\n        )\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=create_worbench_post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create transport workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    workbench_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def unpack_transport_package(\n        self, package_id: int, workbench_id: int\n    ) -&gt; dict | None:\n        \"\"\"Unpack an existing Transport Package into an existing Workbench.\n\n        Args:\n            package_id (int): ID of package to be unpacked\n            workbench_id (int): ID of target workbench\n        Returns:\n            dict: Unpack response or None if the unpacking fails.\n        \"\"\"\n\n        unpack_package_post_data = {\"workbench_id\": workbench_id}\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(package_id) + \"/unpack\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Unpack transport package with ID -&gt; %s into workbench with ID -&gt; %s; calling -&gt; %s\",\n            str(package_id),\n            str(workbench_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=unpack_package_post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to unpack package -&gt; %s; to workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(package_id),\n                    str(workbench_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def deploy_workbench(self, workbench_id: int) -&gt; dict | None:\n        \"\"\"Deploy an existing Workbench.\n\n        Args:\n            workbench_d (int): ID of the workbench to be deployed\n        Returns:\n            dict: Deploy response or None if the deployment fails.\n        \"\"\"\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(workbench_id) + \"/deploy\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Deploy workbench with ID -&gt; %s; calling -&gt; %s\",\n            str(workbench_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # As this is a potentially long-running request we put it in try / except:\n            try:\n                response = requests.post(\n                    url=request_url,\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n            except requests.exceptions.RequestException as exception:\n                logger.error(\n                    \"Error deploying workbench -&gt; %s; error -&gt; %s\",\n                    str(workbench_id),\n                    exception.strerror,\n                )\n                return None\n            if response.ok:\n                response_dict = self.parse_request_response(response)\n                if not response_dict:\n                    logger.error(\"Error deploying workbench -&gt; %s\", str(workbench_id))\n                    return None\n                return response_dict\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.warning(\n                    \"Failed to depoloy workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    workbench_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def deploy_transport(\n        self,\n        package_url: str,\n        package_name: str,\n        package_description: str = \"\",\n        replacements: list | None = None,\n        extractions: list | None = None,\n    ) -&gt; dict | None:\n        \"\"\"Main method to deploy a transport. This uses subfunctions to upload,\n           unpackage and deploy the transport, and creates the required workbench.\n\n        Args:\n            package_url (str): URL to download the transport package.\n            package_name (str): Name of the transport package ZIP file\n            package_description (str): Description of the transport package\n            replacements (list of dicts): List of replacement values to be applied\n                                          to all XML files in transport;\n                                          each dict needs to have two values:\n                                          - placeholder: text to replace\n                                          - value: text to replace with\n            extractions (list of dicts): List of XML Subtrees to extract\n                                         each XML file in transport;\n                                         each dict needs to have two values:\n                                          - xpath: defining the subtree to extract\n                                          - enabled: True if the extraction is active\n        Returns:\n            dict: Deploy response or None if the deployment fails.\n        \"\"\"\n\n        if replacements is None:\n            replacements = []\n        if extractions is None:\n            extractions = []\n\n        # Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\n        response = self.get_volume(525)\n        transport_root_volume_id = self.get_result_value(response, \"id\")\n        if not transport_root_volume_id:\n            logger.error(\"Failed to retrieve transport root volume\")\n            return None\n        logger.info(\"Transport root volume ID -&gt; %s\", str(transport_root_volume_id))\n\n        response = self.get_node_by_parent_and_name(\n            transport_root_volume_id, \"Transport Packages\"\n        )\n        transport_package_volume_id = self.get_result_value(response, \"id\")\n        if not transport_package_volume_id:\n            logger.error(\"Failed to retrieve transport package volume\")\n            return None\n        logger.info(\n            \"Transport package volume ID -&gt; %s\", str(transport_package_volume_id)\n        )\n\n        # Step 1: Upload Transport Package\n        logger.info(\"Check if transport package -&gt; %s already exists...\", package_name)\n        response = self.get_node_by_parent_and_name(\n            transport_package_volume_id, package_name\n        )\n        package_id = self.get_result_value(response, \"id\")\n        if package_id:\n            logger.info(\n                \"Transport package -&gt; %s does already exist; existing package ID -&gt; %s\",\n                package_name,\n                str(package_id),\n            )\n        else:\n            logger.info(\n                \"Transport package -&gt; %s does not yet exist, loading from -&gt; %s\",\n                package_name,\n                package_url,\n            )\n            # If we have string replacements configured execute them now:\n            if replacements:\n                logger.info(\n                    \"Transport -&gt; %s has replacements -&gt; %s\",\n                    package_name,\n                    str(replacements),\n                )\n                self.replace_transport_placeholders(package_url, replacements)\n            else:\n                logger.info(\"Transport -&gt; %s has no replacements!\", package_name)\n            # If we have data extractions configured execute them now:\n            if extractions:\n                logger.info(\n                    \"Transport -&gt; %s has extractions -&gt; %s\",\n                    package_name,\n                    str(extractions),\n                )\n                self.extract_transport_data(package_url, extractions)\n            else:\n                logger.info(\"Transport -&gt; %s has no extractions!\", package_name)\n            # Upload package to Extended ECM:\n            response = self.upload_file_to_volume(\n                package_url, package_name, \"application/zip\", 531\n            )\n            package_id = self.get_result_value(response, \"id\")\n            if not package_id:\n                logger.error(\"Failed to upload transport package -&gt; %s\", package_url)\n                return None\n            logger.info(\n                \"Successfully uploaded transport package -&gt; %s; new package ID -&gt; %s\",\n                package_name,\n                str(package_id),\n            )\n\n        # Step 2: Create Transport Workbench (if not yet exist)\n        workbench_name = package_name.split(\".\")[0]\n        logger.info(\"Check if workbench -&gt; %s is already deployed...\", workbench_name)\n        # check if the package name has the suffix \"(deployed)\" - this indicates it is alreadey\n        # successfully deployed (see renaming at the end of this method)\n        response = self.get_node_by_parent_and_name(\n            transport_root_volume_id, workbench_name + \" (deployed)\"\n        )\n        workbench_id = self.get_result_value(response, \"id\")\n        if workbench_id:\n            logger.info(\n                \"Workbench -&gt; %s has already been deployed successfully; existing workbench ID -&gt; %s; skipping transport\",\n                workbench_name,\n                str(workbench_id),\n            )\n            # we return and skip this transport...\n            return response\n        else:\n            logger.info(\"Check if workbench -&gt; %s already exists...\", workbench_name)\n            response = self.get_node_by_parent_and_name(\n                transport_root_volume_id, workbench_name\n            )\n            workbench_id = self.get_result_value(response, \"id\")\n            if workbench_id:\n                logger.info(\n                    \"Workbench -&gt; %s does already exist but is not successfully deployed; existing workbench ID -&gt; %s\",\n                    workbench_name,\n                    str(workbench_id),\n                )\n            else:\n                response = self.create_transport_workbench(workbench_name)\n                workbench_id = self.get_result_value(response, \"id\")\n                if not workbench_id:\n                    logger.error(\"Failed to create workbench -&gt; %s\", workbench_name)\n                    return None\n                logger.info(\n                    \"Successfully created workbench -&gt; %s; new workbench ID -&gt; %s\",\n                    workbench_name,\n                    str(workbench_id),\n                )\n\n        # Step 3: Unpack Transport Package to Workbench\n        logger.info(\n            \"Unpack transport package -&gt; %s (%s) to workbench -&gt; %s (%s)\",\n            package_name,\n            str(package_id),\n            workbench_name,\n            str(workbench_id),\n        )\n        response = self.unpack_transport_package(package_id, workbench_id)\n        if not response:\n            logger.error(\"Failed to unpack the transport package -&gt; %s\", package_name)\n            return None\n        logger.info(\n            \"Successfully unpackaged to workbench -&gt; %s (%s)\",\n            workbench_name,\n            str(workbench_id),\n        )\n\n        # Step 4: Deploy Workbench\n        logger.info(\"Deploy workbench -&gt; %s (%s)\", workbench_name, str(workbench_id))\n        response = self.deploy_workbench(workbench_id)\n        if not response:\n            logger.error(\"Failed to deploy workbench -&gt; %s\", workbench_name)\n            return None\n\n        logger.info(\n            \"Successfully deployed workbench -&gt; %s (%s)\",\n            workbench_name,\n            str(workbench_id),\n        )\n        self.rename_node(\n            workbench_id,\n            workbench_name + \" (deployed)\",\n            package_description,\n        )\n\n        return response\n\n    # end method definition\n\n    def replace_transport_placeholders(\n        self, zip_file_path: str, replacements: list\n    ) -&gt; bool:\n        \"\"\"Search and replace strings in the XML files of the transport package\n\n        Args:\n            zip_file_path (str): Path to transport zip file\n            replacements (list of dicts): List of replacement values; dict needs to have two values:\n                                         * placeholder: text to replace\n                                         * value: text to replace with\n        Returns:\n            Filename to the updated zip file\n        \"\"\"\n\n        if not os.path.isfile(zip_file_path):\n            logger.error(\"Zip file -&gt; %s not found.\", zip_file_path)\n            return False\n\n        # Extract the zip file to a temporary directory\n        zip_file_folder = os.path.splitext(zip_file_path)[0]\n        with zipfile.ZipFile(zip_file_path, \"r\") as zfile:\n            zfile.extractall(zip_file_folder)\n\n        modified = False\n\n        # Replace search pattern with replace string in all XML files in the directory and its subdirectories\n        for replacement in replacements:\n            if not \"value\" in replacement:\n                logger.error(\n                    \"Replacement needs a value but it is not specified. Skipping...\"\n                )\n                continue\n            if \"enabled\" in replacement and not replacement[\"enabled\"]:\n                logger.info(\n                    \"Replacement for transport -&gt; %s is disabled. Skipping...\",\n                    zip_file_path,\n                )\n                continue\n            # there are two types of replacements:\n            # 1. XPath - more elegant and powerful\n            # 2. Search &amp; Replace - basically treat the XML file like a text file and do a search &amp; replace\n            if \"xpath\" in replacement:\n                logger.info(\n                    \"Using xpath -&gt; %s to narrow down the replacement\",\n                    replacement[\"xpath\"],\n                )\n                if \"setting\" in replacement:\n                    logger.info(\n                        \"Looking up setting -&gt; %s in XML element\",\n                        replacement[\"setting\"],\n                    )\n                if \"assoc_elem\" in replacement:\n                    logger.info(\n                        \"Looking up assoc element -&gt; %s in XML element\",\n                        replacement[\"assoc_elem\"],\n                    )\n            else:  # we have a simple \"search &amp; replace\" replacement\n                if not \"placeholder\" in replacement:\n                    logger.error(\n                        \"Replacement without an xpath needs a placeholder value but it is not specified. Skipping...\"\n                    )\n                    continue\n                if replacement.get(\"placeholder\") == replacement[\"value\"]:\n                    logger.info(\n                        \"Placeholder and replacement are identical -&gt; %s. Skipping...\",\n                        replacement[\"value\"],\n                    )\n                    continue\n                logger.info(\n                    \"Replace -&gt; %s with -&gt; %s in Transport package -&gt; %s\",\n                    replacement[\"placeholder\"],\n                    replacement[\"value\"],\n                    zip_file_folder,\n                )\n\n            found = XML.replace_in_xml_files(\n                zip_file_folder,\n                replacement.get(\"placeholder\"),\n                replacement[\"value\"],\n                replacement.get(\"xpath\"),\n                replacement.get(\"setting\"),\n                replacement.get(\"assoc_elem\"),\n            )\n            if found:\n                logger.info(\n                    \"Replacement -&gt; %s has been completed successfully for Transport package -&gt; %s\",\n                    replacement,\n                    zip_file_folder,\n                )\n                modified = True\n            else:\n                logger.warning(\n                    \"Replacement -&gt; %s not found in Transport package -&gt; %s\",\n                    replacement,\n                    zip_file_folder,\n                )\n\n        if not modified:\n            logger.warning(\n                \"None of the specified replacements have been found in Transport package -&gt; %s. No need to create a new transport package.\",\n                zip_file_folder,\n            )\n            return False\n\n        # Create the new zip file and add all files from the directory to it\n        new_zip_file_path = (\n            os.path.dirname(zip_file_path) + \"/new_\" + os.path.basename(zip_file_path)\n        )\n        logger.info(\n            \"Content of transport -&gt; %s has been modified - repacking to new zip file -&gt; %s\",\n            zip_file_folder,\n            new_zip_file_path,\n        )\n        with zipfile.ZipFile(new_zip_file_path, \"w\", zipfile.ZIP_DEFLATED) as zip_ref:\n            for subdir, _, files in os.walk(\n                zip_file_folder\n            ):  # 2nd parameter is not used, thus using _ instead of dirs\n                for file in files:\n                    file_path = os.path.join(subdir, file)\n                    rel_path = os.path.relpath(file_path, zip_file_folder)\n                    zip_ref.write(file_path, arcname=rel_path)\n\n        # Close the new zip file and delete the temporary directory\n        zip_ref.close()\n        old_zip_file_path = (\n            os.path.dirname(zip_file_path) + \"/old_\" + os.path.basename(zip_file_path)\n        )\n        logger.info(\n            \"Rename orginal transport zip file -&gt; %s to -&gt; %s\",\n            zip_file_path,\n            old_zip_file_path,\n        )\n        os.rename(zip_file_path, old_zip_file_path)\n        logger.info(\n            \"Rename new transport zip file -&gt; %s to -&gt; %s\",\n            new_zip_file_path,\n            zip_file_path,\n        )\n        os.rename(new_zip_file_path, zip_file_path)\n\n        # Return the path to the new zip file\n        return True\n\n        # end method definition\n\n    def extract_transport_data(self, zip_file_path: str, extractions: list) -&gt; bool:\n        \"\"\"Search and extract XML data from the transport package\n\n        Args:\n            zip_file_path (str): Path to transport zip file\n            extractions (list of dicts): List of extraction values; dict needs to have two values:\n                                         * xpath: structure to find\n                                         * enabed (optional): if the extraction is active\n        Returns:\n            True if successful, False otherwise. THIS METHOD MODIFIES EXTRACTIONS\n            BY ADDING A NEW KEY \"data\" TO EACH EXTRACTION ELEMENT!!\n        \"\"\"\n\n        if not os.path.isfile(zip_file_path):\n            logger.error(\"Zip file -&gt; %s not found.\", zip_file_path)\n            return False\n\n        # Extract the zip file to a temporary directory\n        zip_file_folder = os.path.splitext(zip_file_path)[0]\n        with zipfile.ZipFile(zip_file_path, \"r\") as zfile:\n            zfile.extractall(zip_file_folder)\n\n        # Extract data from all XML files in the directory and its subdirectories\n        for extraction in extractions:\n            if not \"xpath\" in extraction:\n                logger.error(\n                    \"Extraction needs an XPath but it is not specified. Skipping...\"\n                )\n                continue\n            if \"enabled\" in extraction and not extraction[\"enabled\"]:\n                logger.info(\n                    \"Extraction for transport -&gt; %s is disabled. Skipping...\",\n                    zip_file_path,\n                )\n                continue\n\n            xpath = extraction[\"xpath\"]\n            logger.info(\n                \"Using xpath -&gt; %s to extract the data\",\n                xpath,\n            )\n\n            # This delivers a list of strings containing the extracted data:\n            extracted_data = XML.extract_from_xml_files(\n                zip_file_folder,\n                xpath,\n            )\n            if extracted_data:\n                logger.info(\n                    \"Extraction with XPath -&gt; %s has been successfully completed for Transport package -&gt; %s\",\n                    xpath,\n                    zip_file_folder,\n                )\n                # Add the extracted elements to the extraction data structure (dict).\n                extraction[\"data\"] = extracted_data\n            else:\n                logger.warning(\n                    \"Extraction with XPath -&gt; %s has not delivered any data for Transport package -&gt; %s\",\n                    xpath,\n                    zip_file_folder,\n                )\n                extraction[\"data\"] = []\n\n        # Return the path to the new zip file\n        return True\n\n        # end method definition\n\n    def get_business_object_types(self) -&gt; dict | None:\n        \"\"\"Get information for all configured business object types.\n\n        Args:\n            None\n        Returns:\n            dict: Workspace Types information (for all external systems)\n                  or None if the request fails.\n        \"\"\"\n\n        request_url = self.config()[\"businessObjectTypesUrl\"]\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get all business object types; calling -&gt; %s\",\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get business object types; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_business_object_type(\n        self,\n        external_system_id: str,\n        type_name: str,\n        expand_workspace_type: bool = True,\n        expand_external_system: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Get business object type information. Unfortunately this REST API is\n           pretty much limited. It does not return Field names of external system properties\n           and also does not return property groups defined.\n\n        Args:\n            external_system_id (str): External system Id (such as \"TM6\")\n            type_name (str): Type name of the business object (such as \"SAP Customer\")\n        Returns:\n            dict: Business Object Type information or None if the request fails.\n\n            Example response:\n            {\n                'businessProperties': [\n                    {\n                        'attributeID': '14012_29',\n                        'categoryID': '14012',\n                        'name': 'Name',\n                        'type': 'String'\n                    },\n                    {\n                        'attributeID': '14012_28',\n                        'categoryID': '14012',\n                        'name': 'Customer Number',\n                        'type': 'String'\n                    }\n                ]\n                'bwsinfo': {'id': None},\n                'cadxref_doc_info': {'has_relation': False},\n                'categories': [],\n                'claimed_doc_info': {'is_claimed': False},\n                'columns': [{...}, {...}, {...}, {...}],\n                'doctemplates_info': {'isInDocTemplateVolTree': False},\n                'followups': [],\n                'nicknames': {'nickname': '16568'},\n                'properties': {\n                    'advanced_versioning': None,\n                    'container': False,\n                    'container_size': 0,\n                    'create_date': '2017-11-23T16:43:34Z',\n                    'create_user_id': 1000,\n                    'description': '',\n                    'description_multilingual': {...},\n                    'external_create_date': None,\n                    'external_identity': '',\n                    ...\n                },\n                'rmiconsdata': {'class_id': 0, 'official': 0, 'show_classify': False, 'show_hold': False, 'show_hold_tab': False, 'show_label_tab': True, 'show_official': False, 'show_xref': False, 'show_xref_tab': False},\n                'sestatus_doc_info': {'is_se_document': False, 'sync_tooltip': ''},\n                'sharing_info': {'is_shared': False, 'sync_state': -1},\n                'showmainruleicon': False,\n                ...\n            }\n        \"\"\"\n\n        query = {\n            \"expand_ext_system\": expand_external_system,\n            \"expand_wksp_type\": expand_workspace_type,\n        }\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        encoded_type_name = type_name.replace(\"/\", \"%2F\")\n\n        request_url = (\n            self.config()[\"externalSystemUrl\"]\n            + \"/\"\n            + external_system_id\n            + \"/botypes/\"\n            + encoded_type_name\n            + \"?{}\".format(encoded_query)\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get business object type -&gt; %s for external system -&gt; %s; calling -&gt; %s\",\n            type_name,\n            external_system_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get business object type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    type_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_business_objects(\n        self,\n        external_system_id: str,\n        type_name: str,\n        where_clauses: dict | None = None,\n        limit: int | None = None,\n        page: int | None = None,\n    ) -&gt; dict | None:\n        \"\"\"Get all business objects for an external system and a given business object type.\n\n        Args:\n            external_system_id (str): External system Id (such as \"TM6\")\n            type_name (str): Type name of the business object (such as \"SAP Customer\")\n            where_clause (dict, optional): filter the results based on 1 or kultiple\n                                           where clauses (THE  NAME CONVENTION FOR THE\n                                           FIELDS IS UNCLEAR)\n            limit (int, optional): maximum result items\n            page (int, optional): page for chunked result lists\n        Returns:\n            dict: Business Object information (for all results)\n                  or None if the request fails.\n\n            Example response (for a Salesforce Account):\n            {\n                'links': {'data': {...}},\n                'paging': {'limit': 500, 'page': 1, 'page_total': 1, 'range_max': 15, 'range_min': 1, 'total_count': 15},\n                'results': {\n                    'column_descriptions': [\n                        {\n                            'fieldLabel': 'AccountDetail.AccountID',\n                            'fieldName': 'Account.ID',\n                            'keyField': 'X',\n                            'length': 18,\n                            'position': 4\n                        },\n                        {\n                            'fieldLabel': 'AccountName',\n                            'fieldName': 'Account.Name',\n                            'keyField': ' ',\n                            'length': 255,\n                            'position': 2\n                        },\n                        {\n                            'fieldLabel': 'AccountNumber',\n                            'fieldName': 'Account.AccountNumber',\n                            'keyField': ' ',\n                            'length': 40,\n                            'position': 3\n                        },\n                        ...\n                    ]\n                    'max_rows_exceeded': False,\n                    'result_rows': [\n                        {\n                            'AccountDetail.AccountID': '001Dn00000w0bCQIAY',\n                            'AccountDetail.AccountName': 'Jet Stream Inc.',\n                            'AccountDetail.AccountNumber': '1234567',\n                            'AccountDetail.AccountOwner': 'Nick Wheeler',\n                            'AccountDetail.AnnualRevenue': '$900001',\n                            'AccountDetail.Description': '',\n                            'AccountDetail.Employees': '',\n                            'AccountDetail.Industry': 'Biotechnology',\n                            'AccountDetail.ParentAccount': '',\n                            ...\n                        },\n                        ...\n                    ]\n                }\n            }\n        \"\"\"\n\n        query = {\n            \"ext_system_id\": external_system_id,\n            \"bo_type\": type_name,\n        }\n        if limit:\n            query[\"limit\"] = limit\n        if page:\n            query[\"page\"] = page\n        if where_clauses:\n            query.update(\n                {(\"where_\" + key): value for key, value in where_clauses.items()}\n            )\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = self.config()[\"businessObjectsUrl\"] + \"?{}\".format(encoded_query)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get all business objects of type -&gt; %s from external system -&gt; %s; calling -&gt; %s\",\n            type_name,\n            external_system_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get business objects of type -&gt; %s from external system -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    type_name,\n                    external_system_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_business_objects_search(\n        self,\n        external_system_id: str,\n        type_name: str,\n    ) -&gt; dict | None:\n        \"\"\"Get business object type information. Unfortunately this REST API is\n           pretty much limited. It does not return Field names of external system properties\n           and also does not return property groups defined.\n\n        Args:\n            external_system_id (str): External system Id (such as \"TM6\")\n            type_name (str): Type name of the business object (such as \"SAP Customer\")\n        Returns:\n            dict: Business Object Search Form or None if the request fails.\n        \"\"\"\n\n        query = {\n            \"ext_system_id\": external_system_id,\n            \"bo_type\": type_name,\n        }\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = self.config()[\"businessObjectsSearchUrl\"] + \"?{}\".format(\n            encoded_query\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get search form for business object type -&gt; %s and external system -&gt; %s; calling -&gt; %s\",\n            type_name,\n            external_system_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get search form for business object type -&gt; %s and external system -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    type_name,\n                    external_system_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_workspace_types(\n        self, expand_workspace_info: bool = True, expand_templates: bool = True\n    ) -&gt; dict | None:\n        \"\"\"Get all workspace types configured in Extended ECM.\n\n        Args:\n            expand_workspace_info (bool, optional): Controls if the workspace info\n                                                    is returned as well\n            expand_workspace_info (bool, optional): Controls if the list of workspace templates\n                                                    per workspace typ is returned as well\n        Returns:\n            dict: Workspace Types or None if the request fails.\n\n            Example response:\n            {\n                'links': {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data': {\n                            'properties': {\n                                'rm_enabled': False,\n                                'templates': [\n                                    {\n                                        'id': 14471,\n                                        'name': 'Campaign',\n                                        'subtype': 848\n                                    },\n                                    ...\n                                ],\n                                'wksp_type_id': 35,\n                                'wksp_type_name': 'Campaign'\n                            },\n                            'wksp_info': {\n                                'wksp_type_icon': '/appimg/ot_bws/icons/13147%2Esvg?v=161108_84584'\n                            }\n                        }\n                    }\n                ]\n            }\n        \"\"\"\n\n        request_url = self.config()[\"businessWorkspaceTypesUrl\"]\n        if expand_templates:\n            request_url += \"?expand_templates=true\"\n        else:\n            request_url += \"?expand_templates=false\"\n        if expand_workspace_info:\n            request_url += \"&amp;expand_wksp_info=true\"\n        else:\n            request_url += \"&amp;expand_wksp_info=false\"\n\n        request_header = self.request_form_header()\n\n        logger.info(\"Get workspace types; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get workspace types; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_workspace_create_form(\n        self,\n        template_id: int,\n        external_system_id: int = None,\n        bo_type: int = None,\n        bo_id: int = None,\n        parent_id: int = None,\n    ) -&gt; dict | None:\n        \"\"\"Get the Workspace create form.\n\n        Args:\n            template_id (int): ID of the workspace template\n            external_system_id (int, optional): Identifier of the external system (None if no external system)\n            bo_type (int, optional): Business object type (None if no external system)\n            bo_id (int, optional): Business object identifier / key (None if no external system)\n            parent_id (int, optional): Parent ID of the workspaces. Needs only be specified in special\n                                       cases where workspace location cannot be derived from workspace\n                                       type definition, e.g. sub-workspace\n        Returns:\n            dict: Workspace Create Form data or None if the request fails.\n        \"\"\"\n\n        request_url = self.config()[\n            \"businessworkspacecreateform\"\n        ] + \"?template_id={}\".format(template_id)\n        # Is a parent ID specifified? Then we need to add it to the request URL\n        if parent_id is not None:\n            request_url += \"&amp;parent_id={}\".format(parent_id)\n        # Is this workspace connected to a business application / external system?\n        if external_system_id and bo_type and bo_id:\n            request_url += \"&amp;ext_system_id={}\".format(external_system_id)\n            request_url += \"&amp;bo_type={}\".format(bo_type)\n            request_url += \"&amp;bo_id={}\".format(bo_id)\n            logger.info(\n                \"Include business object connection -&gt; (%s, %s, %s) in workspace create form...\",\n                str(external_system_id),\n                str(bo_type),\n                str(bo_id),\n            )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get workspace create form for workspace template ID -&gt; %s; calling -&gt; %s\",\n            str(template_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get workspace create form for template -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(template_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_workspace(self, node_id: int) -&gt; dict | None:\n        \"\"\"Get a workspace based on the node ID.\n\n        Args:\n            node_id (int): Node ID of the workspace to retrieve.\n        Returns:\n            dict: Workspace node information or None if no node with this ID is found.\n\n            Example response:\n            {\n                'links': {\n                    'data': {...}\n                },\n                'meta_data': {\n                    'properties': {...}\n                },\n                'paging': {\n                    'limit': 500,\n                    'page': 1,\n                    'page_total': 1,\n                    'range_max': 1,\n                    'range_min': 1,\n                    'total_count': 1\n                },\n                'results': [\n                    {\n                        'actions': {...},\n                        'data': {\n                            'business_properties': {\n                                'business_object_id': '000004000240',\n                                'business_object_type': 'BUS2007',\n                                'business_object_type_id': 18,\n                                'business_object_type_name': 'Maintenance Order',\n                                'business_object_type_name_multilingual': {...},\n                                'display_url': \"https://fiori.qa.idea-te.eimdemo.com:8443/sap/bc/ui2/flp#MaintenanceOrder-displayXecmFactSheet&amp;//C_ObjPgMaintOrder('000004000240')\",\n                                'external_system_id': 'TM6',\n                                'external_system_name': 'TM6',\n                                'has_default_display': True,\n                                'has_default_search': True,\n                                'isEarly': False,\n                                'workspace_type_id': 42,\n                                'workspace_type_name': 'Maintenance Order',\n                                'workspace_type_name_multilingual': {},\n                                ...\n                            }\n                            'properties': {\n                                'volume_id': -2000,\n                                'id': 36780,\n                                'parent_id': 13567,\n                                'owner_user_id': 7240,\n                                'name': '4600000044 - C.E.B. New York Inc.',\n                                'type': 848,\n                                'description': '',\n                                'create_date': '2023-09-02T11:07:06',\n                                'create_user_id': 7240,\n                                'create_user_id': 7240,\n                                'modify_date': '2023-09-02T11:07:11',\n                                'modify_user_id': 7240,\n                                'reserved': False,\n                                'reserved_user_id': 0,\n                                'reserved_date': None,\n                                'order': None,\n                                'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                                'hidden': False,\n                                'mime_type': None,\n                                'original_id': 0,\n                                'wnf_wksp_type_id': 16,\n                                'wnf_wksp_template_id': 15615,\n                                'size_formatted': '7 Items',\n                                'type_name': 'Business Workspace',\n                                'container': True,\n                                'size': 7,\n                                ...\n                            }\n                            'wksp_info':\n                            {\n                                'wksp_type_icon': '/appimg/ot_bws/icons/16634%2Esvg?v=161194_13949'\n                            }\n                        },\n                        'metadata': {...},\n                        'metadata_order': {...}\n                    }\n                ],\n                'wksp_info': {\n                    'wksp_type_icon': None\n                }\n                'workspace_references': [\n                    {\n                        'business_object_id': '000004000240',\n                        'business_object_type': 'BUS2007',\n                        'business_object_type_id': 18,\n                        'external_system_id': 'TM6',\n                        'has_default_display': True,\n                        'has_default_search': True,\n                        'workspace_type_id': 42\n                    }\n                ]\n            }\n        \"\"\"\n\n        request_url = self.config()[\"businessWorkspacesUrl\"] + \"/\" + str(node_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get workspace with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_workspace_instances(\n        self, type_name: str = \"\", type_id: int = None, expanded_view: bool = True\n    ):\n        \"\"\"Get all workspace instances of a given type. This is a convenience\n           wrapper method for get_workspace_by_type_and_name()\n\n        Args:\n            type_name (str, optional): Name of the workspace type\n            type_id (int, optional): ID of the workspace_type\n            expanded_view (bool, optional): If 'False' then just search in recently\n                                            accessed business workspace for this name and type.\n                                            If 'True' (this is the default) then search in all\n                                            workspaces for this name and type.\n        Returns:\n            dict: Workspace information or None if the workspace is not found.\n        \"\"\"\n\n        # Omitting the name lets it return all instances of the type:\n        return self.get_workspace_by_type_and_name(\n            type_name=type_name, type_id=type_id, name=\"\", expanded_view=expanded_view\n        )\n\n    # end method definition\n\n    def get_workspace_by_type_and_name(\n        self,\n        type_name: str = \"\",\n        type_id: int = None,\n        name: str = \"\",\n        expanded_view: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Lookup workspace based on workspace type and workspace name.\n\n        Args:\n            type_name (str, optional): name of the workspace type\n            type_id (int, optional): ID of the workspace_type\n            name (str, optional): Name of the workspace, if \"\" then deliver all instances\n                                  of the given workspace type.\n            expanded_view (bool, optional): If 'False' then just search in recently\n                                            accessed business workspace for this name and type.\n                                            If 'True' (this is the default) then search in all\n                                            workspaces for this name and type.\n        Returns:\n            dict: Workspace information or None if the workspace is not found.\n        \"\"\"\n\n        # Add query parameters (these are NOT passed via JSon body!)\n        query = {\n            \"expanded_view\": expanded_view,\n        }\n        if type_name:\n            query[\"where_workspace_type_name\"] = type_name\n        if type_id:\n            query[\"where_workspace_type_id\"] = type_id\n        if name:\n            query[\"where_name\"] = name\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = self.config()[\"businessWorkspacesUrl\"] + \"?{}\".format(\n            encoded_query\n        )\n        request_header = self.request_form_header()\n\n        if name:\n            logger.info(\n                \"Get workspace with name -&gt; %s and type -&gt; %s; calling -&gt; %s\",\n                name,\n                type_name,\n                request_url,\n            )\n        else:\n            logger.info(\n                \"Get all workspace instances of type -&gt; %s; calling -&gt; %s\",\n                type_name,\n                request_url,\n            )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if name:\n                    logger.warning(\n                        \"Failed to get workspace -&gt; %s of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        name,\n                        type_name,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.warning(\n                        \"Failed to get workspace instances of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        type_name,\n                        response.status_code,\n                        response.text,\n                    )\n                return None\n\n    # end method definition\n\n    def get_workspace_by_business_object(\n        self,\n        external_system_name: str,\n        business_object_type: str,\n        business_object_id: str,\n        return_workspace_metadata: bool = False,\n        show_error: bool = False,\n    ) -&gt; dict | None:\n        \"\"\"Get a workspace based on the business object of an external system.\n\n        Args:\n            external_system_name (str): Name of the connection\n            business_object_type (str): Type of the Business object, e.g. KNA1 for SAP customers\n            business_object_id (str): ID of the business object in the external system\n            return_workspace_metadata (bool, optional): Whether or not workspace metadata (categories) should be returned.\n                                                        Default is False.\n            show_error (bool, optional): Treat as error if node is not found. Default is False.\n        Returns:\n            dict: Workspace node information or None if no node with this ID is found.\n\n            Example response:\n            {\n                'links': {\n                    'data': {...}\n                },\n                'meta_data': {\n                    'properties': {...}\n                },\n                'paging': {\n                    'limit': 500,\n                    'page': 1,\n                    'page_total': 1,\n                    'range_max': 1,\n                    'range_min': 1,\n                    'total_count': 1\n                },\n                'results': [\n                    {\n                        'actions': {...},\n                        'data': {\n                            'properties': {\n                                'volume_id': -2000,\n                                'id': 36780,\n                                'parent_id': 13567,\n                                'owner_user_id': 7240,\n                                'name': '4600000044 - C.E.B. New York Inc.',\n                                'type': 848,\n                                'description': '',\n                                'create_date': '2023-09-02T11:07:06',\n                                'create_user_id': 7240,\n                                'create_user_id': 7240,\n                                'modify_date': '2023-09-02T11:07:11',\n                                'modify_user_id': 7240,\n                                'reserved': False,\n                                'reserved_user_id': 0,\n                                'reserved_date': None,\n                                'order': None,\n                                'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                                'hidden': False,\n                                'mime_type': None,\n                                'original_id': 0,\n                                'wnf_wksp_type_id': 16,\n                                'wnf_wksp_template_id': 15615,\n                                'size_formatted': '7 Items',\n                                'type_name': 'Business Workspace',\n                                'container': True,\n                                'size': 7,\n                                ...\n                            }\n                        },\n                        'metadata': {...},\n                        'metadata_order': {...}\n                    }\n                ],\n                'wksp_info': {\n                    'wksp_type_icon': None\n                }\n            }\n        \"\"\"\n\n        request_url = (\n            self.config()[\"externalSystemUrl\"]\n            + \"/\"\n            + external_system_name\n            + \"/botypes/\"\n            + business_object_type\n            + \"/boids/\"\n            + business_object_id\n        )\n        if return_workspace_metadata:\n            request_url += \"?metadata\"\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); calling -&gt; %s\",\n            external_system_name,\n            business_object_type,\n            business_object_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\n                        external_system_name,\n                        business_object_type,\n                        business_object_id,\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.info(\n                        \"Cannot fing workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\n                        external_system_name,\n                        business_object_type,\n                        business_object_id,\n                        response.status_code,\n                        response.text,\n                    )\n                return None\n\n    # end method definition\n\n    def create_workspace(\n        self,\n        workspace_template_id: int,\n        workspace_name: str,\n        workspace_description: str,\n        workspace_type: int,\n        category_data: dict | None = None,\n        external_system_id: int = None,\n        bo_type: int | None = None,\n        bo_id: int | None = None,\n        parent_id: int | None = None,\n        ibo_workspace_id: int | None = None,\n        show_error: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Create a new business workspace.\n\n        Args:\n            workspace_template_id (int): ID of the workspace template\n            workspace_name (str): Name of the workspace\n            workspace_description (str): Description of the workspace\n            workspace_type (int): Type ID of the workspace\n            category_data (dict): Category and attributes\n            external_system_id (str, optional): Identifier of the external system (None if no external system)\n            bo_type (str, optional): Business object type (None if no external system)\n            bo_id (str, optional): Business object identifier / key (None if no external system)\n            parent_id (str, optional): Parent ID of the workspaces. Needs only be specified in special\n                                       cases where workspace location cannot be derived from workspace\n                                       type definition\n            ibo_workspace_id (int, optional): Node ID of an existing workspace that is already connected to another\n                                              external system. This allows for subsequent calls to coonect the workspace\n                                              to multiple Business Objects (IBO = Identical Business Objects)\n            show_error (bool, optional): Log an error if workspace cration fails. Otherwise log a warning.\n        Returns:\n            dict: Workspace Create Form data or None if the request fails.\n        \"\"\"\n\n        # Avoid linter warning W0102\n        if category_data is None:\n            category_data = {}\n\n        create_workspace_post_data = {\n            \"template_id\": str(workspace_template_id),\n            \"name\": workspace_name,\n            \"description\": workspace_description,\n            \"wksp_type_id\": str(workspace_type),\n            \"type\": str(848),\n            \"roles\": category_data,\n        }\n\n        # Is this workspace connected to a business application / external system?\n        if external_system_id and bo_type and bo_id:\n            create_workspace_post_data[\"ext_system_id\"] = str(external_system_id)\n            create_workspace_post_data[\"bo_type\"] = str(bo_type)\n            create_workspace_post_data[\"bo_id\"] = str(bo_id)\n            logger.info(\n                \"Use business object connection -&gt; (%s, %s, %s) for workspace -&gt; %s\",\n                str(external_system_id),\n                str(bo_type),\n                str(bo_id),\n                workspace_name,\n            )\n            if ibo_workspace_id:\n                logger.info(\n                    \"This is a subsequent call to create a cross-application workspace (IBO)\"\n                )\n                create_workspace_post_data[\"ibo_workspace_id\"] = ibo_workspace_id\n\n        # If workspace creation location cannot be derived from the workspace type\n        # there may be an optional parent parameter passed to this method. This can\n        # also be the case if workspaces are nested into each other:\n        if parent_id is not None:\n            create_workspace_post_data[\"parent_id\"] = parent_id\n            logger.info(\n                \"Use specified location -&gt; %s for workspace -&gt; %s\",\n                str(parent_id),\n                workspace_name,\n            )\n        else:\n            logger.info(\n                \"Determine location of workspace -&gt; %s via workspace type -&gt; %s\",\n                workspace_name,\n                str(workspace_type),\n            )\n\n        request_url = self.config()[\"businessWorkspacesUrl\"]\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create workspace -&gt; %s with type -&gt; %s from template -&gt; %s; calling -&gt; %s\",\n            workspace_name,\n            str(workspace_type),\n            str(workspace_template_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            # See https://developer.opentext.com/apis/14ba85a7-4693-48d3-8c93-9214c663edd2/4403207c-40f1-476a-b794-fdb563e37e1f/07229613-7ef4-4519-8b8a-47eaff639d42#operation/createBusinessWorkspace\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data={\"body\": json.dumps(create_workspace_post_data)},\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to create workspace -&gt; %s from template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        workspace_name,\n                        str(workspace_template_id),\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.warning(\n                        \"Couldn't create workspace -&gt; %s from template with ID -&gt; %s (it may exist already); status -&gt; %s; error -&gt; %s\",\n                        workspace_name,\n                        str(workspace_template_id),\n                        response.status_code,\n                        response.text,\n                    )\n                return None\n\n    # end method definition\n\n    def create_workspace_relationship(\n        self,\n        workspace_id: int,\n        related_workspace_id: int,\n        relationship_type: str = \"child\",\n    ) -&gt; dict | None:\n        \"\"\"Create a relationship between two workspaces.\n\n        Args:\n            workspace_id (int): ID of the workspace\n            related_workspace_id (int): ID of the related workspace\n            relationship_type (str, optional): \"parent\" or \"child\" - \"child\" is default if omitted\n        Returns:\n            dict: Workspace Relationship data (json) or None if the request fails.\n        \"\"\"\n\n        create_workspace_relationship_post_data = {\n            \"rel_bw_id\": str(related_workspace_id),\n            \"rel_type\": relationship_type,\n        }\n\n        request_url = self.config()[\n            \"businessWorkspacesUrl\"\n        ] + \"/{}/relateditems\".format(workspace_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create workspace relationship between -&gt; %s and -&gt; %s; calling -&gt; %s\",\n            str(workspace_id),\n            str(related_workspace_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=create_workspace_relationship_post_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create workspace relationship between -&gt; %s and -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(workspace_id),\n                    str(related_workspace_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_workspace_relationships(self, workspace_id: int) -&gt; dict | None:\n        \"\"\"Get the Workspace relationships to other workspaces.\n\n        Args:\n            workspace_id (int): ID of the workspace template\n        Returns:\n            dict: Workspace relationships or None if the request fails.\n        \"\"\"\n\n        request_url = (\n            self.config()[\"businessWorkspacesUrl\"]\n            + \"/\"\n            + str(workspace_id)\n            + \"/relateditems\"\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get related workspaces for workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(workspace_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get related workspaces of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(workspace_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_workspace_roles(self, workspace_id: int) -&gt; dict | None:\n        \"\"\"Get the Workspace roles.\n\n        Args:\n            workspace_id (int): ID of the workspace template\n        Returns:\n            dict: Workspace Roles data or None if the request fails.\n        \"\"\"\n\n        request_url = (\n            self.config()[\"businessWorkspacesUrl\"] + \"/\" + str(workspace_id) + \"/roles\"\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get workspace roles of workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(workspace_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get roles of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(workspace_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_member_to_workspace(\n        self, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n    ) -&gt; dict | None:\n        \"\"\"Add member to a workspace role. Check that the user/group is not yet a member.\n\n        Args:\n            workspace_id (int): ID of the workspace\n            role_id (int): ID of the role\n            member_id (int): User ID or Group ID\n            show_warning (bool, optional): If True logs a warning if member is already in role\n        Returns:\n            dict: Workspace Role Membership or None if the request fails.\n        \"\"\"\n\n        add_member_to_workspace_post_data = {\"id\": str(member_id)}\n\n        request_url = self.config()[\n            \"businessWorkspacesUrl\"\n        ] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Check if user/group with ID -&gt; %s is already in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(member_id),\n            str(role_id),\n            str(workspace_id),\n            request_url,\n        )\n\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if not response.ok:\n            logger.error(\n                \"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n\n        workspace_members = self.parse_request_response(response)\n\n        if self.exist_result_item(workspace_members, \"id\", member_id):\n            if show_warning:\n                logger.warning(\n                    \"User/group with ID -&gt; %s is already a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\n                    str(member_id),\n                    str(role_id),\n                    str(workspace_id),\n                )\n            return workspace_members\n\n        logger.info(\n            \"Add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(member_id),\n            str(role_id),\n            str(workspace_id),\n            request_url,\n        )\n\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=add_member_to_workspace_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n\n        if response.ok:\n            return self.parse_request_response(response)\n        else:\n            logger.error(\n                \"Failed to add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(member_id),\n                str(role_id),\n                str(workspace_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n\n    # end method definition\n\n    def remove_member_from_workspace(\n        self, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n    ) -&gt; dict | None:\n        \"\"\"Remove a member from a workspace role. Check that the user is currently a member.\n\n        Args:\n            workspace_id (int): ID of the workspace\n            role_id (int): ID of the role\n            member_id (int): User or Group Id\n            show_warning (bool, optional): If True logs a warning if member is not in role\n        Returns:\n            dict: Workspace Role Membership or None if the request fails.\n        \"\"\"\n\n        request_url = self.config()[\n            \"businessWorkspacesUrl\"\n        ] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Check if user/group with ID -&gt; %s is in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(member_id),\n            str(role_id),\n            str(workspace_id),\n            request_url,\n        )\n\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if not response.ok:\n            logger.error(\n                \"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n\n        workspace_members = self.parse_request_response(response)\n\n        if not self.exist_result_item(workspace_members, \"id\", member_id):\n            if show_warning:\n                logger.warning(\n                    \"User/group with ID -&gt; %s is not a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\n                    str(member_id),\n                    str(role_id),\n                    str(workspace_id),\n                )\n            return None\n\n        request_url = self.config()[\n            \"businessWorkspacesUrl\"\n        ] + \"/{}/roles/{}/members/{}\".format(workspace_id, role_id, member_id)\n\n        logger.info(\n            \"Removing user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(member_id),\n            str(role_id),\n            str(workspace_id),\n            request_url,\n        )\n\n        response = requests.delete(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n\n        if response.ok:\n            return self.parse_request_response(response)\n        else:\n            logger.error(\n                \"Failed to remove user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(member_id),\n                str(role_id),\n                str(workspace_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n\n    # end method definition\n\n    def assign_workspace_permissions(\n        self, workspace_id: int, role_id: int, permissions: list, apply_to: int = 2\n    ) -&gt; dict | None:\n        \"\"\"Update permissions of a workspace role\n        Args:\n            workspace_id (int): ID of the workspace\n            role_id (int): ID of the role\n            permissions (list): List of permissions - potential elements:\n                                \"see\"\n                                \"see_contents\"\n                                \"modify\"\n                                \"edit_attributes\"\n                                \"add_items\"\n                                \"reserve\"\n                                \"add_major_version\"\n                                \"delete_versions\"\n                                \"delete\"\n                                \"edit_permissions\"\n            apply_to (int, optional):  Items to apply the permission change. Possible values:\n                                       0 = this item\n                                       1 = sub-items\n                                       2 = This item and sub-items (default)\n                                       3 = This item and immediate sub-items\n        Returns:\n            dict: Workspace Role Membership or None if the request fails.\n        \"\"\"\n\n        request_url = self.config()[\"businessWorkspacesUrl\"] + \"/{}/roles/{}\".format(\n            workspace_id, role_id\n        )\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Updating Permissions of role with ID -&gt; %s of workspace with ID -&gt; %s with permissions -&gt; %s; calling -&gt; %s\",\n            str(role_id),\n            str(workspace_id),\n            str(permissions),\n            request_url,\n        )\n\n        permission_post_data = {\n            \"permissions\": permissions,\n            \"apply_to\": apply_to,\n        }\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                headers=request_header,\n                data={\"body\": json.dumps(permission_post_data)},\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update permissions for role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(role_id),\n                    str(workspace_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def update_workspace_icon(\n        self, workspace_id: int, file_path: str, file_mimetype: str = \"image/*\"\n    ) -&gt; dict | None:\n        \"\"\"Update a workspace with a with a new icon (which is uploaded).\n\n        Args:\n            workspace_id (int): ID of the workspace\n            file_path (str): path + filename of icon file\n            file_mimetype (str, optional): mimetype of the image\n        Returns:\n            dict: Node information or None if REST call fails.\n        \"\"\"\n\n        if not os.path.exists(file_path):\n            logger.error(\"Workspace icon file does not exist -&gt; %s\", file_path)\n            return None\n\n        update_workspace_icon_post_body = {\n            \"file_content_type\": file_mimetype,\n            \"file_filename\": os.path.basename(file_path),\n        }\n\n        upload_workspace_icon_post_files = [\n            (\n                \"file\",\n                (\n                    f\"{os.path.basename(file_path)}\",\n                    open(file_path, \"rb\"),\n                    file_mimetype,\n                ),\n            )\n        ]\n\n        request_url = (\n            self.config()[\"businessWorkspacesUrl\"] + \"/\" + str(workspace_id) + \"/icons\"\n        )\n\n        request_header = self.cookie()\n\n        logger.info(\n            \"Update icon for workspace ID -&gt; %s with icon file -&gt; %s; calling -&gt; %s\",\n            str(workspace_id),\n            file_path,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=update_workspace_icon_post_body,\n                files=upload_workspace_icon_post_files,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update workspace ID -&gt; %s with new icon -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(workspace_id),\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_unique_names(self, names: list, subtype: int | None = None) -&gt; dict | None:\n        \"\"\"Get definition information for Unique Names.\n\n        Args:\n            names (list): list of unique names to lookup.\n            subtype (int): filter unique names for those pointing to a specific subtype\n\n        Returns:\n            dict | None: Unique name definition information or None if REST call fails.\n\n            Example response:\n            {\n                'links': {'data': {...}},\n                'results': [\n                    {\n                        'NodeId': 13653,\n                        'NodeName': 'Functional Location',\n                        'UniqueName': 'ot_templ_func_location'\n                    },\n                    {\n                        'NodeId': 2424,\n                        'NodeName': 'Content Server Document Templates',\n                        'UniqueName': 'Document Templates'\n                    }\n                ]\n            }\n        \"\"\"\n\n        if not names:\n            logger.error(\"Missing Unique Names!\")\n            return None\n\n        # Add query parameters (these are NOT passed via JSon body!)\n        query = {\"where_names\": \"{\" + \", \".join(names) + \"}\"}\n        if subtype:\n            query[\"where_subtype\"] = subtype\n\n        encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = self.config()[\"uniqueNamesUrl\"] + \"?{}\".format(encoded_query)\n        request_header = self.request_form_header()\n\n        if subtype:\n            logger.info(\n                \"Get unique names -&gt; %s with subtype -&gt; %s; calling -&gt; %s\",\n                str(names),\n                str(subtype),\n                request_url,\n            )\n        else:\n            logger.info(\n                \"Get unique names -&gt; %s; calling -&gt; %s\",\n                str(names),\n                request_url,\n            )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if subtype:\n                    logger.warning(\n                        \"Failed to get unique names -&gt; %s of subtype -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        str(names),\n                        str(subtype),\n                        response.status_code,\n                        response.text,\n                    )\n                else:\n                    logger.warning(\n                        \"Failed to get unique names -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        str(names),\n                        response.status_code,\n                        response.text,\n                    )\n                return None\n\n    def create_item(\n        self,\n        parent_id: int,\n        item_type: str,\n        item_name: str,\n        item_description: str = \"\",\n        url: str = \"\",\n        original_id: int = 0,\n    ) -&gt; dict | None:\n        \"\"\"Create an Extended ECM item. This REST call is somewhat limited. It cannot set favortie (featured item) or hidden item.\n           It does also not accept owner group information.\n\n        Args:\n            parent_id (int): Node ID of the parent\n            item_type (str): Type of the item (e.g. 0 = foler, 140 = URL)\n            item_name (str): Name of the item\n            item_description (str, optional): Description of the item\n            url (str, optional): Address of the URL item (if it is an URL item type)\n            original_id (int, optional): Node ID of the original (referenced) item.\n                                         Required if a shortcut item is created\n        Returns:\n            dict: Request response of the create item call or None if the REST call has failed.\n        \"\"\"\n\n        create_item_post_data = {\n            \"parent_id\": parent_id,\n            \"type\": item_type,\n            \"name\": item_name,\n            \"description\": item_description,\n        }\n\n        if url:\n            create_item_post_data[\"url\"] = url\n        if original_id &gt; 0:\n            create_item_post_data[\"original_id\"] = original_id\n\n        request_url = self.config()[\"nodesUrlv2\"]\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create item -&gt; %s (type -&gt; %s) under parent with ID -&gt; %s; calling -&gt; %s\",\n            item_name,\n            item_type,\n            str(parent_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            response = requests.post(\n                url=request_url,\n                data={\"body\": json.dumps(create_item_post_data)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create item -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    item_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def update_item(\n        self,\n        node_id: int,\n        parent_id: int = 0,\n        item_name: str = \"\",\n        item_description: str = \"\",\n    ) -&gt; dict | None:\n        \"\"\"Update an Extended ECM item (parent, name, description). Changing the parent ID is\n           a move operation. If parent ID = 0 the item will not be moved.\n\n        Args:\n            node_id (int): ID of the node\n            parent_id (int, optional): node ID of the new parent (in case of a move operation)\n            item_name (str, optional): new name of the item\n            item_description (str, optional): new description of the item\n        Returns:\n            dict: Response of the update item request or None if the REST call has failed.\n        \"\"\"\n\n        update_item_put_data = {}\n\n        if item_name:\n            # this is a rename operation\n            update_item_put_data[\"name\"] = item_name\n        if item_description:\n            # this is a change description operation\n            update_item_put_data[\"description\"] = item_description\n        if parent_id:\n            # this is a move operation\n            update_item_put_data[\"parent_id\"] = parent_id\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Update item -&gt; %s with data -&gt; %s; calling -&gt; %s\",\n            item_name,\n            str(update_item_put_data),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            response = requests.put(\n                url=request_url,\n                data={\"body\": json.dumps(update_item_put_data)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update item -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    item_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_document_templates(self, parent_id: int):\n        \"\"\"Get all document templates for a given target location.\n\n        Args:\n            parent_id (int): node ID of target location (e.g. a folder)\n\n        Returns:\n            dict: response of the REST call (converted to a Python dictionary)\n\n            Example response:\n            'results': [\n                {\n                    'container': False,\n                    'hasTemplates': False,\n                    'name': 'Document',\n                    'subtype': 144,\n                    'templates': [\n                        {\n                            'description_multilingual': {...},\n                            'id': 16817,\n                            'isDPWizardAvailable': False,\n                            'mime_type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            'name': 'Innovate Procurement Contract Template 2022.docx',\n                            'name_multilingual': {...},\n                            'size': 144365,\n                            'sizeformatted': '141 KB',\n                            'type': 144\n                        },\n                        {\n                            ...\n                        }\n                    ]\n                }\n            ]\n        \"\"\"\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(parent_id)\n            + \"/doctemplates?subtypes={144}&amp;sidepanel_subtypes={144}\"\n        )\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get document templates for target location -&gt; %s (parent ID); calling -&gt; %s\",\n            str(parent_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get document templates for parent folder -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(parent_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def create_document_from_template(\n        self,\n        template_id: int,\n        parent_id: int,\n        classification_id: int,\n        category_data: dict,\n        doc_name: str,\n        doc_desciption: str = \"\",\n    ) -&gt; dict | None:\n        \"\"\"Create a document based on a document template\n\n        Args:\n            template_id (int): node ID of the document template\n            parent_id (int): node ID of the target location (parent)\n            classification_id (int): node ID of the classification\n            category_data (dict): metadata / category data\n                                    Example: category ID = 12508\n                                    {\n                                        \"12508\": {\n                                            \"12508_2\": \"Draft\",         # Text drop-down\n                                            \"12508_3\": 8559,            # user ID\n                                            \"12508_4\": \"2023-05-10\",    # date\n                                            \"12508_6\": 7357,            # user ID\n                                            \"12508_7\": \"2023-05-11\",    # date\n                                            \"12508_5\": True,            # checkbox / bool\n                                            \"12508_8\": \"EN\",            # text drop-down\n                                            \"12508_9\": \"MS Word\",       # text drop-down\n                                        }\n                                    }\n            doc_name (str): Name of the item to create.\n            doc_description (str, optional): Description of the item to create.\n        \"\"\"\n\n        create_document_post_data = {\n            \"template_id\": template_id,\n            \"parent_id\": parent_id,\n            \"name\": doc_name,\n            \"description\": doc_desciption,\n            \"type\": 144,\n            \"roles\": {\n                \"categories\": category_data,\n                \"classifications\": {\"create_id\": [classification_id], \"id\": []},\n            },\n        }\n\n        request_url = self.config()[\"doctemplatesUrl\"]\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create document -&gt; %s from template with ID -&gt; %s in target location -&gt; %s (parent ID) with classification ID -&gt; %s; calling -&gt; %s\",\n            doc_name,\n            str(template_id),\n            str(parent_id),\n            str(classification_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            response = requests.post(\n                url=request_url,\n                # this seems to only work with a \"body\" tag and is different form the documentation\n                # on developer.opentext.com\n                data={\"body\": json.dumps(create_document_post_data)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create document -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    doc_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_web_report_parameters(self, nickname: str):\n        \"\"\"Get parameters of a Web Report in Extended ECM. These are defined on the Web Report node\n            (Properties --&gt; Parameters)\n\n        Args:\n            nickname (str): Nickname of the Web Reports node.\n        Returns:\n            Response: List of Web Report parameters. Each list item is a dict describing the parameter.\n            Structure of the list items:\n            {\n                \"type\": \"string\",\n                \"parm_name\": \"string\",\n                \"display_text\": \"string\",\n                \"prompt\": true,\n                \"prompt_order\": 0,\n                \"default_value\": null,\n                \"description\": \"string\",\n                \"mandatory\": true\n            }\n            None if the REST call has failed.\n        \"\"\"\n\n        request_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname + \"/parameters\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Retrieving parameters of Web Report with nickname -&gt; %s; calling -&gt; %s\",\n            nickname,\n            request_url,\n        )\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                # Return the \"data\" element which is a list of dict items:\n                result_dict = self.parse_request_response(response)\n                logger.debug(\"Web Report parameters result -&gt; %s\", str(result_dict))\n                if not result_dict.get(\"data\"):\n                    return None\n                return result_dict[\"data\"]\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to retrieve parameters of Web Report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    nickname,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def run_web_report(\n        self, nickname: str, web_report_parameters: dict | None = None\n    ) -&gt; dict | None:\n        \"\"\"Run a Web Report that is identified by its nick name.\n\n        Args:\n            nickname (str): nickname of the Web Reports node.\n            web_report_parameters (dict): Parameters of the Web Report (names + value pairs)\n        Returns:\n            dict: Response of the run Web Report request or None if the Web Report execution has failed.\n        \"\"\"\n\n        # Avoid linter warning W0102:\n        if web_report_parameters is None:\n            web_report_parameters = {}\n\n        request_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Running Web Report with nickname -&gt; %s; calling -&gt; %s\",\n            nickname,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=web_report_parameters,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to run web report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    nickname,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def install_cs_application(self, application_name: str) -&gt; dict | None:\n        \"\"\"Install a CS Application (based on WebReports)\n\n        Args:\n            application_name (str): name of the application (e.g. OTPOReports, OTRMReports, OTRMSecReports)\n        Returns:\n            dict: Response or None if the installation of the CS Application has failed.\n        \"\"\"\n\n        install_cs_application_post_data = {\"appName\": application_name}\n\n        request_url = self.config()[\"csApplicationsUrl\"] + \"/install\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Install CS Application -&gt; %s; calling -&gt; %s\", application_name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=install_cs_application_post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to install CS Application -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    application_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def assign_item_to_user_group(\n        self, node_id: int, subject: str, instruction: str, assignees: list\n    ) -&gt; dict | None:\n        \"\"\"Assign an Extended ECM item to users and groups. This is a function used by\n           Extended ECM for Government.\n\n        Args:\n            node_id (int): node ID of the Extended ECM item (e.g. a workspace or a document)\n            subject (str): title / subject of the assignment\n            instructions (str): more detailed description or instructions for the assignment\n            assignees (list): list of IDs of users or groups\n        Returns:\n            dict: Response of the request or None if the assignment has failed.\n        \"\"\"\n\n        assignment_post_data = {\n            \"subject\": subject,\n            \"instruction\": instruction,\n            \"assignees\": assignees,\n        }\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/xgovassignments\"\n        )\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); calling -&gt; %s\",\n            str(node_id),\n            str(assignees),\n            subject,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"add_assignment\" tag.\n            response = requests.post(\n                url=request_url,\n                data={\"add_assignment\": json.dumps(assignment_post_data)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    str(assignees),\n                    subject,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def convert_permission_string_to_permission_value(self, permissions: list) -&gt; int:\n        \"\"\"Converts a list of permission names (strongs) to a bit-mask.\n\n        Args:\n            permissions (list): List of permission names - see conversion variable below.\n        Returns:\n            int: bit-encoded permission value\n        \"\"\"\n\n        conversion = {\n            \"see\": 130,  # Bits 2 and 8\n            \"see_contents\": 36865,  # Bit 17\n            \"modify\": 65536,  # Bit 18\n            \"edit_attributes\": 131072,  # Bit 19\n            \"add_items\": 4,  # Bit 3\n            \"reserve\": 8192,  # Bit 14\n            \"add_major_version\": 4194304,  # Bit 23\n            \"delete_versions\": 16384,  # Bit 15\n            \"delete\": 8,  # Bit 4\n            \"edit_permissions\": 16,  # Bit 5\n        }\n\n        permission_value = 0\n\n        for permission in permissions:\n            if not conversion.get(permission):\n                logger.error(\"Illegal permission value -&gt; %s\", str(permission))\n                return 0\n            permission_value += conversion[permission]\n\n        return permission_value\n\n    # end method definition\n\n    def convert_permission_value_to_permission_string(\n        self, permission_value: int\n    ) -&gt; list:\n        \"\"\"Converts a bit-encoded permission value to a list of permission names (strings).\n\n        Args:\n            permission_value (int): bit-encoded permission value\n        Returns:\n            list: list of permission names\n        \"\"\"\n\n        conversion = {\n            \"see\": 130,  # Bits 2 and 8\n            \"see_contents\": 36865,  # Bit 17\n            \"modify\": 65536,  # Bit 18\n            \"edit_attributes\": 131072,  # Bit 19\n            \"add_items\": 4,  # Bit 3\n            \"reserve\": 8192,  # Bit 14\n            \"add_major_version\": 4194304,  # Bit 23\n            \"delete_versions\": 16384,  # Bit 15\n            \"delete\": 8,  # Bit 4\n            \"edit_permissions\": 16,  # Bit 5\n        }\n\n        permissions = []\n\n        for key, value in conversion.items():\n            if permission_value &amp; value:  # binary and\n                permissions.append(key)\n\n        return permissions\n\n    # end method definition\n\n    def assign_permission(\n        self,\n        node_id: int,\n        assignee_type: str,\n        assignee: int,\n        permissions: list,\n        apply_to: int = 0,\n    ) -&gt; dict | None:\n        \"\"\"Assign permissions for Extended ECM item to a user or group.\n\n        Args:\n            node_id (int): node ID of the Extended ECM item\n            assignee_type (str): this can be either \"owner\", \"group\" (for owner group),\n                                    \"public\", or \"custom\" (assigned access)\n            assignee (int): ID of user or group (\"right ID\"). If 0 and assigneeType\n                                is \"owner\" or \"group\" then it is assumed that the owner and\n                                owner group should not be changed.\n            permissions (list): list of permissions - potential elements:\n                                \"see\"\n                                \"see_contents\"\n                                \"modify\"\n                                \"edit_attributes\"\n                                \"add_items\"\n                                \"reserve\"\n                                \"add_major_version\"\n                                \"delete_versions\"\n                                \"delete\"\n                                \"edit_permissions\"\n            apply_to (int, optional): elements to apply permissions to - potential values:\n                                 0 = this item (default)\n                                 1 = sub-items\n                                 2 = This item and sub-items\n                                 3 = This item and immediate sub-items\n        Returns:\n            dict: Response of the request or None if the assignment of permissions has failed.\n        \"\"\"\n\n        if not assignee_type or not assignee_type in [\n            \"owner\",\n            \"group\",\n            \"public\",\n            \"custom\",\n        ]:\n            logger.error(\n                \"Missing or wrong assignee type. Needs to be owner, group, public or custom!\"\n            )\n            return None\n        if assignee_type == \"custom\" and not assignee:\n            logger.error(\"Missing permission assignee!\")\n            return None\n\n        permission_post_data = {\n            \"permissions\": permissions,\n            \"apply_to\": apply_to,\n        }\n\n        # Assignees can be specified for owner and group and must be specified for custom:\n        #\n        if assignee:\n            permission_post_data[\"right_id\"] = assignee\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(node_id)\n            + \"/permissions/\"\n            + assignee_type\n        )\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Assign permissions -&gt; %s to item with ID -&gt; %s; assignee type -&gt; %s; calling -&gt; %s\",\n            str(permissions),\n            str(node_id),\n            assignee_type,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n            if assignee_type == \"custom\":\n                # Custom also has a REST POST - we prefer this one as to\n                # also allows to add a new assigned permission (user or group):\n                response = requests.post(\n                    url=request_url,\n                    data={\"body\": json.dumps(permission_post_data)},\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n            else:\n                # Owner, Owner Group and Public require REST PUT:\n                response = requests.put(\n                    url=request_url,\n                    data={\"body\": json.dumps(permission_post_data)},\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign permissions -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(permissions),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_node_categories(self, node_id: int, metadata: bool = True):\n        \"\"\"Get categories assigned to a node.\n\n        Args:\n            node_id (int): ID of the node to get the categories for.\n            metadata (bool, optional): expand the attribute definitions of the category. Default is True.\n        Returns:\n            dict: category response or None if the call to the REST API fails.\n        \"\"\"\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\n        if metadata:\n            request_url += \"?metadata\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get categories of node with ID -&gt; %s; calling -&gt; %s\",\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get categories for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_node_category(self, node_id: int, category_id: int, metadata: bool = True):\n        \"\"\"Get a specific category assigned to a node.\n\n        Args:\n            node_id (int): ID of the node to get the categories for.\n            category_id (int): ID of the category definition ID (in category volume)\n            metadata (bool, optional): expand the attribute definitions of the category. Default is True\n        Returns:\n            dict: category response or None if the call to the REST API fails.\n        \"\"\"\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(node_id)\n            + \"/categories/\"\n            + str(category_id)\n        )\n        if metadata:\n            request_url += \"?metadata\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Get category with ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\n            str(category_id),\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get category with ID -&gt; %s for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(category_id),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_node_category_ids(self, node_id: int) -&gt; list:\n        \"\"\"Get list of all category definition IDs that are assign to the node.\n\n        Args:\n            node_id (int): ID of the node to get the categories for.\n        Returns:\n            list: list of category IDs (all categories assigned to the node)\n        \"\"\"\n\n        categories = self.get_node_categories(node_id)\n        if not categories or not categories[\"results\"]:\n            return None\n\n        category_id_list = []\n\n        for category in categories[\"results\"]:\n            category_id_list += [\n                int(i) for i in category[\"metadata_order\"][\"categories\"]\n            ]\n\n        return category_id_list\n\n    # end method definition\n\n    def get_node_category_definition(\n        self, node_id: int, category_name: str\n    ) -&gt; tuple[int, dict]:\n        \"\"\"Get category definition (category id and attribute IDs and types)\n\n        Args:\n            node_id (int): node to read the category definition from\n                           (e.g. a workspace template or a document template or a target folder)\n                           This should NOT be the category definition object!\n            category_name (str): name of the category\n        Returns:\n            int: category ID\n            dict: keys are the attribute names. values are sub-dictionaries with the id and type of the attribute.\n\n            Example response:\n            {\n                'Status': {\n                    'id': '12532_2',\n                    'type': 'String'\n                },\n                'Legal Approval': {\n                    'id': '12532_3',\n                    'type': 'user'\n                },\n                ...\n            }\n        \"\"\"\n\n        attribute_definitions = {}\n        cat_id = -1\n\n        response = self.get_node_categories(node_id)\n        if response and response[\"results\"]:\n            for categories in response[\"results\"]:\n                keys = categories[\"metadata\"][\"categories\"].keys()\n                cat_id = next((key for key in keys if \"_\" not in key), -1)\n                cat_name = categories[\"metadata\"][\"categories\"][cat_id][\"name\"]\n                if cat_name != category_name:\n                    continue\n                for att_id in categories[\"metadata\"][\"categories\"]:\n                    if not \"_\" in att_id:\n                        continue\n                    att_name = categories[\"metadata\"][\"categories\"][att_id][\"name\"]\n                    if categories[\"metadata\"][\"categories\"][att_id][\"persona\"]:\n                        att_type = categories[\"metadata\"][\"categories\"][att_id][\n                            \"persona\"\n                        ]\n                    else:\n                        att_type = categories[\"metadata\"][\"categories\"][att_id][\n                            \"type_name\"\n                        ]\n                    attribute_definitions[att_name] = {\"id\": att_id, \"type\": att_type}\n        return cat_id, attribute_definitions\n\n    # end method definition\n\n    def assign_category(\n        self,\n        node_id: int,\n        category_id: list,\n        inheritance: bool = False,\n        apply_to_sub_items: bool = False,\n        apply_action: str = \"add_upgrade\",\n        add_version: bool = False,\n        clear_existing_categories: bool = False,\n    ) -&gt; bool:\n        \"\"\"Assign a category to a node. Optionally turn on inheritance and apply\n           category to sub-items (if node_id is a container / folder / workspace).\n           If the category is already assigned to the node this method will\n           throw an error.\n\n        Args:\n            node_id (int): node ID to apply the category to\n            category_id (list): ID of the category definition object\n            inheritance (bool): turn on inheritance for the category\n                                   (this makes only sense if the node is a container like a folder or workspace)\n            apply_to_sub_items (bool, optional): if True the category is applied to\n                                                    the item and all its sub-items\n                                                    if False the category is only applied\n                                                    to the item\n            apply_action (str, optional): supported values are \"add\", \"add_upgrade\", \"upgrade\", \"replace\", \"delete\", \"none\", None\n            add_version (bool, optional): if a document version should be added for the category change (default = False)\n            clear_existing_categories (bool, optional): whether or not existing (other) categories should be removed (default = False)\n        Returns:\n            bool: True = success, False = error\n        \"\"\"\n\n        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\n        request_header = self.request_form_header()\n\n        #\n        # 1. Assign Category to Node if not yet assigned:\n        #\n\n        existing_category_ids = self.get_node_category_ids(node_id)\n        if not category_id in existing_category_ids:\n            logger.info(\n                \"Category with ID -&gt; %s is not yet assigned to node ID -&gt; %s. Assigning it now...\",\n                str(category_id),\n                str(node_id),\n            )\n            category_post_data = {\n                \"category_id\": category_id,\n            }\n\n            logger.info(\n                \"Assign category with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\n                str(category_id),\n                str(node_id),\n                request_url,\n            )\n\n            retries = 0\n            while True:\n                response = requests.post(\n                    url=request_url,\n                    data=category_post_data,\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n                if response.ok:\n                    break\n                # Check if Session has expired - then re-authenticate and try once more\n                elif response.status_code == 401 and retries == 0:\n                    logger.warning(\"Session has expired - try to re-authenticate...\")\n                    self.authenticate(revalidate=True)\n                    retries += 1\n                else:\n                    logger.error(\n                        \"Failed to assign category with ID -&gt; %s to node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        str(category_id),\n                        str(node_id),\n                        response.status_code,\n                        response.text,\n                    )\n                    return False\n\n        #\n        # 2. Set Inheritance\n        #\n\n        request_url_inheritance = request_url + \"/\" + str(category_id) + \"/inheritance\"\n\n        retries = 0\n        while True:\n            if inheritance:\n                # Enable inheritance\n                response = requests.post(\n                    url=request_url_inheritance,\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n            else:\n                # Disable inheritance\n                response = requests.delete(\n                    url=request_url_inheritance,\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n            if response.ok:\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to set inheritance for category with ID -&gt; %s on node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(category_id),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n        #\n        # 3. Apply to sub-items\n        #\n\n        if apply_to_sub_items:\n            request_url_apply_sub_items = request_url + \"/apply\"\n\n            category_post_data = {\n                \"categories\": [{\"id\": category_id, \"action\": apply_action}],\n                \"add_version\": add_version,\n                \"clear_existing_categories\": clear_existing_categories,\n            }\n\n            retries = 0\n            while True:\n                # we need to wrap the body of this POST call into a \"body\"\n                # tag. This is documented worngly on developer.opentext.com\n                response = requests.post(\n                    url=request_url_apply_sub_items,\n                    data={\"body\": json.dumps(category_post_data)},\n                    headers=request_header,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n                if response.ok:\n                    break\n                # Check if Session has expired - then re-authenticate and try once more\n                elif response.status_code == 401 and retries == 0:\n                    logger.warning(\"Session has expired - try to re-authenticate...\")\n                    self.authenticate(revalidate=True)\n                    retries += 1\n                else:\n                    logger.error(\n                        \"Failed to apply category with ID -&gt; %s to sub-items of node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                        str(category_id),\n                        str(node_id),\n                        response.status_code,\n                        response.text,\n                    )\n                    return False\n        return True\n\n    # end method definition\n\n    def set_category_value(\n        self,\n        node_id: int,\n        value,\n        category_id: int,\n        attribute_id: int,\n        set_id: int = 0,\n        set_row: int = 1,\n    ) -&gt; dict | None:\n        \"\"\"Set a value to a specific attribute in a category. Categories and have sets (groupings), multi-line sets (matrix),\n           and multi-value attributes (list of values). This method supports all variants.\n\n        Args:\n            node_id (int): ID of the node\n            value (multi-typed): value to be set - can be string or list of strings (for multi-value attributes)\n            category_id (int):ID of the category object\n            attribute_id (int): ID of the attribute\n            set_id (int, optional): ID of the set. Defaults to 0.\n            set_row (int, optional): Row of . Defaults to 1.\n\n        Returns:\n            dict: REST API response or None if the call fails\n        \"\"\"\n\n        request_url = (\n            self.config()[\"nodesUrlv2\"]\n            + \"/\"\n            + str(node_id)\n            + \"/categories/\"\n            + str(category_id)\n        )\n        request_header = self.request_form_header()\n\n        if set_id:\n            logger.info(\n                \"Assign value -&gt; %s to category with ID -&gt; %s, set ID -&gt; %s, row -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\n                str(value),\n                str(category_id),\n                str(set_id),\n                str(set_row),\n                str(attribute_id),\n                str(node_id),\n                request_url,\n            )\n            category_put_data = {\n                \"category_id\": category_id,\n                \"{}_{}_{}_{}\".format(category_id, set_id, set_row, attribute_id): value,\n            }\n        else:\n            logger.info(\n                \"Assign value -&gt; %s to category ID -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\n                str(value),\n                str(category_id),\n                str(attribute_id),\n                str(node_id),\n                request_url,\n            )\n            category_put_data = {\n                \"category_id\": category_id,\n                \"{}_{}\".format(category_id, attribute_id): value,\n            }\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                data=category_put_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to set value -&gt; %s for category with ID -&gt; %s, attribute ID -&gt; %s on node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(value),\n                    str(category_id),\n                    str(attribute_id),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def assign_classification(\n        self, node_id: int, classifications: list, apply_to_sub_items: bool = False\n    ) -&gt; dict | None:\n        \"\"\"Assign one or multiple classifications to an Extended ECM item\n        Args:\n            node_id (int): node ID of the Extended ECM item\n            classifications (list): list of classification item IDs\n            apply_to_sub_items (bool, optional): if True the classification is applied to\n                                                    the item and all its sub-items\n                                                    if False the classification is only applied\n                                                    to the item\n        Returns:\n            dict: Response of the request or None if the assignment of the classification has failed.\n        \"\"\"\n\n        # the REST API expects a list of dict elements with \"id\" and the actual IDs\n        classification_list = []\n        for classification in classifications:\n            classification_list.append({\"id\": classification})\n\n        classification_post_data = {\n            \"class_id\": classification_list,\n            \"apply_to_sub_items\": apply_to_sub_items,\n        }\n\n        request_url = (\n            self.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/classifications\"\n        )\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Assign classifications with IDs -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\n            str(classifications),\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=classification_post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign classifications with IDs -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(classifications),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def assign_rm_classification(\n        self, node_id: int, rm_classification: int, apply_to_sub_items: bool = False\n    ) -&gt; dict | None:\n        \"\"\"Assign a RM classification to an Extended ECM item\n        Args:\n            node_id (int): node ID of the Extended ECM item\n            rm_classification (int): Records Management classification ID\n            apply_to_sub_items (bool, optional): if True the RM classification is applied to\n                                                    the item and all its sub-items\n                                                    if False the RM classification is only applied\n                                                    to the item\n        Returns:\n            dict: Response of the request or None if the assignment of the RM classification has failed.\n        \"\"\"\n\n        rm_classification_post_data = {\n            \"class_id\": rm_classification,\n            \"apply_to_sub_items\": apply_to_sub_items,\n        }\n\n        request_url = (\n            self.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/rmclassifications\"\n        )\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\n            str(rm_classification),\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=rm_classification_post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(rm_classification),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def register_workspace_template(self, node_id: int) -&gt; dict | None:\n        \"\"\"Register a workspace template as project template for Extended ECM for Engineering\n        Args:\n            node_id (int): node ID of the Extended ECM workspace template\n        Returns:\n            dict: Response of request or None if the registration of the workspace template has failed.\n        \"\"\"\n\n        registration_post_data = {\"ids\": \"{{ {} }}\".format(node_id)}\n\n        request_url = self.config()[\"xEngProjectTemplateUrl\"]\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Register workspace template with ID -&gt; %s; calling -&gt; %s\",\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=registration_post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to register Workspace Template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_records_management_rsis(self, limit: int = 100) -&gt; list | None:\n        \"\"\"Get all Records management RSIs togther with their RSI Schedules.\n\n        Args:\n            limit (int, optional): max elements to return (default = 100)\n        Returns:\n            list: list of Records Management RSIs or None if the request fails.\n            Each RSI list element is a dict with this structure:\n            {\n                \"RSIID\": 0,\n                \"RSI\": \"string\",\n                \"Title\": \"string\",\n                \"Subject\": \"string\",\n                \"Description\": \"string\",\n                \"CreateDate\": \"string\",\n                \"RSIStatus\": \"string\",\n                \"StatusDate\": \"string\",\n                \"DiscontFlag\": 0,\n                \"DiscontDate\": \"string\",\n                \"DiscontComment\": \"string\",\n                \"Active\": 0,\n                \"DispControl\": 0,\n                \"RSIScheduleID\": 0,\n                \"RetStage\": \"string\",\n                \"RecordType\": 0,\n                \"EventType\": 0,\n                \"RSIRuleCode\": \"string\",\n                \"DateToUse\": \"string\",\n                \"YearEndMonth\": 0,\n                \"YearEndDay\": 0,\n                \"RetYears\": 0,\n                \"RetMonths\": 0,\n                \"RetDays\": 0,\n                \"RetIntervals\": 0,\n                \"EventRuleDate\": \"string\",\n                \"EventRule\": \"string\",\n                \"EventComment\": \"string\",\n                \"StageAction\": \"string\",\n                \"FixedRet\": 0,\n                \"ActionCode\": \"string\",\n                \"ActionDescription\": \"string\",\n                \"Disposition\": \"string\",\n                \"ApprovalFlag\": 0,\n                \"MaximumRet\": 0,\n                \"ObjectType\": \"LIV\"\n            }\n        \"\"\"\n\n        request_url = self.config()[\"rsisUrl\"] + \"?limit=\" + str(limit)\n        request_header = self.request_form_header()\n\n        logger.info(\"Get list of Records Management RSIs; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                rsi_dict = self.parse_request_response(response)\n                return rsi_dict[\"results\"][\"data\"][\"rsis\"]\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of Records Management RSIs; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_records_management_codes(self) -&gt; dict | None:\n        \"\"\"Get Records Management Codes. These are the most basic data types of\n           the Records Management configuration and required to create RSIs and\n           other higher-level Records Management configurations\n\n        Args:\n            None\n        Returns:\n            dict: RM codes or None if the request fails.\n        \"\"\"\n\n        request_url = self.config()[\"recordsManagementUrlv2\"] + \"/rmcodes\"\n        request_header = self.request_form_header()\n\n        logger.info(\"Get list of Records Management codes; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                rm_codes_dict = self.parse_request_response(response)\n                return rm_codes_dict[\"results\"][\"data\"]\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of Records Management codes; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    # This is not yet working. REST API endpoint seems not to be in 22.4. Retest with 23.1\n    def update_records_management_codes(self, rm_codes: dict) -&gt; dict | None:\n        \"\"\"Update Records Management Codes. These are the most basic data types of\n           the Records Management configuration and required to create RSIs and\n           other higher-level Records Management configurations\n           THIS METHOD IS CURRENTLY NOT WORKING\n\n        Args:\n            rm_codes (dict): Codes to be updated\n        Returns:\n            dict: RSI data or None if the request fails.\n        \"\"\"\n\n        update_rm_codes_post_data = {}\n\n        request_url = self.config()[\"recordsManagementUrl\"] + \"/rmcodes\"\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Update Records Management codes -&gt; %s; calling -&gt; %s\",\n            str(rm_codes),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=update_rm_codes_post_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                rm_codes_dict = self.parse_request_response(response)\n                return rm_codes_dict[\"results\"][\"data\"]\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update Records Management codes; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def create_records_management_rsi(\n        self,\n        name: str,\n        status: str,\n        status_date: str,\n        description: str,\n        subject: str,\n        title: str,\n        dispcontrol: bool,\n    ) -&gt; dict | None:\n        \"\"\"Create a new Records Management RSI.\n\n        Args:\n            name (str): name of the RSI\n            status (str): status of the RSI\n            status_date (str): statusDate of the RSI YYYY-MM-DDTHH:mm:ss\n            description (str): description of the RSI\n            subject (str): status of the RSI\n            title (str): status of the RSI\n            dispcontrol (bool): status of the RSI\n        Returns:\n            dict: RSI data or None if the request fails.\n        \"\"\"\n\n        if status_date == \"\":\n            now = datetime.now()\n            status_date = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        create_rsi_post_data = {\n            \"name\": name,\n            \"status\": status,\n            \"statusDate\": status_date,\n            \"description\": description,\n            \"subject\": subject,\n            \"title\": title,\n            \"dispcontrol\": dispcontrol,\n        }\n\n        request_url = self.config()[\"rsiSchedulesUrl\"]\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create Records Management RSI -&gt; %s; calling -&gt; %s\", name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=create_rsi_post_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create Records Management RSI -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def create_records_management_rsi_schedule(\n        self,\n        rsi_id: int,\n        stage: str,\n        event_type: int = 1,\n        object_type: str = \"LIV\",\n        rule_code: str = \"\",\n        rule_comment: str = \"\",\n        date_to_use: int = 91,\n        retention_years: int = 0,\n        retention_months: int = 0,\n        retention_days: int = 0,\n        category_id: int = 0,\n        attribute_id: int = 0,\n        year_end_month: int = 12,\n        year_end_day: int = 31,\n        retention_intervals: int = 1,\n        fixed_retention: bool = True,\n        maximum_retention: bool = True,\n        fixed_date: str = \"\",\n        event_condition: str = \"\",\n        disposition: str = \"\",\n        action_code: int = 0,\n        description: str = \"\",\n        new_status: str = \"\",\n        min_num_versions_to_keep: int = 1,\n        purge_superseded: bool = False,\n        purge_majors: bool = False,\n        mark_official_rendition: bool = False,\n    ) -&gt; dict | None:\n        \"\"\"Create a new Records Management RSI Schedule for an existing RSI.\n\n        Args:\n            rsi_id (int): ID of an existing RSI the schedule should be created for\n            stage (str): retention stage - this is the key parameter to define multiple stages (stages are basically schedules)\n            event_type (int): 1 Calculated Date, 2 Calendar Calculation, 3 Event Based, 4 Fixed Date, 5 Permanent\n            object_type (str): either \"LIV\" - Classified Objects (default) or \"LRM\" - RM Classifications\n            rule_code (str, optional): rule code - this value must be defined upfront\n            rule_comment (str, optional): comment for the rule\n            date_to_use (int, optional): 91 Create Date, 92 Reserved Data, 93 Modification Date, 94 Status Date, 95 Records Date\n            retention_years (int, optional): years to wait before disposition\n            retention_months (int, optional): month to wait before disposition\n            retention_days (int, optional): days to wait before disposition\n            category_id (int, optional): ID of the category\n            attribute_id (int, optional): ID of the category attribute\n            year_end_month (int, optional): month the year ends (default = 12)\n            year_end_day (int, optional): day the year ends (default = 31)\n            retention_intervals (int, optional): retention intervals\n            fixed_retention (bool, optional): fixedRetention\n            maximum_retention (bool,optional): maximumRetention\n            fixed_date(str, optional): fixed date format : YYYY-MM-DDTHH:mm:ss\n            event_condition (str, optional): eventCondition\n            disposition (str, optional): disposition\n            action_code (int, optional): 0 None, 1 Change Status, 7 Close, 8 Finalize Record, 9 Mark Official, 10 Export, 11 Update Storage Provider, 12 Delete Electronic Format, 15 Purge Versions, 16 Make Rendition, 32 Destroy\n            description (str, optional): description\n            new_status (str, optional): new status\n            min_num_versions_to_keep (int, optional): minimum document versions to keep, . Default is 1.\n            purge_superseded (bool, optional): purge superseded. Default is False.\n            purge_majors (bool, optional): purge majors. Default is False.\n            mark_official_rendition (bool, optional): mark official rendition. Default is False.\n        Returns:\n            dict: RSI Schedule data or None if the request fails.\n        \"\"\"\n\n        if fixedDate == \"\":\n            now = datetime.now()\n            fixedDate = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        create_rsi_schedule_post_data = {\n            \"objectType\": object_type,\n            \"stage\": stage,\n            \"eventType\": event_type,\n            \"ruleCode\": rule_code,\n            \"ruleComment\": rule_comment,\n            \"dateToUse\": date_to_use,\n            \"retentionYears\": retention_years,\n            \"retentionMonths\": retention_months,\n            \"retentionDays\": retention_days,\n            \"categoryId\": category_id,\n            \"attributeId\": attribute_id,\n            \"yearEndMonth\": year_end_month,\n            \"yearEndDay\": year_end_day,\n            \"retentionIntervals\": retention_intervals,\n            \"fixedRetention\": fixed_retention,\n            \"maximumRetention\": maximum_retention,\n            \"fixedDate\": fixed_date,\n            \"eventCondition\": event_condition,\n            \"disposition\": disposition,\n            \"actionCode\": action_code,\n            \"description\": description,\n            \"newStatus\": new_status,\n            \"minNumVersionsToKeep\": min_num_versions_to_keep,\n            \"purgeSuperseded\": purge_superseded,\n            \"purgeMajors\": purge_majors,\n            \"markOfficialRendition\": mark_official_rendition,\n        }\n\n        request_url = self.config()[\"rsiSchedulesUrl\"] + \"/\" + str(rsi_id) + \"/stages\"\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create Records Management RSI Schedule -&gt; %s for RSI -&gt; %s; calling -&gt; %s\",\n            stage,\n            str(rsi_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=create_rsi_schedule_post_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create Records Management RSI Schedule -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    stage,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def create_records_management_hold(\n        self,\n        hold_type: str,\n        name: str,\n        comment: str,\n        alternate_id: str = \"\",\n        parent_id: int = 0,\n        date_applied: str = \"\",\n        date_to_remove: str = \"\",\n    ) -&gt; dict | None:\n        \"\"\"Create a new Records Management Hold.\n\n        Args:\n            hold_type (str): type of the Hold\n            name (str): name of the RSI\n            comment (str): comment\n            alternate_id (str, optional): alternate hold ID\n            parent_id (int, optional): ID of the parent node. If parent_id is 0 the item will be created right under \"Hold Management\" (top level item)\n            date_applied (str, optional): create date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n            date_to_remove (str, optional): suspend date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n        Returns:\n            dict: Hold data or None if the request fails. The dict structure is this: {'holdID': &lt;ID&gt;}\n        \"\"\"\n\n        if date_applied == \"\":\n            now = datetime.now()\n            date_applied = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        create_hold_post_data = {\n            \"type\": hold_type,\n            \"name\": name,\n            \"comment\": comment,\n            \"date_applied\": date_applied,\n            \"date_to_remove\": date_to_remove,\n            \"alternate_id\": alternate_id,\n        }\n\n        if parent_id &gt; 0:\n            create_hold_post_data[\"parent_id\"] = parent_id\n\n        request_url = self.config()[\"holdsUrl\"]\n\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Create Records Management Hold -&gt; %s; calling -&gt; %s\", name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=create_hold_post_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to create Records Management Hold -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_records_management_holds(self) -&gt; dict | None:\n        \"\"\"Get a list of all Records Management Holds in the system. Even though there are folders\n        in the holds management area in RM these are not real folders - they cannot be retrieved\n        with get_node_by_parent_and_name() thus we need this method to get them all.\n\n        Args:\n            None\n        Returns:\n            dict: Response with list of holds:\n            \"results\": {\n                \"data\": {\n                    \"holds\": [\n                        {\n                            \"HoldID\": 0,\n                            \"HoldName\": \"string\",\n                            \"ActiveHold\": 0,\n                            \"OBJECT\": 0,\n                            \"ApplyPatron\": \"string\",\n                            \"DateApplied\": \"string\",\n                            \"HoldComment\": \"string\",\n                            \"HoldType\": \"string\",\n                            \"DateToRemove\": \"string\",\n                            \"DateRemoved\": \"string\",\n                            \"RemovalPatron\": \"string\",\n                            \"RemovalComment\": \"string\",\n                            \"EditDate\": \"string\",\n                            \"EditPatron\": \"string\",\n                            \"AlternateHoldID\": 0,\n                            \"ParentID\": 0\n                        }\n                    ]\n                }\n            }\n        \"\"\"\n\n        request_url = self.config()[\"holdsUrlv2\"]\n\n        request_header = self.request_form_header()\n\n        logger.info(\"Get list of Records Management Holds; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get list of Records Management Holds; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def import_records_management_settings(self, file_path: str) -&gt; bool:\n        \"\"\"Import Records Management settings from a file that is uploaded from the python pod\n\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"recordsManagementUrl\"] + \"/importSettings\"\n\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n        logger.info(\n            \"Importing Records Management Settings from file -&gt; %s; calling -&gt; %s\",\n            file_path,\n            request_url,\n        )\n\n        filename = os.path.basename(file_path)\n        if not os.path.exists(file_path):\n            logger.error(\n                \"The file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(file_path),\n            )\n            return False\n        settings_post_file = {\n            \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                files=settings_post_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import Records Management Settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def import_records_management_codes(\n        self, file_path: str, update_existing_codes: bool = True\n    ) -&gt; bool:\n        \"\"\"Import RM Codes from a file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of settings file in Python container filesystem\n            update_existing_codes (bool): Flag that controls whether existing table maintenance codes\n                                          should be updated.\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"recordsManagementUrl\"] + \"/importCodes\"\n\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n        logger.info(\n            \"Importing Records Management Codes from file -&gt; %s; calling -&gt; %s\",\n            file_path,\n            request_url,\n        )\n\n        settings_post_data = {\"updateExistingCodes\": update_existing_codes}\n\n        filename = os.path.basename(file_path)\n        if not os.path.exists(file_path):\n            logger.error(\n                \"The file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(file_path),\n            )\n            return False\n        settings_post_file = {\n            \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=settings_post_data,\n                files=settings_post_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import Records Management Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def import_records_management_rsis(\n        self,\n        file_path: str,\n        update_existing_rsis: bool = True,\n        delete_schedules: bool = False,\n    ) -&gt; bool:\n        \"\"\"Import RM RSIs from a config file that is uploaded from the Python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n            update_existing_rsis (bool, optional): whether or not existing RSIs should be updated (or ignored)\n            delete_schedules (bool, optional): whether RSI Schedules should be deleted\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"recordsManagementUrl\"] + \"/importRSIs\"\n\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n        logger.info(\n            \"Importing Records Management RSIs from file -&gt; %s; calling -&gt; %s\",\n            file_path,\n            request_url,\n        )\n\n        settings_post_data = {\n            \"updateExistingRSIs\": update_existing_rsis,\n            \"deleteSchedules\": delete_schedules,\n        }\n\n        filename = os.path.basename(file_path)\n        if not os.path.exists(file_path):\n            logger.error(\n                \"The file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(file_path),\n            )\n            return False\n        settings_post_file = {\n            \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=settings_post_data,\n                files=settings_post_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import Records Management RSIs from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def import_physical_objects_settings(self, file_path: str) -&gt; bool:\n        \"\"\"Import Physical Objects settings from a config file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"physicalObjectsUrl\"] + \"/importSettings\"\n\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n        logger.info(\n            \"Importing Physical Objects Settings from server file -&gt; %s; calling -&gt; %s\",\n            file_path,\n            request_url,\n        )\n\n        filename = os.path.basename(file_path)\n        if not os.path.exists(file_path):\n            logger.error(\n                \"The file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(file_path),\n            )\n            return False\n        settings_post_file = {\n            \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                files=settings_post_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import Physical Objects settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def import_physical_objects_codes(\n        self, file_path: str, update_existing_codes: bool = True\n    ) -&gt; bool:\n        \"\"\"Import Physical Objects codes from a config file that is uploaded from the Python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n            update_existing_codes (bool): whether or not existing codes should be updated (default = True)\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"physicalObjectsUrl\"] + \"/importCodes\"\n\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n        logger.info(\n            \"Importing Physical Objects Codes from file -&gt; %s; calling -&gt; %s\",\n            file_path,\n            request_url,\n        )\n\n        settings_post_data = {\"updateExistingCodes\": update_existing_codes}\n\n        filename = os.path.basename(file_path)\n        if not os.path.exists(file_path):\n            logger.error(\n                \"The file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(file_path),\n            )\n            return False\n        settings_post_file = {\n            \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=settings_post_data,\n                files=settings_post_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import Physical Objects Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def import_physical_objects_locators(self, file_path: str) -&gt; bool:\n        \"\"\"Import Physical Objects locators from a config file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"physicalObjectsUrl\"] + \"/importLocators\"\n\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n        logger.info(\n            \"Importing Physical Objects Locators from file -&gt; %s; calling -&gt; %s\",\n            file_path,\n            request_url,\n        )\n\n        filename = os.path.basename(file_path)\n        if not os.path.exists(file_path):\n            logger.error(\n                \"The file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(file_path),\n            )\n            return False\n        settings_post_file = {\n            \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                files=settings_post_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import Physical Objects Locators from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def import_security_clearance_codes(\n        self, file_path: str, include_users: bool = False\n    ) -&gt; bool:\n        \"\"\"Import Security Clearance codes from a config file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n            include_users (bool): defines if users should be included or not\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\n\n        request_url = self.config()[\"securityClearancesUrl\"] + \"/importCodes\"\n\n        request_header = (\n            self.cookie()\n        )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n        logger.info(\n            \"Importing Security Clearance Codes from file -&gt; %s; calling -&gt; %s\",\n            file_path,\n            request_url,\n        )\n\n        settings_post_data = {\"includeusers\": include_users}\n\n        filename = os.path.basename(file_path)\n        if not os.path.exists(file_path):\n            logger.error(\n                \"The file -&gt; %s does not exist in path -&gt; %s!\",\n                filename,\n                os.path.dirname(file_path),\n            )\n            return False\n        settings_post_file = {\n            \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n        }\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=settings_post_data,\n                files=settings_post_file,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to import Security Clearance Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    file_path,\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def assign_user_security_clearance(\n        self, user_id: int, security_clearance: int\n    ) -&gt; dict | None:\n        \"\"\"Assign a Security Clearance level to an Extended ECM user\n\n        Args:\n            user_id (int): ID of the user\n            security_clearance (int): security clearance level to be set\n        Returns:\n            dict: REST response or None if the REST call fails.\n        \"\"\"\n\n        assign_user_security_clearance_post_data = {\n            \"securityLevel\": security_clearance,\n        }\n\n        request_url = self.config()[\n            \"userSecurityUrl\"\n        ] + \"/{}/securityclearancelevel\".format(user_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Assign security clearance -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\n            str(security_clearance),\n            str(user_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=assign_user_security_clearance_post_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign security clearance -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(security_clearance),\n                    str(user_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def assign_user_supplemental_markings(\n        self, user_id: int, supplemental_markings: list\n    ) -&gt; dict | None:\n        \"\"\"Assign a list of Supplemental Markings to a user\n\n        Args:\n            user_id (int): ID of the user\n            supplemental_markings (list of strings): list of Supplemental Markings to be set\n        Returns:\n            dict: REST response or None if the REST call fails.\n        \"\"\"\n\n        assign_user_supplemental_markings_post_data = {\n            \"suppMarks\": supplemental_markings,\n        }\n\n        request_url = self.config()[\n            \"userSecurityUrl\"\n        ] + \"/{}/supplementalmarkings\".format(user_id)\n        request_header = self.request_form_header()\n\n        logger.info(\n            \"Assign supplemental markings -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\n            str(supplemental_markings),\n            str(user_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                data=assign_user_supplemental_markings_post_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign supplemental markings -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(supplemental_markings),\n                    str(user_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def check_workspace_aviator(\n        self,\n        workspace_id: int,\n    ) -&gt; bool:\n        \"\"\"Check if Content Aviator is enabled for a workspace\n\n        Args:\n            workspace_id (int): node ID of the workspace\n        Returns:\n            bool: True if aviator is enabled, False otherwise\n        \"\"\"\n\n        response = self.get_node_actions(\n            node_id=workspace_id, filter_actions=[\"disableai\", \"enableai\"]\n        )\n        result_data = self.get_result_value(\n            response=response,\n            key=str(workspace_id),\n        )\n        if result_data and \"data\" in result_data:\n            data = result_data[\"data\"]\n            if \"disableai\" in data:\n                logger.info(\n                    \"Aviator is enabled for workspace with ID -&gt; %s\", str(workspace_id)\n                )\n                return True\n            elif \"enableai\" in data:\n                logger.info(\n                    \"Aviator is disabled for workspace with ID -&gt; %s\", str(workspace_id)\n                )\n\n        return False\n\n    # end method definition\n\n    def update_workspace_aviator(\n        self,\n        workspace_id: int,\n        status: bool,\n    ) -&gt; dict | None:\n        \"\"\"Enable or disable the Content Aviator for a workspace\n\n        Args:\n            workspace_id (int): node ID of the workspace\n            status (bool): True = enable, False = disable Content Aviator for this workspace\n        Returns:\n            dict: REST response or None if the REST call fails.\n        \"\"\"\n\n        aviator_status_put_data = {\n            \"enabled\": status,\n        }\n\n        request_url = self.config()[\"aiUrl\"] + \"/{}\".format(workspace_id)\n        request_header = self.request_form_header()\n\n        if status is True:\n            logger.info(\n                \"Enable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\n                str(workspace_id),\n                request_url,\n            )\n        else:\n            logger.info(\n                \"Disable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\n                str(workspace_id),\n                request_url,\n            )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                headers=request_header,\n                data=aviator_status_put_data,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to change status for Content Aviator on workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(workspace_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def volume_translator(\n        self,\n        current_node_id: int,\n        translator: object,\n        languages: list,\n        simulate: bool = False,\n    ):\n        \"\"\"Experimental code to translate the item names and item descriptions in a given hierarchy.\n           The actual translation is done by a tranlator object. This recursive method just\n           traverses the hierarchy and calls the translate() method of the translator object.\n\n        Args:\n            current_node_id (int): current node ID to translate\n            translator (object): this object needs to be created based on the \"Translator\" class\n                                 and passed to this method\n            languages (list): list of target languages\n            simulate (bool, optional): if True, do not really rename but just traverse and log info.\n                                       the default is False\n        \"\"\"\n        # Get current node based on the ID:\n        current_node = self.get_node(current_node_id)\n        current_node_id = self.get_result_value(current_node, \"id\")\n\n        name = self.get_result_value(current_node, \"name\")\n        description = self.get_result_value(current_node, \"description\")\n        names_multilingual = self.get_result_value(current_node, \"name_multilingual\")\n        descriptions_multilingual = self.get_result_value(\n            current_node, \"description_multilingual\"\n        )\n\n        for language in languages:\n            if language == \"en\":\n                continue\n            # Does the language not exist as metadata language or is it already translated?\n            # Then we skip this language:\n            if (\n                language in names_multilingual\n                and names_multilingual[\"en\"]\n                and not names_multilingual[language]\n            ):\n                names_multilingual[language] = translator.translate(\n                    \"en\", language, names_multilingual[\"en\"]\n                )\n                logger.info(\n                    \"Translate name of node -&gt; %s from -&gt; %s (%s) to -&gt; %s (%s)\",\n                    current_node_id,\n                    name,\n                    \"en\",\n                    names_multilingual[language],\n                    language,\n                )\n            if (\n                language in descriptions_multilingual\n                and descriptions_multilingual[\"en\"]\n                and not descriptions_multilingual[language]\n            ):\n                descriptions_multilingual[language] = translator.translate(\n                    \"en\", language, descriptions_multilingual[\"en\"]\n                )\n                logger.info(\n                    \"Translate description of node -&gt; %s from -&gt; %s (%s) to -&gt; %s (%s)\",\n                    current_node_id,\n                    name,\n                    \"en\",\n                    names_multilingual[language],\n                    language,\n                )\n\n        # Rename node multi-lingual:\n        if not simulate:\n            self.rename_node(\n                current_node_id,\n                name,\n                description,\n                names_multilingual,\n                descriptions_multilingual,\n            )\n\n        # Get children nodes of the current node:\n        results = self.get_subnodes(current_node_id, limit=200)[\"results\"]\n\n        # Recursive call of all subnodes:\n        for result in results:\n            self.volume_translator(\n                result[\"data\"][\"properties\"][\"id\"], translator, languages\n            )\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.__init__","title":"<code>__init__(protocol, hostname, port, public_url, username=None, password=None, user_partition='Content Server Members', resource_name='cs', default_license='X3', otds_ticket=None, base_path='/cs/cs')</code>","text":"<p>Initialize the OTCS object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>Either http or https.</p> required <code>hostname</code> <code>str</code> <p>The hostname of Extended ECM server to communicate with.</p> required <code>port</code> <code>int</code> <p>The port number used to talk to the Extended ECM server.</p> required <code>public_url</code> <code>str</code> <p>public (external) URL</p> required <code>username</code> <code>str</code> <p>The admin user name of Extended ECM. Optional if otds_ticket is provided.</p> <code>None</code> <code>password</code> <code>str</code> <p>The admin password of Extended ECM. Optional if otds_ticket is provided.</p> <code>None</code> <code>user_partition</code> <code>str</code> <p>Name of the OTDS partition for OTCS users. Default is \"Content Server Members\".</p> <code>'Content Server Members'</code> <code>resource_name</code> <code>str</code> <p>Name of the OTDS resource for OTCS. Dault is \"cs\".</p> <code>'cs'</code> <code>default_license</code> <code>str</code> <p>name of the default user license. Default is \"X3\".</p> <code>'X3'</code> <code>otds_ticket</code> <code>str</code> <p>Authentication ticket of OTDS</p> <code>None</code> <code>base_path</code> <code>str</code> <p>Base Path of OTCS. Default is \"/cs/cs\".</p> <code>'/cs/cs'</code> Source code in <code>pyxecm/otcs.py</code> <pre><code>def __init__(\n    self,\n    protocol: str,\n    hostname: str,\n    port: int,\n    public_url: str,\n    username: str | None = None,\n    password: str | None = None,\n    user_partition: str = \"Content Server Members\",\n    resource_name: str = \"cs\",\n    default_license: str = \"X3\",\n    otds_ticket: str | None = None,\n    base_path: str = \"/cs/cs\",\n):\n    \"\"\"Initialize the OTCS object\n\n    Args:\n        protocol (str): Either http or https.\n        hostname (str): The hostname of Extended ECM server to communicate with.\n        port (int): The port number used to talk to the Extended ECM server.\n        public_url (str): public (external) URL\n        username (str, optional): The admin user name of Extended ECM. Optional if otds_ticket is provided.\n        password (str, optional): The admin password of Extended ECM. Optional if otds_ticket is provided.\n        user_partition (str): Name of the OTDS partition for OTCS users. Default is \"Content Server Members\".\n        resource_name (str, optional): Name of the OTDS resource for OTCS. Dault is \"cs\".\n        default_license (str, optional): name of the default user license. Default is \"X3\".\n        otds_ticket (str, optional): Authentication ticket of OTDS\n        base_path (str, optional): Base Path of OTCS. Default is \"/cs/cs\".\n    \"\"\"\n\n    # Initialize otcs_config as an empty dictionary\n    otcs_config = {}\n\n    if hostname:\n        otcs_config[\"hostname\"] = hostname\n    else:\n        otcs_config[\"hostname\"] = \"otcs-admin-0\"\n\n    if protocol:\n        otcs_config[\"protocol\"] = protocol\n    else:\n        otcs_config[\"protocol\"] = \"http\"\n\n    if port:\n        otcs_config[\"port\"] = port\n    else:\n        otcs_config[\"port\"] = 8080\n\n    otcs_config[\"publicUrl\"] = public_url\n\n    if username:\n        otcs_config[\"username\"] = username\n    else:\n        otcs_config[\"username\"] = \"admin\"\n\n    if password:\n        otcs_config[\"password\"] = password\n    else:\n        otcs_config[\"password\"] = \"\"\n\n    if user_partition:\n        otcs_config[\"partition\"] = user_partition\n    else:\n        otcs_config[\"partition\"] = \"\"\n\n    if resource_name:\n        otcs_config[\"resource\"] = resource_name\n    else:\n        otcs_config[\"resource\"] = \"\"\n\n    if default_license:\n        otcs_config[\"license\"] = default_license\n    else:\n        otcs_config[\"license\"] = \"\"\n\n    otcs_base_url = protocol + \"://\" + otcs_config[\"hostname\"]\n    if str(port) not in [\"80\", \"443\"]:\n        otcs_base_url += \":{}\".format(port)\n    otcs_config[\"baseUrl\"] = otcs_base_url\n    otcs_support_url = otcs_base_url + \"/cssupport\"\n    otcs_config[\"supportUrl\"] = otcs_support_url\n    otcs_public_support_url = public_url + \"/cssupport\"\n    otcs_config[\"supportPublicUrl\"] = otcs_public_support_url\n\n    otcs_config[\"configuredUrl\"] = otcs_support_url + \"/csconfigured\"\n\n    otcs_url = otcs_base_url + base_path\n    otcs_config[\"csUrl\"] = otcs_url\n    otcs_public_url = public_url + base_path\n    otcs_config[\"csPublicUrl\"] = otcs_public_url\n\n    otcs_rest_url = otcs_url + \"/api\"\n    otcs_config[\"restUrl\"] = otcs_rest_url\n\n    otcs_config[\"isReady\"] = otcs_rest_url + \"/v1/ping\"\n    otcs_config[\"authenticationUrl\"] = otcs_rest_url + \"/v1/auth\"\n    otcs_config[\"serverInfoUrl\"] = otcs_rest_url + \"/v1/serverinfo\"\n    otcs_config[\"membersUrl\"] = otcs_rest_url + \"/v1/members\"\n    otcs_config[\"membersUrlv2\"] = otcs_rest_url + \"/v2/members\"\n    otcs_config[\"nodesUrl\"] = otcs_rest_url + \"/v1/nodes\"\n    otcs_config[\"nodesUrlv2\"] = otcs_rest_url + \"/v2/nodes\"\n    otcs_config[\"doctemplatesUrl\"] = otcs_rest_url + \"/v2/doctemplates\"\n    otcs_config[\"nicknameUrl\"] = otcs_rest_url + \"/v2/nicknames\"\n    otcs_config[\"importSettingsUrl\"] = otcs_rest_url + \"/v2/import/settings/admin\"\n    otcs_config[\"searchUrl\"] = otcs_rest_url + \"/v2/search\"\n    otcs_config[\"volumeUrl\"] = otcs_rest_url + \"/v2/volumes\"\n    otcs_config[\"externalSystemUrl\"] = otcs_rest_url + \"/v2/externalsystems\"\n    otcs_config[\"businessObjectsUrl\"] = otcs_rest_url + \"/v2/businessobjects\"\n    otcs_config[\"businessObjectTypesUrl\"] = (\n        otcs_rest_url + \"/v2/businessobjecttypes\"\n    )\n    otcs_config[\"businessObjectsSearchUrl\"] = (\n        otcs_rest_url + \"/v2/forms/businessobjects/search\"\n    )\n    otcs_config[\"businessWorkspaceTypesUrl\"] = (\n        otcs_rest_url + \"/v2/businessworkspacetypes\"\n    )\n    otcs_config[\"businessworkspacecreateform\"] = (\n        otcs_rest_url + \"/v2/forms/businessworkspaces/create\"\n    )\n    otcs_config[\"businessWorkspacesUrl\"] = otcs_rest_url + \"/v2/businessworkspaces\"\n    otcs_config[\"uniqueNamesUrl\"] = otcs_rest_url + \"/v2/uniquenames\"\n    otcs_config[\"favoritesUrl\"] = otcs_rest_url + \"/v2/members/favorites\"\n    otcs_config[\"webReportsUrl\"] = otcs_rest_url + \"/v1/webreports\"\n    otcs_config[\"csApplicationsUrl\"] = otcs_rest_url + \"/v2/csapplications\"\n    otcs_config[\"xEngProjectTemplateUrl\"] = (\n        otcs_rest_url + \"/v2/xengcrt/projecttemplate\"\n    )\n    otcs_config[\"rsisUrl\"] = otcs_rest_url + \"/v2/rsis\"\n    otcs_config[\"rsiSchedulesUrl\"] = otcs_rest_url + \"/v2/rsischedules\"\n    otcs_config[\"recordsManagementUrl\"] = otcs_rest_url + \"/v1/recordsmanagement\"\n    otcs_config[\"recordsManagementUrlv2\"] = otcs_rest_url + \"/v2/recordsmanagement\"\n    otcs_config[\"userSecurityUrl\"] = otcs_rest_url + \"/v2/members/usersecurity\"\n    otcs_config[\"physicalObjectsUrl\"] = otcs_rest_url + \"/v1/physicalobjects\"\n    otcs_config[\"securityClearancesUrl\"] = otcs_rest_url + \"/v1/securityclearances\"\n    otcs_config[\"holdsUrl\"] = otcs_rest_url + \"/v1/holds\"\n    otcs_config[\"holdsUrlv2\"] = otcs_rest_url + \"/v2/holds\"\n    otcs_config[\"validationUrl\"] = otcs_rest_url + \"/v1/validation/nodes/names\"\n    otcs_config[\"aiUrl\"] = otcs_rest_url + \"/v2/ai/nodes\"\n\n    self._config = otcs_config\n    self._otds_ticket = otds_ticket\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_document_version","title":"<code>add_document_version(node_id, file_url, file_name, mime_type='text/plain', description='')</code>","text":"<p>Fetch a file from a URL or local filesystem and upload it as a new document version.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the document to add add version to</p> required <code>file_url</code> <code>str</code> <p>URL to download file or local file</p> required <code>file_name</code> <code>str</code> <p>name of the file</p> required <code>mime_type</code> <code>str</code> <p>mimeType of the file (default = text/plain)</p> <code>'text/plain'</code> <code>description</code> <code>str</code> <p>description of the version (default = no description)</p> <code>''</code> <p>Returns:     dict: Add version response or None if the upload fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_document_version(\n    self,\n    node_id: int,\n    file_url: str,\n    file_name: str,\n    mime_type: str = \"text/plain\",\n    description: str = \"\",\n) -&gt; dict | None:\n    \"\"\"Fetch a file from a URL or local filesystem and upload it as a new document version.\n\n    Args:\n        node_id (int): ID of the document to add add version to\n        file_url (str): URL to download file or local file\n        file_name (str): name of the file\n        mime_type (str, optional): mimeType of the file (default = text/plain)\n        description (str, optional): description of the version (default = no description)\n    Returns:\n        dict: Add version response or None if the upload fails.\n    \"\"\"\n\n    if file_url.startswith(\"http\"):\n        # Download file from remote location specified by the file_url parameter\n        # this must be a public place without authentication:\n        logger.info(\"Download file from URL -&gt; %s\", file_url)\n\n        try:\n            response = requests.get(\n                url=file_url,\n                timeout=None,\n            )\n            response.raise_for_status()\n        except requests.exceptions.HTTPError as errh:\n            logger.error(\"Http Error -&gt; %s\", errh.strerror)\n            return None\n        except requests.exceptions.ConnectionError as errc:\n            logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n            return None\n        except requests.exceptions.Timeout as errt:\n            logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n            return None\n        except requests.exceptions.RequestException as err:\n            logger.error(\"Request error -&gt; %s\", err.strerror)\n            return None\n\n        logger.info(\n            \"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\n            file_url,\n            response.status_code,\n        )\n        file_content = response.content\n\n    elif os.path.exists(file_url):\n        logger.info(\"Uploading local file -&gt; %s\", file_url)\n        file_content = open(file=file_url, mode=\"rb\")\n\n    else:\n        logger.warning(\"Cannot access -&gt; %s\", file_url)\n        return None\n\n    upload_post_data = {\"description\": description}\n    upload_post_files = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/versions\"\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\n\n    logger.info(\n        \"Uploading file -&gt; %s with mime type -&gt; %s as new version to document node with ID -&gt; %s; calling -&gt; %s\",\n        file_name,\n        mime_type,\n        node_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=upload_post_data,\n            files=upload_post_files,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add file -&gt; %s as new version to document with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_url,\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_external_system_connection","title":"<code>add_external_system_connection(connection_name, connection_type, as_url, base_url, username, password, authentication_method='BASIC', client_id=None, client_secret=None)</code>","text":"<p>Add Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).</p> <p>Parameters:</p> Name Type Description Default <code>connection_name</code> <code>str</code> <p>Name of the connection</p> required <code>connection_type</code> <code>str</code> <p>Type of the connection (HTTP, SF, SFInstance)</p> required <code>as_url</code> <code>str</code> <p>Application URL of the external system</p> required <code>base_url</code> <code>str</code> <p>Base URL of the external system</p> required <code>username</code> <code>str</code> <p>username (used for BASIC authentication)</p> required <code>password</code> <code>str</code> <p>password (used for BASIC authentication)</p> required <code>authentication_method</code> <code>str</code> <p>either BASIC (using username and password) or OAUTH</p> <code>'BASIC'</code> <code>client_id</code> <code>str</code> <p>OAUTH Client ID (only required if authenticationMethod = OAUTH)</p> <code>None</code> <code>client_secret</code> <code>str</code> <p>OAUTH Client Secret (only required if authenticationMethod = OAUTH)</p> <code>None</code> <p>Returns:     dict: External system Details or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_external_system_connection(\n    self,\n    connection_name: str,\n    connection_type: str,\n    as_url: str,\n    base_url: str,\n    username: str,\n    password: str,\n    authentication_method: str = \"BASIC\",  # either BASIC or OAUTH\n    client_id: str = None,\n    client_secret: str = None,\n) -&gt; dict | None:\n    \"\"\"Add Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n\n    Args:\n        connection_name (str): Name of the connection\n        connection_type (str): Type of the connection (HTTP, SF, SFInstance)\n        as_url (str): Application URL of the external system\n        base_url (str): Base URL of the external system\n        username (str): username (used for BASIC authentication)\n        password (str): password (used for BASIC authentication)\n        authentication_method (str, optional): either BASIC (using username and password) or OAUTH\n        client_id (str, optional): OAUTH Client ID (only required if authenticationMethod = OAUTH)\n        client_secret (str, optional): OAUTH Client Secret (only required if authenticationMethod = OAUTH)\n    Returns:\n        dict: External system Details or None if the REST call fails.\n    \"\"\"\n\n    external_system_post_body = {\n        \"external_system_name\": connection_name,\n        \"conn_type\": connection_type,\n        \"asurl\": as_url,\n        \"baseurl\": base_url,\n        \"username\": username,\n        \"password\": password,\n    }\n\n    if authentication_method == \"OAUTH\" and client_id and client_secret:\n        external_system_post_body[\"authentication_method\"] = str(\n            authentication_method\n        )\n        external_system_post_body[\"client_id\"] = str(client_id)\n        external_system_post_body[\"client_secret\"] = str(client_secret)\n\n    request_url = self.config()[\"externalSystemUrl\"]\n    request_header = self.cookie()\n\n    logger.info(\n        \"Creating external system connection -&gt; %s of type -&gt; %s with URL -&gt; %s; calling -&gt; %s\",\n        connection_name,\n        connection_type,\n        as_url,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=external_system_post_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                connection_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_favorite","title":"<code>add_favorite(node_id)</code>","text":"<p>Add a favorite for the current (authenticated) user.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node.</p> required <p>Returns:     dict: Request response or None if the favorite creation has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_favorite(self, node_id: int) -&gt; dict | None:\n    \"\"\"Add a favorite for the current (authenticated) user.\n\n    Args:\n        node_id (int): ID of the node.\n    Returns:\n        dict: Request response or None if the favorite creation has failed.\n    \"\"\"\n\n    request_url = self.config()[\"favoritesUrl\"] + \"/\" + str(node_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Adding favorite for node ID -&gt; %s; calling -&gt; %s\", node_id, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add favorite for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_favorite_tab","title":"<code>add_favorite_tab(tab_name, order)</code>","text":"<p>Add a favorite tab for the current (authenticated) user.</p> <p>Parameters:</p> Name Type Description Default <code>tab_name</code> <code>str</code> <p>Name of the new tab.</p> required <code>order</code> <code>int</code> <p>The order of the tab.</p> required <p>Returns:     dict: Request response or None if the favorite tab creation has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_favorite_tab(self, tab_name: str, order: int) -&gt; dict | None:\n    \"\"\"Add a favorite tab for the current (authenticated) user.\n\n    Args:\n        tab_name (str): Name of the new tab.\n        order (int): The order of the tab.\n    Returns:\n        dict: Request response or None if the favorite tab creation has failed.\n    \"\"\"\n\n    favorite_tab_post_body = {\"name\": tab_name, \"order\": str(order)}\n\n    request_url = self.config()[\"favoritesUrl\"] + \"/tabs\"\n    request_header = self.request_form_header()\n\n    logger.info(\"Adding favorite tab -&gt; %s; calling -&gt; %s\", tab_name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=favorite_tab_post_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add favorite tab -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                tab_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_group","title":"<code>add_group(name)</code>","text":"<p>Add Content Server group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the group</p> required <p>Returns:     dict: Group information or None if the group couldn't be created (e.g. because it exisits already).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_group(self, name: str) -&gt; dict | None:\n    \"\"\"Add Content Server group.\n\n    Args:\n        name (str): name of the group\n    Returns:\n        dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n    \"\"\"\n\n    group_post_body = {\"type\": 1, \"name\": name}\n\n    request_url = self.config()[\"membersUrlv2\"]\n    request_header = self.request_form_header()\n\n    logger.info(\"Adding group -&gt; %s; calling -&gt; %s\", name, request_url)\n    logger.debug(\"Group Attributes -&gt; %s\", str(group_post_body))\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=group_post_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_group_member","title":"<code>add_group_member(member_id, group_id)</code>","text":"<p>Add a user or group to a target group.</p> <p>Parameters:</p> Name Type Description Default <code>member_id</code> <code>int</code> <p>ID of the user or group to add.</p> required <code>group_id</code> <code>int</code> <p>ID of the target group.</p> required <p>Returns:     dict: Response or None if adding a the member fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_group_member(self, member_id: int, group_id: int) -&gt; dict | None:\n    \"\"\"Add a user or group to a target group.\n\n    Args:\n        member_id (int): ID of the user or group to add.\n        group_id (int): ID of the target group.\n    Returns:\n        dict: Response or None if adding a the member fails.\n    \"\"\"\n\n    group_member_post_body = {\"member_id\": member_id}\n\n    request_url = self.config()[\"membersUrlv2\"] + \"/\" + str(group_id) + \"/members\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Adding member with ID -&gt; %s to group with ID -&gt; %s; calling -&gt; %s\",\n        str(member_id),\n        str(group_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=group_member_post_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add member with ID -&gt; %s to group with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(member_id),\n                str(group_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_member_to_workspace","title":"<code>add_member_to_workspace(workspace_id, role_id, member_id, show_warning=True)</code>","text":"<p>Add member to a workspace role. Check that the user/group is not yet a member.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>role_id</code> <code>int</code> <p>ID of the role</p> required <code>member_id</code> <code>int</code> <p>User ID or Group ID</p> required <code>show_warning</code> <code>bool</code> <p>If True logs a warning if member is already in role</p> <code>True</code> <p>Returns:     dict: Workspace Role Membership or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_member_to_workspace(\n    self, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n) -&gt; dict | None:\n    \"\"\"Add member to a workspace role. Check that the user/group is not yet a member.\n\n    Args:\n        workspace_id (int): ID of the workspace\n        role_id (int): ID of the role\n        member_id (int): User ID or Group ID\n        show_warning (bool, optional): If True logs a warning if member is already in role\n    Returns:\n        dict: Workspace Role Membership or None if the request fails.\n    \"\"\"\n\n    add_member_to_workspace_post_data = {\"id\": str(member_id)}\n\n    request_url = self.config()[\n        \"businessWorkspacesUrl\"\n    ] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Check if user/group with ID -&gt; %s is already in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n        str(member_id),\n        str(role_id),\n        str(workspace_id),\n        request_url,\n    )\n\n    response = requests.get(\n        url=request_url,\n        headers=request_header,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n    if not response.ok:\n        logger.error(\n            \"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\n            response.status_code,\n            response.text,\n        )\n        return None\n\n    workspace_members = self.parse_request_response(response)\n\n    if self.exist_result_item(workspace_members, \"id\", member_id):\n        if show_warning:\n            logger.warning(\n                \"User/group with ID -&gt; %s is already a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\n                str(member_id),\n                str(role_id),\n                str(workspace_id),\n            )\n        return workspace_members\n\n    logger.info(\n        \"Add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n        str(member_id),\n        str(role_id),\n        str(workspace_id),\n        request_url,\n    )\n\n    response = requests.post(\n        url=request_url,\n        headers=request_header,\n        data=add_member_to_workspace_post_data,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n\n    if response.ok:\n        return self.parse_request_response(response)\n    else:\n        logger.error(\n            \"Failed to add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n            str(member_id),\n            str(role_id),\n            str(workspace_id),\n            response.status_code,\n            response.text,\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_user","title":"<code>add_user(name, password, first_name, last_name, email, title, base_group, privileges=None)</code>","text":"<p>Add Content Server user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>login name of the user</p> required <code>password</code> <code>str</code> <p>password of the user</p> required <code>first_name</code> <code>str</code> <p>first name of the user</p> required <code>last_name</code> <code>str</code> <p>last name of the user</p> required <code>email</code> <code>str</code> <p>email address of the user</p> required <code>title</code> <code>str</code> <p>title of the user</p> required <code>base_group</code> <code>int</code> <p>base group id of the user (e.g. department)</p> required <code>privileges</code> <code>list</code> <p>values are Login, Public Access, Content Manager,                          Modify Users, Modify Groups, User Admin Rights,                          Grant Discovery, System Admin Rights</p> <code>None</code> <p>Returns:     dict: User information or None if the user couldn't be created (e.g. because it exisits already).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_user(\n    self,\n    name: str,\n    password: str,\n    first_name: str,\n    last_name: str,\n    email: str,\n    title: str,\n    base_group: int,\n    privileges: list | None = None,\n) -&gt; dict | None:\n    \"\"\"Add Content Server user.\n\n    Args:\n        name (str): login name of the user\n        password (str): password of the user\n        first_name (str): first name of the user\n        last_name (str): last name of the user\n        email (str): email address of the user\n        title (str): title of the user\n        base_group (int): base group id of the user (e.g. department)\n        privileges (list, optional): values are Login, Public Access, Content Manager,\n                                     Modify Users, Modify Groups, User Admin Rights,\n                                     Grant Discovery, System Admin Rights\n    Returns:\n        dict: User information or None if the user couldn't be created (e.g. because it exisits already).\n    \"\"\"\n\n    if privileges is None:\n        privileges = [\"Login\", \"Public Access\"]\n\n    user_post_body = {\n        \"type\": 0,\n        \"name\": name,\n        \"password\": password,\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"business_email\": email,\n        \"title\": title,\n        \"group_id\": base_group,\n        \"privilege_login\": (\"Login\" in privileges),\n        \"privilege_public_access\": (\"Public Access\" in privileges),\n        \"privilege_content_manager\": (\"Content Manager\" in privileges),\n        \"privilege_modify_users\": (\"Modify Users\" in privileges),\n        \"privilege_modify_groups\": (\"Modify Groups\" in privileges),\n        \"privilege_user_admin_rights\": (\"User Admin Rights\" in privileges),\n        \"privilege_grant_discovery\": (\"Grant Discovery\" in privileges),\n        \"privilege_system_admin_rights\": (\"System Admin Rights\" in privileges),\n    }\n\n    request_url = self.config()[\"membersUrlv2\"]\n    request_header = self.request_form_header()\n\n    logger.info(\"Adding user -&gt; %s; calling -&gt; %s\", name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=user_post_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_user_proxy","title":"<code>add_user_proxy(proxy_user_id, from_date=None, to_date=None)</code>","text":"<p>Add a user as a proxy user to the current user.    IMPORTANT: This method needs to be called as the user the proxy is acting for.    Optional this method can be provided with a time span the proxy should be active.    This method differentiates between the old (xGov) based    implementation and the new Extended ECM platform one    that was introduced with version 23.4.</p> <p>Example payload for proxy user 19340 without time span:    {\"id\":2545, \"from_date\": None, \"to_date\": None}</p> <p>Example payload for proxy user 19340 with time span:    {\"id\":2545, \"from_date\":\"2023-03-15\", \"to_date\":\"2023-03-31\"}</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>from_date</code> <code>str</code> <p>start date for proxy (format YYYY-MM-DD)</p> <code>None</code> <code>to_date</code> <code>str</code> <p>end date for proxy (format YYYY-MM-DD)</p> <code>None</code> <p>Returns:     dict: Request response or None if call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_user_proxy(\n    self,\n    proxy_user_id: int,\n    from_date: str = None,\n    to_date: str = None,\n) -&gt; dict | None:\n    \"\"\"Add a user as a proxy user to the current user.\n       IMPORTANT: This method needs to be called as the user the proxy is acting for.\n       Optional this method can be provided with a time span the proxy should be active.\n       This method differentiates between the old (xGov) based\n       implementation and the new Extended ECM platform one\n       that was introduced with version 23.4.\n\n       Example payload for proxy user 19340 without time span:\n       {\"id\":2545, \"from_date\": None, \"to_date\": None}\n\n       Example payload for proxy user 19340 with time span:\n       {\"id\":2545, \"from_date\":\"2023-03-15\", \"to_date\":\"2023-03-31\"}\n\n    Args:\n        user_id (int): ID of the user\n        from_date (str, optional): start date for proxy (format YYYY-MM-DD)\n        to_date (str, optional): end date for proxy (format YYYY-MM-DD)\n    Returns:\n        dict: Request response or None if call fails.\n    \"\"\"\n\n    version_number = self.get_server_version()\n    # Split the version number by dot\n    parts = version_number.split(\".\")\n    # Take the first two parts and join them back with a dot\n    stripped_version = \".\".join(parts[:2])\n    version_number = float(stripped_version)\n\n    # for versions older than 23.4 we need to use\n    # the egacy Extended ECM for Government Proxy\n    # implementation:\n    if version_number &gt;= 23.4:\n        post_dict = {}\n        post_dict[\"id\"] = proxy_user_id\n        post_dict[\"from_date\"] = from_date\n        post_dict[\"to_date\"] = to_date\n        post_data = {\"body\": json.dumps(post_dict)}\n        request_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\n        logger.info(\n            \"Assign proxy user with ID -&gt; %s to current user; calling -&gt; %s\",\n            proxy_user_id,\n            request_url,\n        )\n    else:\n        post_dict = {}\n        if from_date and to_date:\n            post_dict[\"from_date\"] = from_date\n            post_dict[\"to_date\"] = to_date\n        post_dict = {str(proxy_user_id): post_dict}\n        post_data = {\"add_proxy\": json.dumps(post_dict)}\n        request_url = self.config()[\"membersUrl\"] + \"/proxies\"\n        logger.info(\n            \"Assign proxy user with ID -&gt; %s to current user (legacy xGov); calling -&gt; %s\",\n            proxy_user_id,\n            request_url,\n        )\n\n    request_header = self.request_form_header()\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        response = requests.post(\n            url=request_url,\n            data=post_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign proxy user with ID -&gt; %s to current user; status -&gt; %s; error -&gt; %s\",\n                proxy_user_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.apply_config","title":"<code>apply_config(xml_file_path)</code>","text":"<p>Apply Content Server administration settings from XML file</p> <p>Parameters:</p> Name Type Description Default <code>xml_file_path</code> <code>str</code> <p>name + path of the XML settings file</p> required <p>Returns:     dict: Import response or None if the import fails.           The field response\"results\"[\"restart\"] indicates if the settings           require a restart of the OTCS services.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def apply_config(self, xml_file_path: str) -&gt; dict | None:\n    \"\"\"Apply Content Server administration settings from XML file\n\n    Args:\n        xml_file_path (str): name + path of the XML settings file\n    Returns:\n        dict: Import response or None if the import fails.\n              The field response[\"results\"][\"data\"][\"restart\"] indicates if the settings\n              require a restart of the OTCS services.\n    \"\"\"\n\n    filename = os.path.basename(xml_file_path)\n\n    if not os.path.exists(xml_file_path):\n        logger.error(\n            \"The admin settings file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(xml_file_path),\n        )\n        return None\n\n    llconfig_file = {\n        \"file\": (filename, open(file=xml_file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    request_url = self.config()[\"importSettingsUrl\"]\n    request_header = self._cookie\n\n    logger.info(\n        \"Applying admin settings from file -&gt; %s; calling -&gt; %s\",\n        xml_file_path,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            files=llconfig_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            logger.debug(\n                \"Admin settings in file -&gt; %s have been applied\", xml_file_path\n            )\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import settings file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                xml_file_path,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_category","title":"<code>assign_category(node_id, category_id, inheritance=False, apply_to_sub_items=False, apply_action='add_upgrade', add_version=False, clear_existing_categories=False)</code>","text":"<p>Assign a category to a node. Optionally turn on inheritance and apply    category to sub-items (if node_id is a container / folder / workspace).    If the category is already assigned to the node this method will    throw an error.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID to apply the category to</p> required <code>category_id</code> <code>list</code> <p>ID of the category definition object</p> required <code>inheritance</code> <code>bool</code> <p>turn on inheritance for the category                    (this makes only sense if the node is a container like a folder or workspace)</p> <code>False</code> <code>apply_to_sub_items</code> <code>bool</code> <p>if True the category is applied to                                     the item and all its sub-items                                     if False the category is only applied                                     to the item</p> <code>False</code> <code>apply_action</code> <code>str</code> <p>supported values are \"add\", \"add_upgrade\", \"upgrade\", \"replace\", \"delete\", \"none\", None</p> <code>'add_upgrade'</code> <code>add_version</code> <code>bool</code> <p>if a document version should be added for the category change (default = False)</p> <code>False</code> <code>clear_existing_categories</code> <code>bool</code> <p>whether or not existing (other) categories should be removed (default = False)</p> <code>False</code> <p>Returns:     bool: True = success, False = error</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_category(\n    self,\n    node_id: int,\n    category_id: list,\n    inheritance: bool = False,\n    apply_to_sub_items: bool = False,\n    apply_action: str = \"add_upgrade\",\n    add_version: bool = False,\n    clear_existing_categories: bool = False,\n) -&gt; bool:\n    \"\"\"Assign a category to a node. Optionally turn on inheritance and apply\n       category to sub-items (if node_id is a container / folder / workspace).\n       If the category is already assigned to the node this method will\n       throw an error.\n\n    Args:\n        node_id (int): node ID to apply the category to\n        category_id (list): ID of the category definition object\n        inheritance (bool): turn on inheritance for the category\n                               (this makes only sense if the node is a container like a folder or workspace)\n        apply_to_sub_items (bool, optional): if True the category is applied to\n                                                the item and all its sub-items\n                                                if False the category is only applied\n                                                to the item\n        apply_action (str, optional): supported values are \"add\", \"add_upgrade\", \"upgrade\", \"replace\", \"delete\", \"none\", None\n        add_version (bool, optional): if a document version should be added for the category change (default = False)\n        clear_existing_categories (bool, optional): whether or not existing (other) categories should be removed (default = False)\n    Returns:\n        bool: True = success, False = error\n    \"\"\"\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\n    request_header = self.request_form_header()\n\n    #\n    # 1. Assign Category to Node if not yet assigned:\n    #\n\n    existing_category_ids = self.get_node_category_ids(node_id)\n    if not category_id in existing_category_ids:\n        logger.info(\n            \"Category with ID -&gt; %s is not yet assigned to node ID -&gt; %s. Assigning it now...\",\n            str(category_id),\n            str(node_id),\n        )\n        category_post_data = {\n            \"category_id\": category_id,\n        }\n\n        logger.info(\n            \"Assign category with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\n            str(category_id),\n            str(node_id),\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                data=category_post_data,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to assign category with ID -&gt; %s to node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(category_id),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return False\n\n    #\n    # 2. Set Inheritance\n    #\n\n    request_url_inheritance = request_url + \"/\" + str(category_id) + \"/inheritance\"\n\n    retries = 0\n    while True:\n        if inheritance:\n            # Enable inheritance\n            response = requests.post(\n                url=request_url_inheritance,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n        else:\n            # Disable inheritance\n            response = requests.delete(\n                url=request_url_inheritance,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n        if response.ok:\n            break\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to set inheritance for category with ID -&gt; %s on node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(category_id),\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return False\n\n    #\n    # 3. Apply to sub-items\n    #\n\n    if apply_to_sub_items:\n        request_url_apply_sub_items = request_url + \"/apply\"\n\n        category_post_data = {\n            \"categories\": [{\"id\": category_id, \"action\": apply_action}],\n            \"add_version\": add_version,\n            \"clear_existing_categories\": clear_existing_categories,\n        }\n\n        retries = 0\n        while True:\n            # we need to wrap the body of this POST call into a \"body\"\n            # tag. This is documented worngly on developer.opentext.com\n            response = requests.post(\n                url=request_url_apply_sub_items,\n                data={\"body\": json.dumps(category_post_data)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to apply category with ID -&gt; %s to sub-items of node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(category_id),\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return False\n    return True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_classification","title":"<code>assign_classification(node_id, classifications, apply_to_sub_items=False)</code>","text":"<p>Assign one or multiple classifications to an Extended ECM item Args:     node_id (int): node ID of the Extended ECM item     classifications (list): list of classification item IDs     apply_to_sub_items (bool, optional): if True the classification is applied to                                             the item and all its sub-items                                             if False the classification is only applied                                             to the item Returns:     dict: Response of the request or None if the assignment of the classification has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_classification(\n    self, node_id: int, classifications: list, apply_to_sub_items: bool = False\n) -&gt; dict | None:\n    \"\"\"Assign one or multiple classifications to an Extended ECM item\n    Args:\n        node_id (int): node ID of the Extended ECM item\n        classifications (list): list of classification item IDs\n        apply_to_sub_items (bool, optional): if True the classification is applied to\n                                                the item and all its sub-items\n                                                if False the classification is only applied\n                                                to the item\n    Returns:\n        dict: Response of the request or None if the assignment of the classification has failed.\n    \"\"\"\n\n    # the REST API expects a list of dict elements with \"id\" and the actual IDs\n    classification_list = []\n    for classification in classifications:\n        classification_list.append({\"id\": classification})\n\n    classification_post_data = {\n        \"class_id\": classification_list,\n        \"apply_to_sub_items\": apply_to_sub_items,\n    }\n\n    request_url = (\n        self.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/classifications\"\n    )\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Assign classifications with IDs -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\n        str(classifications),\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=classification_post_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign classifications with IDs -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(classifications),\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_item_to_user_group","title":"<code>assign_item_to_user_group(node_id, subject, instruction, assignees)</code>","text":"<p>Assign an Extended ECM item to users and groups. This is a function used by    Extended ECM for Government.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the Extended ECM item (e.g. a workspace or a document)</p> required <code>subject</code> <code>str</code> <p>title / subject of the assignment</p> required <code>instructions</code> <code>str</code> <p>more detailed description or instructions for the assignment</p> required <code>assignees</code> <code>list</code> <p>list of IDs of users or groups</p> required <p>Returns:     dict: Response of the request or None if the assignment has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_item_to_user_group(\n    self, node_id: int, subject: str, instruction: str, assignees: list\n) -&gt; dict | None:\n    \"\"\"Assign an Extended ECM item to users and groups. This is a function used by\n       Extended ECM for Government.\n\n    Args:\n        node_id (int): node ID of the Extended ECM item (e.g. a workspace or a document)\n        subject (str): title / subject of the assignment\n        instructions (str): more detailed description or instructions for the assignment\n        assignees (list): list of IDs of users or groups\n    Returns:\n        dict: Response of the request or None if the assignment has failed.\n    \"\"\"\n\n    assignment_post_data = {\n        \"subject\": subject,\n        \"instruction\": instruction,\n        \"assignees\": assignees,\n    }\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/xgovassignments\"\n    )\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); calling -&gt; %s\",\n        str(node_id),\n        str(assignees),\n        subject,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"add_assignment\" tag.\n        response = requests.post(\n            url=request_url,\n            data={\"add_assignment\": json.dumps(assignment_post_data)},\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                str(assignees),\n                subject,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_permission","title":"<code>assign_permission(node_id, assignee_type, assignee, permissions, apply_to=0)</code>","text":"<p>Assign permissions for Extended ECM item to a user or group.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the Extended ECM item</p> required <code>assignee_type</code> <code>str</code> <p>this can be either \"owner\", \"group\" (for owner group),                     \"public\", or \"custom\" (assigned access)</p> required <code>assignee</code> <code>int</code> <p>ID of user or group (\"right ID\"). If 0 and assigneeType                 is \"owner\" or \"group\" then it is assumed that the owner and                 owner group should not be changed.</p> required <code>permissions</code> <code>list</code> <p>list of permissions - potential elements:                 \"see\"                 \"see_contents\"                 \"modify\"                 \"edit_attributes\"                 \"add_items\"                 \"reserve\"                 \"add_major_version\"                 \"delete_versions\"                 \"delete\"                 \"edit_permissions\"</p> required <code>apply_to</code> <code>int</code> <p>elements to apply permissions to - potential values:                  0 = this item (default)                  1 = sub-items                  2 = This item and sub-items                  3 = This item and immediate sub-items</p> <code>0</code> <p>Returns:     dict: Response of the request or None if the assignment of permissions has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_permission(\n    self,\n    node_id: int,\n    assignee_type: str,\n    assignee: int,\n    permissions: list,\n    apply_to: int = 0,\n) -&gt; dict | None:\n    \"\"\"Assign permissions for Extended ECM item to a user or group.\n\n    Args:\n        node_id (int): node ID of the Extended ECM item\n        assignee_type (str): this can be either \"owner\", \"group\" (for owner group),\n                                \"public\", or \"custom\" (assigned access)\n        assignee (int): ID of user or group (\"right ID\"). If 0 and assigneeType\n                            is \"owner\" or \"group\" then it is assumed that the owner and\n                            owner group should not be changed.\n        permissions (list): list of permissions - potential elements:\n                            \"see\"\n                            \"see_contents\"\n                            \"modify\"\n                            \"edit_attributes\"\n                            \"add_items\"\n                            \"reserve\"\n                            \"add_major_version\"\n                            \"delete_versions\"\n                            \"delete\"\n                            \"edit_permissions\"\n        apply_to (int, optional): elements to apply permissions to - potential values:\n                             0 = this item (default)\n                             1 = sub-items\n                             2 = This item and sub-items\n                             3 = This item and immediate sub-items\n    Returns:\n        dict: Response of the request or None if the assignment of permissions has failed.\n    \"\"\"\n\n    if not assignee_type or not assignee_type in [\n        \"owner\",\n        \"group\",\n        \"public\",\n        \"custom\",\n    ]:\n        logger.error(\n            \"Missing or wrong assignee type. Needs to be owner, group, public or custom!\"\n        )\n        return None\n    if assignee_type == \"custom\" and not assignee:\n        logger.error(\"Missing permission assignee!\")\n        return None\n\n    permission_post_data = {\n        \"permissions\": permissions,\n        \"apply_to\": apply_to,\n    }\n\n    # Assignees can be specified for owner and group and must be specified for custom:\n    #\n    if assignee:\n        permission_post_data[\"right_id\"] = assignee\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(node_id)\n        + \"/permissions/\"\n        + assignee_type\n    )\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Assign permissions -&gt; %s to item with ID -&gt; %s; assignee type -&gt; %s; calling -&gt; %s\",\n        str(permissions),\n        str(node_id),\n        assignee_type,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        if assignee_type == \"custom\":\n            # Custom also has a REST POST - we prefer this one as to\n            # also allows to add a new assigned permission (user or group):\n            response = requests.post(\n                url=request_url,\n                data={\"body\": json.dumps(permission_post_data)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n        else:\n            # Owner, Owner Group and Public require REST PUT:\n            response = requests.put(\n                url=request_url,\n                data={\"body\": json.dumps(permission_post_data)},\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign permissions -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(permissions),\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_rm_classification","title":"<code>assign_rm_classification(node_id, rm_classification, apply_to_sub_items=False)</code>","text":"<p>Assign a RM classification to an Extended ECM item Args:     node_id (int): node ID of the Extended ECM item     rm_classification (int): Records Management classification ID     apply_to_sub_items (bool, optional): if True the RM classification is applied to                                             the item and all its sub-items                                             if False the RM classification is only applied                                             to the item Returns:     dict: Response of the request or None if the assignment of the RM classification has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_rm_classification(\n    self, node_id: int, rm_classification: int, apply_to_sub_items: bool = False\n) -&gt; dict | None:\n    \"\"\"Assign a RM classification to an Extended ECM item\n    Args:\n        node_id (int): node ID of the Extended ECM item\n        rm_classification (int): Records Management classification ID\n        apply_to_sub_items (bool, optional): if True the RM classification is applied to\n                                                the item and all its sub-items\n                                                if False the RM classification is only applied\n                                                to the item\n    Returns:\n        dict: Response of the request or None if the assignment of the RM classification has failed.\n    \"\"\"\n\n    rm_classification_post_data = {\n        \"class_id\": rm_classification,\n        \"apply_to_sub_items\": apply_to_sub_items,\n    }\n\n    request_url = (\n        self.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/rmclassifications\"\n    )\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\n        str(rm_classification),\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=rm_classification_post_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(rm_classification),\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_user_security_clearance","title":"<code>assign_user_security_clearance(user_id, security_clearance)</code>","text":"<p>Assign a Security Clearance level to an Extended ECM user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>security_clearance</code> <code>int</code> <p>security clearance level to be set</p> required <p>Returns:     dict: REST response or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_user_security_clearance(\n    self, user_id: int, security_clearance: int\n) -&gt; dict | None:\n    \"\"\"Assign a Security Clearance level to an Extended ECM user\n\n    Args:\n        user_id (int): ID of the user\n        security_clearance (int): security clearance level to be set\n    Returns:\n        dict: REST response or None if the REST call fails.\n    \"\"\"\n\n    assign_user_security_clearance_post_data = {\n        \"securityLevel\": security_clearance,\n    }\n\n    request_url = self.config()[\n        \"userSecurityUrl\"\n    ] + \"/{}/securityclearancelevel\".format(user_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Assign security clearance -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\n        str(security_clearance),\n        str(user_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=assign_user_security_clearance_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign security clearance -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(security_clearance),\n                str(user_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_user_supplemental_markings","title":"<code>assign_user_supplemental_markings(user_id, supplemental_markings)</code>","text":"<p>Assign a list of Supplemental Markings to a user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>supplemental_markings</code> <code>list of strings</code> <p>list of Supplemental Markings to be set</p> required <p>Returns:     dict: REST response or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_user_supplemental_markings(\n    self, user_id: int, supplemental_markings: list\n) -&gt; dict | None:\n    \"\"\"Assign a list of Supplemental Markings to a user\n\n    Args:\n        user_id (int): ID of the user\n        supplemental_markings (list of strings): list of Supplemental Markings to be set\n    Returns:\n        dict: REST response or None if the REST call fails.\n    \"\"\"\n\n    assign_user_supplemental_markings_post_data = {\n        \"suppMarks\": supplemental_markings,\n    }\n\n    request_url = self.config()[\n        \"userSecurityUrl\"\n    ] + \"/{}/supplementalmarkings\".format(user_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Assign supplemental markings -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\n        str(supplemental_markings),\n        str(user_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=assign_user_supplemental_markings_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to assign supplemental markings -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(supplemental_markings),\n                str(user_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_workspace_permissions","title":"<code>assign_workspace_permissions(workspace_id, role_id, permissions, apply_to=2)</code>","text":"<p>Update permissions of a workspace role Args:     workspace_id (int): ID of the workspace     role_id (int): ID of the role     permissions (list): List of permissions - potential elements:                         \"see\"                         \"see_contents\"                         \"modify\"                         \"edit_attributes\"                         \"add_items\"                         \"reserve\"                         \"add_major_version\"                         \"delete_versions\"                         \"delete\"                         \"edit_permissions\"     apply_to (int, optional):  Items to apply the permission change. Possible values:                                0 = this item                                1 = sub-items                                2 = This item and sub-items (default)                                3 = This item and immediate sub-items Returns:     dict: Workspace Role Membership or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_workspace_permissions(\n    self, workspace_id: int, role_id: int, permissions: list, apply_to: int = 2\n) -&gt; dict | None:\n    \"\"\"Update permissions of a workspace role\n    Args:\n        workspace_id (int): ID of the workspace\n        role_id (int): ID of the role\n        permissions (list): List of permissions - potential elements:\n                            \"see\"\n                            \"see_contents\"\n                            \"modify\"\n                            \"edit_attributes\"\n                            \"add_items\"\n                            \"reserve\"\n                            \"add_major_version\"\n                            \"delete_versions\"\n                            \"delete\"\n                            \"edit_permissions\"\n        apply_to (int, optional):  Items to apply the permission change. Possible values:\n                                   0 = this item\n                                   1 = sub-items\n                                   2 = This item and sub-items (default)\n                                   3 = This item and immediate sub-items\n    Returns:\n        dict: Workspace Role Membership or None if the request fails.\n    \"\"\"\n\n    request_url = self.config()[\"businessWorkspacesUrl\"] + \"/{}/roles/{}\".format(\n        workspace_id, role_id\n    )\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Updating Permissions of role with ID -&gt; %s of workspace with ID -&gt; %s with permissions -&gt; %s; calling -&gt; %s\",\n        str(role_id),\n        str(workspace_id),\n        str(permissions),\n        request_url,\n    )\n\n    permission_post_data = {\n        \"permissions\": permissions,\n        \"apply_to\": apply_to,\n    }\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            headers=request_header,\n            data={\"body\": json.dumps(permission_post_data)},\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update permissions for role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(role_id),\n                str(workspace_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticates at Content Server and retrieve OTCS Ticket.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determinse if a re-athentication is enforced                          (e.g. if session has timed out with 401 error)                          By default we use the OTDS ticket (if exists) for the authentication with OTCS.                          This switch allows the forced usage of username / password for the authentication.</p> <code>False</code> <p>Returns:     dict: Cookie information of None in case of an error.           Also stores cookie information in self._cookie</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; dict | None:\n    \"\"\"Authenticates at Content Server and retrieve OTCS Ticket.\n\n    Args:\n        revalidate (bool, optional): determinse if a re-athentication is enforced\n                                     (e.g. if session has timed out with 401 error)\n                                     By default we use the OTDS ticket (if exists) for the authentication with OTCS.\n                                     This switch allows the forced usage of username / password for the authentication.\n    Returns:\n        dict: Cookie information of None in case of an error.\n              Also stores cookie information in self._cookie\n    \"\"\"\n\n    # Already authenticated and session still valid?\n    if self._cookie and not revalidate:\n        logger.info(\n            \"Session still valid - return existing cookie -&gt; %s\",\n            str(self._cookie),\n        )\n        return self._cookie\n\n    otcs_ticket = None\n\n    logger.info(\"Wait for OTCS to be ready...\")\n    while not self.is_ready():\n        logger.warning(\n            \"OTCS is not ready to receive requests yet. Waiting 30 seconds...\"\n        )\n        time.sleep(30)\n\n    request_url = self.config()[\"authenticationUrl\"]\n\n    if self._otds_ticket and not revalidate:\n        logger.info(\n            \"Requesting OTCS ticket with OTDS ticket; calling -&gt; %s\",\n            request_url,\n        )\n        request_header = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Accept\": \"application/json\",\n            \"OTDSTicket\": self._otds_ticket,\n        }\n\n        try:\n            response = requests.get(\n                url=request_url, headers=request_header, timeout=10\n            )\n            if response.ok:\n                otcs_ticket = response.headers.get(\"OTCSTicket\")\n\n        except requests.exceptions.RequestException as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s; error -&gt; %s\",\n                request_url,\n                exception.strerror,\n            )\n\n    # Check if previous authentication was not successful.\n    # Then we do the normal username + password authentication:\n    if not otcs_ticket:\n        logger.info(\n            \"Requesting OTCS ticket with User/Password; calling -&gt; %s\",\n            request_url,\n        )\n\n        response = None\n        try:\n            response = requests.post(\n                url=request_url,\n                data=self.credentials(),  # this includes username + password\n                headers=REQUEST_FORM_HEADERS,\n                timeout=REQUEST_TIMEOUT,\n            )\n        except requests.exceptions.RequestException as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s; error -&gt; %s\",\n                request_url,\n                exception.strerror,\n            )\n            logger.warning(\"OTCS service may not be ready yet.\")\n            return None\n\n        if response.ok:\n            authenticate_dict = self.parse_request_response(\n                response, \"This can be normal during restart\", False\n            )\n            if not authenticate_dict:\n                return None\n            else:\n                otcs_ticket = authenticate_dict[\"ticket\"]\n                logger.info(\"Ticket -&gt; %s\", otcs_ticket)\n        else:\n            logger.error(\n                \"Failed to request an OTCS ticket; error -&gt; %s\", response.text\n            )\n            return None\n\n    # Store authentication ticket:\n    self._cookie = {\"otcsticket\": otcs_ticket, \"LLCookie\": otcs_ticket}\n    self._otcs_ticket = otcs_ticket\n\n    return self._cookie\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.base_url","title":"<code>base_url()</code>","text":"<p>Returns the base URL of Extended ECM</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>base URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def base_url(self) -&gt; str:\n    \"\"\"Returns the base URL of Extended ECM\n\n    Returns:\n        str: base URL\n    \"\"\"\n    return self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.check_node_name","title":"<code>check_node_name(parent_id, node_name)</code>","text":"<p>Check if a node with a given name does already exist under a given parent node.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>int</code> <p>ID of the parent location</p> required <code>node_name</code> <code>str</code> <p>name of the new node</p> required <p>Returns:     dict | None: if response[\"results\"] contains an element then the node with the name does exist.                  if not response[\"results\"] then the node with the given name does not exist                  None in case an error occured</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def check_node_name(self, parent_id: int, node_name: str) -&gt; dict | None:\n    \"\"\"Check if a node with a given name does already exist under a given parent node.\n\n    Args:\n        parent_id (int): ID of the parent location\n        node_name (str): name of the new node\n    Returns:\n        dict | None: if response[\"results\"] contains an element then the node with the name does exist.\n                     if not response[\"results\"] then the node with the given name does not exist\n                     None in case an error occured\n    \"\"\"\n\n    request_url = self.config()[\"validationUrl\"]\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Check if node with name -&gt; %s can be created in parent with ID -&gt; %s; calling -&gt; %s\",\n        node_name,\n        str(parent_id),\n        request_url,\n    )\n\n    check_node_name_post_data = {\"parent_id\": parent_id, \"names\": [node_name]}\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data={\"body\": json.dumps(check_node_name_post_data)},\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to check if node name -&gt; %s can be created in parent with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                node_name,\n                str(parent_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.check_workspace_aviator","title":"<code>check_workspace_aviator(workspace_id)</code>","text":"<p>Check if Content Aviator is enabled for a workspace</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>node ID of the workspace</p> required <p>Returns:     bool: True if aviator is enabled, False otherwise</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def check_workspace_aviator(\n    self,\n    workspace_id: int,\n) -&gt; bool:\n    \"\"\"Check if Content Aviator is enabled for a workspace\n\n    Args:\n        workspace_id (int): node ID of the workspace\n    Returns:\n        bool: True if aviator is enabled, False otherwise\n    \"\"\"\n\n    response = self.get_node_actions(\n        node_id=workspace_id, filter_actions=[\"disableai\", \"enableai\"]\n    )\n    result_data = self.get_result_value(\n        response=response,\n        key=str(workspace_id),\n    )\n    if result_data and \"data\" in result_data:\n        data = result_data[\"data\"]\n        if \"disableai\" in data:\n            logger.info(\n                \"Aviator is enabled for workspace with ID -&gt; %s\", str(workspace_id)\n            )\n            return True\n        elif \"enableai\" in data:\n            logger.info(\n                \"Aviator is disabled for workspace with ID -&gt; %s\", str(workspace_id)\n            )\n\n    return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Returns the configuration dictionary\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    return self._config\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.convert_permission_string_to_permission_value","title":"<code>convert_permission_string_to_permission_value(permissions)</code>","text":"<p>Converts a list of permission names (strongs) to a bit-mask.</p> <p>Parameters:</p> Name Type Description Default <code>permissions</code> <code>list</code> <p>List of permission names - see conversion variable below.</p> required <p>Returns:     int: bit-encoded permission value</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def convert_permission_string_to_permission_value(self, permissions: list) -&gt; int:\n    \"\"\"Converts a list of permission names (strongs) to a bit-mask.\n\n    Args:\n        permissions (list): List of permission names - see conversion variable below.\n    Returns:\n        int: bit-encoded permission value\n    \"\"\"\n\n    conversion = {\n        \"see\": 130,  # Bits 2 and 8\n        \"see_contents\": 36865,  # Bit 17\n        \"modify\": 65536,  # Bit 18\n        \"edit_attributes\": 131072,  # Bit 19\n        \"add_items\": 4,  # Bit 3\n        \"reserve\": 8192,  # Bit 14\n        \"add_major_version\": 4194304,  # Bit 23\n        \"delete_versions\": 16384,  # Bit 15\n        \"delete\": 8,  # Bit 4\n        \"edit_permissions\": 16,  # Bit 5\n    }\n\n    permission_value = 0\n\n    for permission in permissions:\n        if not conversion.get(permission):\n            logger.error(\"Illegal permission value -&gt; %s\", str(permission))\n            return 0\n        permission_value += conversion[permission]\n\n    return permission_value\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.convert_permission_value_to_permission_string","title":"<code>convert_permission_value_to_permission_string(permission_value)</code>","text":"<p>Converts a bit-encoded permission value to a list of permission names (strings).</p> <p>Parameters:</p> Name Type Description Default <code>permission_value</code> <code>int</code> <p>bit-encoded permission value</p> required <p>Returns:     list: list of permission names</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def convert_permission_value_to_permission_string(\n    self, permission_value: int\n) -&gt; list:\n    \"\"\"Converts a bit-encoded permission value to a list of permission names (strings).\n\n    Args:\n        permission_value (int): bit-encoded permission value\n    Returns:\n        list: list of permission names\n    \"\"\"\n\n    conversion = {\n        \"see\": 130,  # Bits 2 and 8\n        \"see_contents\": 36865,  # Bit 17\n        \"modify\": 65536,  # Bit 18\n        \"edit_attributes\": 131072,  # Bit 19\n        \"add_items\": 4,  # Bit 3\n        \"reserve\": 8192,  # Bit 14\n        \"add_major_version\": 4194304,  # Bit 23\n        \"delete_versions\": 16384,  # Bit 15\n        \"delete\": 8,  # Bit 4\n        \"edit_permissions\": 16,  # Bit 5\n    }\n\n    permissions = []\n\n    for key, value in conversion.items():\n        if permission_value &amp; value:  # binary and\n            permissions.append(key)\n\n    return permissions\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cookie","title":"<code>cookie()</code>","text":"<p>Returns the login cookie of Extended ECM.    This is set by the authenticate() method</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Estended ECM cookie</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cookie(self) -&gt; dict:\n    \"\"\"Returns the login cookie of Extended ECM.\n       This is set by the authenticate() method\n\n    Returns:\n        dict: Estended ECM cookie\n    \"\"\"\n    return self._cookie\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_document_from_template","title":"<code>create_document_from_template(template_id, parent_id, classification_id, category_data, doc_name, doc_desciption='')</code>","text":"<p>Create a document based on a document template</p> <p>Parameters:</p> Name Type Description Default <code>template_id</code> <code>int</code> <p>node ID of the document template</p> required <code>parent_id</code> <code>int</code> <p>node ID of the target location (parent)</p> required <code>classification_id</code> <code>int</code> <p>node ID of the classification</p> required <code>category_data</code> <code>dict</code> <p>metadata / category data                     Example: category ID = 12508                     {                         \"12508\": {                             \"12508_2\": \"Draft\",         # Text drop-down                             \"12508_3\": 8559,            # user ID                             \"12508_4\": \"2023-05-10\",    # date                             \"12508_6\": 7357,            # user ID                             \"12508_7\": \"2023-05-11\",    # date                             \"12508_5\": True,            # checkbox / bool                             \"12508_8\": \"EN\",            # text drop-down                             \"12508_9\": \"MS Word\",       # text drop-down                         }                     }</p> required <code>doc_name</code> <code>str</code> <p>Name of the item to create.</p> required <code>doc_description</code> <code>str</code> <p>Description of the item to create.</p> required Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_document_from_template(\n    self,\n    template_id: int,\n    parent_id: int,\n    classification_id: int,\n    category_data: dict,\n    doc_name: str,\n    doc_desciption: str = \"\",\n) -&gt; dict | None:\n    \"\"\"Create a document based on a document template\n\n    Args:\n        template_id (int): node ID of the document template\n        parent_id (int): node ID of the target location (parent)\n        classification_id (int): node ID of the classification\n        category_data (dict): metadata / category data\n                                Example: category ID = 12508\n                                {\n                                    \"12508\": {\n                                        \"12508_2\": \"Draft\",         # Text drop-down\n                                        \"12508_3\": 8559,            # user ID\n                                        \"12508_4\": \"2023-05-10\",    # date\n                                        \"12508_6\": 7357,            # user ID\n                                        \"12508_7\": \"2023-05-11\",    # date\n                                        \"12508_5\": True,            # checkbox / bool\n                                        \"12508_8\": \"EN\",            # text drop-down\n                                        \"12508_9\": \"MS Word\",       # text drop-down\n                                    }\n                                }\n        doc_name (str): Name of the item to create.\n        doc_description (str, optional): Description of the item to create.\n    \"\"\"\n\n    create_document_post_data = {\n        \"template_id\": template_id,\n        \"parent_id\": parent_id,\n        \"name\": doc_name,\n        \"description\": doc_desciption,\n        \"type\": 144,\n        \"roles\": {\n            \"categories\": category_data,\n            \"classifications\": {\"create_id\": [classification_id], \"id\": []},\n        },\n    }\n\n    request_url = self.config()[\"doctemplatesUrl\"]\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create document -&gt; %s from template with ID -&gt; %s in target location -&gt; %s (parent ID) with classification ID -&gt; %s; calling -&gt; %s\",\n        doc_name,\n        str(template_id),\n        str(parent_id),\n        str(classification_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        response = requests.post(\n            url=request_url,\n            # this seems to only work with a \"body\" tag and is different form the documentation\n            # on developer.opentext.com\n            data={\"body\": json.dumps(create_document_post_data)},\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create document -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                doc_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_item","title":"<code>create_item(parent_id, item_type, item_name, item_description='', url='', original_id=0)</code>","text":"<p>Create an Extended ECM item. This REST call is somewhat limited. It cannot set favortie (featured item) or hidden item.    It does also not accept owner group information.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>int</code> <p>Node ID of the parent</p> required <code>item_type</code> <code>str</code> <p>Type of the item (e.g. 0 = foler, 140 = URL)</p> required <code>item_name</code> <code>str</code> <p>Name of the item</p> required <code>item_description</code> <code>str</code> <p>Description of the item</p> <code>''</code> <code>url</code> <code>str</code> <p>Address of the URL item (if it is an URL item type)</p> <code>''</code> <code>original_id</code> <code>int</code> <p>Node ID of the original (referenced) item.                          Required if a shortcut item is created</p> <code>0</code> <p>Returns:     dict: Request response of the create item call or None if the REST call has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_item(\n    self,\n    parent_id: int,\n    item_type: str,\n    item_name: str,\n    item_description: str = \"\",\n    url: str = \"\",\n    original_id: int = 0,\n) -&gt; dict | None:\n    \"\"\"Create an Extended ECM item. This REST call is somewhat limited. It cannot set favortie (featured item) or hidden item.\n       It does also not accept owner group information.\n\n    Args:\n        parent_id (int): Node ID of the parent\n        item_type (str): Type of the item (e.g. 0 = foler, 140 = URL)\n        item_name (str): Name of the item\n        item_description (str, optional): Description of the item\n        url (str, optional): Address of the URL item (if it is an URL item type)\n        original_id (int, optional): Node ID of the original (referenced) item.\n                                     Required if a shortcut item is created\n    Returns:\n        dict: Request response of the create item call or None if the REST call has failed.\n    \"\"\"\n\n    create_item_post_data = {\n        \"parent_id\": parent_id,\n        \"type\": item_type,\n        \"name\": item_name,\n        \"description\": item_description,\n    }\n\n    if url:\n        create_item_post_data[\"url\"] = url\n    if original_id &gt; 0:\n        create_item_post_data[\"original_id\"] = original_id\n\n    request_url = self.config()[\"nodesUrlv2\"]\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create item -&gt; %s (type -&gt; %s) under parent with ID -&gt; %s; calling -&gt; %s\",\n        item_name,\n        item_type,\n        str(parent_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        response = requests.post(\n            url=request_url,\n            data={\"body\": json.dumps(create_item_post_data)},\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create item -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                item_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_records_management_hold","title":"<code>create_records_management_hold(hold_type, name, comment, alternate_id='', parent_id=0, date_applied='', date_to_remove='')</code>","text":"<p>Create a new Records Management Hold.</p> <p>Parameters:</p> Name Type Description Default <code>hold_type</code> <code>str</code> <p>type of the Hold</p> required <code>name</code> <code>str</code> <p>name of the RSI</p> required <code>comment</code> <code>str</code> <p>comment</p> required <code>alternate_id</code> <code>str</code> <p>alternate hold ID</p> <code>''</code> <code>parent_id</code> <code>int</code> <p>ID of the parent node. If parent_id is 0 the item will be created right under \"Hold Management\" (top level item)</p> <code>0</code> <code>date_applied</code> <code>str</code> <p>create date of the Hold in this format: YYYY-MM-DDTHH:mm:ss</p> <code>''</code> <code>date_to_remove</code> <code>str</code> <p>suspend date of the Hold in this format: YYYY-MM-DDTHH:mm:ss</p> <code>''</code> <p>Returns:     dict: Hold data or None if the request fails. The dict structure is this: {'holdID': } Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_records_management_hold(\n    self,\n    hold_type: str,\n    name: str,\n    comment: str,\n    alternate_id: str = \"\",\n    parent_id: int = 0,\n    date_applied: str = \"\",\n    date_to_remove: str = \"\",\n) -&gt; dict | None:\n    \"\"\"Create a new Records Management Hold.\n\n    Args:\n        hold_type (str): type of the Hold\n        name (str): name of the RSI\n        comment (str): comment\n        alternate_id (str, optional): alternate hold ID\n        parent_id (int, optional): ID of the parent node. If parent_id is 0 the item will be created right under \"Hold Management\" (top level item)\n        date_applied (str, optional): create date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n        date_to_remove (str, optional): suspend date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n    Returns:\n        dict: Hold data or None if the request fails. The dict structure is this: {'holdID': &lt;ID&gt;}\n    \"\"\"\n\n    if date_applied == \"\":\n        now = datetime.now()\n        date_applied = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    create_hold_post_data = {\n        \"type\": hold_type,\n        \"name\": name,\n        \"comment\": comment,\n        \"date_applied\": date_applied,\n        \"date_to_remove\": date_to_remove,\n        \"alternate_id\": alternate_id,\n    }\n\n    if parent_id &gt; 0:\n        create_hold_post_data[\"parent_id\"] = parent_id\n\n    request_url = self.config()[\"holdsUrl\"]\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create Records Management Hold -&gt; %s; calling -&gt; %s\", name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=create_hold_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create Records Management Hold -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_records_management_rsi","title":"<code>create_records_management_rsi(name, status, status_date, description, subject, title, dispcontrol)</code>","text":"<p>Create a new Records Management RSI.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the RSI</p> required <code>status</code> <code>str</code> <p>status of the RSI</p> required <code>status_date</code> <code>str</code> <p>statusDate of the RSI YYYY-MM-DDTHH:mm:ss</p> required <code>description</code> <code>str</code> <p>description of the RSI</p> required <code>subject</code> <code>str</code> <p>status of the RSI</p> required <code>title</code> <code>str</code> <p>status of the RSI</p> required <code>dispcontrol</code> <code>bool</code> <p>status of the RSI</p> required <p>Returns:     dict: RSI data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_records_management_rsi(\n    self,\n    name: str,\n    status: str,\n    status_date: str,\n    description: str,\n    subject: str,\n    title: str,\n    dispcontrol: bool,\n) -&gt; dict | None:\n    \"\"\"Create a new Records Management RSI.\n\n    Args:\n        name (str): name of the RSI\n        status (str): status of the RSI\n        status_date (str): statusDate of the RSI YYYY-MM-DDTHH:mm:ss\n        description (str): description of the RSI\n        subject (str): status of the RSI\n        title (str): status of the RSI\n        dispcontrol (bool): status of the RSI\n    Returns:\n        dict: RSI data or None if the request fails.\n    \"\"\"\n\n    if status_date == \"\":\n        now = datetime.now()\n        status_date = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    create_rsi_post_data = {\n        \"name\": name,\n        \"status\": status,\n        \"statusDate\": status_date,\n        \"description\": description,\n        \"subject\": subject,\n        \"title\": title,\n        \"dispcontrol\": dispcontrol,\n    }\n\n    request_url = self.config()[\"rsiSchedulesUrl\"]\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create Records Management RSI -&gt; %s; calling -&gt; %s\", name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=create_rsi_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create Records Management RSI -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_records_management_rsi_schedule","title":"<code>create_records_management_rsi_schedule(rsi_id, stage, event_type=1, object_type='LIV', rule_code='', rule_comment='', date_to_use=91, retention_years=0, retention_months=0, retention_days=0, category_id=0, attribute_id=0, year_end_month=12, year_end_day=31, retention_intervals=1, fixed_retention=True, maximum_retention=True, fixed_date='', event_condition='', disposition='', action_code=0, description='', new_status='', min_num_versions_to_keep=1, purge_superseded=False, purge_majors=False, mark_official_rendition=False)</code>","text":"<p>Create a new Records Management RSI Schedule for an existing RSI.</p> <p>Parameters:</p> Name Type Description Default <code>rsi_id</code> <code>int</code> <p>ID of an existing RSI the schedule should be created for</p> required <code>stage</code> <code>str</code> <p>retention stage - this is the key parameter to define multiple stages (stages are basically schedules)</p> required <code>event_type</code> <code>int</code> <p>1 Calculated Date, 2 Calendar Calculation, 3 Event Based, 4 Fixed Date, 5 Permanent</p> <code>1</code> <code>object_type</code> <code>str</code> <p>either \"LIV\" - Classified Objects (default) or \"LRM\" - RM Classifications</p> <code>'LIV'</code> <code>rule_code</code> <code>str</code> <p>rule code - this value must be defined upfront</p> <code>''</code> <code>rule_comment</code> <code>str</code> <p>comment for the rule</p> <code>''</code> <code>date_to_use</code> <code>int</code> <p>91 Create Date, 92 Reserved Data, 93 Modification Date, 94 Status Date, 95 Records Date</p> <code>91</code> <code>retention_years</code> <code>int</code> <p>years to wait before disposition</p> <code>0</code> <code>retention_months</code> <code>int</code> <p>month to wait before disposition</p> <code>0</code> <code>retention_days</code> <code>int</code> <p>days to wait before disposition</p> <code>0</code> <code>category_id</code> <code>int</code> <p>ID of the category</p> <code>0</code> <code>attribute_id</code> <code>int</code> <p>ID of the category attribute</p> <code>0</code> <code>year_end_month</code> <code>int</code> <p>month the year ends (default = 12)</p> <code>12</code> <code>year_end_day</code> <code>int</code> <p>day the year ends (default = 31)</p> <code>31</code> <code>retention_intervals</code> <code>int</code> <p>retention intervals</p> <code>1</code> <code>fixed_retention</code> <code>bool</code> <p>fixedRetention</p> <code>True</code> <code>maximum_retention</code> <code>(bool, optional)</code> <p>maximumRetention</p> <code>True</code> <code>fixed_date(str,</code> <code>optional</code> <p>fixed date format : YYYY-MM-DDTHH:mm:ss</p> required <code>event_condition</code> <code>str</code> <p>eventCondition</p> <code>''</code> <code>disposition</code> <code>str</code> <p>disposition</p> <code>''</code> <code>action_code</code> <code>int</code> <p>0 None, 1 Change Status, 7 Close, 8 Finalize Record, 9 Mark Official, 10 Export, 11 Update Storage Provider, 12 Delete Electronic Format, 15 Purge Versions, 16 Make Rendition, 32 Destroy</p> <code>0</code> <code>description</code> <code>str</code> <p>description</p> <code>''</code> <code>new_status</code> <code>str</code> <p>new status</p> <code>''</code> <code>min_num_versions_to_keep</code> <code>int</code> <p>minimum document versions to keep, . Default is 1.</p> <code>1</code> <code>purge_superseded</code> <code>bool</code> <p>purge superseded. Default is False.</p> <code>False</code> <code>purge_majors</code> <code>bool</code> <p>purge majors. Default is False.</p> <code>False</code> <code>mark_official_rendition</code> <code>bool</code> <p>mark official rendition. Default is False.</p> <code>False</code> <p>Returns:     dict: RSI Schedule data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_records_management_rsi_schedule(\n    self,\n    rsi_id: int,\n    stage: str,\n    event_type: int = 1,\n    object_type: str = \"LIV\",\n    rule_code: str = \"\",\n    rule_comment: str = \"\",\n    date_to_use: int = 91,\n    retention_years: int = 0,\n    retention_months: int = 0,\n    retention_days: int = 0,\n    category_id: int = 0,\n    attribute_id: int = 0,\n    year_end_month: int = 12,\n    year_end_day: int = 31,\n    retention_intervals: int = 1,\n    fixed_retention: bool = True,\n    maximum_retention: bool = True,\n    fixed_date: str = \"\",\n    event_condition: str = \"\",\n    disposition: str = \"\",\n    action_code: int = 0,\n    description: str = \"\",\n    new_status: str = \"\",\n    min_num_versions_to_keep: int = 1,\n    purge_superseded: bool = False,\n    purge_majors: bool = False,\n    mark_official_rendition: bool = False,\n) -&gt; dict | None:\n    \"\"\"Create a new Records Management RSI Schedule for an existing RSI.\n\n    Args:\n        rsi_id (int): ID of an existing RSI the schedule should be created for\n        stage (str): retention stage - this is the key parameter to define multiple stages (stages are basically schedules)\n        event_type (int): 1 Calculated Date, 2 Calendar Calculation, 3 Event Based, 4 Fixed Date, 5 Permanent\n        object_type (str): either \"LIV\" - Classified Objects (default) or \"LRM\" - RM Classifications\n        rule_code (str, optional): rule code - this value must be defined upfront\n        rule_comment (str, optional): comment for the rule\n        date_to_use (int, optional): 91 Create Date, 92 Reserved Data, 93 Modification Date, 94 Status Date, 95 Records Date\n        retention_years (int, optional): years to wait before disposition\n        retention_months (int, optional): month to wait before disposition\n        retention_days (int, optional): days to wait before disposition\n        category_id (int, optional): ID of the category\n        attribute_id (int, optional): ID of the category attribute\n        year_end_month (int, optional): month the year ends (default = 12)\n        year_end_day (int, optional): day the year ends (default = 31)\n        retention_intervals (int, optional): retention intervals\n        fixed_retention (bool, optional): fixedRetention\n        maximum_retention (bool,optional): maximumRetention\n        fixed_date(str, optional): fixed date format : YYYY-MM-DDTHH:mm:ss\n        event_condition (str, optional): eventCondition\n        disposition (str, optional): disposition\n        action_code (int, optional): 0 None, 1 Change Status, 7 Close, 8 Finalize Record, 9 Mark Official, 10 Export, 11 Update Storage Provider, 12 Delete Electronic Format, 15 Purge Versions, 16 Make Rendition, 32 Destroy\n        description (str, optional): description\n        new_status (str, optional): new status\n        min_num_versions_to_keep (int, optional): minimum document versions to keep, . Default is 1.\n        purge_superseded (bool, optional): purge superseded. Default is False.\n        purge_majors (bool, optional): purge majors. Default is False.\n        mark_official_rendition (bool, optional): mark official rendition. Default is False.\n    Returns:\n        dict: RSI Schedule data or None if the request fails.\n    \"\"\"\n\n    if fixedDate == \"\":\n        now = datetime.now()\n        fixedDate = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    create_rsi_schedule_post_data = {\n        \"objectType\": object_type,\n        \"stage\": stage,\n        \"eventType\": event_type,\n        \"ruleCode\": rule_code,\n        \"ruleComment\": rule_comment,\n        \"dateToUse\": date_to_use,\n        \"retentionYears\": retention_years,\n        \"retentionMonths\": retention_months,\n        \"retentionDays\": retention_days,\n        \"categoryId\": category_id,\n        \"attributeId\": attribute_id,\n        \"yearEndMonth\": year_end_month,\n        \"yearEndDay\": year_end_day,\n        \"retentionIntervals\": retention_intervals,\n        \"fixedRetention\": fixed_retention,\n        \"maximumRetention\": maximum_retention,\n        \"fixedDate\": fixed_date,\n        \"eventCondition\": event_condition,\n        \"disposition\": disposition,\n        \"actionCode\": action_code,\n        \"description\": description,\n        \"newStatus\": new_status,\n        \"minNumVersionsToKeep\": min_num_versions_to_keep,\n        \"purgeSuperseded\": purge_superseded,\n        \"purgeMajors\": purge_majors,\n        \"markOfficialRendition\": mark_official_rendition,\n    }\n\n    request_url = self.config()[\"rsiSchedulesUrl\"] + \"/\" + str(rsi_id) + \"/stages\"\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create Records Management RSI Schedule -&gt; %s for RSI -&gt; %s; calling -&gt; %s\",\n        stage,\n        str(rsi_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=create_rsi_schedule_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create Records Management RSI Schedule -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                stage,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_transport_workbench","title":"<code>create_transport_workbench(workbench_name)</code>","text":"<p>Create a Workbench in the Transport Volume.</p> <p>Parameters:</p> Name Type Description Default <code>workbench_name</code> <code>str</code> <p>Name of the workbench to be created</p> required <p>Returns:     dict: Create response or None if the creation fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_transport_workbench(self, workbench_name: str) -&gt; dict | None:\n    \"\"\"Create a Workbench in the Transport Volume.\n\n    Args:\n        workbench_name (str): Name of the workbench to be created\n    Returns:\n        dict: Create response or None if the creation fails.\n    \"\"\"\n\n    create_worbench_post_data = {\"type\": \"528\", \"name\": workbench_name}\n\n    request_url = self.config()[\"nodesUrlv2\"]\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create transport workbench -&gt; %s; calling -&gt; %s\",\n        workbench_name,\n        request_url,\n    )\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=create_worbench_post_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create transport workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                workbench_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_workspace","title":"<code>create_workspace(workspace_template_id, workspace_name, workspace_description, workspace_type, category_data=None, external_system_id=None, bo_type=None, bo_id=None, parent_id=None, ibo_workspace_id=None, show_error=True)</code>","text":"<p>Create a new business workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_template_id</code> <code>int</code> <p>ID of the workspace template</p> required <code>workspace_name</code> <code>str</code> <p>Name of the workspace</p> required <code>workspace_description</code> <code>str</code> <p>Description of the workspace</p> required <code>workspace_type</code> <code>int</code> <p>Type ID of the workspace</p> required <code>category_data</code> <code>dict</code> <p>Category and attributes</p> <code>None</code> <code>external_system_id</code> <code>str</code> <p>Identifier of the external system (None if no external system)</p> <code>None</code> <code>bo_type</code> <code>str</code> <p>Business object type (None if no external system)</p> <code>None</code> <code>bo_id</code> <code>str</code> <p>Business object identifier / key (None if no external system)</p> <code>None</code> <code>parent_id</code> <code>str</code> <p>Parent ID of the workspaces. Needs only be specified in special                        cases where workspace location cannot be derived from workspace                        type definition</p> <code>None</code> <code>ibo_workspace_id</code> <code>int</code> <p>Node ID of an existing workspace that is already connected to another                               external system. This allows for subsequent calls to coonect the workspace                               to multiple Business Objects (IBO = Identical Business Objects)</p> <code>None</code> <code>show_error</code> <code>bool</code> <p>Log an error if workspace cration fails. Otherwise log a warning.</p> <code>True</code> <p>Returns:     dict: Workspace Create Form data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_workspace(\n    self,\n    workspace_template_id: int,\n    workspace_name: str,\n    workspace_description: str,\n    workspace_type: int,\n    category_data: dict | None = None,\n    external_system_id: int = None,\n    bo_type: int | None = None,\n    bo_id: int | None = None,\n    parent_id: int | None = None,\n    ibo_workspace_id: int | None = None,\n    show_error: bool = True,\n) -&gt; dict | None:\n    \"\"\"Create a new business workspace.\n\n    Args:\n        workspace_template_id (int): ID of the workspace template\n        workspace_name (str): Name of the workspace\n        workspace_description (str): Description of the workspace\n        workspace_type (int): Type ID of the workspace\n        category_data (dict): Category and attributes\n        external_system_id (str, optional): Identifier of the external system (None if no external system)\n        bo_type (str, optional): Business object type (None if no external system)\n        bo_id (str, optional): Business object identifier / key (None if no external system)\n        parent_id (str, optional): Parent ID of the workspaces. Needs only be specified in special\n                                   cases where workspace location cannot be derived from workspace\n                                   type definition\n        ibo_workspace_id (int, optional): Node ID of an existing workspace that is already connected to another\n                                          external system. This allows for subsequent calls to coonect the workspace\n                                          to multiple Business Objects (IBO = Identical Business Objects)\n        show_error (bool, optional): Log an error if workspace cration fails. Otherwise log a warning.\n    Returns:\n        dict: Workspace Create Form data or None if the request fails.\n    \"\"\"\n\n    # Avoid linter warning W0102\n    if category_data is None:\n        category_data = {}\n\n    create_workspace_post_data = {\n        \"template_id\": str(workspace_template_id),\n        \"name\": workspace_name,\n        \"description\": workspace_description,\n        \"wksp_type_id\": str(workspace_type),\n        \"type\": str(848),\n        \"roles\": category_data,\n    }\n\n    # Is this workspace connected to a business application / external system?\n    if external_system_id and bo_type and bo_id:\n        create_workspace_post_data[\"ext_system_id\"] = str(external_system_id)\n        create_workspace_post_data[\"bo_type\"] = str(bo_type)\n        create_workspace_post_data[\"bo_id\"] = str(bo_id)\n        logger.info(\n            \"Use business object connection -&gt; (%s, %s, %s) for workspace -&gt; %s\",\n            str(external_system_id),\n            str(bo_type),\n            str(bo_id),\n            workspace_name,\n        )\n        if ibo_workspace_id:\n            logger.info(\n                \"This is a subsequent call to create a cross-application workspace (IBO)\"\n            )\n            create_workspace_post_data[\"ibo_workspace_id\"] = ibo_workspace_id\n\n    # If workspace creation location cannot be derived from the workspace type\n    # there may be an optional parent parameter passed to this method. This can\n    # also be the case if workspaces are nested into each other:\n    if parent_id is not None:\n        create_workspace_post_data[\"parent_id\"] = parent_id\n        logger.info(\n            \"Use specified location -&gt; %s for workspace -&gt; %s\",\n            str(parent_id),\n            workspace_name,\n        )\n    else:\n        logger.info(\n            \"Determine location of workspace -&gt; %s via workspace type -&gt; %s\",\n            workspace_name,\n            str(workspace_type),\n        )\n\n    request_url = self.config()[\"businessWorkspacesUrl\"]\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create workspace -&gt; %s with type -&gt; %s from template -&gt; %s; calling -&gt; %s\",\n        workspace_name,\n        str(workspace_type),\n        str(workspace_template_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        # See https://developer.opentext.com/apis/14ba85a7-4693-48d3-8c93-9214c663edd2/4403207c-40f1-476a-b794-fdb563e37e1f/07229613-7ef4-4519-8b8a-47eaff639d42#operation/createBusinessWorkspace\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data={\"body\": json.dumps(create_workspace_post_data)},\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to create workspace -&gt; %s from template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    workspace_name,\n                    str(workspace_template_id),\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.warning(\n                    \"Couldn't create workspace -&gt; %s from template with ID -&gt; %s (it may exist already); status -&gt; %s; error -&gt; %s\",\n                    workspace_name,\n                    str(workspace_template_id),\n                    response.status_code,\n                    response.text,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_workspace_relationship","title":"<code>create_workspace_relationship(workspace_id, related_workspace_id, relationship_type='child')</code>","text":"<p>Create a relationship between two workspaces.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>related_workspace_id</code> <code>int</code> <p>ID of the related workspace</p> required <code>relationship_type</code> <code>str</code> <p>\"parent\" or \"child\" - \"child\" is default if omitted</p> <code>'child'</code> <p>Returns:     dict: Workspace Relationship data (json) or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_workspace_relationship(\n    self,\n    workspace_id: int,\n    related_workspace_id: int,\n    relationship_type: str = \"child\",\n) -&gt; dict | None:\n    \"\"\"Create a relationship between two workspaces.\n\n    Args:\n        workspace_id (int): ID of the workspace\n        related_workspace_id (int): ID of the related workspace\n        relationship_type (str, optional): \"parent\" or \"child\" - \"child\" is default if omitted\n    Returns:\n        dict: Workspace Relationship data (json) or None if the request fails.\n    \"\"\"\n\n    create_workspace_relationship_post_data = {\n        \"rel_bw_id\": str(related_workspace_id),\n        \"rel_type\": relationship_type,\n    }\n\n    request_url = self.config()[\n        \"businessWorkspacesUrl\"\n    ] + \"/{}/relateditems\".format(workspace_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Create workspace relationship between -&gt; %s and -&gt; %s; calling -&gt; %s\",\n        str(workspace_id),\n        str(related_workspace_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=create_workspace_relationship_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to create workspace relationship between -&gt; %s and -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(workspace_id),\n                str(related_workspace_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.credentials","title":"<code>credentials()</code>","text":"<p>Get credentials (username + password)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with username and password</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def credentials(self) -&gt; dict:\n    \"\"\"Get credentials (username + password)\n\n    Returns:\n        dict: dictionary with username and password\n    \"\"\"\n    return {\n        \"username\": self.config()[\"username\"],\n        \"password\": self.config()[\"password\"],\n    }\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_public_url","title":"<code>cs_public_url()</code>","text":"<p>Returns the public (external) Extended ECM URL (incl. base_path /cs/cs )</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM Public URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_public_url(self) -&gt; str:\n    \"\"\"Returns the public (external) Extended ECM URL (incl. base_path /cs/cs )\n\n    Returns:\n        str: Extended ECM Public URL\n    \"\"\"\n    return self.config()[\"csPublicUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_support_public_url","title":"<code>cs_support_public_url()</code>","text":"<p>Returns the Extended ECM Public Support URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM Public Support URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_support_public_url(self) -&gt; str:\n    \"\"\"Returns the Extended ECM Public Support URL\n\n    Returns:\n        str: Extended ECM Public Support URL\n    \"\"\"\n    return self.config()[\"supportPublicUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_support_url","title":"<code>cs_support_url()</code>","text":"<p>Returns the Extended ECM Support URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM Support URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_support_url(self) -&gt; str:\n    \"\"\"Returns the Extended ECM Support URL\n\n    Returns:\n        str: Extended ECM Support URL\n    \"\"\"\n    return self.config()[\"supportUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_url","title":"<code>cs_url()</code>","text":"<p>Returns the Extended ECM URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_url(self) -&gt; str:\n    \"\"\"Returns the Extended ECM URL\n\n    Returns:\n        str: Extended ECM URL\n    \"\"\"\n    return self.config()[\"csUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.deploy_transport","title":"<code>deploy_transport(package_url, package_name, package_description='', replacements=None, extractions=None)</code>","text":"<p>Main method to deploy a transport. This uses subfunctions to upload,    unpackage and deploy the transport, and creates the required workbench.</p> <p>Parameters:</p> Name Type Description Default <code>package_url</code> <code>str</code> <p>URL to download the transport package.</p> required <code>package_name</code> <code>str</code> <p>Name of the transport package ZIP file</p> required <code>package_description</code> <code>str</code> <p>Description of the transport package</p> <code>''</code> <code>replacements</code> <code>list of dicts</code> <p>List of replacement values to be applied                           to all XML files in transport;                           each dict needs to have two values:                           - placeholder: text to replace                           - value: text to replace with</p> <code>None</code> <code>extractions</code> <code>list of dicts</code> <p>List of XML Subtrees to extract                          each XML file in transport;                          each dict needs to have two values:                           - xpath: defining the subtree to extract                           - enabled: True if the extraction is active</p> <code>None</code> <p>Returns:     dict: Deploy response or None if the deployment fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def deploy_transport(\n    self,\n    package_url: str,\n    package_name: str,\n    package_description: str = \"\",\n    replacements: list | None = None,\n    extractions: list | None = None,\n) -&gt; dict | None:\n    \"\"\"Main method to deploy a transport. This uses subfunctions to upload,\n       unpackage and deploy the transport, and creates the required workbench.\n\n    Args:\n        package_url (str): URL to download the transport package.\n        package_name (str): Name of the transport package ZIP file\n        package_description (str): Description of the transport package\n        replacements (list of dicts): List of replacement values to be applied\n                                      to all XML files in transport;\n                                      each dict needs to have two values:\n                                      - placeholder: text to replace\n                                      - value: text to replace with\n        extractions (list of dicts): List of XML Subtrees to extract\n                                     each XML file in transport;\n                                     each dict needs to have two values:\n                                      - xpath: defining the subtree to extract\n                                      - enabled: True if the extraction is active\n    Returns:\n        dict: Deploy response or None if the deployment fails.\n    \"\"\"\n\n    if replacements is None:\n        replacements = []\n    if extractions is None:\n        extractions = []\n\n    # Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\n    response = self.get_volume(525)\n    transport_root_volume_id = self.get_result_value(response, \"id\")\n    if not transport_root_volume_id:\n        logger.error(\"Failed to retrieve transport root volume\")\n        return None\n    logger.info(\"Transport root volume ID -&gt; %s\", str(transport_root_volume_id))\n\n    response = self.get_node_by_parent_and_name(\n        transport_root_volume_id, \"Transport Packages\"\n    )\n    transport_package_volume_id = self.get_result_value(response, \"id\")\n    if not transport_package_volume_id:\n        logger.error(\"Failed to retrieve transport package volume\")\n        return None\n    logger.info(\n        \"Transport package volume ID -&gt; %s\", str(transport_package_volume_id)\n    )\n\n    # Step 1: Upload Transport Package\n    logger.info(\"Check if transport package -&gt; %s already exists...\", package_name)\n    response = self.get_node_by_parent_and_name(\n        transport_package_volume_id, package_name\n    )\n    package_id = self.get_result_value(response, \"id\")\n    if package_id:\n        logger.info(\n            \"Transport package -&gt; %s does already exist; existing package ID -&gt; %s\",\n            package_name,\n            str(package_id),\n        )\n    else:\n        logger.info(\n            \"Transport package -&gt; %s does not yet exist, loading from -&gt; %s\",\n            package_name,\n            package_url,\n        )\n        # If we have string replacements configured execute them now:\n        if replacements:\n            logger.info(\n                \"Transport -&gt; %s has replacements -&gt; %s\",\n                package_name,\n                str(replacements),\n            )\n            self.replace_transport_placeholders(package_url, replacements)\n        else:\n            logger.info(\"Transport -&gt; %s has no replacements!\", package_name)\n        # If we have data extractions configured execute them now:\n        if extractions:\n            logger.info(\n                \"Transport -&gt; %s has extractions -&gt; %s\",\n                package_name,\n                str(extractions),\n            )\n            self.extract_transport_data(package_url, extractions)\n        else:\n            logger.info(\"Transport -&gt; %s has no extractions!\", package_name)\n        # Upload package to Extended ECM:\n        response = self.upload_file_to_volume(\n            package_url, package_name, \"application/zip\", 531\n        )\n        package_id = self.get_result_value(response, \"id\")\n        if not package_id:\n            logger.error(\"Failed to upload transport package -&gt; %s\", package_url)\n            return None\n        logger.info(\n            \"Successfully uploaded transport package -&gt; %s; new package ID -&gt; %s\",\n            package_name,\n            str(package_id),\n        )\n\n    # Step 2: Create Transport Workbench (if not yet exist)\n    workbench_name = package_name.split(\".\")[0]\n    logger.info(\"Check if workbench -&gt; %s is already deployed...\", workbench_name)\n    # check if the package name has the suffix \"(deployed)\" - this indicates it is alreadey\n    # successfully deployed (see renaming at the end of this method)\n    response = self.get_node_by_parent_and_name(\n        transport_root_volume_id, workbench_name + \" (deployed)\"\n    )\n    workbench_id = self.get_result_value(response, \"id\")\n    if workbench_id:\n        logger.info(\n            \"Workbench -&gt; %s has already been deployed successfully; existing workbench ID -&gt; %s; skipping transport\",\n            workbench_name,\n            str(workbench_id),\n        )\n        # we return and skip this transport...\n        return response\n    else:\n        logger.info(\"Check if workbench -&gt; %s already exists...\", workbench_name)\n        response = self.get_node_by_parent_and_name(\n            transport_root_volume_id, workbench_name\n        )\n        workbench_id = self.get_result_value(response, \"id\")\n        if workbench_id:\n            logger.info(\n                \"Workbench -&gt; %s does already exist but is not successfully deployed; existing workbench ID -&gt; %s\",\n                workbench_name,\n                str(workbench_id),\n            )\n        else:\n            response = self.create_transport_workbench(workbench_name)\n            workbench_id = self.get_result_value(response, \"id\")\n            if not workbench_id:\n                logger.error(\"Failed to create workbench -&gt; %s\", workbench_name)\n                return None\n            logger.info(\n                \"Successfully created workbench -&gt; %s; new workbench ID -&gt; %s\",\n                workbench_name,\n                str(workbench_id),\n            )\n\n    # Step 3: Unpack Transport Package to Workbench\n    logger.info(\n        \"Unpack transport package -&gt; %s (%s) to workbench -&gt; %s (%s)\",\n        package_name,\n        str(package_id),\n        workbench_name,\n        str(workbench_id),\n    )\n    response = self.unpack_transport_package(package_id, workbench_id)\n    if not response:\n        logger.error(\"Failed to unpack the transport package -&gt; %s\", package_name)\n        return None\n    logger.info(\n        \"Successfully unpackaged to workbench -&gt; %s (%s)\",\n        workbench_name,\n        str(workbench_id),\n    )\n\n    # Step 4: Deploy Workbench\n    logger.info(\"Deploy workbench -&gt; %s (%s)\", workbench_name, str(workbench_id))\n    response = self.deploy_workbench(workbench_id)\n    if not response:\n        logger.error(\"Failed to deploy workbench -&gt; %s\", workbench_name)\n        return None\n\n    logger.info(\n        \"Successfully deployed workbench -&gt; %s (%s)\",\n        workbench_name,\n        str(workbench_id),\n    )\n    self.rename_node(\n        workbench_id,\n        workbench_name + \" (deployed)\",\n        package_description,\n    )\n\n    return response\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.deploy_workbench","title":"<code>deploy_workbench(workbench_id)</code>","text":"<p>Deploy an existing Workbench.</p> <p>Parameters:</p> Name Type Description Default <code>workbench_d</code> <code>int</code> <p>ID of the workbench to be deployed</p> required <p>Returns:     dict: Deploy response or None if the deployment fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def deploy_workbench(self, workbench_id: int) -&gt; dict | None:\n    \"\"\"Deploy an existing Workbench.\n\n    Args:\n        workbench_d (int): ID of the workbench to be deployed\n    Returns:\n        dict: Deploy response or None if the deployment fails.\n    \"\"\"\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(workbench_id) + \"/deploy\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Deploy workbench with ID -&gt; %s; calling -&gt; %s\",\n        str(workbench_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # As this is a potentially long-running request we put it in try / except:\n        try:\n            response = requests.post(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n        except requests.exceptions.RequestException as exception:\n            logger.error(\n                \"Error deploying workbench -&gt; %s; error -&gt; %s\",\n                str(workbench_id),\n                exception.strerror,\n            )\n            return None\n        if response.ok:\n            response_dict = self.parse_request_response(response)\n            if not response_dict:\n                logger.error(\"Error deploying workbench -&gt; %s\", str(workbench_id))\n                return None\n            return response_dict\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.warning(\n                \"Failed to depoloy workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                workbench_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.download_config_file","title":"<code>download_config_file(otcs_url_suffix, file_path, search='', replace='')</code>","text":"<p>Download a config file from a given OTCS URL. This is NOT     for downloading documents from within the OTCS repository     but for configuration files such as app packages for MS Teams.</p> <p>Parameters:</p> Name Type Description Default <code>otcs_url_suffix</code> <code>str</code> <p>OTCS URL suffix starting typically starting                       with /cs/cs?func=,                       e.g. /cs/cs?func=officegroups.DownloadTeamsPackage</p> required <code>file_path</code> <code>str</code> <p>local path to save the file (direcotry + filename)</p> required <code>search</code> <code>str</code> <p>optional string to search for a replacement</p> <code>''</code> <code>replace</code> <code>str</code> <p>optional replacement</p> <code>''</code> <p>Returns:     bool: True if the download succeeds, False otherwise</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def download_config_file(\n    self, otcs_url_suffix: str, file_path: str, search: str = \"\", replace: str = \"\"\n) -&gt; bool:\n    \"\"\"Download a config file from a given OTCS URL. This is NOT\n        for downloading documents from within the OTCS repository\n        but for configuration files such as app packages for MS Teams.\n\n    Args:\n        otcs_url_suffix (str): OTCS URL suffix starting typically starting\n                                  with /cs/cs?func=,\n                                  e.g. /cs/cs?func=officegroups.DownloadTeamsPackage\n        file_path (str): local path to save the file (direcotry + filename)\n        search (str, optional): optional string to search for a replacement\n        replace (str, optional): optional replacement\n    Returns:\n        bool: True if the download succeeds, False otherwise\n    \"\"\"\n\n    request_url = self.config()[\"baseUrl\"] + otcs_url_suffix\n    # request_header = self.cookie()\n    request_header = self.request_download_header()\n\n    logger.info(\"Download config file from URL -&gt; %s\", request_url)\n\n    try:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=REQUEST_TIMEOUT,\n        )\n        response.raise_for_status()\n    except requests.exceptions.HTTPError as errh:\n        logger.error(\"Http Error -&gt; %s\", errh.strerror)\n        return False\n    except requests.exceptions.ConnectionError as errc:\n        logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n        return False\n    except requests.exceptions.Timeout as errt:\n        logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n        return False\n    except requests.exceptions.RequestException as err:\n        logger.error(\"Request error -&gt; %s\", err.strerror)\n        return False\n\n    content = response.content\n\n    if search:\n        logger.info(\n            \"Search for all occurances of %s in the config file and replace them with %s\",\n            search,\n            replace,\n        )\n        content = content.replace(search.encode(\"utf-8\"), replace.encode(\"utf-8\"))\n\n    # Open file in write binary mode\n    with open(file=file_path, mode=\"wb\") as file:\n        # Write the content to the file\n        file.write(content)\n\n    logger.info(\n        \"Successfully downloaded config file -&gt; %s to -&gt; %s; status code -&gt; %s\",\n        request_url,\n        file_path,\n        response.status_code,\n    )\n\n    return True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.download_document","title":"<code>download_document(node_id, file_path, version_number='')</code>","text":"<p>Download a document from Extended ECM to local file system.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the document to download</p> required <code>file_path</code> <code>str</code> <p>local file path (directory)</p> required <code>version_number</code> <code>str</code> <p>version of the document to download.                      If version = \"\" then download the latest                      version.</p> <code>''</code> <p>Returns:     bool: True if the document has been download to the specified file.              False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def download_document(\n    self, node_id: int, file_path: str, version_number: str = \"\"\n) -&gt; bool:\n    \"\"\"Download a document from Extended ECM to local file system.\n\n    Args:\n        node_id (int): node ID of the document to download\n        file_path (str): local file path (directory)\n        version_number (str): version of the document to download.\n                                 If version = \"\" then download the latest\n                                 version.\n    Returns:\n        bool: True if the document has been download to the specified file.\n                 False otherwise.\n    \"\"\"\n\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        logger.error(\"Directory -&gt; %s does not exist\", directory)\n        return False\n\n    if not version_number:\n        response = self.get_latest_document_version(node_id)\n        if not response:\n            logger.error(\n                \"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n            )\n        version_number = response[\"data\"][\"version_number\"]\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(node_id)\n        + \"/versions/\"\n        + str(version_number)\n        + \"/content\"\n    )\n    request_header = self.request_download_header()\n\n    logger.info(\n        \"Download document with node ID -&gt; %s; calling -&gt; %s\",\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            content = response.content\n            break\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return False\n\n    logger.info(\"Writing document content to file -&gt; %s\", file_path)\n\n    # Open file in write binary mode\n    with open(file=file_path, mode=\"wb\") as file:\n        # Write the content to the file\n        file.write(content)\n\n    return True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.exist_result_item","title":"<code>exist_result_item(response, key, value, property_name='properties')</code>","text":"<p>Check existence of key / value pair in the response properties of an Extended ECM REST API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an OTCS REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>value</code> <code>str</code> <p>value to find in the item with the matching key</p> required <code>property_name</code> <code>str</code> <p>name of the substructure that includes the values</p> <code>'properties'</code> <p>Returns:     bool: True if the value was found, False otherwise</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def exist_result_item(\n    self, response: dict, key: str, value: str, property_name: str = \"properties\"\n) -&gt; bool:\n    \"\"\"Check existence of key / value pair in the response properties of an Extended ECM REST API call.\n\n    Args:\n        response (dict): REST response from an OTCS REST Call\n        key (str): property name (key)\n        value (str): value to find in the item with the matching key\n        property_name (str, optional): name of the substructure that includes the values\n    Returns:\n        bool: True if the value was found, False otherwise\n    \"\"\"\n\n    if not response:\n        return False\n    if not \"results\" in response:\n        return False\n\n    results = response[\"results\"]\n    # check if results is a list or a dict (both is possible - dependent on the actual REST API):\n    if isinstance(results, dict):\n        # result is a dict - we don't need index value:\n        if not \"data\" in results:\n            return False\n        data = results[\"data\"]\n        if isinstance(data, dict):\n            # data is a dict - we don't need index value:\n            if property_name and not property_name in data:\n                logger.error(\n                    \"There's no -&gt; %s dictionary in data -&gt; %s\", property_name, data\n                )\n                return False\n            properties = data[property_name]\n            if isinstance(properties, dict):\n                if key in properties:\n                    return properties[key] == value\n                else:\n                    return False\n            elif isinstance(properties, list):\n                # properties is a list we iterate through the list and try to find the key:\n                for item in properties:\n                    if key in item and item[key] == value:\n                        return True\n            else:\n                logger.error(\n                    \"Properties needs to be a list or dict but it is -&gt; %s\",\n                    str(type(properties)),\n                )\n                return False\n        elif isinstance(data, list):\n            # data is a list\n            for item in data:\n                if property_name and not property_name in item:\n                    logger.error(\n                        \"There's no -&gt; %s dictionary in the data list item -&gt; %s\",\n                        property_name,\n                        item,\n                    )\n                    continue\n                # if properties if passed as empty string then we assume that\n                # the key fields are directly in the item dictionary. This is\n                # the case e.g. with the V2 Proxy APIs\n                if not property_name:\n                    properties = item\n                else:\n                    properties = item[property_name]\n                if key in properties and properties[key] == value:\n                    return True\n            return False\n        else:\n            logger.error(\n                \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n            )\n            return False\n    elif isinstance(results, list):\n        # result is a list - we need index value\n        for result in results:\n            if not \"data\" in result:\n                continue\n            data = result[\"data\"]\n            if isinstance(data, dict):\n                # data is a dict - we don't need index value:\n                properties = data[property_name]\n                if key in properties and properties[key] == value:\n                    return True\n            elif isinstance(data, list):\n                # data is a list we iterate through the list and try to find the key:\n                for item in data:\n                    properties = item[property_name]\n                    if key in properties and properties[key] == value:\n                        return True\n            else:\n                logger.error(\n                    \"Data needs to be a list or dict but it is -&gt; %s\",\n                    str(type(data)),\n                )\n                return False\n        return False\n    else:\n        logger.error(\n            \"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n        )\n        return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.extract_transport_data","title":"<code>extract_transport_data(zip_file_path, extractions)</code>","text":"<p>Search and extract XML data from the transport package</p> <p>Parameters:</p> Name Type Description Default <code>zip_file_path</code> <code>str</code> <p>Path to transport zip file</p> required <code>extractions</code> <code>list of dicts</code> <p>List of extraction values; dict needs to have two values:                          * xpath: structure to find                          * enabed (optional): if the extraction is active</p> required <p>Returns:     True if successful, False otherwise. THIS METHOD MODIFIES EXTRACTIONS     BY ADDING A NEW KEY \"data\" TO EACH EXTRACTION ELEMENT!!</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def extract_transport_data(self, zip_file_path: str, extractions: list) -&gt; bool:\n    \"\"\"Search and extract XML data from the transport package\n\n    Args:\n        zip_file_path (str): Path to transport zip file\n        extractions (list of dicts): List of extraction values; dict needs to have two values:\n                                     * xpath: structure to find\n                                     * enabed (optional): if the extraction is active\n    Returns:\n        True if successful, False otherwise. THIS METHOD MODIFIES EXTRACTIONS\n        BY ADDING A NEW KEY \"data\" TO EACH EXTRACTION ELEMENT!!\n    \"\"\"\n\n    if not os.path.isfile(zip_file_path):\n        logger.error(\"Zip file -&gt; %s not found.\", zip_file_path)\n        return False\n\n    # Extract the zip file to a temporary directory\n    zip_file_folder = os.path.splitext(zip_file_path)[0]\n    with zipfile.ZipFile(zip_file_path, \"r\") as zfile:\n        zfile.extractall(zip_file_folder)\n\n    # Extract data from all XML files in the directory and its subdirectories\n    for extraction in extractions:\n        if not \"xpath\" in extraction:\n            logger.error(\n                \"Extraction needs an XPath but it is not specified. Skipping...\"\n            )\n            continue\n        if \"enabled\" in extraction and not extraction[\"enabled\"]:\n            logger.info(\n                \"Extraction for transport -&gt; %s is disabled. Skipping...\",\n                zip_file_path,\n            )\n            continue\n\n        xpath = extraction[\"xpath\"]\n        logger.info(\n            \"Using xpath -&gt; %s to extract the data\",\n            xpath,\n        )\n\n        # This delivers a list of strings containing the extracted data:\n        extracted_data = XML.extract_from_xml_files(\n            zip_file_folder,\n            xpath,\n        )\n        if extracted_data:\n            logger.info(\n                \"Extraction with XPath -&gt; %s has been successfully completed for Transport package -&gt; %s\",\n                xpath,\n                zip_file_folder,\n            )\n            # Add the extracted elements to the extraction data structure (dict).\n            extraction[\"data\"] = extracted_data\n        else:\n            logger.warning(\n                \"Extraction with XPath -&gt; %s has not delivered any data for Transport package -&gt; %s\",\n                xpath,\n                zip_file_folder,\n            )\n            extraction[\"data\"] = []\n\n    # Return the path to the new zip file\n    return True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_business_object_type","title":"<code>get_business_object_type(external_system_id, type_name, expand_workspace_type=True, expand_external_system=True)</code>","text":"<p>Get business object type information. Unfortunately this REST API is    pretty much limited. It does not return Field names of external system properties    and also does not return property groups defined.</p> <p>Parameters:</p> Name Type Description Default <code>external_system_id</code> <code>str</code> <p>External system Id (such as \"TM6\")</p> required <code>type_name</code> <code>str</code> <p>Type name of the business object (such as \"SAP Customer\")</p> required <p>Returns:     dict: Business Object Type information or None if the request fails.</p> <pre><code>Example response:\n{\n    'businessProperties': [\n        {\n            'attributeID': '14012_29',\n            'categoryID': '14012',\n            'name': 'Name',\n            'type': 'String'\n        },\n        {\n            'attributeID': '14012_28',\n            'categoryID': '14012',\n            'name': 'Customer Number',\n            'type': 'String'\n        }\n    ]\n    'bwsinfo': {'id': None},\n    'cadxref_doc_info': {'has_relation': False},\n    'categories': [],\n    'claimed_doc_info': {'is_claimed': False},\n    'columns': [{...}, {...}, {...}, {...}],\n    'doctemplates_info': {'isInDocTemplateVolTree': False},\n    'followups': [],\n    'nicknames': {'nickname': '16568'},\n    'properties': {\n        'advanced_versioning': None,\n        'container': False,\n        'container_size': 0,\n        'create_date': '2017-11-23T16:43:34Z',\n        'create_user_id': 1000,\n        'description': '',\n        'description_multilingual': {...},\n        'external_create_date': None,\n        'external_identity': '',\n        ...\n    },\n    'rmiconsdata': {'class_id': 0, 'official': 0, 'show_classify': False, 'show_hold': False, 'show_hold_tab': False, 'show_label_tab': True, 'show_official': False, 'show_xref': False, 'show_xref_tab': False},\n    'sestatus_doc_info': {'is_se_document': False, 'sync_tooltip': ''},\n    'sharing_info': {'is_shared': False, 'sync_state': -1},\n    'showmainruleicon': False,\n    ...\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_business_object_type(\n    self,\n    external_system_id: str,\n    type_name: str,\n    expand_workspace_type: bool = True,\n    expand_external_system: bool = True,\n) -&gt; dict | None:\n    \"\"\"Get business object type information. Unfortunately this REST API is\n       pretty much limited. It does not return Field names of external system properties\n       and also does not return property groups defined.\n\n    Args:\n        external_system_id (str): External system Id (such as \"TM6\")\n        type_name (str): Type name of the business object (such as \"SAP Customer\")\n    Returns:\n        dict: Business Object Type information or None if the request fails.\n\n        Example response:\n        {\n            'businessProperties': [\n                {\n                    'attributeID': '14012_29',\n                    'categoryID': '14012',\n                    'name': 'Name',\n                    'type': 'String'\n                },\n                {\n                    'attributeID': '14012_28',\n                    'categoryID': '14012',\n                    'name': 'Customer Number',\n                    'type': 'String'\n                }\n            ]\n            'bwsinfo': {'id': None},\n            'cadxref_doc_info': {'has_relation': False},\n            'categories': [],\n            'claimed_doc_info': {'is_claimed': False},\n            'columns': [{...}, {...}, {...}, {...}],\n            'doctemplates_info': {'isInDocTemplateVolTree': False},\n            'followups': [],\n            'nicknames': {'nickname': '16568'},\n            'properties': {\n                'advanced_versioning': None,\n                'container': False,\n                'container_size': 0,\n                'create_date': '2017-11-23T16:43:34Z',\n                'create_user_id': 1000,\n                'description': '',\n                'description_multilingual': {...},\n                'external_create_date': None,\n                'external_identity': '',\n                ...\n            },\n            'rmiconsdata': {'class_id': 0, 'official': 0, 'show_classify': False, 'show_hold': False, 'show_hold_tab': False, 'show_label_tab': True, 'show_official': False, 'show_xref': False, 'show_xref_tab': False},\n            'sestatus_doc_info': {'is_se_document': False, 'sync_tooltip': ''},\n            'sharing_info': {'is_shared': False, 'sync_state': -1},\n            'showmainruleicon': False,\n            ...\n        }\n    \"\"\"\n\n    query = {\n        \"expand_ext_system\": expand_external_system,\n        \"expand_wksp_type\": expand_workspace_type,\n    }\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    encoded_type_name = type_name.replace(\"/\", \"%2F\")\n\n    request_url = (\n        self.config()[\"externalSystemUrl\"]\n        + \"/\"\n        + external_system_id\n        + \"/botypes/\"\n        + encoded_type_name\n        + \"?{}\".format(encoded_query)\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get business object type -&gt; %s for external system -&gt; %s; calling -&gt; %s\",\n        type_name,\n        external_system_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get business object type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                type_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_business_object_types","title":"<code>get_business_object_types()</code>","text":"<p>Get information for all configured business object types.</p> <p>Returns:     dict: Workspace Types information (for all external systems)           or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_business_object_types(self) -&gt; dict | None:\n    \"\"\"Get information for all configured business object types.\n\n    Args:\n        None\n    Returns:\n        dict: Workspace Types information (for all external systems)\n              or None if the request fails.\n    \"\"\"\n\n    request_url = self.config()[\"businessObjectTypesUrl\"]\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get all business object types; calling -&gt; %s\",\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get business object types; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_business_objects","title":"<code>get_business_objects(external_system_id, type_name, where_clauses=None, limit=None, page=None)</code>","text":"<p>Get all business objects for an external system and a given business object type.</p> <p>Parameters:</p> Name Type Description Default <code>external_system_id</code> <code>str</code> <p>External system Id (such as \"TM6\")</p> required <code>type_name</code> <code>str</code> <p>Type name of the business object (such as \"SAP Customer\")</p> required <code>where_clause</code> <code>dict</code> <p>filter the results based on 1 or kultiple                            where clauses (THE  NAME CONVENTION FOR THE                            FIELDS IS UNCLEAR)</p> required <code>limit</code> <code>int</code> <p>maximum result items</p> <code>None</code> <code>page</code> <code>int</code> <p>page for chunked result lists</p> <code>None</code> <p>Returns:     dict: Business Object information (for all results)           or None if the request fails.</p> <pre><code>Example response (for a Salesforce Account):\n{\n    'links': {'data': {...}},\n    'paging': {'limit': 500, 'page': 1, 'page_total': 1, 'range_max': 15, 'range_min': 1, 'total_count': 15},\n    'results': {\n        'column_descriptions': [\n            {\n                'fieldLabel': 'AccountDetail.AccountID',\n                'fieldName': 'Account.ID',\n                'keyField': 'X',\n                'length': 18,\n                'position': 4\n            },\n            {\n                'fieldLabel': 'AccountName',\n                'fieldName': 'Account.Name',\n                'keyField': ' ',\n                'length': 255,\n                'position': 2\n            },\n            {\n                'fieldLabel': 'AccountNumber',\n                'fieldName': 'Account.AccountNumber',\n                'keyField': ' ',\n                'length': 40,\n                'position': 3\n            },\n            ...\n        ]\n        'max_rows_exceeded': False,\n        'result_rows': [\n            {\n                'AccountDetail.AccountID': '001Dn00000w0bCQIAY',\n                'AccountDetail.AccountName': 'Jet Stream Inc.',\n                'AccountDetail.AccountNumber': '1234567',\n                'AccountDetail.AccountOwner': 'Nick Wheeler',\n                'AccountDetail.AnnualRevenue': '$900001',\n                'AccountDetail.Description': '',\n                'AccountDetail.Employees': '',\n                'AccountDetail.Industry': 'Biotechnology',\n                'AccountDetail.ParentAccount': '',\n                ...\n            },\n            ...\n        ]\n    }\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_business_objects(\n    self,\n    external_system_id: str,\n    type_name: str,\n    where_clauses: dict | None = None,\n    limit: int | None = None,\n    page: int | None = None,\n) -&gt; dict | None:\n    \"\"\"Get all business objects for an external system and a given business object type.\n\n    Args:\n        external_system_id (str): External system Id (such as \"TM6\")\n        type_name (str): Type name of the business object (such as \"SAP Customer\")\n        where_clause (dict, optional): filter the results based on 1 or kultiple\n                                       where clauses (THE  NAME CONVENTION FOR THE\n                                       FIELDS IS UNCLEAR)\n        limit (int, optional): maximum result items\n        page (int, optional): page for chunked result lists\n    Returns:\n        dict: Business Object information (for all results)\n              or None if the request fails.\n\n        Example response (for a Salesforce Account):\n        {\n            'links': {'data': {...}},\n            'paging': {'limit': 500, 'page': 1, 'page_total': 1, 'range_max': 15, 'range_min': 1, 'total_count': 15},\n            'results': {\n                'column_descriptions': [\n                    {\n                        'fieldLabel': 'AccountDetail.AccountID',\n                        'fieldName': 'Account.ID',\n                        'keyField': 'X',\n                        'length': 18,\n                        'position': 4\n                    },\n                    {\n                        'fieldLabel': 'AccountName',\n                        'fieldName': 'Account.Name',\n                        'keyField': ' ',\n                        'length': 255,\n                        'position': 2\n                    },\n                    {\n                        'fieldLabel': 'AccountNumber',\n                        'fieldName': 'Account.AccountNumber',\n                        'keyField': ' ',\n                        'length': 40,\n                        'position': 3\n                    },\n                    ...\n                ]\n                'max_rows_exceeded': False,\n                'result_rows': [\n                    {\n                        'AccountDetail.AccountID': '001Dn00000w0bCQIAY',\n                        'AccountDetail.AccountName': 'Jet Stream Inc.',\n                        'AccountDetail.AccountNumber': '1234567',\n                        'AccountDetail.AccountOwner': 'Nick Wheeler',\n                        'AccountDetail.AnnualRevenue': '$900001',\n                        'AccountDetail.Description': '',\n                        'AccountDetail.Employees': '',\n                        'AccountDetail.Industry': 'Biotechnology',\n                        'AccountDetail.ParentAccount': '',\n                        ...\n                    },\n                    ...\n                ]\n            }\n        }\n    \"\"\"\n\n    query = {\n        \"ext_system_id\": external_system_id,\n        \"bo_type\": type_name,\n    }\n    if limit:\n        query[\"limit\"] = limit\n    if page:\n        query[\"page\"] = page\n    if where_clauses:\n        query.update(\n            {(\"where_\" + key): value for key, value in where_clauses.items()}\n        )\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = self.config()[\"businessObjectsUrl\"] + \"?{}\".format(encoded_query)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get all business objects of type -&gt; %s from external system -&gt; %s; calling -&gt; %s\",\n        type_name,\n        external_system_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get business objects of type -&gt; %s from external system -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                type_name,\n                external_system_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_business_objects_search","title":"<code>get_business_objects_search(external_system_id, type_name)</code>","text":"<p>Get business object type information. Unfortunately this REST API is    pretty much limited. It does not return Field names of external system properties    and also does not return property groups defined.</p> <p>Parameters:</p> Name Type Description Default <code>external_system_id</code> <code>str</code> <p>External system Id (such as \"TM6\")</p> required <code>type_name</code> <code>str</code> <p>Type name of the business object (such as \"SAP Customer\")</p> required <p>Returns:     dict: Business Object Search Form or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_business_objects_search(\n    self,\n    external_system_id: str,\n    type_name: str,\n) -&gt; dict | None:\n    \"\"\"Get business object type information. Unfortunately this REST API is\n       pretty much limited. It does not return Field names of external system properties\n       and also does not return property groups defined.\n\n    Args:\n        external_system_id (str): External system Id (such as \"TM6\")\n        type_name (str): Type name of the business object (such as \"SAP Customer\")\n    Returns:\n        dict: Business Object Search Form or None if the request fails.\n    \"\"\"\n\n    query = {\n        \"ext_system_id\": external_system_id,\n        \"bo_type\": type_name,\n    }\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = self.config()[\"businessObjectsSearchUrl\"] + \"?{}\".format(\n        encoded_query\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get search form for business object type -&gt; %s and external system -&gt; %s; calling -&gt; %s\",\n        type_name,\n        external_system_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get search form for business object type -&gt; %s and external system -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                type_name,\n                external_system_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_document_content","title":"<code>get_document_content(node_id, version_number='')</code>","text":"<p>Get document content from Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the document to download</p> required <code>version_number</code> <code>str</code> <p>version of the document to download.                             If version = \"\" then download the latest                             version.</p> <code>''</code> <p>Returns:     bytes: content of the file or None in case of an error.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_document_content(self, node_id: int, version_number: str = \"\") -&gt; bytes:\n    \"\"\"Get document content from Extended ECM.\n\n    Args:\n        node_id (int): node ID of the document to download\n        version_number (str, optional): version of the document to download.\n                                        If version = \"\" then download the latest\n                                        version.\n    Returns:\n        bytes: content of the file or None in case of an error.\n    \"\"\"\n\n    if not version_number:\n        response = self.get_latest_document_version(node_id)\n        if not response:\n            logger.error(\n                \"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n            )\n        version_number = response[\"data\"][\"version_number\"]\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(node_id)\n        + \"/versions/\"\n        + str(version_number)\n        + \"/content\"\n    )\n    request_header = self.request_download_header()\n\n    logger.info(\n        \"Retrieve document with node ID -&gt; %s and version -&gt; %s; calling -&gt; %s\",\n        str(node_id),\n        str(version_number),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            content = response.content\n            break\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n\n    return content\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_document_templates","title":"<code>get_document_templates(parent_id)</code>","text":"<p>Get all document templates for a given target location.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>int</code> <p>node ID of target location (e.g. a folder)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>response of the REST call (converted to a Python dictionary)</p> <p>Example response:</p> <p>'results': [ {     'container': False,     'hasTemplates': False,     'name': 'Document',     'subtype': 144,     'templates': [         {             'description_multilingual': {...},             'id': 16817,             'isDPWizardAvailable': False,             'mime_type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',             'name': 'Innovate Procurement Contract Template 2022.docx',             'name_multilingual': {...},             'size': 144365,             'sizeformatted': '141 KB',             'type': 144         },         {             ...         }     ] }</p> <p>]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_document_templates(self, parent_id: int):\n    \"\"\"Get all document templates for a given target location.\n\n    Args:\n        parent_id (int): node ID of target location (e.g. a folder)\n\n    Returns:\n        dict: response of the REST call (converted to a Python dictionary)\n\n        Example response:\n        'results': [\n            {\n                'container': False,\n                'hasTemplates': False,\n                'name': 'Document',\n                'subtype': 144,\n                'templates': [\n                    {\n                        'description_multilingual': {...},\n                        'id': 16817,\n                        'isDPWizardAvailable': False,\n                        'mime_type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                        'name': 'Innovate Procurement Contract Template 2022.docx',\n                        'name_multilingual': {...},\n                        'size': 144365,\n                        'sizeformatted': '141 KB',\n                        'type': 144\n                    },\n                    {\n                        ...\n                    }\n                ]\n            }\n        ]\n    \"\"\"\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(parent_id)\n        + \"/doctemplates?subtypes={144}&amp;sidepanel_subtypes={144}\"\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get document templates for target location -&gt; %s (parent ID); calling -&gt; %s\",\n        str(parent_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get document templates for parent folder -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(parent_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_external_system_connection","title":"<code>get_external_system_connection(connection_name, show_error=False)</code>","text":"<p>Get Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).</p> <p>Parameters:</p> Name Type Description Default <code>connection_name</code> <code>str</code> <p>Name of the connection</p> required <code>show_error</code> <code>bool</code> <p>If True, treat as error if connection is not found.</p> <code>False</code> <p>Returns:     dict: External system Details or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_external_system_connection(\n    self, connection_name: str, show_error: bool = False\n) -&gt; dict | None:\n    \"\"\"Get Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n\n    Args:\n        connection_name (str): Name of the connection\n        show_error (bool, optional): If True, treat as error if connection is not found.\n    Returns:\n        dict: External system Details or None if the REST call fails.\n    \"\"\"\n\n    request_url = (\n        self.config()[\"externalSystemUrl\"] + \"/\" + connection_name + \"/config\"\n    )\n    request_header = self.cookie()\n\n    logger.info(\n        \"Get external system connection -&gt; %s; calling -&gt; %s\",\n        connection_name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    connection_name,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\"External system -&gt; %s not found.\", connection_name)\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_group","title":"<code>get_group(name, show_error=False)</code>","text":"<p>Lookup Content Server group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the group</p> required <code>show_error</code> <code>bool</code> <p>if True, treat as error if group is not found</p> <code>False</code> <p>Returns:     dict: Group information or None if the group is not found.     The returned information has a structure like this:     \"data\": [         {             \"id\": 0,             \"name\": \"string\",             ...         }     ]     To access the id of the first group found use \"data\"[\"id\"]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_group(self, name: str, show_error: bool = False) -&gt; dict | None:\n    \"\"\"Lookup Content Server group.\n\n    Args:\n        name (str): name of the group\n        show_error (bool): if True, treat as error if group is not found\n    Returns:\n        dict: Group information or None if the group is not found.\n        The returned information has a structure like this:\n        \"data\": [\n            {\n                \"id\": 0,\n                \"name\": \"string\",\n                ...\n            }\n        ]\n        To access the id of the first group found use [\"data\"][0][\"id\"]\n    \"\"\"\n\n    # Add query parameters (these are NOT passed via JSon body!)\n    # type = 1 ==&gt; Group\n    request_url = self.config()[\"membersUrlv2\"] + \"?where_type=1&amp;query={}\".format(\n        name\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\"Get group with name -&gt; %s; calling -&gt; %s\", name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\"Group -&gt; %s not found.\", name)\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_group_members","title":"<code>get_group_members(group, member_type, limit=100)</code>","text":"<p>Get Content Server group members.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>int</code> <p>ID of the group.</p> required <code>member_type</code> <code>int</code> <p>users = 0, groups = 1</p> required <code>limit</code> <code>int</code> <p>max number of results (internal default is 25)</p> <code>100</code> <p>Returns:     dict: Group members or None if the group members couldn't be found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_group_members(\n    self, group: int, member_type: int, limit: int = 100\n) -&gt; dict | None:\n    \"\"\"Get Content Server group members.\n\n    Args:\n        group (int): ID of the group.\n        member_type (int): users = 0, groups = 1\n        limit (int, optional): max number of results (internal default is 25)\n    Returns:\n        dict: Group members or None if the group members couldn't be found.\n    \"\"\"\n\n    # default limit is 25 which may not be enough for groups with many members\n    # where_type = 1 makes sure we just get groups and not users\n    request_url = (\n        self.config()[\"membersUrlv2\"]\n        + \"/\"\n        + str(group)\n        + \"/members?where_type=\"\n        + str(member_type)\n        + \"&amp;limit=\"\n        + str(limit)\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Getting members of group with ID -&gt; %s; calling -&gt; %s\",\n        str(group),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get members of group -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(group),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_latest_document_version","title":"<code>get_latest_document_version(node_id)</code>","text":"<p>Get latest version of a document node based on the node ID.</p> <p>Returns:     dict: Node information or None if no node with this ID is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_latest_document_version(self, node_id: int) -&gt; dict | None:\n    \"\"\"Get latest version of a document node based on the node ID.\n\n    Args:\n        node_id (int) is the node Id of the node\n    Returns:\n        dict: Node information or None if no node with this ID is found.\n    \"\"\"\n\n    request_url = (\n        self.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/versions/latest\"\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get latest version of document with node ID -&gt; %s; calling -&gt; %s\",\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get latest version of document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node","title":"<code>get_node(node_id, timeout=REQUEST_TIMEOUT)</code>","text":"<p>Get a node based on the node ID.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>timeout for the request in seconds</p> <code>REQUEST_TIMEOUT</code> <p>Returns:     dict: Node information or None if no node with this ID is found.     \"results\": [         {             \"data\": [                 {                     \"columns\": [                         {                         \"data_type\": 0,                         \"key\": \"string\",                         \"name\": \"string\",                         \"sort_key\": \"string\"                         }                     ],                     \"properties\": [                         {                             \"advanced_versioning\": true,                             \"container\": true,                             \"container_size\": 0,                             \"create_date\": \"string\",                             \"create_user_id\": 0,                             \"description\": \"string\",                             \"description_multilingual\": {                                 \"en\": \"string\",                                 \"de\": \"string\"                             },                             \"external_create_date\": \"2019-08-24\",                             \"external_identity\": \"string\",                             \"external_identity_type\": \"string\",                             \"external_modify_date\": \"2019-08-24\",                             \"external_source\": \"string\",                             \"favorite\": true,                             \"guid\": \"string\",                             \"hidden\": true,                             \"icon\": \"string\",                             \"icon_large\": \"string\",                             \"id\": 0,                             \"modify_date\": \"2019-08-24\",                             \"modify_user_id\": 0,                             \"name\": \"string\",                             \"name_multilingual\": {                                 \"en\": \"string\",                                 \"de\": \"string\"                             },                             \"owner\": \"string\",                             \"owner_group_id\": 0,                             \"owner_user_id\": 0,                             \"parent_id\": 0,                             \"reserved\": true,                             \"reserved_date\": \"string\",                             \"reserved_user_id\": 0,                             \"status\": 0,                             \"type\": 0,                             \"type_name\": \"string\",                             \"versionable\": true,                             \"versions_control_advanced\": true,                             \"volume_id\": 0                         }                     ]                 }             ]         }     ]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node(self, node_id: int, timeout: int = REQUEST_TIMEOUT) -&gt; dict | None:\n    \"\"\"Get a node based on the node ID.\n\n    Args:\n        node_id (int) is the node Id of the node\n        timeout (int, optional): timeout for the request in seconds\n    Returns:\n        dict: Node information or None if no node with this ID is found.\n        \"results\": [\n            {\n                \"data\": [\n                    {\n                        \"columns\": [\n                            {\n                            \"data_type\": 0,\n                            \"key\": \"string\",\n                            \"name\": \"string\",\n                            \"sort_key\": \"string\"\n                            }\n                        ],\n                        \"properties\": [\n                            {\n                                \"advanced_versioning\": true,\n                                \"container\": true,\n                                \"container_size\": 0,\n                                \"create_date\": \"string\",\n                                \"create_user_id\": 0,\n                                \"description\": \"string\",\n                                \"description_multilingual\": {\n                                    \"en\": \"string\",\n                                    \"de\": \"string\"\n                                },\n                                \"external_create_date\": \"2019-08-24\",\n                                \"external_identity\": \"string\",\n                                \"external_identity_type\": \"string\",\n                                \"external_modify_date\": \"2019-08-24\",\n                                \"external_source\": \"string\",\n                                \"favorite\": true,\n                                \"guid\": \"string\",\n                                \"hidden\": true,\n                                \"icon\": \"string\",\n                                \"icon_large\": \"string\",\n                                \"id\": 0,\n                                \"modify_date\": \"2019-08-24\",\n                                \"modify_user_id\": 0,\n                                \"name\": \"string\",\n                                \"name_multilingual\": {\n                                    \"en\": \"string\",\n                                    \"de\": \"string\"\n                                },\n                                \"owner\": \"string\",\n                                \"owner_group_id\": 0,\n                                \"owner_user_id\": 0,\n                                \"parent_id\": 0,\n                                \"reserved\": true,\n                                \"reserved_date\": \"string\",\n                                \"reserved_user_id\": 0,\n                                \"status\": 0,\n                                \"type\": 0,\n                                \"type_name\": \"string\",\n                                \"versionable\": true,\n                                \"versions_control_advanced\": true,\n                                \"volume_id\": 0\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    \"\"\"\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\n    request_header = self.request_form_header()\n\n    logger.info(\"Get node with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url)\n\n    retries = 0\n    while True:\n        try:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=timeout,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(node_id),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n        except requests.exceptions.Timeout:\n            if retries &lt;= REQUEST_MAX_RETRIES:\n                logger.warning(\n                    \"Request timed out. Retrying in %s seconds...\",\n                    str(REQUEST_RETRY_DELAY),\n                )\n                retries += 1\n                time.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\n            else:\n                logger.error(\n                    \"Failed to get node with ID -&gt; %s; timeout error\", str(node_id)\n                )\n                # If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\n                logger.warning(\"Turn timeouts off and wait forever...\")\n                timeout = None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_actions","title":"<code>get_node_actions(node_id, filter_actions=None)</code>","text":"<p>Get allowed actions for a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>description</p> required <code>filter_actions</code> <code>list</code> <p>description</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>description</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_actions(self, node_id: int, filter_actions: list = None) -&gt; dict:\n    \"\"\"Get allowed actions for a node.\n\n    Args:\n        node_id (int): _description_\n        filter_actions (list, optional): _description_\n\n    Returns:\n        dict: _description_\n    \"\"\"\n\n    actions_post_body = {\"ids\": [node_id], \"actions\": filter_actions}\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/actions\"\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get actions for node with ID -&gt; %s; calling -&gt; %s\",\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=actions_post_body,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get actions for node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                node_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_by_parent_and_name","title":"<code>get_node_by_parent_and_name(parent_id, name, fields='properties', show_error=False)</code>","text":"<p>Get a node based on the parent ID and name. This method does basically    a query with \"where_name\" and the \"result\" is a list.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>str</code> <p>which fields to retrieve. This can have a big impact on performance!</p> <code>'properties'</code> <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:     dict: Node information or None if no node with this name is found in parent.                 Access to node ID with: response\"results\"\"data\"[\"id\"]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_by_parent_and_name(\n    self,\n    parent_id: int,\n    name: str,\n    fields: str = \"properties\",\n    show_error: bool = False,\n) -&gt; dict | None:\n    \"\"\"Get a node based on the parent ID and name. This method does basically\n       a query with \"where_name\" and the \"result\" is a list.\n\n    Args:\n        parent_id (int) is the node Id of the parent node\n        name (str) is the name of the node to get\n        fields (str, optional): which fields to retrieve. This can have a big impact on performance!\n        show_error (bool, optional): treat as error if node is not found\n    Returns:\n        dict: Node information or None if no node with this name is found in parent.\n                    Access to node ID with: response[\"results\"][0][\"data\"][\"properties\"][\"id\"]\n    \"\"\"\n\n    # Add query parameters (these are NOT passed via JSon body!)\n    query = {\"where_name\": name}\n    if fields:\n        query[\"fields\"] = fields\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(parent_id)\n        + \"/nodes?{}\".format(encoded_query)\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get node with name -&gt; %s and parent ID -&gt; %s; calling -&gt; %s\",\n        name,\n        str(parent_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get node with name -&gt; %s and parent ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    str(parent_id),\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\n                    \"Node with name -&gt; %s and parent ID -&gt; %s not found.\",\n                    name,\n                    str(parent_id),\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_by_volume_and_path","title":"<code>get_node_by_volume_and_path(volume_type, path=None)</code>","text":"<p>Get a node based on the volume and path (list of container items).</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>int</code> <p>Volume type ID (default is 141 = Enterprise Workspace) \"Records Management\"                = 550 \"Content Server Document Templates\" = 20541 \"O365 Office Online Volume\"         = 1296 \"Categories Volume\"                 = 133 \"Perspectives\"                      = 908 \"Perspective Assets\"                = 954 \"Facets Volume\"                     = 901 \"Transport Warehouse\"               = 525 \"Transport Warehouse Workbench\"     = 528 \"Transport Warehouse Package\"       = 531 \"Event Action Center Configuration\" = 898 \"Classification Volume\"             = 198 \"Support Asset Volume\"              = 1309 \"Physical Objects Workspace\"        = 413 \"Extended ECM\"                      = 882 \"Enterprise Workspace\"              = 141 \"Personal Workspace\"                = 142 \"Business Workspaces\"               = 862</p> required <code>path</code> <code>list</code> <p>list of container items (top down), last item is name of to be retrieved item.          If path is empty the node of the volume is returned.</p> <code>None</code> <p>Returns:     dict: Node information or None if no node with this path is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_by_volume_and_path(\n    self, volume_type: int, path: list | None = None\n) -&gt; dict | None:\n    \"\"\"Get a node based on the volume and path (list of container items).\n\n    Args:\n        volume_type (int): Volume type ID (default is 141 = Enterprise Workspace)\n            \"Records Management\"                = 550\n            \"Content Server Document Templates\" = 20541\n            \"O365 Office Online Volume\"         = 1296\n            \"Categories Volume\"                 = 133\n            \"Perspectives\"                      = 908\n            \"Perspective Assets\"                = 954\n            \"Facets Volume\"                     = 901\n            \"Transport Warehouse\"               = 525\n            \"Transport Warehouse Workbench\"     = 528\n            \"Transport Warehouse Package\"       = 531\n            \"Event Action Center Configuration\" = 898\n            \"Classification Volume\"             = 198\n            \"Support Asset Volume\"              = 1309\n            \"Physical Objects Workspace\"        = 413\n            \"Extended ECM\"                      = 882\n            \"Enterprise Workspace\"              = 141\n            \"Personal Workspace\"                = 142\n            \"Business Workspaces\"               = 862\n        path (list): list of container items (top down), last item is name of to be retrieved item.\n                     If path is empty the node of the volume is returned.\n    Returns:\n        dict: Node information or None if no node with this path is found.\n    \"\"\"\n\n    # If path is not given we use empty list to make the for loop below working in this case as well\n    if path is None:\n        path = []\n\n    # Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\n    response = self.get_volume(volume_type)\n    if not response:\n        logger.error(\"Volume type -&gt; %s not found!\", str(volume_type))\n        return None\n\n    volume_id = self.get_result_value(response, \"id\")\n    logger.info(\n        \"Volume type -&gt; %s has node ID -&gt; %s\", str(volume_type), str(volume_id)\n    )\n\n    current_item_id = volume_id\n\n    # in case the path is an empty list\n    # we will have the node of the volume:\n    node = self.get_node(current_item_id)\n\n    for path_element in path:\n        node = self.get_node_by_parent_and_name(current_item_id, path_element)\n        path_item_id = self.get_result_value(node, \"id\")\n        if not path_item_id:\n            logger.error(\n                \"Cannot find path element -&gt; %s in container with ID -&gt; %s.\",\n                path_element,\n                str(current_item_id),\n            )\n            return None\n        current_item_id = path_item_id\n        logger.debug(\"Traversing path element with ID -&gt; %s\", str(current_item_id))\n\n    return node\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_by_workspace_and_path","title":"<code>get_node_by_workspace_and_path(workspace_id, path, show_error=False)</code>","text":"<p>Get a node based on the workspace ID (= node ID) and path (list of folder names).</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>node ID of the workspace</p> required <code>path</code> <code>list</code> <p>list of container items (top down), last item is name of to be retrieved item.          If path is empty the node of the volume is returned.</p> required <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:     dict: Node information or None if no node with this path is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_by_workspace_and_path(\n    self, workspace_id: int, path: list, show_error: bool = False\n) -&gt; dict | None:\n    \"\"\"Get a node based on the workspace ID (= node ID) and path (list of folder names).\n\n    Args:\n        workspace_id (int): node ID of the workspace\n        path (list): list of container items (top down), last item is name of to be retrieved item.\n                     If path is empty the node of the volume is returned.\n        show_error (bool, optional): treat as error if node is not found\n    Returns:\n        dict: Node information or None if no node with this path is found.\n    \"\"\"\n\n    current_item_id = workspace_id\n\n    # in case the path is an empty list\n    # we will have the node of the workspace:\n    node = self.get_node(current_item_id)\n\n    for path_element in path:\n        node = self.get_node_by_parent_and_name(current_item_id, path_element)\n        current_item_id = self.get_result_value(node, \"id\")\n        if not current_item_id:\n            if show_error:\n                logger.error(\"Cannot find path element -&gt; %s!\", path_element)\n            else:\n                logger.info(\"Cannot find path element -&gt; %s.\", path_element)\n            return None\n        logger.debug(\n            \"Traversing path element -&gt; %s (%s)\", path_element, str(current_item_id)\n        )\n\n    return node\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_categories","title":"<code>get_node_categories(node_id, metadata=True)</code>","text":"<p>Get categories assigned to a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node to get the categories for.</p> required <code>metadata</code> <code>bool</code> <p>expand the attribute definitions of the category. Default is True.</p> <code>True</code> <p>Returns:     dict: category response or None if the call to the REST API fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_categories(self, node_id: int, metadata: bool = True):\n    \"\"\"Get categories assigned to a node.\n\n    Args:\n        node_id (int): ID of the node to get the categories for.\n        metadata (bool, optional): expand the attribute definitions of the category. Default is True.\n    Returns:\n        dict: category response or None if the call to the REST API fails.\n    \"\"\"\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\n    if metadata:\n        request_url += \"?metadata\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get categories of node with ID -&gt; %s; calling -&gt; %s\",\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get categories for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_category","title":"<code>get_node_category(node_id, category_id, metadata=True)</code>","text":"<p>Get a specific category assigned to a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node to get the categories for.</p> required <code>category_id</code> <code>int</code> <p>ID of the category definition ID (in category volume)</p> required <code>metadata</code> <code>bool</code> <p>expand the attribute definitions of the category. Default is True</p> <code>True</code> <p>Returns:     dict: category response or None if the call to the REST API fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_category(self, node_id: int, category_id: int, metadata: bool = True):\n    \"\"\"Get a specific category assigned to a node.\n\n    Args:\n        node_id (int): ID of the node to get the categories for.\n        category_id (int): ID of the category definition ID (in category volume)\n        metadata (bool, optional): expand the attribute definitions of the category. Default is True\n    Returns:\n        dict: category response or None if the call to the REST API fails.\n    \"\"\"\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(node_id)\n        + \"/categories/\"\n        + str(category_id)\n    )\n    if metadata:\n        request_url += \"?metadata\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get category with ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\n        str(category_id),\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get category with ID -&gt; %s for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(category_id),\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_category_definition","title":"<code>get_node_category_definition(node_id, category_name)</code>","text":"<p>Get category definition (category id and attribute IDs and types)</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node to read the category definition from            (e.g. a workspace template or a document template or a target folder)            This should NOT be the category definition object!</p> required <code>category_name</code> <code>str</code> <p>name of the category</p> required <p>Returns:     int: category ID     dict: keys are the attribute names. values are sub-dictionaries with the id and type of the attribute.</p> <pre><code>Example response:\n{\n    'Status': {\n        'id': '12532_2',\n        'type': 'String'\n    },\n    'Legal Approval': {\n        'id': '12532_3',\n        'type': 'user'\n    },\n    ...\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_category_definition(\n    self, node_id: int, category_name: str\n) -&gt; tuple[int, dict]:\n    \"\"\"Get category definition (category id and attribute IDs and types)\n\n    Args:\n        node_id (int): node to read the category definition from\n                       (e.g. a workspace template or a document template or a target folder)\n                       This should NOT be the category definition object!\n        category_name (str): name of the category\n    Returns:\n        int: category ID\n        dict: keys are the attribute names. values are sub-dictionaries with the id and type of the attribute.\n\n        Example response:\n        {\n            'Status': {\n                'id': '12532_2',\n                'type': 'String'\n            },\n            'Legal Approval': {\n                'id': '12532_3',\n                'type': 'user'\n            },\n            ...\n        }\n    \"\"\"\n\n    attribute_definitions = {}\n    cat_id = -1\n\n    response = self.get_node_categories(node_id)\n    if response and response[\"results\"]:\n        for categories in response[\"results\"]:\n            keys = categories[\"metadata\"][\"categories\"].keys()\n            cat_id = next((key for key in keys if \"_\" not in key), -1)\n            cat_name = categories[\"metadata\"][\"categories\"][cat_id][\"name\"]\n            if cat_name != category_name:\n                continue\n            for att_id in categories[\"metadata\"][\"categories\"]:\n                if not \"_\" in att_id:\n                    continue\n                att_name = categories[\"metadata\"][\"categories\"][att_id][\"name\"]\n                if categories[\"metadata\"][\"categories\"][att_id][\"persona\"]:\n                    att_type = categories[\"metadata\"][\"categories\"][att_id][\n                        \"persona\"\n                    ]\n                else:\n                    att_type = categories[\"metadata\"][\"categories\"][att_id][\n                        \"type_name\"\n                    ]\n                attribute_definitions[att_name] = {\"id\": att_id, \"type\": att_type}\n    return cat_id, attribute_definitions\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_category_ids","title":"<code>get_node_category_ids(node_id)</code>","text":"<p>Get list of all category definition IDs that are assign to the node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node to get the categories for.</p> required <p>Returns:     list: list of category IDs (all categories assigned to the node)</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_category_ids(self, node_id: int) -&gt; list:\n    \"\"\"Get list of all category definition IDs that are assign to the node.\n\n    Args:\n        node_id (int): ID of the node to get the categories for.\n    Returns:\n        list: list of category IDs (all categories assigned to the node)\n    \"\"\"\n\n    categories = self.get_node_categories(node_id)\n    if not categories or not categories[\"results\"]:\n        return None\n\n    category_id_list = []\n\n    for category in categories[\"results\"]:\n        category_id_list += [\n            int(i) for i in category[\"metadata_order\"][\"categories\"]\n        ]\n\n    return category_id_list\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_from_nickname","title":"<code>get_node_from_nickname(nickname, show_error=False)</code>","text":"<p>Get a node based on the nickname.</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>str</code> <p>Nickname of the node.</p> required <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:     dict: Node information or None if no node with this nickname is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_from_nickname(\n    self, nickname: str, show_error: bool = False\n) -&gt; dict | None:\n    \"\"\"Get a node based on the nickname.\n\n    Args:\n        nickname (str): Nickname of the node.\n        show_error (bool): treat as error if node is not found\n    Returns:\n        dict: Node information or None if no node with this nickname is found.\n    \"\"\"\n\n    request_url = self.config()[\"nicknameUrl\"] + \"/\" + nickname + \"/nodes\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get node with nickname -&gt; %s; calling -&gt; %s\", nickname, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get node with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    nickname,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\"Node with nickname -&gt; %s not found.\", nickname)\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_records_management_codes","title":"<code>get_records_management_codes()</code>","text":"<p>Get Records Management Codes. These are the most basic data types of    the Records Management configuration and required to create RSIs and    other higher-level Records Management configurations</p> <p>Returns:     dict: RM codes or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_records_management_codes(self) -&gt; dict | None:\n    \"\"\"Get Records Management Codes. These are the most basic data types of\n       the Records Management configuration and required to create RSIs and\n       other higher-level Records Management configurations\n\n    Args:\n        None\n    Returns:\n        dict: RM codes or None if the request fails.\n    \"\"\"\n\n    request_url = self.config()[\"recordsManagementUrlv2\"] + \"/rmcodes\"\n    request_header = self.request_form_header()\n\n    logger.info(\"Get list of Records Management codes; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            rm_codes_dict = self.parse_request_response(response)\n            return rm_codes_dict[\"results\"][\"data\"]\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of Records Management codes; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_records_management_holds","title":"<code>get_records_management_holds()</code>","text":"<p>Get a list of all Records Management Holds in the system. Even though there are folders in the holds management area in RM these are not real folders - they cannot be retrieved with get_node_by_parent_and_name() thus we need this method to get them all.</p> <p>Returns:     dict: Response with list of holds:     \"results\": {         \"data\": {             \"holds\": [                 {                     \"HoldID\": 0,                     \"HoldName\": \"string\",                     \"ActiveHold\": 0,                     \"OBJECT\": 0,                     \"ApplyPatron\": \"string\",                     \"DateApplied\": \"string\",                     \"HoldComment\": \"string\",                     \"HoldType\": \"string\",                     \"DateToRemove\": \"string\",                     \"DateRemoved\": \"string\",                     \"RemovalPatron\": \"string\",                     \"RemovalComment\": \"string\",                     \"EditDate\": \"string\",                     \"EditPatron\": \"string\",                     \"AlternateHoldID\": 0,                     \"ParentID\": 0                 }             ]         }     }</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_records_management_holds(self) -&gt; dict | None:\n    \"\"\"Get a list of all Records Management Holds in the system. Even though there are folders\n    in the holds management area in RM these are not real folders - they cannot be retrieved\n    with get_node_by_parent_and_name() thus we need this method to get them all.\n\n    Args:\n        None\n    Returns:\n        dict: Response with list of holds:\n        \"results\": {\n            \"data\": {\n                \"holds\": [\n                    {\n                        \"HoldID\": 0,\n                        \"HoldName\": \"string\",\n                        \"ActiveHold\": 0,\n                        \"OBJECT\": 0,\n                        \"ApplyPatron\": \"string\",\n                        \"DateApplied\": \"string\",\n                        \"HoldComment\": \"string\",\n                        \"HoldType\": \"string\",\n                        \"DateToRemove\": \"string\",\n                        \"DateRemoved\": \"string\",\n                        \"RemovalPatron\": \"string\",\n                        \"RemovalComment\": \"string\",\n                        \"EditDate\": \"string\",\n                        \"EditPatron\": \"string\",\n                        \"AlternateHoldID\": 0,\n                        \"ParentID\": 0\n                    }\n                ]\n            }\n        }\n    \"\"\"\n\n    request_url = self.config()[\"holdsUrlv2\"]\n\n    request_header = self.request_form_header()\n\n    logger.info(\"Get list of Records Management Holds; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of Records Management Holds; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_records_management_rsis","title":"<code>get_records_management_rsis(limit=100)</code>","text":"<p>Get all Records management RSIs togther with their RSI Schedules.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>max elements to return (default = 100)</p> <code>100</code> <p>Returns:     list: list of Records Management RSIs or None if the request fails.     Each RSI list element is a dict with this structure:     {         \"RSIID\": 0,         \"RSI\": \"string\",         \"Title\": \"string\",         \"Subject\": \"string\",         \"Description\": \"string\",         \"CreateDate\": \"string\",         \"RSIStatus\": \"string\",         \"StatusDate\": \"string\",         \"DiscontFlag\": 0,         \"DiscontDate\": \"string\",         \"DiscontComment\": \"string\",         \"Active\": 0,         \"DispControl\": 0,         \"RSIScheduleID\": 0,         \"RetStage\": \"string\",         \"RecordType\": 0,         \"EventType\": 0,         \"RSIRuleCode\": \"string\",         \"DateToUse\": \"string\",         \"YearEndMonth\": 0,         \"YearEndDay\": 0,         \"RetYears\": 0,         \"RetMonths\": 0,         \"RetDays\": 0,         \"RetIntervals\": 0,         \"EventRuleDate\": \"string\",         \"EventRule\": \"string\",         \"EventComment\": \"string\",         \"StageAction\": \"string\",         \"FixedRet\": 0,         \"ActionCode\": \"string\",         \"ActionDescription\": \"string\",         \"Disposition\": \"string\",         \"ApprovalFlag\": 0,         \"MaximumRet\": 0,         \"ObjectType\": \"LIV\"     }</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_records_management_rsis(self, limit: int = 100) -&gt; list | None:\n    \"\"\"Get all Records management RSIs togther with their RSI Schedules.\n\n    Args:\n        limit (int, optional): max elements to return (default = 100)\n    Returns:\n        list: list of Records Management RSIs or None if the request fails.\n        Each RSI list element is a dict with this structure:\n        {\n            \"RSIID\": 0,\n            \"RSI\": \"string\",\n            \"Title\": \"string\",\n            \"Subject\": \"string\",\n            \"Description\": \"string\",\n            \"CreateDate\": \"string\",\n            \"RSIStatus\": \"string\",\n            \"StatusDate\": \"string\",\n            \"DiscontFlag\": 0,\n            \"DiscontDate\": \"string\",\n            \"DiscontComment\": \"string\",\n            \"Active\": 0,\n            \"DispControl\": 0,\n            \"RSIScheduleID\": 0,\n            \"RetStage\": \"string\",\n            \"RecordType\": 0,\n            \"EventType\": 0,\n            \"RSIRuleCode\": \"string\",\n            \"DateToUse\": \"string\",\n            \"YearEndMonth\": 0,\n            \"YearEndDay\": 0,\n            \"RetYears\": 0,\n            \"RetMonths\": 0,\n            \"RetDays\": 0,\n            \"RetIntervals\": 0,\n            \"EventRuleDate\": \"string\",\n            \"EventRule\": \"string\",\n            \"EventComment\": \"string\",\n            \"StageAction\": \"string\",\n            \"FixedRet\": 0,\n            \"ActionCode\": \"string\",\n            \"ActionDescription\": \"string\",\n            \"Disposition\": \"string\",\n            \"ApprovalFlag\": 0,\n            \"MaximumRet\": 0,\n            \"ObjectType\": \"LIV\"\n        }\n    \"\"\"\n\n    request_url = self.config()[\"rsisUrl\"] + \"?limit=\" + str(limit)\n    request_header = self.request_form_header()\n\n    logger.info(\"Get list of Records Management RSIs; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            rsi_dict = self.parse_request_response(response)\n            return rsi_dict[\"results\"][\"data\"][\"rsis\"]\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get list of Records Management RSIs; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_result_value","title":"<code>get_result_value(response, key, index=0, property_name='properties')</code>","text":"<p>Read an item value from the REST API response. This is considering    the most typical structures delivered by V2 REST API of Extended ECM.    See developer.opentext.com for more details.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST API response object</p> required <code>key</code> <code>str</code> <p>key to find (e.g. \"id\", \"name\", ...)</p> required <code>index</code> <code>int</code> <p>In case a list of results is delivered the index                    to use (1st element has index  0). Defaults to 0.</p> <code>0</code> <code>property_name</code> <code>str</code> <p>name of the sub dictionary holding the actual values.                            Default is \"properties\".</p> <code>'properties'</code> <p>Returns:     str: value of the item with the given key for None if no value is found for the given key.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_result_value(\n    self,\n    response: dict,\n    key: str,\n    index: int = 0,\n    property_name: str = \"properties\",\n) -&gt; str | None:\n    \"\"\"Read an item value from the REST API response. This is considering\n       the most typical structures delivered by V2 REST API of Extended ECM.\n       See developer.opentext.com for more details.\n\n    Args:\n        response (dict): REST API response object\n        key (str): key to find (e.g. \"id\", \"name\", ...)\n        index (int, optional): In case a list of results is delivered the index\n                               to use (1st element has index  0). Defaults to 0.\n        property_name (str, optional): name of the sub dictionary holding the actual values.\n                                       Default is \"properties\".\n    Returns:\n        str: value of the item with the given key for None if no value is found for the given key.\n    \"\"\"\n\n    # First do some sanity checks:\n    if not response:\n        logger.info(\"Empty REST response - returning None\")\n        return None\n    if not \"results\" in response:\n        logger.error(\"No 'results' key in REST response - returning None\")\n        return None\n\n    results = response[\"results\"]\n    if not results:\n        logger.info(\"No results found!\")\n        return None\n\n    # check if results is a list or a dict (both is possible - dependent on the actual REST API):\n    if isinstance(results, dict):\n        # result is a dict - we don't need index value\n\n        # this is a special treatment for the businessworkspaces REST API - it returns\n        # for \"Create business workspace\" the ID directly in the results dict (without data substructure)\n        if key in results:\n            return results[key]\n        data = results[\"data\"]\n        if isinstance(data, dict):\n            # data is a dict - we don't need index value:\n            properties = data[property_name]\n        elif isinstance(data, list):\n            # data is a list - this has typically just one item, so we use 0 as index\n            properties = data[0][property_name]\n        else:\n            logger.error(\n                \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n            )\n            return None\n        logger.debug(\"Properties of results (dict) -&gt; %s\", str(properties))\n        # For nearly all OTCS REST Calls perperties is a dict:\n        if isinstance(properties, dict):\n            if not key in properties:\n                logger.error(\"Key -&gt; %s is not in result properties!\", key)\n                return None\n            return properties[key]\n        # but there are some strange ones that have other names for\n        # properties and may use a list - see e.g. /v2/holds\n        elif isinstance(properties, list):\n            if index &gt; len(properties) - 1:\n                logger.error(\n                    \"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\n                    str(index),\n                    str(len(properties)),\n                )\n                return None\n            return properties[index][key]\n        else:\n            logger.error(\n                \"Properties needs to be a list or dict but it is -&gt; %s\",\n                str(type(properties)),\n            )\n            return False\n    elif isinstance(results, list):\n        # result is a list - we need a valid index:\n        if index &gt; len(results) - 1:\n            logger.error(\n                \"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\n                str(index),\n                str(len(results)),\n            )\n            return None\n        data = results[index][\"data\"]\n        if isinstance(data, dict):\n            # data is a dict - we don't need index value:\n            properties = data[property_name]\n        elif isinstance(data, list):\n            # data is a list - this has typically just one item, so we use 0 as index\n            properties = data[0][property_name]\n        else:\n            logger.error(\n                \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n            )\n            return None\n        logger.debug(\n            \"Properties of results (list, index -&gt; %s) -&gt; %s\",\n            str(index),\n            properties,\n        )\n        if not key in properties:\n            logger.error(\"Key -&gt; %s is not in result properties!\", key)\n            return None\n        return properties[key]\n    else:\n        logger.error(\n            \"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_server_info","title":"<code>get_server_info()</code>","text":"<p>Get Content Server information (server info)</p> <p>Returns:     dict: server information or None if the call fails</p> <pre><code>Example response:\n{\n    'mobile': {\n        'cs_viewer_support': False,\n        'offline_use': True\n    },\n    'server': {\n        'advanced_versioning': True,\n        'character_encoding': 1,\n        'current_date': '2023-09-05T17:09:41',\n        'current_locale_suffix': '_en_US',\n        'domain_access_enabled': False,\n        'enhanced_advanced_versioning': False,\n        'force_download_for_mime_types': [...],\n        'language_code': 'USA',\n        'languages': [...],\n        'metadata_languages: [...],\n        'url': 'https://otcs.dev.idea-te.eimdemo.com/cs/cs'\n        'version': '23.3'\n        ...\n    },\n    'sessions': {\n        'enabled': True,\n        'expire_after_last_login': False,\n        'expire_after_last_request': True,\n        'logout_url': '?func=ll.DoLogout&amp;secureRequestToken=LUAQSY%2BJs4KnlwoVgxLtxQFYrov2XefJQM9ShyhOK93Mzp3ymCxX6IGMTtUgNvTH7AYVt%2BbWLEw%3D',\n        'session_inactivity': 7020000,\n        'session_reaction_time': 180000,\n        'session_timeout': 7200000\n    },\n    'viewer': {\n        'content_suite': {...}\n    }\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_server_info(self) -&gt; dict | None:\n    \"\"\"Get Content Server information (server info)\n\n    Args:\n        None\n    Returns:\n        dict: server information or None if the call fails\n\n        Example response:\n        {\n            'mobile': {\n                'cs_viewer_support': False,\n                'offline_use': True\n            },\n            'server': {\n                'advanced_versioning': True,\n                'character_encoding': 1,\n                'current_date': '2023-09-05T17:09:41',\n                'current_locale_suffix': '_en_US',\n                'domain_access_enabled': False,\n                'enhanced_advanced_versioning': False,\n                'force_download_for_mime_types': [...],\n                'language_code': 'USA',\n                'languages': [...],\n                'metadata_languages: [...],\n                'url': 'https://otcs.dev.idea-te.eimdemo.com/cs/cs'\n                'version': '23.3'\n                ...\n            },\n            'sessions': {\n                'enabled': True,\n                'expire_after_last_login': False,\n                'expire_after_last_request': True,\n                'logout_url': '?func=ll.DoLogout&amp;secureRequestToken=LUAQSY%2BJs4KnlwoVgxLtxQFYrov2XefJQM9ShyhOK93Mzp3ymCxX6IGMTtUgNvTH7AYVt%2BbWLEw%3D',\n                'session_inactivity': 7020000,\n                'session_reaction_time': 180000,\n                'session_timeout': 7200000\n            },\n            'viewer': {\n                'content_suite': {...}\n            }\n        }\n    \"\"\"\n\n    request_url = self.config()[\"serverInfoUrl\"]\n    request_header = self._cookie\n\n    logger.info(\n        \"Retrieve Extended ECM server information; calling -&gt; %s\", request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to retrieve Extended ECM server information; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_server_version","title":"<code>get_server_version()</code>","text":"<p>Get Content Server version</p> <p>Returns:     str: server version number like 23.4</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_server_version(self) -&gt; str | None:\n    \"\"\"Get Content Server version\n\n    Args:\n        None\n    Returns:\n        str: server version number like 23.4\n    \"\"\"\n\n    response = self.get_server_info()\n    if not response:\n        return None\n\n    server_info = response.get(\"server\")\n    if not server_info:\n        return None\n\n    return server_info.get(\"version\")\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_subnodes","title":"<code>get_subnodes(parent_node_id, filter_node_types=-2, filter_name='', show_hidden=False, limit=100, page=1, fields='properties')</code>","text":"<p>Get a subnodes of a parent node ID.</p> <p>Parameters:</p> Name Type Description Default <code>filter_node_types</code> <code>int</code> <p>-1 get all containers -2 get all searchable objects (default) -3 get all non-containers</p> <code>-2</code> <code>filter_name</code> <code>str</code> <p>filter nodes for specific name (dfault = no filter)</p> <code>''</code> <code>show_hidden</code> <code>bool</code> <p>list also hidden items (default = False)</p> <code>False</code> <code>limit</code> <code>int</code> <p>maximum number of results (default = 100)</p> <code>100</code> <code>page</code> <code>int</code> <p>number of result page (default = 1 = 1st page)</p> <code>1</code> <code>fields</code> <code>str</code> <p>which fields to retrieve. This can have a big impact on performance!</p> <code>'properties'</code> <p>Returns:     dict: Subnodes information or None if no node with this parent ID is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_subnodes(\n    self,\n    parent_node_id: int,\n    filter_node_types: int = -2,\n    filter_name: str = \"\",\n    show_hidden: bool = False,\n    limit: int = 100,\n    page: int = 1,\n    fields: str = \"properties\",  # per default we just get the most important information\n) -&gt; dict | None:\n    \"\"\"Get a subnodes of a parent node ID.\n\n    Args:\n        parent_node_id (int) is the node Id of the node\n        filter_node_types (int, optional):\n            -1 get all containers\n            -2 get all searchable objects (default)\n            -3 get all non-containers\n        filter_name (str, optional): filter nodes for specific name (dfault = no filter)\n        show_hidden (bool, optional): list also hidden items (default = False)\n        limit (int, optional): maximum number of results (default = 100)\n        page (int, optional): number of result page (default = 1 = 1st page)\n        fields (str): which fields to retrieve. This can have a big impact on performance!\n    Returns:\n        dict: Subnodes information or None if no node with this parent ID is found.\n    \"\"\"\n\n    # Add query parameters (these are NOT passed via JSon body!)\n    query = {\n        \"where_type\": filter_node_types,\n        \"limit\": limit,\n    }\n    if filter_name:\n        query[\"where_name\"] = filter_name\n    if show_hidden:\n        query[\"show_hidden\"] = show_hidden\n    if page &gt; 1:\n        query[\"page\"] = page\n    if fields:\n        query[\"fields\"] = fields\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(parent_node_id)\n        + \"/nodes\"\n        + \"?{}\".format(encoded_query)\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get subnodes of parent node with ID -&gt; %s; calling -&gt; %s\",\n        str(parent_node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get subnodes for parent node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                parent_node_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_unique_names","title":"<code>get_unique_names(names, subtype=None)</code>","text":"<p>Get definition information for Unique Names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>list</code> <p>list of unique names to lookup.</p> required <code>subtype</code> <code>int</code> <p>filter unique names for those pointing to a specific subtype</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Unique name definition information or None if REST call fails.</p> <code>dict | None</code> <p>Example response:</p> <code>dict | None</code> <p>{ 'links': {'data': {...}}, 'results': [     {         'NodeId': 13653,         'NodeName': 'Functional Location',         'UniqueName': 'ot_templ_func_location'     },     {         'NodeId': 2424,         'NodeName': 'Content Server Document Templates',         'UniqueName': 'Document Templates'     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_unique_names(self, names: list, subtype: int | None = None) -&gt; dict | None:\n    \"\"\"Get definition information for Unique Names.\n\n    Args:\n        names (list): list of unique names to lookup.\n        subtype (int): filter unique names for those pointing to a specific subtype\n\n    Returns:\n        dict | None: Unique name definition information or None if REST call fails.\n\n        Example response:\n        {\n            'links': {'data': {...}},\n            'results': [\n                {\n                    'NodeId': 13653,\n                    'NodeName': 'Functional Location',\n                    'UniqueName': 'ot_templ_func_location'\n                },\n                {\n                    'NodeId': 2424,\n                    'NodeName': 'Content Server Document Templates',\n                    'UniqueName': 'Document Templates'\n                }\n            ]\n        }\n    \"\"\"\n\n    if not names:\n        logger.error(\"Missing Unique Names!\")\n        return None\n\n    # Add query parameters (these are NOT passed via JSon body!)\n    query = {\"where_names\": \"{\" + \", \".join(names) + \"}\"}\n    if subtype:\n        query[\"where_subtype\"] = subtype\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = self.config()[\"uniqueNamesUrl\"] + \"?{}\".format(encoded_query)\n    request_header = self.request_form_header()\n\n    if subtype:\n        logger.info(\n            \"Get unique names -&gt; %s with subtype -&gt; %s; calling -&gt; %s\",\n            str(names),\n            str(subtype),\n            request_url,\n        )\n    else:\n        logger.info(\n            \"Get unique names -&gt; %s; calling -&gt; %s\",\n            str(names),\n            request_url,\n        )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if subtype:\n                logger.warning(\n                    \"Failed to get unique names -&gt; %s of subtype -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(names),\n                    str(subtype),\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.warning(\n                    \"Failed to get unique names -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(names),\n                    response.status_code,\n                    response.text,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_user","title":"<code>get_user(name, show_error=False)</code>","text":"<p>Lookup Extended ECM user based on the name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the user</p> required <code>show_error</code> <code>bool</code> <p>treat as error if user is not found</p> <code>False</code> <p>Returns:     dict: User information or None if the user is not found.     The returned information has a structure like this:</p> <pre><code>{\n    'collection':\n    {\n        'paging': {...},\n        'sorting': {...}\n    },\n    'links':\n    {\n        'data': {...}\n    },\n    'results': [\n        {\n            'data':\n            {\n                {\n                    'birth_date': None,\n                    'business_email': 'pramos@M365x61936377.onmicrosoft.com',\n                    'business_fax': None,\n                    'business_phone': None,\n                    'cell_phone': None,\n                    'deleted': False,\n                    'display_language': None,\n                    'first_name': 'Peter',\n                    'gender': None,\n                    'group_id': 8006,\n                    'home_address_1': None,\n                    'home_address_2': None,\n                    'home_fax': None,\n                    'home_phone': None,\n                    'id': 8123,\n                    'initials': None,\n                    'last_name': 'Ramos',\n                    'middle_name': None,\n                    'name': 'pramos',\n                    'name_formatted': 'Peter Ramos',\n                    ...\n                    'photo_id': 13981,\n                    'photo_url': 'api/v1/members/8123/photo?v=13981.1'\n                    ...\n                    'type'; 0,\n                    'type_name': 'User'\n                    }\n            }\n        }\n    ]\n}\nTo access the (login) name of the first user found use [\"results\"][0][\"data\"][\"properties\"][\"name\"].\nIt is easier to use the method get_result_value(response, \"name\", 0)\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_user(self, name: str, show_error: bool = False) -&gt; dict | None:\n    \"\"\"Lookup Extended ECM user based on the name.\n\n    Args:\n        name (str): name of the user\n        show_error (bool): treat as error if user is not found\n    Returns:\n        dict: User information or None if the user is not found.\n        The returned information has a structure like this:\n\n        {\n            'collection':\n            {\n                'paging': {...},\n                'sorting': {...}\n            },\n            'links':\n            {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data':\n                    {\n                        {\n                            'birth_date': None,\n                            'business_email': 'pramos@M365x61936377.onmicrosoft.com',\n                            'business_fax': None,\n                            'business_phone': None,\n                            'cell_phone': None,\n                            'deleted': False,\n                            'display_language': None,\n                            'first_name': 'Peter',\n                            'gender': None,\n                            'group_id': 8006,\n                            'home_address_1': None,\n                            'home_address_2': None,\n                            'home_fax': None,\n                            'home_phone': None,\n                            'id': 8123,\n                            'initials': None,\n                            'last_name': 'Ramos',\n                            'middle_name': None,\n                            'name': 'pramos',\n                            'name_formatted': 'Peter Ramos',\n                            ...\n                            'photo_id': 13981,\n                            'photo_url': 'api/v1/members/8123/photo?v=13981.1'\n                            ...\n                            'type'; 0,\n                            'type_name': 'User'\n                            }\n                    }\n                }\n            ]\n        }\n        To access the (login) name of the first user found use [\"results\"][0][\"data\"][\"properties\"][\"name\"].\n        It is easier to use the method get_result_value(response, \"name\", 0)\n    \"\"\"\n\n    # Add query parameters (these are NOT passed via JSon body!)\n    # type = 0 ==&gt; User\n    request_url = self.config()[\"membersUrlv2\"] + \"?where_type=0&amp;query={}\".format(\n        name\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\"Get user with name -&gt; %s; calling -&gt; %s\", name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\"User -&gt; %s not found.\", name)\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_user_profile","title":"<code>get_user_profile()</code>","text":"<p>Update a defined field for a user profile.    IMPORTANT: this method needs to be called by the authenticated user</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>user profile field</p> required <code>value</code> <code>str</code> <p>new field value</p> required <p>Returns:     dict: User information or None if the user couldn't be updated           (e.g. because it doesn't exist).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_user_profile(self) -&gt; dict | None:\n    \"\"\"Update a defined field for a user profile.\n       IMPORTANT: this method needs to be called by the authenticated user\n\n    Args:\n        field (str): user profile field\n        value (str): new field value\n    Returns:\n        dict: User information or None if the user couldn't be updated\n              (e.g. because it doesn't exist).\n    \"\"\"\n\n    request_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get profile (settings) for current user; calling -&gt; %s\",\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get profile of current user; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_user_proxies","title":"<code>get_user_proxies(use_v2=False)</code>","text":"<p>Get list of user proxies.    This method needs to be called as the user the proxy is acting for. Args:     None Returns:     dict: Node information or None if REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_user_proxies(self, use_v2: bool = False) -&gt; dict | None:\n    \"\"\"Get list of user proxies.\n       This method needs to be called as the user the proxy is acting for.\n    Args:\n        None\n    Returns:\n        dict: Node information or None if REST call fails.\n    \"\"\"\n\n    if use_v2:\n        request_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\n    else:\n        request_url = self.config()[\"membersUrl\"] + \"/proxies\"\n    request_header = self.request_form_header()\n\n    logger.info(\"Get proxy users for current user; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get proxy users for current user; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_volume","title":"<code>get_volume(volume_type, timeout=REQUEST_TIMEOUT)</code>","text":"<p>Get Volume information based on the volume type ID.</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>int</code> <p>ID of the volume type</p> required <code>timeout</code> <code>int</code> <p>timeout for the request in seconds</p> <code>REQUEST_TIMEOUT</code> <p>Returns:     dict: Volume Details or None if volume is not found.     \"results\"\"properties\" is the node ID of the volume.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_volume(\n    self, volume_type: int, timeout: int = REQUEST_TIMEOUT\n) -&gt; dict | None:\n    \"\"\"Get Volume information based on the volume type ID.\n\n    Args:\n        volume_type (int): ID of the volume type\n        timeout (int, optional): timeout for the request in seconds\n    Returns:\n        dict: Volume Details or None if volume is not found.\n        [\"results\"][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n    \"\"\"\n\n    request_url = self.config()[\"volumeUrl\"] + \"/\" + str(volume_type)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get volume type -&gt; %s; calling -&gt; %s\", str(volume_type), request_url\n    )\n\n    retries = 0\n    while True:\n        try:\n            response = requests.get(\n                url=request_url,\n                headers=request_header,\n                cookies=self.cookie(),\n                timeout=timeout,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get volume type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    str(volume_type),\n                    response.status_code,\n                    response.text,\n                )\n                return None\n        except requests.exceptions.Timeout:\n            if retries &lt;= REQUEST_MAX_RETRIES:\n                logger.warning(\n                    \"Request timed out. Retrying in %s seconds...\",\n                    str(REQUEST_RETRY_DELAY),\n                )\n                retries += 1\n                time.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\n            else:\n                logger.error(\n                    \"Failed to get volume type -&gt; %s; timeout error\",\n                    str(volume_type),\n                )\n                # If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\n                logger.warning(\"Turn timeouts off and wait forever...\")\n                timeout = None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_volumes","title":"<code>get_volumes()</code>","text":"<p>Get all Volumes.</p> <p>Returns:     dict: Volume Details or None if an error occured.     {         'links': {             'data': {...}         },         'results': [             {                 'data': {                     'properties': {                         'advanced_versioning': None,                         'container': True,                         'container_size': 16,                         'create_date': '2023-05-07T23:18:50Z',                         'create_user_id': 1000,                         'description': '',                         'description_multilingual': {'de': '', 'en': '', 'fr': '', 'it': '', 'ja': ''},                         'external_create_date': None,                         'external_identity': '',                         'external_identity_type': '',                         'external_modify_date': None,                         'external_source': '',                         'favorite': False,                         'hidden': False,                         ...                         'id': 2000,                         ...                         'name': 'Enterprise',                         'name_multilingual': {'de': '', 'en': 'Enterprise', 'fr': '', 'it': '', 'ja': ''},                         ...                         'parent_id': -1,                         'type': 141,                         'volume_id': -2000,                         ...                     }                     ...                 }             },             ...         ]     }     Example:     \"results\"\"data\"[\"id\"] is the node ID of the volume.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_volumes(self) -&gt; dict | None:\n    \"\"\"Get all Volumes.\n\n    Args:\n        None\n    Returns:\n        dict: Volume Details or None if an error occured.\n        {\n            'links': {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data': {\n                        'properties': {\n                            'advanced_versioning': None,\n                            'container': True,\n                            'container_size': 16,\n                            'create_date': '2023-05-07T23:18:50Z',\n                            'create_user_id': 1000,\n                            'description': '',\n                            'description_multilingual': {'de': '', 'en': '', 'fr': '', 'it': '', 'ja': ''},\n                            'external_create_date': None,\n                            'external_identity': '',\n                            'external_identity_type': '',\n                            'external_modify_date': None,\n                            'external_source': '',\n                            'favorite': False,\n                            'hidden': False,\n                            ...\n                            'id': 2000,\n                            ...\n                            'name': 'Enterprise',\n                            'name_multilingual': {'de': '', 'en': 'Enterprise', 'fr': '', 'it': '', 'ja': ''},\n                            ...\n                            'parent_id': -1,\n                            'type': 141,\n                            'volume_id': -2000,\n                            ...\n                        }\n                        ...\n                    }\n                },\n                ...\n            ]\n        }\n        Example:\n        [\"results\"][0][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n    \"\"\"\n\n    request_url = self.config()[\"volumeUrl\"]\n    request_header = self.request_form_header()\n\n    logger.info(\"Get volumes; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get volumes; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_web_report_parameters","title":"<code>get_web_report_parameters(nickname)</code>","text":"<p>Get parameters of a Web Report in Extended ECM. These are defined on the Web Report node     (Properties --&gt; Parameters)</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>str</code> <p>Nickname of the Web Reports node.</p> required <p>Returns:     Response: List of Web Report parameters. Each list item is a dict describing the parameter.     Structure of the list items:     {         \"type\": \"string\",         \"parm_name\": \"string\",         \"display_text\": \"string\",         \"prompt\": true,         \"prompt_order\": 0,         \"default_value\": null,         \"description\": \"string\",         \"mandatory\": true     }     None if the REST call has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_web_report_parameters(self, nickname: str):\n    \"\"\"Get parameters of a Web Report in Extended ECM. These are defined on the Web Report node\n        (Properties --&gt; Parameters)\n\n    Args:\n        nickname (str): Nickname of the Web Reports node.\n    Returns:\n        Response: List of Web Report parameters. Each list item is a dict describing the parameter.\n        Structure of the list items:\n        {\n            \"type\": \"string\",\n            \"parm_name\": \"string\",\n            \"display_text\": \"string\",\n            \"prompt\": true,\n            \"prompt_order\": 0,\n            \"default_value\": null,\n            \"description\": \"string\",\n            \"mandatory\": true\n        }\n        None if the REST call has failed.\n    \"\"\"\n\n    request_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname + \"/parameters\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Retrieving parameters of Web Report with nickname -&gt; %s; calling -&gt; %s\",\n        nickname,\n        request_url,\n    )\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            # Return the \"data\" element which is a list of dict items:\n            result_dict = self.parse_request_response(response)\n            logger.debug(\"Web Report parameters result -&gt; %s\", str(result_dict))\n            if not result_dict.get(\"data\"):\n                return None\n            return result_dict[\"data\"]\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to retrieve parameters of Web Report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                nickname,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace","title":"<code>get_workspace(node_id)</code>","text":"<p>Get a workspace based on the node ID.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>Node ID of the workspace to retrieve.</p> required <p>Returns:     dict: Workspace node information or None if no node with this ID is found.</p> <pre><code>Example response:\n{\n    'links': {\n        'data': {...}\n    },\n    'meta_data': {\n        'properties': {...}\n    },\n    'paging': {\n        'limit': 500,\n        'page': 1,\n        'page_total': 1,\n        'range_max': 1,\n        'range_min': 1,\n        'total_count': 1\n    },\n    'results': [\n        {\n            'actions': {...},\n            'data': {\n                'business_properties': {\n                    'business_object_id': '000004000240',\n                    'business_object_type': 'BUS2007',\n                    'business_object_type_id': 18,\n                    'business_object_type_name': 'Maintenance Order',\n                    'business_object_type_name_multilingual': {...},\n                    'display_url': \"https://fiori.qa.idea-te.eimdemo.com:8443/sap/bc/ui2/flp#MaintenanceOrder-displayXecmFactSheet&amp;//C_ObjPgMaintOrder('000004000240')\",\n                    'external_system_id': 'TM6',\n                    'external_system_name': 'TM6',\n                    'has_default_display': True,\n                    'has_default_search': True,\n                    'isEarly': False,\n                    'workspace_type_id': 42,\n                    'workspace_type_name': 'Maintenance Order',\n                    'workspace_type_name_multilingual': {},\n                    ...\n                }\n                'properties': {\n                    'volume_id': -2000,\n                    'id': 36780,\n                    'parent_id': 13567,\n                    'owner_user_id': 7240,\n                    'name': '4600000044 - C.E.B. New York Inc.',\n                    'type': 848,\n                    'description': '',\n                    'create_date': '2023-09-02T11:07:06',\n                    'create_user_id': 7240,\n                    'create_user_id': 7240,\n                    'modify_date': '2023-09-02T11:07:11',\n                    'modify_user_id': 7240,\n                    'reserved': False,\n                    'reserved_user_id': 0,\n                    'reserved_date': None,\n                    'order': None,\n                    'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                    'hidden': False,\n                    'mime_type': None,\n                    'original_id': 0,\n                    'wnf_wksp_type_id': 16,\n                    'wnf_wksp_template_id': 15615,\n                    'size_formatted': '7 Items',\n                    'type_name': 'Business Workspace',\n                    'container': True,\n                    'size': 7,\n                    ...\n                }\n                'wksp_info':\n                {\n                    'wksp_type_icon': '/appimg/ot_bws/icons/16634%2Esvg?v=161194_13949'\n                }\n            },\n            'metadata': {...},\n            'metadata_order': {...}\n        }\n    ],\n    'wksp_info': {\n        'wksp_type_icon': None\n    }\n    'workspace_references': [\n        {\n            'business_object_id': '000004000240',\n            'business_object_type': 'BUS2007',\n            'business_object_type_id': 18,\n            'external_system_id': 'TM6',\n            'has_default_display': True,\n            'has_default_search': True,\n            'workspace_type_id': 42\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace(self, node_id: int) -&gt; dict | None:\n    \"\"\"Get a workspace based on the node ID.\n\n    Args:\n        node_id (int): Node ID of the workspace to retrieve.\n    Returns:\n        dict: Workspace node information or None if no node with this ID is found.\n\n        Example response:\n        {\n            'links': {\n                'data': {...}\n            },\n            'meta_data': {\n                'properties': {...}\n            },\n            'paging': {\n                'limit': 500,\n                'page': 1,\n                'page_total': 1,\n                'range_max': 1,\n                'range_min': 1,\n                'total_count': 1\n            },\n            'results': [\n                {\n                    'actions': {...},\n                    'data': {\n                        'business_properties': {\n                            'business_object_id': '000004000240',\n                            'business_object_type': 'BUS2007',\n                            'business_object_type_id': 18,\n                            'business_object_type_name': 'Maintenance Order',\n                            'business_object_type_name_multilingual': {...},\n                            'display_url': \"https://fiori.qa.idea-te.eimdemo.com:8443/sap/bc/ui2/flp#MaintenanceOrder-displayXecmFactSheet&amp;//C_ObjPgMaintOrder('000004000240')\",\n                            'external_system_id': 'TM6',\n                            'external_system_name': 'TM6',\n                            'has_default_display': True,\n                            'has_default_search': True,\n                            'isEarly': False,\n                            'workspace_type_id': 42,\n                            'workspace_type_name': 'Maintenance Order',\n                            'workspace_type_name_multilingual': {},\n                            ...\n                        }\n                        'properties': {\n                            'volume_id': -2000,\n                            'id': 36780,\n                            'parent_id': 13567,\n                            'owner_user_id': 7240,\n                            'name': '4600000044 - C.E.B. New York Inc.',\n                            'type': 848,\n                            'description': '',\n                            'create_date': '2023-09-02T11:07:06',\n                            'create_user_id': 7240,\n                            'create_user_id': 7240,\n                            'modify_date': '2023-09-02T11:07:11',\n                            'modify_user_id': 7240,\n                            'reserved': False,\n                            'reserved_user_id': 0,\n                            'reserved_date': None,\n                            'order': None,\n                            'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                            'hidden': False,\n                            'mime_type': None,\n                            'original_id': 0,\n                            'wnf_wksp_type_id': 16,\n                            'wnf_wksp_template_id': 15615,\n                            'size_formatted': '7 Items',\n                            'type_name': 'Business Workspace',\n                            'container': True,\n                            'size': 7,\n                            ...\n                        }\n                        'wksp_info':\n                        {\n                            'wksp_type_icon': '/appimg/ot_bws/icons/16634%2Esvg?v=161194_13949'\n                        }\n                    },\n                    'metadata': {...},\n                    'metadata_order': {...}\n                }\n            ],\n            'wksp_info': {\n                'wksp_type_icon': None\n            }\n            'workspace_references': [\n                {\n                    'business_object_id': '000004000240',\n                    'business_object_type': 'BUS2007',\n                    'business_object_type_id': 18,\n                    'external_system_id': 'TM6',\n                    'has_default_display': True,\n                    'has_default_search': True,\n                    'workspace_type_id': 42\n                }\n            ]\n        }\n    \"\"\"\n\n    request_url = self.config()[\"businessWorkspacesUrl\"] + \"/\" + str(node_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get workspace with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_by_business_object","title":"<code>get_workspace_by_business_object(external_system_name, business_object_type, business_object_id, return_workspace_metadata=False, show_error=False)</code>","text":"<p>Get a workspace based on the business object of an external system.</p> <p>Parameters:</p> Name Type Description Default <code>external_system_name</code> <code>str</code> <p>Name of the connection</p> required <code>business_object_type</code> <code>str</code> <p>Type of the Business object, e.g. KNA1 for SAP customers</p> required <code>business_object_id</code> <code>str</code> <p>ID of the business object in the external system</p> required <code>return_workspace_metadata</code> <code>bool</code> <p>Whether or not workspace metadata (categories) should be returned.                                         Default is False.</p> <code>False</code> <code>show_error</code> <code>bool</code> <p>Treat as error if node is not found. Default is False.</p> <code>False</code> <p>Returns:     dict: Workspace node information or None if no node with this ID is found.</p> <pre><code>Example response:\n{\n    'links': {\n        'data': {...}\n    },\n    'meta_data': {\n        'properties': {...}\n    },\n    'paging': {\n        'limit': 500,\n        'page': 1,\n        'page_total': 1,\n        'range_max': 1,\n        'range_min': 1,\n        'total_count': 1\n    },\n    'results': [\n        {\n            'actions': {...},\n            'data': {\n                'properties': {\n                    'volume_id': -2000,\n                    'id': 36780,\n                    'parent_id': 13567,\n                    'owner_user_id': 7240,\n                    'name': '4600000044 - C.E.B. New York Inc.',\n                    'type': 848,\n                    'description': '',\n                    'create_date': '2023-09-02T11:07:06',\n                    'create_user_id': 7240,\n                    'create_user_id': 7240,\n                    'modify_date': '2023-09-02T11:07:11',\n                    'modify_user_id': 7240,\n                    'reserved': False,\n                    'reserved_user_id': 0,\n                    'reserved_date': None,\n                    'order': None,\n                    'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                    'hidden': False,\n                    'mime_type': None,\n                    'original_id': 0,\n                    'wnf_wksp_type_id': 16,\n                    'wnf_wksp_template_id': 15615,\n                    'size_formatted': '7 Items',\n                    'type_name': 'Business Workspace',\n                    'container': True,\n                    'size': 7,\n                    ...\n                }\n            },\n            'metadata': {...},\n            'metadata_order': {...}\n        }\n    ],\n    'wksp_info': {\n        'wksp_type_icon': None\n    }\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_by_business_object(\n    self,\n    external_system_name: str,\n    business_object_type: str,\n    business_object_id: str,\n    return_workspace_metadata: bool = False,\n    show_error: bool = False,\n) -&gt; dict | None:\n    \"\"\"Get a workspace based on the business object of an external system.\n\n    Args:\n        external_system_name (str): Name of the connection\n        business_object_type (str): Type of the Business object, e.g. KNA1 for SAP customers\n        business_object_id (str): ID of the business object in the external system\n        return_workspace_metadata (bool, optional): Whether or not workspace metadata (categories) should be returned.\n                                                    Default is False.\n        show_error (bool, optional): Treat as error if node is not found. Default is False.\n    Returns:\n        dict: Workspace node information or None if no node with this ID is found.\n\n        Example response:\n        {\n            'links': {\n                'data': {...}\n            },\n            'meta_data': {\n                'properties': {...}\n            },\n            'paging': {\n                'limit': 500,\n                'page': 1,\n                'page_total': 1,\n                'range_max': 1,\n                'range_min': 1,\n                'total_count': 1\n            },\n            'results': [\n                {\n                    'actions': {...},\n                    'data': {\n                        'properties': {\n                            'volume_id': -2000,\n                            'id': 36780,\n                            'parent_id': 13567,\n                            'owner_user_id': 7240,\n                            'name': '4600000044 - C.E.B. New York Inc.',\n                            'type': 848,\n                            'description': '',\n                            'create_date': '2023-09-02T11:07:06',\n                            'create_user_id': 7240,\n                            'create_user_id': 7240,\n                            'modify_date': '2023-09-02T11:07:11',\n                            'modify_user_id': 7240,\n                            'reserved': False,\n                            'reserved_user_id': 0,\n                            'reserved_date': None,\n                            'order': None,\n                            'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                            'hidden': False,\n                            'mime_type': None,\n                            'original_id': 0,\n                            'wnf_wksp_type_id': 16,\n                            'wnf_wksp_template_id': 15615,\n                            'size_formatted': '7 Items',\n                            'type_name': 'Business Workspace',\n                            'container': True,\n                            'size': 7,\n                            ...\n                        }\n                    },\n                    'metadata': {...},\n                    'metadata_order': {...}\n                }\n            ],\n            'wksp_info': {\n                'wksp_type_icon': None\n            }\n        }\n    \"\"\"\n\n    request_url = (\n        self.config()[\"externalSystemUrl\"]\n        + \"/\"\n        + external_system_name\n        + \"/botypes/\"\n        + business_object_type\n        + \"/boids/\"\n        + business_object_id\n    )\n    if return_workspace_metadata:\n        request_url += \"?metadata\"\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); calling -&gt; %s\",\n        external_system_name,\n        business_object_type,\n        business_object_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\n                    external_system_name,\n                    business_object_type,\n                    business_object_id,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\n                    \"Cannot fing workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\n                    external_system_name,\n                    business_object_type,\n                    business_object_id,\n                    response.status_code,\n                    response.text,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_by_type_and_name","title":"<code>get_workspace_by_type_and_name(type_name='', type_id=None, name='', expanded_view=True)</code>","text":"<p>Lookup workspace based on workspace type and workspace name.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>name of the workspace type</p> <code>''</code> <code>type_id</code> <code>int</code> <p>ID of the workspace_type</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the workspace, if \"\" then deliver all instances                   of the given workspace type.</p> <code>''</code> <code>expanded_view</code> <code>bool</code> <p>If 'False' then just search in recently                             accessed business workspace for this name and type.                             If 'True' (this is the default) then search in all                             workspaces for this name and type.</p> <code>True</code> <p>Returns:     dict: Workspace information or None if the workspace is not found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_by_type_and_name(\n    self,\n    type_name: str = \"\",\n    type_id: int = None,\n    name: str = \"\",\n    expanded_view: bool = True,\n) -&gt; dict | None:\n    \"\"\"Lookup workspace based on workspace type and workspace name.\n\n    Args:\n        type_name (str, optional): name of the workspace type\n        type_id (int, optional): ID of the workspace_type\n        name (str, optional): Name of the workspace, if \"\" then deliver all instances\n                              of the given workspace type.\n        expanded_view (bool, optional): If 'False' then just search in recently\n                                        accessed business workspace for this name and type.\n                                        If 'True' (this is the default) then search in all\n                                        workspaces for this name and type.\n    Returns:\n        dict: Workspace information or None if the workspace is not found.\n    \"\"\"\n\n    # Add query parameters (these are NOT passed via JSon body!)\n    query = {\n        \"expanded_view\": expanded_view,\n    }\n    if type_name:\n        query[\"where_workspace_type_name\"] = type_name\n    if type_id:\n        query[\"where_workspace_type_id\"] = type_id\n    if name:\n        query[\"where_name\"] = name\n\n    encoded_query = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = self.config()[\"businessWorkspacesUrl\"] + \"?{}\".format(\n        encoded_query\n    )\n    request_header = self.request_form_header()\n\n    if name:\n        logger.info(\n            \"Get workspace with name -&gt; %s and type -&gt; %s; calling -&gt; %s\",\n            name,\n            type_name,\n            request_url,\n        )\n    else:\n        logger.info(\n            \"Get all workspace instances of type -&gt; %s; calling -&gt; %s\",\n            type_name,\n            request_url,\n        )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if name:\n                logger.warning(\n                    \"Failed to get workspace -&gt; %s of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    type_name,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.warning(\n                    \"Failed to get workspace instances of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    type_name,\n                    response.status_code,\n                    response.text,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_create_form","title":"<code>get_workspace_create_form(template_id, external_system_id=None, bo_type=None, bo_id=None, parent_id=None)</code>","text":"<p>Get the Workspace create form.</p> <p>Parameters:</p> Name Type Description Default <code>template_id</code> <code>int</code> <p>ID of the workspace template</p> required <code>external_system_id</code> <code>int</code> <p>Identifier of the external system (None if no external system)</p> <code>None</code> <code>bo_type</code> <code>int</code> <p>Business object type (None if no external system)</p> <code>None</code> <code>bo_id</code> <code>int</code> <p>Business object identifier / key (None if no external system)</p> <code>None</code> <code>parent_id</code> <code>int</code> <p>Parent ID of the workspaces. Needs only be specified in special                        cases where workspace location cannot be derived from workspace                        type definition, e.g. sub-workspace</p> <code>None</code> <p>Returns:     dict: Workspace Create Form data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_create_form(\n    self,\n    template_id: int,\n    external_system_id: int = None,\n    bo_type: int = None,\n    bo_id: int = None,\n    parent_id: int = None,\n) -&gt; dict | None:\n    \"\"\"Get the Workspace create form.\n\n    Args:\n        template_id (int): ID of the workspace template\n        external_system_id (int, optional): Identifier of the external system (None if no external system)\n        bo_type (int, optional): Business object type (None if no external system)\n        bo_id (int, optional): Business object identifier / key (None if no external system)\n        parent_id (int, optional): Parent ID of the workspaces. Needs only be specified in special\n                                   cases where workspace location cannot be derived from workspace\n                                   type definition, e.g. sub-workspace\n    Returns:\n        dict: Workspace Create Form data or None if the request fails.\n    \"\"\"\n\n    request_url = self.config()[\n        \"businessworkspacecreateform\"\n    ] + \"?template_id={}\".format(template_id)\n    # Is a parent ID specifified? Then we need to add it to the request URL\n    if parent_id is not None:\n        request_url += \"&amp;parent_id={}\".format(parent_id)\n    # Is this workspace connected to a business application / external system?\n    if external_system_id and bo_type and bo_id:\n        request_url += \"&amp;ext_system_id={}\".format(external_system_id)\n        request_url += \"&amp;bo_type={}\".format(bo_type)\n        request_url += \"&amp;bo_id={}\".format(bo_id)\n        logger.info(\n            \"Include business object connection -&gt; (%s, %s, %s) in workspace create form...\",\n            str(external_system_id),\n            str(bo_type),\n            str(bo_id),\n        )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get workspace create form for workspace template ID -&gt; %s; calling -&gt; %s\",\n        str(template_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get workspace create form for template -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(template_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_instances","title":"<code>get_workspace_instances(type_name='', type_id=None, expanded_view=True)</code>","text":"<p>Get all workspace instances of a given type. This is a convenience    wrapper method for get_workspace_by_type_and_name()</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>Name of the workspace type</p> <code>''</code> <code>type_id</code> <code>int</code> <p>ID of the workspace_type</p> <code>None</code> <code>expanded_view</code> <code>bool</code> <p>If 'False' then just search in recently                             accessed business workspace for this name and type.                             If 'True' (this is the default) then search in all                             workspaces for this name and type.</p> <code>True</code> <p>Returns:     dict: Workspace information or None if the workspace is not found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_instances(\n    self, type_name: str = \"\", type_id: int = None, expanded_view: bool = True\n):\n    \"\"\"Get all workspace instances of a given type. This is a convenience\n       wrapper method for get_workspace_by_type_and_name()\n\n    Args:\n        type_name (str, optional): Name of the workspace type\n        type_id (int, optional): ID of the workspace_type\n        expanded_view (bool, optional): If 'False' then just search in recently\n                                        accessed business workspace for this name and type.\n                                        If 'True' (this is the default) then search in all\n                                        workspaces for this name and type.\n    Returns:\n        dict: Workspace information or None if the workspace is not found.\n    \"\"\"\n\n    # Omitting the name lets it return all instances of the type:\n    return self.get_workspace_by_type_and_name(\n        type_name=type_name, type_id=type_id, name=\"\", expanded_view=expanded_view\n    )\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_relationships","title":"<code>get_workspace_relationships(workspace_id)</code>","text":"<p>Get the Workspace relationships to other workspaces.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace template</p> required <p>Returns:     dict: Workspace relationships or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_relationships(self, workspace_id: int) -&gt; dict | None:\n    \"\"\"Get the Workspace relationships to other workspaces.\n\n    Args:\n        workspace_id (int): ID of the workspace template\n    Returns:\n        dict: Workspace relationships or None if the request fails.\n    \"\"\"\n\n    request_url = (\n        self.config()[\"businessWorkspacesUrl\"]\n        + \"/\"\n        + str(workspace_id)\n        + \"/relateditems\"\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get related workspaces for workspace with ID -&gt; %s; calling -&gt; %s\",\n        str(workspace_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get related workspaces of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(workspace_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_roles","title":"<code>get_workspace_roles(workspace_id)</code>","text":"<p>Get the Workspace roles.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace template</p> required <p>Returns:     dict: Workspace Roles data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_roles(self, workspace_id: int) -&gt; dict | None:\n    \"\"\"Get the Workspace roles.\n\n    Args:\n        workspace_id (int): ID of the workspace template\n    Returns:\n        dict: Workspace Roles data or None if the request fails.\n    \"\"\"\n\n    request_url = (\n        self.config()[\"businessWorkspacesUrl\"] + \"/\" + str(workspace_id) + \"/roles\"\n    )\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Get workspace roles of workspace with ID -&gt; %s; calling -&gt; %s\",\n        str(workspace_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get roles of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(workspace_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_types","title":"<code>get_workspace_types(expand_workspace_info=True, expand_templates=True)</code>","text":"<p>Get all workspace types configured in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>expand_workspace_info</code> <code>bool</code> <p>Controls if the workspace info                                     is returned as well</p> <code>True</code> <code>expand_workspace_info</code> <code>bool</code> <p>Controls if the list of workspace templates                                     per workspace typ is returned as well</p> <code>True</code> <p>Returns:     dict: Workspace Types or None if the request fails.</p> <pre><code>Example response:\n{\n    'links': {\n        'data': {...}\n    },\n    'results': [\n        {\n            'data': {\n                'properties': {\n                    'rm_enabled': False,\n                    'templates': [\n                        {\n                            'id': 14471,\n                            'name': 'Campaign',\n                            'subtype': 848\n                        },\n                        ...\n                    ],\n                    'wksp_type_id': 35,\n                    'wksp_type_name': 'Campaign'\n                },\n                'wksp_info': {\n                    'wksp_type_icon': '/appimg/ot_bws/icons/13147%2Esvg?v=161108_84584'\n                }\n            }\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_types(\n    self, expand_workspace_info: bool = True, expand_templates: bool = True\n) -&gt; dict | None:\n    \"\"\"Get all workspace types configured in Extended ECM.\n\n    Args:\n        expand_workspace_info (bool, optional): Controls if the workspace info\n                                                is returned as well\n        expand_workspace_info (bool, optional): Controls if the list of workspace templates\n                                                per workspace typ is returned as well\n    Returns:\n        dict: Workspace Types or None if the request fails.\n\n        Example response:\n        {\n            'links': {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data': {\n                        'properties': {\n                            'rm_enabled': False,\n                            'templates': [\n                                {\n                                    'id': 14471,\n                                    'name': 'Campaign',\n                                    'subtype': 848\n                                },\n                                ...\n                            ],\n                            'wksp_type_id': 35,\n                            'wksp_type_name': 'Campaign'\n                        },\n                        'wksp_info': {\n                            'wksp_type_icon': '/appimg/ot_bws/icons/13147%2Esvg?v=161108_84584'\n                        }\n                    }\n                }\n            ]\n        }\n    \"\"\"\n\n    request_url = self.config()[\"businessWorkspaceTypesUrl\"]\n    if expand_templates:\n        request_url += \"?expand_templates=true\"\n    else:\n        request_url += \"?expand_templates=false\"\n    if expand_workspace_info:\n        request_url += \"&amp;expand_wksp_info=true\"\n    else:\n        request_url += \"&amp;expand_wksp_info=false\"\n\n    request_header = self.request_form_header()\n\n    logger.info(\"Get workspace types; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get workspace types; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.hostname","title":"<code>hostname()</code>","text":"<p>Returns the hostname of Extended ECM (e.g. \"otcs\")</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>hostname</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def hostname(self) -&gt; str:\n    \"\"\"Returns the hostname of Extended ECM (e.g. \"otcs\")\n\n    Returns:\n        str: hostname\n    \"\"\"\n    return self.config()[\"hostname\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_physical_objects_codes","title":"<code>import_physical_objects_codes(file_path, update_existing_codes=True)</code>","text":"<p>Import Physical Objects codes from a config file that is uploaded from the Python pod Args:     file_path (str): path + filename of config file in Python container filesystem     update_existing_codes (bool): whether or not existing codes should be updated (default = True) Returns:     bool: True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_physical_objects_codes(\n    self, file_path: str, update_existing_codes: bool = True\n) -&gt; bool:\n    \"\"\"Import Physical Objects codes from a config file that is uploaded from the Python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n        update_existing_codes (bool): whether or not existing codes should be updated (default = True)\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"physicalObjectsUrl\"] + \"/importCodes\"\n\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n    logger.info(\n        \"Importing Physical Objects Codes from file -&gt; %s; calling -&gt; %s\",\n        file_path,\n        request_url,\n    )\n\n    settings_post_data = {\"updateExistingCodes\": update_existing_codes}\n\n    filename = os.path.basename(file_path)\n    if not os.path.exists(file_path):\n        logger.error(\n            \"The file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(file_path),\n        )\n        return False\n    settings_post_file = {\n        \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=settings_post_data,\n            files=settings_post_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import Physical Objects Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_physical_objects_locators","title":"<code>import_physical_objects_locators(file_path)</code>","text":"<p>Import Physical Objects locators from a config file that is uploaded from the python pod Args:     file_path (str): path + filename of config file in Python container filesystem Returns:     bool: True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_physical_objects_locators(self, file_path: str) -&gt; bool:\n    \"\"\"Import Physical Objects locators from a config file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"physicalObjectsUrl\"] + \"/importLocators\"\n\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n    logger.info(\n        \"Importing Physical Objects Locators from file -&gt; %s; calling -&gt; %s\",\n        file_path,\n        request_url,\n    )\n\n    filename = os.path.basename(file_path)\n    if not os.path.exists(file_path):\n        logger.error(\n            \"The file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(file_path),\n        )\n        return False\n    settings_post_file = {\n        \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            files=settings_post_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import Physical Objects Locators from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_physical_objects_settings","title":"<code>import_physical_objects_settings(file_path)</code>","text":"<p>Import Physical Objects settings from a config file that is uploaded from the python pod Args:     file_path (str): path + filename of config file in Python container filesystem Returns:     bool: True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_physical_objects_settings(self, file_path: str) -&gt; bool:\n    \"\"\"Import Physical Objects settings from a config file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"physicalObjectsUrl\"] + \"/importSettings\"\n\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n    logger.info(\n        \"Importing Physical Objects Settings from server file -&gt; %s; calling -&gt; %s\",\n        file_path,\n        request_url,\n    )\n\n    filename = os.path.basename(file_path)\n    if not os.path.exists(file_path):\n        logger.error(\n            \"The file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(file_path),\n        )\n        return False\n    settings_post_file = {\n        \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            files=settings_post_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import Physical Objects settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_records_management_codes","title":"<code>import_records_management_codes(file_path, update_existing_codes=True)</code>","text":"<p>Import RM Codes from a file that is uploaded from the python pod Args:     file_path (str): path + filename of settings file in Python container filesystem     update_existing_codes (bool): Flag that controls whether existing table maintenance codes                                   should be updated. Returns:     bool: True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_records_management_codes(\n    self, file_path: str, update_existing_codes: bool = True\n) -&gt; bool:\n    \"\"\"Import RM Codes from a file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of settings file in Python container filesystem\n        update_existing_codes (bool): Flag that controls whether existing table maintenance codes\n                                      should be updated.\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"recordsManagementUrl\"] + \"/importCodes\"\n\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n    logger.info(\n        \"Importing Records Management Codes from file -&gt; %s; calling -&gt; %s\",\n        file_path,\n        request_url,\n    )\n\n    settings_post_data = {\"updateExistingCodes\": update_existing_codes}\n\n    filename = os.path.basename(file_path)\n    if not os.path.exists(file_path):\n        logger.error(\n            \"The file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(file_path),\n        )\n        return False\n    settings_post_file = {\n        \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=settings_post_data,\n            files=settings_post_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import Records Management Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_records_management_rsis","title":"<code>import_records_management_rsis(file_path, update_existing_rsis=True, delete_schedules=False)</code>","text":"<p>Import RM RSIs from a config file that is uploaded from the Python pod Args:     file_path (str): path + filename of config file in Python container filesystem     update_existing_rsis (bool, optional): whether or not existing RSIs should be updated (or ignored)     delete_schedules (bool, optional): whether RSI Schedules should be deleted Returns:     bool: True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_records_management_rsis(\n    self,\n    file_path: str,\n    update_existing_rsis: bool = True,\n    delete_schedules: bool = False,\n) -&gt; bool:\n    \"\"\"Import RM RSIs from a config file that is uploaded from the Python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n        update_existing_rsis (bool, optional): whether or not existing RSIs should be updated (or ignored)\n        delete_schedules (bool, optional): whether RSI Schedules should be deleted\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"recordsManagementUrl\"] + \"/importRSIs\"\n\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n    logger.info(\n        \"Importing Records Management RSIs from file -&gt; %s; calling -&gt; %s\",\n        file_path,\n        request_url,\n    )\n\n    settings_post_data = {\n        \"updateExistingRSIs\": update_existing_rsis,\n        \"deleteSchedules\": delete_schedules,\n    }\n\n    filename = os.path.basename(file_path)\n    if not os.path.exists(file_path):\n        logger.error(\n            \"The file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(file_path),\n        )\n        return False\n    settings_post_file = {\n        \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=settings_post_data,\n            files=settings_post_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import Records Management RSIs from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_records_management_settings","title":"<code>import_records_management_settings(file_path)</code>","text":"<p>Import Records Management settings from a file that is uploaded from the python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of config file in Python container filesystem</p> required <p>Returns:     bool: True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_records_management_settings(self, file_path: str) -&gt; bool:\n    \"\"\"Import Records Management settings from a file that is uploaded from the python pod\n\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"recordsManagementUrl\"] + \"/importSettings\"\n\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n    logger.info(\n        \"Importing Records Management Settings from file -&gt; %s; calling -&gt; %s\",\n        file_path,\n        request_url,\n    )\n\n    filename = os.path.basename(file_path)\n    if not os.path.exists(file_path):\n        logger.error(\n            \"The file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(file_path),\n        )\n        return False\n    settings_post_file = {\n        \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            files=settings_post_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import Records Management Settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_security_clearance_codes","title":"<code>import_security_clearance_codes(file_path, include_users=False)</code>","text":"<p>Import Security Clearance codes from a config file that is uploaded from the python pod Args:     file_path (str): path + filename of config file in Python container filesystem     include_users (bool): defines if users should be included or not Returns:     bool: True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_security_clearance_codes(\n    self, file_path: str, include_users: bool = False\n) -&gt; bool:\n    \"\"\"Import Security Clearance codes from a config file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n        include_users (bool): defines if users should be included or not\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\n\n    request_url = self.config()[\"securityClearancesUrl\"] + \"/importCodes\"\n\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\n\n    logger.info(\n        \"Importing Security Clearance Codes from file -&gt; %s; calling -&gt; %s\",\n        file_path,\n        request_url,\n    )\n\n    settings_post_data = {\"includeusers\": include_users}\n\n    filename = os.path.basename(file_path)\n    if not os.path.exists(file_path):\n        logger.error(\n            \"The file -&gt; %s does not exist in path -&gt; %s!\",\n            filename,\n            os.path.dirname(file_path),\n        )\n        return False\n    settings_post_file = {\n        \"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n    }\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=settings_post_data,\n            files=settings_post_file,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to import Security Clearance Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.install_cs_application","title":"<code>install_cs_application(application_name)</code>","text":"<p>Install a CS Application (based on WebReports)</p> <p>Parameters:</p> Name Type Description Default <code>application_name</code> <code>str</code> <p>name of the application (e.g. OTPOReports, OTRMReports, OTRMSecReports)</p> required <p>Returns:     dict: Response or None if the installation of the CS Application has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def install_cs_application(self, application_name: str) -&gt; dict | None:\n    \"\"\"Install a CS Application (based on WebReports)\n\n    Args:\n        application_name (str): name of the application (e.g. OTPOReports, OTRMReports, OTRMSecReports)\n    Returns:\n        dict: Response or None if the installation of the CS Application has failed.\n    \"\"\"\n\n    install_cs_application_post_data = {\"appName\": application_name}\n\n    request_url = self.config()[\"csApplicationsUrl\"] + \"/install\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Install CS Application -&gt; %s; calling -&gt; %s\", application_name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=install_cs_application_post_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to install CS Application -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                application_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.is_configured","title":"<code>is_configured()</code>","text":"<p>Checks if the Content Server pod is configured to receive requests.</p> <p>Returns:     bool: True if pod is ready. False if pod is not yet ready.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def is_configured(self) -&gt; bool:\n    \"\"\"Checks if the Content Server pod is configured to receive requests.\n\n    Args:\n        None.\n    Returns:\n        bool: True if pod is ready. False if pod is not yet ready.\n    \"\"\"\n\n    request_url = self.config()[\"configuredUrl\"]\n\n    logger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\n\n    try:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_JSON_HEADERS,\n            timeout=REQUEST_TIMEOUT,\n        )\n    except requests.exceptions.RequestException as exception:\n        logger.warning(\n            \"Unable to connect to -&gt; %s; warning -&gt; %s\",\n            request_url,\n            exception.strerror,\n        )\n        logger.warning(\"OTCS service may not be ready yet.\")\n        return False\n\n    if not response.ok:\n        logger.warning(\n            \"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\n            request_url,\n            response.status_code,\n            response.text,\n        )\n        return False\n\n    return True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.is_proxy","title":"<code>is_proxy(user_name)</code>","text":"<p>Check if a user is defined as proxy of the current user.    This method differentiates between the old (xGov) based    implementation and the new Extended ECM platform one    that was introduced with version 23.4.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> <p>user  to test (login name)</p> required <p>Returns:     bool: True is user is proxy of current user. False if not.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def is_proxy(self, user_name: str) -&gt; bool:\n    \"\"\"Check if a user is defined as proxy of the current user.\n       This method differentiates between the old (xGov) based\n       implementation and the new Extended ECM platform one\n       that was introduced with version 23.4.\n\n    Args:\n        user_name (str): user  to test (login name)\n    Returns:\n        bool: True is user is proxy of current user. False if not.\n    \"\"\"\n\n    version_number = self.get_server_version()\n    # Split the version number by dot\n    parts = version_number.split(\".\")\n    # Take the first two parts and join them back with a dot\n    stripped_version = \".\".join(parts[:2])\n\n    try:\n        version_number = float(stripped_version)\n    except ValueError:\n        version_number = 99.99  # Set to version 99.99 for \"main\"\n\n    if version_number &gt;= 23.4:\n        response = self.get_user_proxies(use_v2=True)\n        if self.exist_result_item(\n            response=response, key=\"name\", value=user_name, property_name=\"\"\n        ):\n            return True\n        else:\n            return False\n    else:\n        response = self.get_user_proxies(use_v2=False)\n        if not response or not \"proxies\" in response:\n            return False\n        proxies = response[\"proxies\"]\n\n        for proxy in proxies:\n            if proxy[\"name\"] == user_name:\n                return True\n        return False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.is_ready","title":"<code>is_ready()</code>","text":"<p>Checks if the Content Server pod is ready to receive requests.</p> <p>Returns:     bool: True if pod is ready. False if pod is not yet ready.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def is_ready(self) -&gt; bool:\n    \"\"\"Checks if the Content Server pod is ready to receive requests.\n\n    Args:\n        None.\n    Returns:\n        bool: True if pod is ready. False if pod is not yet ready.\n    \"\"\"\n\n    request_url = self.config()[\"isReady\"]\n\n    logger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\n\n    try:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_JSON_HEADERS,\n            timeout=2,\n        )\n    except requests.exceptions.RequestException as exception:\n        logger.warning(\n            \"Unable to connect to -&gt; %s; warning -&gt; %s\",\n            request_url,\n            exception.strerror,\n        )\n        logger.warning(\"OTCS service may not be ready yet.\")\n        return False\n\n    if not response.status_code == 200:\n        logger.warning(\n            \"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\n            request_url,\n            response.status_code,\n            response.text,\n        )\n        return False\n\n    return True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.lookup_result_value","title":"<code>lookup_result_value(response, key, value, return_key)</code>","text":"<p>Lookup a property value based on a provided key / value pair in the    response properties of an Extended ECM REST API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an OTCS REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>value</code> <code>str</code> <p>value to find in the item with the matching key</p> required <code>return_key</code> <code>str</code> <p>determines which value to return based on the name of the dict key</p> required <p>Returns:     str: value of the property with the key defined in \"return_key\"          or None if the lookup fails</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def lookup_result_value(\n    self, response: dict, key: str, value: str, return_key: str\n) -&gt; str | None:\n    \"\"\"Lookup a property value based on a provided key / value pair in the\n       response properties of an Extended ECM REST API call.\n\n    Args:\n        response (dict): REST response from an OTCS REST Call\n        key (str): property name (key)\n        value (str): value to find in the item with the matching key\n        return_key (str): determines which value to return based on the name of the dict key\n    Returns:\n        str: value of the property with the key defined in \"return_key\"\n             or None if the lookup fails\n    \"\"\"\n\n    if not response:\n        return None\n    if not \"results\" in response:\n        return None\n\n    results = response[\"results\"]\n    # check if results is a list or a dict (both is possible -\n    # dependent on the actual REST API):\n    if isinstance(results, dict):\n        # result is a dict - we don't need index value:\n        data = results[\"data\"]\n        if isinstance(data, dict):\n            # data is a dict - we don't need index value:\n            properties = data[\"properties\"]\n            if (\n                key in properties\n                and properties[key] == value\n                and return_key in properties\n            ):\n                return properties[return_key]\n            else:\n                return None\n        elif isinstance(data, list):\n            # data is a list - this has typically just one item, so we use 0 as index\n            for item in data:\n                properties = item[\"properties\"]\n                if (\n                    key in properties\n                    and properties[key] == value\n                    and return_key in properties\n                ):\n                    return properties[return_key]\n            return None\n        else:\n            logger.error(\n                \"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n            )\n            return None\n    elif isinstance(results, list):\n        # result is a list - we need index value\n        for result in results:\n            data = result[\"data\"]\n            if isinstance(data, dict):\n                # data is a dict - we don't need index value:\n                properties = data[\"properties\"]\n                if (\n                    key in properties\n                    and properties[key] == value\n                    and return_key in properties\n                ):\n                    return properties[return_key]\n            elif isinstance(data, list):\n                # data is a list we iterate through the list and try to find the key:\n                for item in data:\n                    properties = item[\"properties\"]\n                    if (\n                        key in properties\n                        and properties[key] == value\n                        and return_key in properties\n                    ):\n                        return properties[return_key]\n            else:\n                logger.error(\n                    \"Data needs to be a list or dict but it is -&gt; %s\",\n                    str(type(data)),\n                )\n                return None\n        return None\n    else:\n        logger.error(\n            \"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the text property of a request response object to a Python dict in a safe way     that also handles exceptions.</p> <pre><code>Content Server may produce corrupt response when it gets restarted\nor hitting resource limits. So we try to avoid a fatal error and bail\nout more gracefully.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>print a custom error message</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>if True log an error, if False log a warning</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response or None in case of an error</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def parse_request_response(\n    self,\n    response_object: object,\n    additional_error_message: str = \"\",\n    show_error: bool = True,\n) -&gt; dict | None:\n    \"\"\"Converts the text property of a request response object to a Python dict in a safe way\n        that also handles exceptions.\n\n        Content Server may produce corrupt response when it gets restarted\n        or hitting resource limits. So we try to avoid a fatal error and bail\n        out more gracefully.\n\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str): print a custom error message\n        show_error (bool): if True log an error, if False log a warning\n\n    Returns:\n        dict: response or None in case of an error\n    \"\"\"\n\n    if not response_object:\n        return None\n\n    try:\n        dict_object = json.loads(response_object.text)\n    except json.JSONDecodeError as exception:\n        if additional_error_message:\n            message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                additional_error_message, exception\n            )\n        else:\n            message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                exception\n            )\n        if show_error:\n            logger.error(message)\n        else:\n            logger.warning(message)\n        return None\n    else:\n        return dict_object\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.register_workspace_template","title":"<code>register_workspace_template(node_id)</code>","text":"<p>Register a workspace template as project template for Extended ECM for Engineering Args:     node_id (int): node ID of the Extended ECM workspace template Returns:     dict: Response of request or None if the registration of the workspace template has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def register_workspace_template(self, node_id: int) -&gt; dict | None:\n    \"\"\"Register a workspace template as project template for Extended ECM for Engineering\n    Args:\n        node_id (int): node ID of the Extended ECM workspace template\n    Returns:\n        dict: Response of request or None if the registration of the workspace template has failed.\n    \"\"\"\n\n    registration_post_data = {\"ids\": \"{{ {} }}\".format(node_id)}\n\n    request_url = self.config()[\"xEngProjectTemplateUrl\"]\n\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Register workspace template with ID -&gt; %s; calling -&gt; %s\",\n        str(node_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=registration_post_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to register Workspace Template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.remove_member_from_workspace","title":"<code>remove_member_from_workspace(workspace_id, role_id, member_id, show_warning=True)</code>","text":"<p>Remove a member from a workspace role. Check that the user is currently a member.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>role_id</code> <code>int</code> <p>ID of the role</p> required <code>member_id</code> <code>int</code> <p>User or Group Id</p> required <code>show_warning</code> <code>bool</code> <p>If True logs a warning if member is not in role</p> <code>True</code> <p>Returns:     dict: Workspace Role Membership or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def remove_member_from_workspace(\n    self, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n) -&gt; dict | None:\n    \"\"\"Remove a member from a workspace role. Check that the user is currently a member.\n\n    Args:\n        workspace_id (int): ID of the workspace\n        role_id (int): ID of the role\n        member_id (int): User or Group Id\n        show_warning (bool, optional): If True logs a warning if member is not in role\n    Returns:\n        dict: Workspace Role Membership or None if the request fails.\n    \"\"\"\n\n    request_url = self.config()[\n        \"businessWorkspacesUrl\"\n    ] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Check if user/group with ID -&gt; %s is in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n        str(member_id),\n        str(role_id),\n        str(workspace_id),\n        request_url,\n    )\n\n    response = requests.get(\n        url=request_url,\n        headers=request_header,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n    if not response.ok:\n        logger.error(\n            \"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\n            response.status_code,\n            response.text,\n        )\n        return None\n\n    workspace_members = self.parse_request_response(response)\n\n    if not self.exist_result_item(workspace_members, \"id\", member_id):\n        if show_warning:\n            logger.warning(\n                \"User/group with ID -&gt; %s is not a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\n                str(member_id),\n                str(role_id),\n                str(workspace_id),\n            )\n        return None\n\n    request_url = self.config()[\n        \"businessWorkspacesUrl\"\n    ] + \"/{}/roles/{}/members/{}\".format(workspace_id, role_id, member_id)\n\n    logger.info(\n        \"Removing user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\n        str(member_id),\n        str(role_id),\n        str(workspace_id),\n        request_url,\n    )\n\n    response = requests.delete(\n        url=request_url,\n        headers=request_header,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n\n    if response.ok:\n        return self.parse_request_response(response)\n    else:\n        logger.error(\n            \"Failed to remove user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n            str(member_id),\n            str(role_id),\n            str(workspace_id),\n            response.status_code,\n            response.text,\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.rename_node","title":"<code>rename_node(node_id, name, description, name_multilingual=None, description_multilingual=None)</code>","text":"<p>Change the name and description of a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node. You can use the get_volume() function below to                to the node id for a volume.</p> required <code>name</code> <code>str</code> <p>New name of the node.</p> required <code>description</code> <code>str</code> <p>New description of the node.</p> required <code>name_multilingual</code> <code>dict</code> <p>multi-lingual node names</p> <code>None</code> <code>description_multilingual</code> <code>dict</code> <p>multi-lingual description</p> <code>None</code> <p>Returns:     dict: Request response or None if the renaming fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def rename_node(\n    self,\n    node_id: int,\n    name: str,\n    description: str,\n    name_multilingual: dict | None = None,\n    description_multilingual: dict | None = None,\n) -&gt; dict | None:\n    \"\"\"Change the name and description of a node.\n\n    Args:\n        node_id (int): ID of the node. You can use the get_volume() function below to\n                           to the node id for a volume.\n        name (str): New name of the node.\n        description (str): New description of the node.\n        name_multilingual (dict, optional): multi-lingual node names\n        description_multilingual (dict, optional): multi-lingual description\n    Returns:\n        dict: Request response or None if the renaming fails.\n    \"\"\"\n\n    rename_node_put_body = {\"name\": name, \"description\": description}\n\n    if name_multilingual:\n        rename_node_put_body[\"name_multilingual\"] = name_multilingual\n    if description_multilingual:\n        rename_node_put_body[\"description_multilingual\"] = description_multilingual\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Renaming node with ID -&gt; %s to -&gt; %s; calling -&gt; %s\",\n        str(node_id),\n        name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            data={\"body\": json.dumps(rename_node_put_body)},\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to rename node with ID -&gt; %s to -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(node_id),\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.replace_transport_placeholders","title":"<code>replace_transport_placeholders(zip_file_path, replacements)</code>","text":"<p>Search and replace strings in the XML files of the transport package</p> <p>Parameters:</p> Name Type Description Default <code>zip_file_path</code> <code>str</code> <p>Path to transport zip file</p> required <code>replacements</code> <code>list of dicts</code> <p>List of replacement values; dict needs to have two values:                          * placeholder: text to replace                          * value: text to replace with</p> required <p>Returns:     Filename to the updated zip file</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def replace_transport_placeholders(\n    self, zip_file_path: str, replacements: list\n) -&gt; bool:\n    \"\"\"Search and replace strings in the XML files of the transport package\n\n    Args:\n        zip_file_path (str): Path to transport zip file\n        replacements (list of dicts): List of replacement values; dict needs to have two values:\n                                     * placeholder: text to replace\n                                     * value: text to replace with\n    Returns:\n        Filename to the updated zip file\n    \"\"\"\n\n    if not os.path.isfile(zip_file_path):\n        logger.error(\"Zip file -&gt; %s not found.\", zip_file_path)\n        return False\n\n    # Extract the zip file to a temporary directory\n    zip_file_folder = os.path.splitext(zip_file_path)[0]\n    with zipfile.ZipFile(zip_file_path, \"r\") as zfile:\n        zfile.extractall(zip_file_folder)\n\n    modified = False\n\n    # Replace search pattern with replace string in all XML files in the directory and its subdirectories\n    for replacement in replacements:\n        if not \"value\" in replacement:\n            logger.error(\n                \"Replacement needs a value but it is not specified. Skipping...\"\n            )\n            continue\n        if \"enabled\" in replacement and not replacement[\"enabled\"]:\n            logger.info(\n                \"Replacement for transport -&gt; %s is disabled. Skipping...\",\n                zip_file_path,\n            )\n            continue\n        # there are two types of replacements:\n        # 1. XPath - more elegant and powerful\n        # 2. Search &amp; Replace - basically treat the XML file like a text file and do a search &amp; replace\n        if \"xpath\" in replacement:\n            logger.info(\n                \"Using xpath -&gt; %s to narrow down the replacement\",\n                replacement[\"xpath\"],\n            )\n            if \"setting\" in replacement:\n                logger.info(\n                    \"Looking up setting -&gt; %s in XML element\",\n                    replacement[\"setting\"],\n                )\n            if \"assoc_elem\" in replacement:\n                logger.info(\n                    \"Looking up assoc element -&gt; %s in XML element\",\n                    replacement[\"assoc_elem\"],\n                )\n        else:  # we have a simple \"search &amp; replace\" replacement\n            if not \"placeholder\" in replacement:\n                logger.error(\n                    \"Replacement without an xpath needs a placeholder value but it is not specified. Skipping...\"\n                )\n                continue\n            if replacement.get(\"placeholder\") == replacement[\"value\"]:\n                logger.info(\n                    \"Placeholder and replacement are identical -&gt; %s. Skipping...\",\n                    replacement[\"value\"],\n                )\n                continue\n            logger.info(\n                \"Replace -&gt; %s with -&gt; %s in Transport package -&gt; %s\",\n                replacement[\"placeholder\"],\n                replacement[\"value\"],\n                zip_file_folder,\n            )\n\n        found = XML.replace_in_xml_files(\n            zip_file_folder,\n            replacement.get(\"placeholder\"),\n            replacement[\"value\"],\n            replacement.get(\"xpath\"),\n            replacement.get(\"setting\"),\n            replacement.get(\"assoc_elem\"),\n        )\n        if found:\n            logger.info(\n                \"Replacement -&gt; %s has been completed successfully for Transport package -&gt; %s\",\n                replacement,\n                zip_file_folder,\n            )\n            modified = True\n        else:\n            logger.warning(\n                \"Replacement -&gt; %s not found in Transport package -&gt; %s\",\n                replacement,\n                zip_file_folder,\n            )\n\n    if not modified:\n        logger.warning(\n            \"None of the specified replacements have been found in Transport package -&gt; %s. No need to create a new transport package.\",\n            zip_file_folder,\n        )\n        return False\n\n    # Create the new zip file and add all files from the directory to it\n    new_zip_file_path = (\n        os.path.dirname(zip_file_path) + \"/new_\" + os.path.basename(zip_file_path)\n    )\n    logger.info(\n        \"Content of transport -&gt; %s has been modified - repacking to new zip file -&gt; %s\",\n        zip_file_folder,\n        new_zip_file_path,\n    )\n    with zipfile.ZipFile(new_zip_file_path, \"w\", zipfile.ZIP_DEFLATED) as zip_ref:\n        for subdir, _, files in os.walk(\n            zip_file_folder\n        ):  # 2nd parameter is not used, thus using _ instead of dirs\n            for file in files:\n                file_path = os.path.join(subdir, file)\n                rel_path = os.path.relpath(file_path, zip_file_folder)\n                zip_ref.write(file_path, arcname=rel_path)\n\n    # Close the new zip file and delete the temporary directory\n    zip_ref.close()\n    old_zip_file_path = (\n        os.path.dirname(zip_file_path) + \"/old_\" + os.path.basename(zip_file_path)\n    )\n    logger.info(\n        \"Rename orginal transport zip file -&gt; %s to -&gt; %s\",\n        zip_file_path,\n        old_zip_file_path,\n    )\n    os.rename(zip_file_path, old_zip_file_path)\n    logger.info(\n        \"Rename new transport zip file -&gt; %s to -&gt; %s\",\n        new_zip_file_path,\n        zip_file_path,\n    )\n    os.rename(new_zip_file_path, zip_file_path)\n\n    # Return the path to the new zip file\n    return True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.request_download_header","title":"<code>request_download_header()</code>","text":"<p>Deliver the request header used for the CRUD REST API calls.    Consists of Cookie + Form Headers (see global vasriable)</p> <p>Return:     dict: request header values</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def request_download_header(self) -&gt; dict:\n    \"\"\"Deliver the request header used for the CRUD REST API calls.\n       Consists of Cookie + Form Headers (see global vasriable)\n\n    Args:\n        None.\n    Return:\n        dict: request header values\n    \"\"\"\n\n    # create union of two dicts: cookie and headers\n    # (with Python 3.9 this would be easier with the \"|\" operator)\n    request_header = {}\n    request_header.update(self.cookie())\n    request_header.update(REQUEST_DOWNLOAD_HEADERS)\n\n    return request_header\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.request_form_header","title":"<code>request_form_header()</code>","text":"<p>Deliver the request header used for the CRUD REST API calls.    Consists of Cookie + Form Headers (see global variable)</p> <p>Return:     dict: request header values</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def request_form_header(self) -&gt; dict:\n    \"\"\"Deliver the request header used for the CRUD REST API calls.\n       Consists of Cookie + Form Headers (see global variable)\n\n    Args:\n        None.\n    Return:\n        dict: request header values\n    \"\"\"\n\n    # create union of two dicts: cookie and headers\n    # (with Python 3.9 this would be easier with the \"|\" operator)\n    request_header = {}\n    request_header.update(self.cookie())\n    request_header.update(REQUEST_FORM_HEADERS)\n\n    return request_header\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.request_json_header","title":"<code>request_json_header()</code>","text":"<p>Deliver the request header for REST calls that require content type application/json.    Consists of Cookie + Json Headers (see global variable)</p> <p>Return:     dict: request header values</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def request_json_header(self) -&gt; dict:\n    \"\"\"Deliver the request header for REST calls that require content type application/json.\n       Consists of Cookie + Json Headers (see global variable)\n\n    Args:\n        None.\n    Return:\n        dict: request header values\n    \"\"\"\n\n    # create union of two dicts: cookie and headers\n    # (with Python 3.9 this would be easier with the \"|\" operator)\n    request_header = {}\n    request_header.update(self.cookie())\n    request_header.update(REQUEST_JSON_HEADERS)\n\n    return request_header\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.rest_url","title":"<code>rest_url()</code>","text":"<p>Returns the REST URL of Extended ECM</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>REST URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def rest_url(self) -&gt; str:\n    \"\"\"Returns the REST URL of Extended ECM\n\n    Returns:\n        str: REST URL\n    \"\"\"\n    return self.config()[\"restUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.run_web_report","title":"<code>run_web_report(nickname, web_report_parameters=None)</code>","text":"<p>Run a Web Report that is identified by its nick name.</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>str</code> <p>nickname of the Web Reports node.</p> required <code>web_report_parameters</code> <code>dict</code> <p>Parameters of the Web Report (names + value pairs)</p> <code>None</code> <p>Returns:     dict: Response of the run Web Report request or None if the Web Report execution has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def run_web_report(\n    self, nickname: str, web_report_parameters: dict | None = None\n) -&gt; dict | None:\n    \"\"\"Run a Web Report that is identified by its nick name.\n\n    Args:\n        nickname (str): nickname of the Web Reports node.\n        web_report_parameters (dict): Parameters of the Web Report (names + value pairs)\n    Returns:\n        dict: Response of the run Web Report request or None if the Web Report execution has failed.\n    \"\"\"\n\n    # Avoid linter warning W0102:\n    if web_report_parameters is None:\n        web_report_parameters = {}\n\n    request_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Running Web Report with nickname -&gt; %s; calling -&gt; %s\",\n        nickname,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=web_report_parameters,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to run web report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                nickname,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.search","title":"<code>search(search_term, look_for='complexQuery', modifier='', slice_id=0, query_id=0, template_id=0, limit=100, page=1)</code>","text":"<p>Search for a search term.</p> <p>Parameters:</p> Name Type Description Default <code>search_term</code> <code>str), e.g. \"test or OTSubType</code> <p>189\"</p> required <code>look_for</code> <code>str</code> <p>'allwords', 'anywords', 'exactphrase', and 'complexquery'.                       If not specified, it defaults to 'complexQuery'.</p> <code>'complexQuery'</code> <code>modifier</code> <code>str</code> <p>'synonymsof', 'relatedto', 'soundslike', 'wordbeginswith',                       and 'wordendswith'.                       If not specified or specify any value other than the available options,                       it will be ignored.</p> <code>''</code> <code>slice_id</code> <code>int</code> <p>ID of an existing search slice</p> <code>0</code> <code>query_id</code> <code>int</code> <p>ID of an saved search query</p> <code>0</code> <code>template_id</code> <code>int</code> <p>ID of an saved search template</p> <code>0</code> <code>limit</code> <code>int</code> <p>maximum number of results (default = 100)</p> <code>100</code> <code>page</code> <code>int</code> <p>number of result page (default = 1 = 1st page)</p> <code>1</code> <p>Returns:     dict: search response or None if the search fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def search(\n    self,\n    search_term: str,\n    look_for: str = \"complexQuery\",\n    modifier: str = \"\",\n    slice_id: int = 0,\n    query_id: int = 0,\n    template_id: int = 0,\n    limit: int = 100,\n    page: int = 1,\n) -&gt; dict | None:\n    \"\"\"Search for a search term.\n\n    Args:\n        search_term (str), e.g. \"test or OTSubType: 189\"\n        look_for (str, optional): 'allwords', 'anywords', 'exactphrase', and 'complexquery'.\n                                  If not specified, it defaults to 'complexQuery'.\n        modifier (str, optional): 'synonymsof', 'relatedto', 'soundslike', 'wordbeginswith',\n                                  and 'wordendswith'.\n                                  If not specified or specify any value other than the available options,\n                                  it will be ignored.\n        slice_id (int, optional): ID of an existing search slice\n        query_id (int, optional): ID of an saved search query\n        template_id (int, optional): ID of an saved search template\n        limit (int, optional): maximum number of results (default = 100)\n        page (int, optional): number of result page (default = 1 = 1st page)\n    Returns:\n        dict: search response or None if the search fails.\n    \"\"\"\n\n    search_post_body = {\n        \"where\": search_term,\n        \"lookfor\": look_for,\n        \"page\": page,\n        \"limit\": limit,\n    }\n\n    if modifier:\n        search_post_body[\"modifier\"] = modifier\n    if slice_id &gt; 0:\n        search_post_body[\"slice_id\"] = slice_id\n    if query_id &gt; 0:\n        search_post_body[\"query_id\"] = query_id\n    if template_id &gt; 0:\n        search_post_body[\"template_id\"] = template_id\n\n    request_url = self.config()[\"searchUrl\"]\n    request_header = self.request_form_header()\n\n    logger.info(\"Search for term -&gt; %s; calling -&gt; %s\", search_term, request_url)\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=search_post_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to search for term -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                search_term,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.search_user","title":"<code>search_user(value, field='where_name')</code>","text":"<p>Find a user based on search criteria.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>field value</p> required <code>field</code> <code>str</code> <p>user field to search with (where_name, where_first_name, where_last_name)</p> <code>'where_name'</code> <p>Returns:     dict: User information or None if the user couldn't be found (e.g. because it doesn't exist).</p> <pre><code>Example response:\n{\n    'collection': {\n        'paging': {...},\n        'sorting': {...}\n    },\n    'links': {\n        'data': {...}\n    },\n    'results': [\n        {\n            'data': {\n                'properties': {\n                    'birth_date': None,\n                    'business_email': 'dfoxhoven@M365x61936377.onmicrosoft.com',\n                    'business_fax': None,\n                    'business_phone': None,\n                    'cell_phone': None,\n                    'deleted': False,\n                    'display_language': None,\n                    'first_name': 'Deke',\n                    'gender': None,\n                    'group_id': 8005,\n                    'home_address_1': None,\n                    'home_address_2': None,\n                    'home_fax': None,\n                    'home_phone': None,\n                    'id': 8562,\n                    'initials': 'DF',\n                    'last_name': 'Foxhoven',\n                    'middle_name': None,\n                    'name': 'dfoxhoven',\n                    'name_formatted': 'Deke Foxhoven',\n                    ...\n                }\n            }\n        }\n    ]\n}\n</code></pre> Source code in <code>pyxecm/otcs.py</code> <pre><code>def search_user(self, value: str, field: str = \"where_name\") -&gt; dict | None:\n    \"\"\"Find a user based on search criteria.\n\n    Args:\n        value (str): field value\n        field (str): user field to search with (where_name, where_first_name, where_last_name)\n    Returns:\n        dict: User information or None if the user couldn't be found (e.g. because it doesn't exist).\n\n        Example response:\n        {\n            'collection': {\n                'paging': {...},\n                'sorting': {...}\n            },\n            'links': {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data': {\n                        'properties': {\n                            'birth_date': None,\n                            'business_email': 'dfoxhoven@M365x61936377.onmicrosoft.com',\n                            'business_fax': None,\n                            'business_phone': None,\n                            'cell_phone': None,\n                            'deleted': False,\n                            'display_language': None,\n                            'first_name': 'Deke',\n                            'gender': None,\n                            'group_id': 8005,\n                            'home_address_1': None,\n                            'home_address_2': None,\n                            'home_fax': None,\n                            'home_phone': None,\n                            'id': 8562,\n                            'initials': 'DF',\n                            'last_name': 'Foxhoven',\n                            'middle_name': None,\n                            'name': 'dfoxhoven',\n                            'name_formatted': 'Deke Foxhoven',\n                            ...\n                        }\n                    }\n                }\n            ]\n        }\n    \"\"\"\n\n    request_url = self.config()[\"membersUrlv2\"] + \"?\" + field + \"=\" + value\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Searching user by field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\n        field,\n        value,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Cannot find user with -&gt; %s = %s; status -&gt; %s; error -&gt; %s\",\n                field,\n                value,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.set_category_value","title":"<code>set_category_value(node_id, value, category_id, attribute_id, set_id=0, set_row=1)</code>","text":"<p>Set a value to a specific attribute in a category. Categories and have sets (groupings), multi-line sets (matrix),    and multi-value attributes (list of values). This method supports all variants.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node</p> required <code>value</code> <code>multi - typed</code> <p>value to be set - can be string or list of strings (for multi-value attributes)</p> required <code>category_id</code> <code>int</code> <p>ID of the category object</p> required <code>attribute_id</code> <code>int</code> <p>ID of the attribute</p> required <code>set_id</code> <code>int</code> <p>ID of the set. Defaults to 0.</p> <code>0</code> <code>set_row</code> <code>int</code> <p>Row of . Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>REST API response or None if the call fails</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def set_category_value(\n    self,\n    node_id: int,\n    value,\n    category_id: int,\n    attribute_id: int,\n    set_id: int = 0,\n    set_row: int = 1,\n) -&gt; dict | None:\n    \"\"\"Set a value to a specific attribute in a category. Categories and have sets (groupings), multi-line sets (matrix),\n       and multi-value attributes (list of values). This method supports all variants.\n\n    Args:\n        node_id (int): ID of the node\n        value (multi-typed): value to be set - can be string or list of strings (for multi-value attributes)\n        category_id (int):ID of the category object\n        attribute_id (int): ID of the attribute\n        set_id (int, optional): ID of the set. Defaults to 0.\n        set_row (int, optional): Row of . Defaults to 1.\n\n    Returns:\n        dict: REST API response or None if the call fails\n    \"\"\"\n\n    request_url = (\n        self.config()[\"nodesUrlv2\"]\n        + \"/\"\n        + str(node_id)\n        + \"/categories/\"\n        + str(category_id)\n    )\n    request_header = self.request_form_header()\n\n    if set_id:\n        logger.info(\n            \"Assign value -&gt; %s to category with ID -&gt; %s, set ID -&gt; %s, row -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\n            str(value),\n            str(category_id),\n            str(set_id),\n            str(set_row),\n            str(attribute_id),\n            str(node_id),\n            request_url,\n        )\n        category_put_data = {\n            \"category_id\": category_id,\n            \"{}_{}_{}_{}\".format(category_id, set_id, set_row, attribute_id): value,\n        }\n    else:\n        logger.info(\n            \"Assign value -&gt; %s to category ID -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\n            str(value),\n            str(category_id),\n            str(attribute_id),\n            str(node_id),\n            request_url,\n        )\n        category_put_data = {\n            \"category_id\": category_id,\n            \"{}_{}\".format(category_id, attribute_id): value,\n        }\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            data=category_put_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to set value -&gt; %s for category with ID -&gt; %s, attribute ID -&gt; %s on node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(value),\n                str(category_id),\n                str(attribute_id),\n                str(node_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.set_credentials","title":"<code>set_credentials(username='admin', password='')</code>","text":"<p>Set the credentials for Extended ECM for the based on user name and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username. Defaults to \"admin\".</p> <code>'admin'</code> <code>password</code> <code>str</code> <p>Password of the user. Defaults to \"\".</p> <code>''</code> Source code in <code>pyxecm/otcs.py</code> <pre><code>def set_credentials(self, username: str = \"admin\", password: str = \"\"):\n    \"\"\"Set the credentials for Extended ECM for the based on user name and password.\n\n    Args:\n        username (str, optional): Username. Defaults to \"admin\".\n        password (str, optional): Password of the user. Defaults to \"\".\n    \"\"\"\n    self.config()[\"username\"] = username\n    self.config()[\"password\"] = password\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.set_hostname","title":"<code>set_hostname(hostname)</code>","text":"<p>Sets the hostname of Extended ECM</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>new hostname</p> required Source code in <code>pyxecm/otcs.py</code> <pre><code>def set_hostname(self, hostname: str):\n    \"\"\"Sets the hostname of Extended ECM\n\n    Args:\n        hostname (str): new hostname\n    \"\"\"\n    self.config()[\"hostname\"] = hostname\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.set_node_nickname","title":"<code>set_node_nickname(node_id, nickname, show_error=False)</code>","text":"<p>Assign a nickname to an Extended ECM node (e.g. workspace)</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>str</code> <p>Nickname of the node.</p> required <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:     dict: Node information or None if no node with this nickname is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def set_node_nickname(\n    self, node_id: int, nickname: str, show_error: bool = False\n) -&gt; dict | None:\n    \"\"\"Assign a nickname to an Extended ECM node (e.g. workspace)\n\n    Args:\n        nickname (str): Nickname of the node.\n        show_error (bool): treat as error if node is not found\n    Returns:\n        dict: Node information or None if no node with this nickname is found.\n    \"\"\"\n\n    nickname_put_body = {\"nickname\": nickname}\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/nicknames\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Assign nickname -&gt; %s to node with ID -&gt; %s; calling -&gt; %s\",\n        nickname,\n        node_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            data=nickname_put_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to assign nickname -&gt; %s to node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    nickname,\n                    node_id,\n                    response.status_code,\n                    response.text,\n                )\n            else:\n                logger.info(\n                    \"Cannot assign nickname -&gt; %s to node ID -&gt; %s. Maybe the nickname is already in use or the node does not exist.\",\n                    nickname,\n                    node_id,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.unpack_transport_package","title":"<code>unpack_transport_package(package_id, workbench_id)</code>","text":"<p>Unpack an existing Transport Package into an existing Workbench.</p> <p>Parameters:</p> Name Type Description Default <code>package_id</code> <code>int</code> <p>ID of package to be unpacked</p> required <code>workbench_id</code> <code>int</code> <p>ID of target workbench</p> required <p>Returns:     dict: Unpack response or None if the unpacking fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def unpack_transport_package(\n    self, package_id: int, workbench_id: int\n) -&gt; dict | None:\n    \"\"\"Unpack an existing Transport Package into an existing Workbench.\n\n    Args:\n        package_id (int): ID of package to be unpacked\n        workbench_id (int): ID of target workbench\n    Returns:\n        dict: Unpack response or None if the unpacking fails.\n    \"\"\"\n\n    unpack_package_post_data = {\"workbench_id\": workbench_id}\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(package_id) + \"/unpack\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Unpack transport package with ID -&gt; %s into workbench with ID -&gt; %s; calling -&gt; %s\",\n        str(package_id),\n        str(workbench_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=unpack_package_post_data,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to unpack package -&gt; %s; to workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(package_id),\n                str(workbench_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_item","title":"<code>update_item(node_id, parent_id=0, item_name='', item_description='')</code>","text":"<p>Update an Extended ECM item (parent, name, description). Changing the parent ID is    a move operation. If parent ID = 0 the item will not be moved.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node</p> required <code>parent_id</code> <code>int</code> <p>node ID of the new parent (in case of a move operation)</p> <code>0</code> <code>item_name</code> <code>str</code> <p>new name of the item</p> <code>''</code> <code>item_description</code> <code>str</code> <p>new description of the item</p> <code>''</code> <p>Returns:     dict: Response of the update item request or None if the REST call has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_item(\n    self,\n    node_id: int,\n    parent_id: int = 0,\n    item_name: str = \"\",\n    item_description: str = \"\",\n) -&gt; dict | None:\n    \"\"\"Update an Extended ECM item (parent, name, description). Changing the parent ID is\n       a move operation. If parent ID = 0 the item will not be moved.\n\n    Args:\n        node_id (int): ID of the node\n        parent_id (int, optional): node ID of the new parent (in case of a move operation)\n        item_name (str, optional): new name of the item\n        item_description (str, optional): new description of the item\n    Returns:\n        dict: Response of the update item request or None if the REST call has failed.\n    \"\"\"\n\n    update_item_put_data = {}\n\n    if item_name:\n        # this is a rename operation\n        update_item_put_data[\"name\"] = item_name\n    if item_description:\n        # this is a change description operation\n        update_item_put_data[\"description\"] = item_description\n    if parent_id:\n        # this is a move operation\n        update_item_put_data[\"parent_id\"] = parent_id\n\n    request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Update item -&gt; %s with data -&gt; %s; calling -&gt; %s\",\n        item_name,\n        str(update_item_put_data),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        response = requests.put(\n            url=request_url,\n            data={\"body\": json.dumps(update_item_put_data)},\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update item -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                item_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_records_management_codes","title":"<code>update_records_management_codes(rm_codes)</code>","text":"<p>Update Records Management Codes. These are the most basic data types of    the Records Management configuration and required to create RSIs and    other higher-level Records Management configurations    THIS METHOD IS CURRENTLY NOT WORKING</p> <p>Parameters:</p> Name Type Description Default <code>rm_codes</code> <code>dict</code> <p>Codes to be updated</p> required <p>Returns:     dict: RSI data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_records_management_codes(self, rm_codes: dict) -&gt; dict | None:\n    \"\"\"Update Records Management Codes. These are the most basic data types of\n       the Records Management configuration and required to create RSIs and\n       other higher-level Records Management configurations\n       THIS METHOD IS CURRENTLY NOT WORKING\n\n    Args:\n        rm_codes (dict): Codes to be updated\n    Returns:\n        dict: RSI data or None if the request fails.\n    \"\"\"\n\n    update_rm_codes_post_data = {}\n\n    request_url = self.config()[\"recordsManagementUrl\"] + \"/rmcodes\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Update Records Management codes -&gt; %s; calling -&gt; %s\",\n        str(rm_codes),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            headers=request_header,\n            data=update_rm_codes_post_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            rm_codes_dict = self.parse_request_response(response)\n            return rm_codes_dict[\"results\"][\"data\"]\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update Records Management codes; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_user","title":"<code>update_user(user_id, field, value)</code>","text":"<p>Update a defined field for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>value</code> <code>str</code> <p>field value</p> required <code>field</code> <code>str</code> <p>user field</p> required <p>Returns:     dict: User information or None if the user couldn't be updated (e.g. because it doesn't exist).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_user(self, user_id: int, field: str, value: str) -&gt; dict | None:\n    \"\"\"Update a defined field for a user.\n\n    Args:\n        user_id (int): ID of the user\n        value (str): field value\n        field (str): user field\n    Returns:\n        dict: User information or None if the user couldn't be updated (e.g. because it doesn't exist).\n    \"\"\"\n\n    user_put_body = {field: value}\n\n    request_url = self.config()[\"membersUrlv2\"] + \"/\" + str(user_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Updating user with ID -&gt; %s, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\n        str(user_id),\n        field,\n        value,\n        request_url,\n    )\n    logger.debug(\"User Attributes -&gt; %s\", str(user_put_body))\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            data=user_put_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(user_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_user_photo","title":"<code>update_user_photo(user_id, photo_id)</code>","text":"<p>Update a user with a profile photo (which must be an existing node).</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>photo_id</code> <code>int</code> <p>Node ID of the photo</p> required <p>Returns:     dict: Node information or None if photo node is not found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_user_photo(self, user_id: int, photo_id: int) -&gt; dict | None:\n    \"\"\"Update a user with a profile photo (which must be an existing node).\n\n    Args:\n        user_id (int): ID of the user\n        photo_id (int): Node ID of the photo\n    Returns:\n        dict: Node information or None if photo node is not found.\n    \"\"\"\n\n    update_user_put_body = {\"photo_id\": photo_id}\n\n    request_url = self.config()[\"membersUrl\"] + \"/\" + str(user_id)\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Update user ID -&gt; %s with photo ID -&gt; %s; calling -&gt; %s\",\n        user_id,\n        photo_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            data=update_user_put_body,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(user_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_user_profile","title":"<code>update_user_profile(field, value, config_section='SmartUI')</code>","text":"<p>Update a defined field for a user profile.    IMPORTANT: this method needs to be called by the authenticated user</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>user profile field</p> required <code>value</code> <code>str</code> <p>new field value</p> required <code>config_section</code> <code>str</code> <p>name of the config section. Possible config_section values:                             * SmartUI                             * General                             * Colors                             * ContentIntelligence                             * Discussion                             * Follow Up                             * Template Workspaces                             * Workflow                             * XECMGOVSettings                             * CommunitySettings                             * RecMan                             * PhysObj</p> <code>'SmartUI'</code> <p>Returns:     dict: User information or None if the user couldn't be updated           (e.g. because it doesn't exist).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_user_profile(\n    self, field: str, value: str, config_section: str = \"SmartUI\"\n) -&gt; dict | None:\n    \"\"\"Update a defined field for a user profile.\n       IMPORTANT: this method needs to be called by the authenticated user\n\n    Args:\n        field (str): user profile field\n        value (str): new field value\n        config_section (str, optional): name of the config section. Possible config_section values:\n                                        * SmartUI\n                                        * General\n                                        * Colors\n                                        * ContentIntelligence\n                                        * Discussion\n                                        * Follow Up\n                                        * Template Workspaces\n                                        * Workflow\n                                        * XECMGOVSettings\n                                        * CommunitySettings\n                                        * RecMan\n                                        * PhysObj\n    Returns:\n        dict: User information or None if the user couldn't be updated\n              (e.g. because it doesn't exist).\n    \"\"\"\n\n    user_profile_put_body = {config_section: {field: value}}\n\n    request_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\n    request_header = self.request_form_header()\n\n    logger.info(\n        \"Updating profile for current user, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\n        field,\n        value,\n        request_url,\n    )\n    logger.debug(\"User Attributes -&gt; %s\", str(user_profile_put_body))\n\n    retries = 0\n    while True:\n        # This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n        response = requests.put(\n            url=request_url,\n            data={\"body\": json.dumps(user_profile_put_body)},\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update profile of current user; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_workspace_aviator","title":"<code>update_workspace_aviator(workspace_id, status)</code>","text":"<p>Enable or disable the Content Aviator for a workspace</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>node ID of the workspace</p> required <code>status</code> <code>bool</code> <p>True = enable, False = disable Content Aviator for this workspace</p> required <p>Returns:     dict: REST response or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_workspace_aviator(\n    self,\n    workspace_id: int,\n    status: bool,\n) -&gt; dict | None:\n    \"\"\"Enable or disable the Content Aviator for a workspace\n\n    Args:\n        workspace_id (int): node ID of the workspace\n        status (bool): True = enable, False = disable Content Aviator for this workspace\n    Returns:\n        dict: REST response or None if the REST call fails.\n    \"\"\"\n\n    aviator_status_put_data = {\n        \"enabled\": status,\n    }\n\n    request_url = self.config()[\"aiUrl\"] + \"/{}\".format(workspace_id)\n    request_header = self.request_form_header()\n\n    if status is True:\n        logger.info(\n            \"Enable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(workspace_id),\n            request_url,\n        )\n    else:\n        logger.info(\n            \"Disable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\n            str(workspace_id),\n            request_url,\n        )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            headers=request_header,\n            data=aviator_status_put_data,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to change status for Content Aviator on workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(workspace_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_workspace_icon","title":"<code>update_workspace_icon(workspace_id, file_path, file_mimetype='image/*')</code>","text":"<p>Update a workspace with a with a new icon (which is uploaded).</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>file_path</code> <code>str</code> <p>path + filename of icon file</p> required <code>file_mimetype</code> <code>str</code> <p>mimetype of the image</p> <code>'image/*'</code> <p>Returns:     dict: Node information or None if REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_workspace_icon(\n    self, workspace_id: int, file_path: str, file_mimetype: str = \"image/*\"\n) -&gt; dict | None:\n    \"\"\"Update a workspace with a with a new icon (which is uploaded).\n\n    Args:\n        workspace_id (int): ID of the workspace\n        file_path (str): path + filename of icon file\n        file_mimetype (str, optional): mimetype of the image\n    Returns:\n        dict: Node information or None if REST call fails.\n    \"\"\"\n\n    if not os.path.exists(file_path):\n        logger.error(\"Workspace icon file does not exist -&gt; %s\", file_path)\n        return None\n\n    update_workspace_icon_post_body = {\n        \"file_content_type\": file_mimetype,\n        \"file_filename\": os.path.basename(file_path),\n    }\n\n    upload_workspace_icon_post_files = [\n        (\n            \"file\",\n            (\n                f\"{os.path.basename(file_path)}\",\n                open(file_path, \"rb\"),\n                file_mimetype,\n            ),\n        )\n    ]\n\n    request_url = (\n        self.config()[\"businessWorkspacesUrl\"] + \"/\" + str(workspace_id) + \"/icons\"\n    )\n\n    request_header = self.cookie()\n\n    logger.info(\n        \"Update icon for workspace ID -&gt; %s with icon file -&gt; %s; calling -&gt; %s\",\n        str(workspace_id),\n        file_path,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=update_workspace_icon_post_body,\n            files=upload_workspace_icon_post_files,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update workspace ID -&gt; %s with new icon -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                str(workspace_id),\n                file_path,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.upload_file_to_parent","title":"<code>upload_file_to_parent(file_url, file_name, mime_type, parent_id)</code>","text":"<p>Fetch a file from a URL or local filesystem and upload it to a Content Server parent (folder).</p> <p>Parameters:</p> Name Type Description Default <code>file_url</code> <code>str</code> <p>URL to download file or local file</p> required <code>file_name</code> <code>str</code> <p>name of the file</p> required <code>mime_type</code> <code>str</code> <p>mimeType of the file</p> required <code>parent_id</code> <code>int</code> <p>parent (ID) of the file to upload</p> required <p>Returns:     dict: Upload response or None if the upload fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def upload_file_to_parent(\n    self, file_url: str, file_name: str, mime_type: str, parent_id: int\n) -&gt; dict | None:\n    \"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server parent (folder).\n\n    Args:\n        file_url (str): URL to download file or local file\n        file_name (str): name of the file\n        mime_type (str): mimeType of the file\n        parent_id (int): parent (ID) of the file to upload\n    Returns:\n        dict: Upload response or None if the upload fails.\n    \"\"\"\n\n    if file_url.startswith(\"http\"):\n        # Download file from remote location specified by the file_url parameter\n        # this must be a public place without authentication:\n        logger.info(\"Download file from URL -&gt; %s\", file_url)\n\n        try:\n            response = requests.get(url=file_url, timeout=1200)\n            response.raise_for_status()\n        except requests.exceptions.HTTPError as errh:\n            logger.error(\"Http Error -&gt; %s\", errh.strerror)\n            return None\n        except requests.exceptions.ConnectionError as errc:\n            logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n            return None\n        except requests.exceptions.Timeout as errt:\n            logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n            return None\n        except requests.exceptions.RequestException as err:\n            logger.error(\"Request error -&gt; %s\", err.strerror)\n            return None\n\n        logger.info(\n            \"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\n            file_url,\n            response.status_code,\n        )\n        file_content = response.content\n\n    elif os.path.exists(file_url):\n        logger.info(\"Uploading local file -&gt; %s\", file_url)\n        file_content = open(file=file_url, mode=\"rb\")\n\n    else:\n        logger.warning(\"Cannot access -&gt; %s\", file_url)\n        return None\n\n    upload_post_data = {\n        \"type\": str(144),\n        \"name\": file_name,\n        \"parent_id\": str(parent_id),\n    }\n    upload_post_files = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\n\n    request_url = self.config()[\"nodesUrlv2\"]\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\n\n    logger.info(\n        \"Uploading file -&gt; %s with mime type -&gt; %s to parent with ID -&gt; %s; calling -&gt; %s\",\n        file_name,\n        mime_type,\n        str(parent_id),\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=upload_post_data,\n            files=upload_post_files,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to upload file -&gt; %s to parent -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                file_url,\n                str(parent_id),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.upload_file_to_volume","title":"<code>upload_file_to_volume(package_url, file_name, mime_type, volume_type)</code>","text":"<p>Fetch a file from a URL or local filesystem and upload it to a Content Server volume.</p> <p>Parameters:</p> Name Type Description Default <code>package_url</code> <code>str</code> <p>URL to download file</p> required <code>file_name</code> <code>str</code> <p>name of the file</p> required <code>mime_type</code> <code>str</code> <p>mimeType of the file</p> required <code>volume_type</code> <code>int</code> <p>type (ID) of the volume</p> required <p>Returns:     dict: Upload response or None if the upload fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def upload_file_to_volume(\n    self, package_url: str, file_name: str, mime_type: str, volume_type: int\n) -&gt; dict | None:\n    \"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server volume.\n\n    Args:\n        package_url (str): URL to download file\n        file_name (str): name of the file\n        mime_type (str): mimeType of the file\n        volume_type (int): type (ID) of the volume\n    Returns:\n        dict: Upload response or None if the upload fails.\n    \"\"\"\n\n    if package_url.startswith(\"http\"):\n        # Download file from remote location specified by the packageUrl\n        # this must be a public place without authentication:\n        logger.info(\"Download transport package from URL -&gt; %s\", package_url)\n\n        try:\n            package = requests.get(url=package_url, timeout=1200)\n            package.raise_for_status()\n        except requests.exceptions.HTTPError as errh:\n            logger.error(\"Http Error -&gt; %s\", errh.strerror)\n            return None\n        except requests.exceptions.ConnectionError as errc:\n            logger.error(\"Error Connecting -&gt; %s\", errc.strerror)\n            return None\n        except requests.exceptions.Timeout as errt:\n            logger.error(\"Timeout Error -&gt; %s\", errt.strerror)\n            return None\n        except requests.exceptions.RequestException as err:\n            logger.error(\"Request error -&gt; %s\", err.strerror)\n            return None\n\n        logger.info(\n            \"Successfully downloaded package -&gt; %s; status code -&gt; %s\",\n            package_url,\n            package.status_code,\n        )\n        file = package.content\n\n    elif os.path.exists(package_url):\n        logger.info(\"Using local package -&gt; %s\", package_url)\n        file = open(file=package_url, mode=\"rb\")\n\n    else:\n        logger.warning(\"Cannot access -&gt; %s\", package_url)\n        return None\n\n    upload_post_data = {\"type\": str(volume_type), \"name\": file_name}\n    upload_post_files = [(\"file\", (f\"{file_name}\", file, mime_type))]\n\n    request_url = self.config()[\"nodesUrlv2\"]\n    request_header = (\n        self.cookie()\n    )  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\n\n    logger.info(\n        \"Uploading package -&gt; %s with mime type -&gt; %s; calling -&gt; %s\",\n        file_name,\n        mime_type,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            data=upload_post_data,\n            files=upload_post_files,\n            headers=request_header,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to upload file -&gt; %s to volume of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                package_url,\n                str(volume_type),\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.volume_translator","title":"<code>volume_translator(current_node_id, translator, languages, simulate=False)</code>","text":"<p>Experimental code to translate the item names and item descriptions in a given hierarchy.    The actual translation is done by a tranlator object. This recursive method just    traverses the hierarchy and calls the translate() method of the translator object.</p> <p>Parameters:</p> Name Type Description Default <code>current_node_id</code> <code>int</code> <p>current node ID to translate</p> required <code>translator</code> <code>object</code> <p>this object needs to be created based on the \"Translator\" class                  and passed to this method</p> required <code>languages</code> <code>list</code> <p>list of target languages</p> required <code>simulate</code> <code>bool</code> <p>if True, do not really rename but just traverse and log info.                        the default is False</p> <code>False</code> Source code in <code>pyxecm/otcs.py</code> <pre><code>def volume_translator(\n    self,\n    current_node_id: int,\n    translator: object,\n    languages: list,\n    simulate: bool = False,\n):\n    \"\"\"Experimental code to translate the item names and item descriptions in a given hierarchy.\n       The actual translation is done by a tranlator object. This recursive method just\n       traverses the hierarchy and calls the translate() method of the translator object.\n\n    Args:\n        current_node_id (int): current node ID to translate\n        translator (object): this object needs to be created based on the \"Translator\" class\n                             and passed to this method\n        languages (list): list of target languages\n        simulate (bool, optional): if True, do not really rename but just traverse and log info.\n                                   the default is False\n    \"\"\"\n    # Get current node based on the ID:\n    current_node = self.get_node(current_node_id)\n    current_node_id = self.get_result_value(current_node, \"id\")\n\n    name = self.get_result_value(current_node, \"name\")\n    description = self.get_result_value(current_node, \"description\")\n    names_multilingual = self.get_result_value(current_node, \"name_multilingual\")\n    descriptions_multilingual = self.get_result_value(\n        current_node, \"description_multilingual\"\n    )\n\n    for language in languages:\n        if language == \"en\":\n            continue\n        # Does the language not exist as metadata language or is it already translated?\n        # Then we skip this language:\n        if (\n            language in names_multilingual\n            and names_multilingual[\"en\"]\n            and not names_multilingual[language]\n        ):\n            names_multilingual[language] = translator.translate(\n                \"en\", language, names_multilingual[\"en\"]\n            )\n            logger.info(\n                \"Translate name of node -&gt; %s from -&gt; %s (%s) to -&gt; %s (%s)\",\n                current_node_id,\n                name,\n                \"en\",\n                names_multilingual[language],\n                language,\n            )\n        if (\n            language in descriptions_multilingual\n            and descriptions_multilingual[\"en\"]\n            and not descriptions_multilingual[language]\n        ):\n            descriptions_multilingual[language] = translator.translate(\n                \"en\", language, descriptions_multilingual[\"en\"]\n            )\n            logger.info(\n                \"Translate description of node -&gt; %s from -&gt; %s (%s) to -&gt; %s (%s)\",\n                current_node_id,\n                name,\n                \"en\",\n                names_multilingual[language],\n                language,\n            )\n\n    # Rename node multi-lingual:\n    if not simulate:\n        self.rename_node(\n            current_node_id,\n            name,\n            description,\n            names_multilingual,\n            descriptions_multilingual,\n        )\n\n    # Get children nodes of the current node:\n    results = self.get_subnodes(current_node_id, limit=200)[\"results\"]\n\n    # Recursive call of all subnodes:\n    for result in results:\n        self.volume_translator(\n            result[\"data\"][\"properties\"][\"id\"], translator, languages\n        )\n</code></pre>"},{"location":"pyxecm/otds/","title":"Directory Services (OTDS)","text":"<p>OTDS Module to implement functions to read / write OTDS objects such as Ressources, Users, Groups, Licenses, Trusted Sites, OAuth Clients, ...</p> <p>Important: userIDs consists of login name + \"@\" + partition name </p> <p>Class: OTDS Methods:</p> <p>init : class initializer config : returns config data set cookie : returns cookie information credentials: returns set of username and password</p> <p>base_url : returns OTDS base URL rest_url : returns OTDS REST base URL credential_url : returns the OTDS Credentials REST URL authHandler_url : returns the OTDS Authentication Handler REST URL partition_url : returns OTDS Partition REST URL access_role_url : returns OTDS Access Role REST URL oauth_client_url : returns OTDS OAuth Client REST URL resource_url : returns OTDS Resource REST URL license_url : returns OTDS License REST URL token_url : returns OTDS Token REST URL users_url : returns OTDS Users REST URL groups_url : returns OTDS Groups REST URL system_config_url : returns OTDS System Config REST URL consolidation_url: returns OTDS consolidation URL</p> <p>authenticate : authenticates at OTDS server</p> <p>add_license_to_resource : Add (or update) a product license to OTDS get_license_for_resource : Get list of licenses for a resource delete_license_from_resource : Delete a license from a resource assign_user_to_license : Assign an OTDS user to a product license (feature) in OTDS. assign_partition_to_license: Assign an OTDS user partition to a license (feature) in OTDS. get_licensed_objects: Return the licensed objects (users, groups, partitions) an OTDS for a                       license + license feature associated with an OTDS resource (like \"cs\"). is_user_licensed: Check if a user is licensed for a license and license feature associated                   with a particular OTDS resource. is_group_licensed: Check if a group is licensed for a license and license feature associated                    with a particular OTDS resource. is_partition_licensed: Check if a user partition is licensed for a license and license feature                        associated with a particular OTDS resource.</p> <p>add_partition : Add an OTDS partition get_partition : Get a partition with a specific name add_user : Add a user to a partion get_user : Get a user with a specific user ID (= login name @ partition) get_users: get all users (with option to filter) update_user : Update attributes of on OTDS user delete_user : Delete a user with a specific ID in a specific partition reset_user_password : Reset a password of a specific user ID add_group: Add an OTDS group get_group: Get a OTDS group by its name add_user_to_group : Add an OTDS user to a OTDS group add_group_to_parent_group : Add on OTDS group to a parent group</p> <p>add_resource : Add a new resource to OTDS get_resource : Get an OTDS resource with a specific name update_resource: Update an existing OTDS resource activate_resource : Activate an OTDS resource</p> <p>get_access_roles : Get all OTDS Access Roles get_access_role: Get an OTDS Access Role with a specific name add_partition_to_access_role : Add an OTDS Partition to to an OTDS Access Role add_user_to_access_role : Add an OTDS user to to an OTDS Access Role add_group_to_access_role : Add an OTDS group to to an OTDS Access Role update_access_role_attributes: Update attributes of an existing access role</p> <p>add_system_attribute : Add an OTDS System Attribute</p> <p>get_trusted_sites : Get OTDS Trusted Sites add_trusted_site : Add a new trusted site to OTDS</p> <p>enable_audit: enable OTDS audit</p> <p>add_oauth_client : Add a new OAuth client to OTDS get_oauth_client : Get an OAuth client with a specific client ID update_oauth_client : Update an OAuth client add_oauth_clients_to_access_role : Add an OTDS OAuth Client to an OTDS Access Role get_access_token : Get an OTDS Access Token</p> <p>get_auth_handler: Gen an auth handler with a given name add_auth_handler_saml: Add an authentication handler for SAML (e.g. for SuccessFactors) add_auth_handler_sap: Add an authentication handler for SAP add_auth_handler_oauth: Add an authentication handler for OAuth (used for Salesforce)</p> <p>consolidate: Consolidate an OTDS resource impersonate_resource: Configure impersonation for an OTDS resource impersonate_oauth_client: Configure impersonation for an OTDS OAuth Client</p> <p>get_password_policy: get the global password policy update_password_policy: updates the global password policy</p>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS","title":"<code>OTDS</code>","text":"<p>Used to automate stettings in OpenText Directory Services (OTDS).</p> Source code in <code>pyxecm/otds.py</code> <pre><code>class OTDS:\n    \"\"\"Used to automate stettings in OpenText Directory Services (OTDS).\"\"\"\n\n    _config = None\n    _cookie = None\n    _otds_ticket = None\n\n    def __init__(\n        self,\n        protocol: str,\n        hostname: str,\n        port: int,\n        username: str | None = None,\n        password: str | None = None,\n        otds_ticket: str | None = None,\n    ):\n        \"\"\"Initialize the OTDS object\n\n        Args:\n            protocol (str): either http or https\n            hostname (str): hostname of otds\n            port (int): port number - typically 80 or 443\n            username (str, optional): otds user name. Optional if otds_ticket is provided.\n            password (str, optional): otds password. Optional if otds_ticket is provided.\n            otds_ticket (str, optional): Authentication ticket of OTDS\n        \"\"\"\n\n        # Initialize otdsConfig as an empty dictionary\n        otds_config = {}\n\n        if hostname:\n            otds_config[\"hostname\"] = hostname\n        else:\n            otds_config[\"hostname\"] = \"otds\"\n\n        if protocol:\n            otds_config[\"protocol\"] = protocol\n        else:\n            otds_config[\"protocol\"] = \"http\"\n\n        if port:\n            otds_config[\"port\"] = port\n        else:\n            otds_config[\"port\"] = 80\n\n        if username:\n            otds_config[\"username\"] = username\n        else:\n            otds_config[\"username\"] = \"admin\"\n\n        if password:\n            otds_config[\"password\"] = password\n        else:\n            otds_config[\"password\"] = \"\"\n\n        if otds_ticket:\n            self._cookie = {\"OTDSTicket\": otds_ticket}\n\n        otdsBaseUrl = protocol + \"://\" + otds_config[\"hostname\"]\n        if str(port) not in [\"80\", \"443\"]:\n            otdsBaseUrl += \":{}\".format(port)\n        otdsBaseUrl += \"/otdsws\"\n        otds_config[\"baseUrl\"] = otdsBaseUrl\n\n        otdsRestUrl = otdsBaseUrl + \"/rest\"\n        otds_config[\"restUrl\"] = otdsRestUrl\n\n        otds_config[\"partitionUrl\"] = otdsRestUrl + \"/partitions\"\n        otds_config[\"accessRoleUrl\"] = otdsRestUrl + \"/accessroles\"\n        otds_config[\"credentialUrl\"] = otdsRestUrl + \"/authentication/credentials\"\n        otds_config[\"oauthClientUrl\"] = otdsRestUrl + \"/oauthclients\"\n        otds_config[\"tokenUrl\"] = otdsBaseUrl + \"/oauth2/token\"\n        otds_config[\"resourceUrl\"] = otdsRestUrl + \"/resources\"\n        otds_config[\"licenseUrl\"] = otdsRestUrl + \"/licensemanagement/licenses\"\n        otds_config[\"usersUrl\"] = otdsRestUrl + \"/users\"\n        otds_config[\"groupsUrl\"] = otdsRestUrl + \"/groups\"\n        otds_config[\"systemConfigUrl\"] = otdsRestUrl + \"/systemconfig\"\n        otds_config[\"authHandlerUrl\"] = otdsRestUrl + \"/authhandlers\"\n        otds_config[\"consolidationUrl\"] = otdsRestUrl + \"/consolidation\"\n\n        self._config = otds_config\n\n    def config(self) -&gt; dict:\n        \"\"\"Returns the configuration dictionary\n\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\n        return self._config\n\n    def cookie(self) -&gt; dict:\n        \"\"\"Returns the login cookie of OTDS.\n           This is set by the authenticate() method\n\n        Returns:\n            dict: OTDS cookie\n        \"\"\"\n        return self._cookie\n\n    def credentials(self) -&gt; dict:\n        \"\"\"Returns the credentials (username + password)\n\n        Returns:\n            dict: dictionary with username and password\n        \"\"\"\n        return {\n            \"userName\": self.config()[\"username\"],\n            \"password\": self.config()[\"password\"],\n        }\n\n    def base_url(self) -&gt; str:\n        \"\"\"Returns the base URL of OTDS\n\n        Returns:\n            str: base URL\n        \"\"\"\n        return self.config()[\"baseUrl\"]\n\n    def rest_url(self) -&gt; str:\n        \"\"\"Returns the REST URL of OTDS\n\n        Returns:\n            str: REST URL\n        \"\"\"\n        return self.config()[\"restUrl\"]\n\n    def credential_url(self) -&gt; str:\n        \"\"\"Returns the Credentials URL of OTDS\n\n        Returns:\n            str: Credentials URL\n        \"\"\"\n        return self.config()[\"credentialUrl\"]\n\n    def auth_handler_url(self) -&gt; str:\n        \"\"\"Returns the Auth Handler URL of OTDS\n\n        Returns:\n            str: Auth Handler URL\n        \"\"\"\n        return self.config()[\"authHandlerUrl\"]\n\n    def partition_url(self) -&gt; str:\n        \"\"\"Returns the Partition URL of OTDS\n\n        Returns:\n            str: Partition URL\n        \"\"\"\n        return self.config()[\"partitionUrl\"]\n\n    def access_role_url(self) -&gt; str:\n        \"\"\"Returns the Access Role URL of OTDS\n\n        Returns:\n            str: Access Role URL\n        \"\"\"\n        return self.config()[\"accessRoleUrl\"]\n\n    def oauth_client_url(self) -&gt; str:\n        \"\"\"Returns the OAuth Client URL of OTDS\n\n        Returns:\n            str: OAuth Client URL\n        \"\"\"\n        return self.config()[\"oauthClientUrl\"]\n\n    def resource_url(self) -&gt; str:\n        \"\"\"Returns the Resource URL of OTDS\n\n        Returns:\n            str: Resource URL\n        \"\"\"\n        return self.config()[\"resourceUrl\"]\n\n    def license_url(self) -&gt; str:\n        \"\"\"Returns the License URL of OTDS\n\n        Returns:\n            str: License URL\n        \"\"\"\n        return self.config()[\"licenseUrl\"]\n\n    def token_url(self) -&gt; str:\n        \"\"\"Returns the Token URL of OTDS\n\n        Returns:\n            str: Token URL\n        \"\"\"\n        return self.config()[\"tokenUrl\"]\n\n    def users_url(self) -&gt; str:\n        \"\"\"Returns the Users URL of OTDS\n\n        Returns:\n            str: Users URL\n        \"\"\"\n        return self.config()[\"usersUrl\"]\n\n    def groups_url(self) -&gt; str:\n        \"\"\"Returns the Groups URL of OTDS\n\n        Returns:\n            str: Groups URL\n        \"\"\"\n        return self.config()[\"groupsUrl\"]\n\n    def system_config_url(self) -&gt; str:\n        \"\"\"Returns the System Config URL of OTDS\n\n        Returns:\n            str: System Config URL\n        \"\"\"\n        return self.config()[\"systemConfigUrl\"]\n\n    def consolidation_url(self) -&gt; str:\n        \"\"\"Returns the Consolidation URL of OTDS\n\n        Returns:\n            str: Consolidation URL\n        \"\"\"\n        return self.config()[\"consolidationUrl\"]\n\n    def parse_request_response(\n        self,\n        response_object: object,\n        additional_error_message: str = \"\",\n        show_error: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Converts the request response to a Python dict in a safe way\n           that also handles exceptions.\n\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str): print a custom error message\n            show_error (bool): if True log an error, if False log a warning\n        Returns:\n            dict: response dictionary or None in case of an error\n        \"\"\"\n\n        if not response_object:\n            return None\n\n        try:\n            dict_object = json.loads(response_object.text)\n        except json.JSONDecodeError as e:\n            if additional_error_message:\n                message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                    additional_error_message, e\n                )\n            else:\n                message = \"Cannot decode response as JSon; error -&gt; {}\".format(e)\n            if show_error:\n                logger.error(message)\n            else:\n                logger.warning(message)\n            return None\n        else:\n            return dict_object\n\n    # end method definition\n\n    def authenticate(self, revalidate: bool = False) -&gt; dict | None:\n        \"\"\"Authenticate at Directory Services and retrieve OTCS Ticket.\n\n        Args:\n            revalidate (bool, optional): determine if a re-athentication is enforced\n                                         (e.g. if session has timed out with 401 error)\n        Returns:\n            dict: Cookie information. Also stores cookie information in self._cookie\n        \"\"\"\n\n        # Already authenticated and session still valid?\n        if self._cookie and not revalidate:\n            logger.info(\n                \"Session still valid - return existing cookie -&gt; %s\",\n                str(self._cookie),\n            )\n            return self._cookie\n\n        otds_ticket = \"NotSet\"\n\n        logger.info(\"Requesting OTDS ticket from -&gt; %s\", self.credential_url())\n\n        response = None\n        try:\n            response = requests.post(\n                url=self.credential_url(),\n                json=self.credentials(),\n                headers=REQUEST_HEADERS,\n                timeout=None,\n            )\n        except requests.exceptions.RequestException as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s; error -&gt; %s\",\n                self.credential_url(),\n                exception.strerror,\n            )\n            logger.warning(\"OTDS service may not be ready yet.\")\n            return None\n\n        if response.ok:\n            authenticate_dict = self.parse_request_response(response)\n            if not authenticate_dict:\n                return None\n            else:\n                otds_ticket = authenticate_dict[\"ticket\"]\n                logger.info(\"Ticket -&gt; %s\", otds_ticket)\n        else:\n            logger.error(\"Failed to request an OTDS ticket; error -&gt; %s\", response.text)\n            return None\n\n        # Store authentication ticket:\n        self._cookie = {\"OTDSTicket\": otds_ticket}\n        self._otds_ticket = otds_ticket\n\n        return self._cookie\n\n    # end method definition\n\n    def add_license_to_resource(\n        self,\n        path_to_license_file: str,\n        product_name: str,\n        product_description: str,\n        resource_id: str,\n        update: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Add a product license to an OTDS resource.\n\n        Args:\n            path_to_license_file (str): fully qualified filename of the license file\n            product_name (str): product name\n            product_description (str): product description\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            update (bool, optional): whether or not an existing license should be updated (default = True)\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails\n        \"\"\"\n\n        logger.info(\"Reading license file -&gt; %s...\", path_to_license_file)\n        try:\n            with open(path_to_license_file, \"rt\", encoding=\"UTF-8\") as license_file:\n                license_content = license_file.read()\n        except IOError as exception:\n            logger.error(\n                \"Error opening license file -&gt; %s; error -&gt; %s\",\n                path_to_license_file,\n                exception.strerror,\n            )\n            return None\n\n        licensePostBodyJson = {\n            \"description\": product_description,\n            \"name\": product_name,\n            \"values\": [\n                {\"name\": \"oTLicenseFile\", \"values\": license_content},\n                {\"name\": \"oTLicenseResource\", \"values\": resource_id},\n                {\"name\": \"oTLicenseFingerprintGenerator\", \"values\": [None]},\n            ],\n        }\n\n        request_url = self.license_url()\n        # Check if we want to update an existing license:\n        if update:\n            existing_license = self.get_license_for_resource(resource_id)\n            if existing_license:\n                request_url += \"/\" + existing_license[0][\"id\"]\n            else:\n                logger.info(\n                    \"No existing license for resource -&gt; %s found - adding a new license...\",\n                    resource_id,\n                )\n                # change strategy to create a new license:\n                update = False\n\n        logger.info(\n            \"Adding product license -&gt; %s for product -&gt; %s to resource -&gt; %s; calling -&gt; %s\",\n            path_to_license_file,\n            product_description,\n            resource_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            if update:\n                # Do a REST PUT call for update an existing license:\n                response = requests.put(\n                    url=request_url,\n                    json=licensePostBodyJson,\n                    headers=REQUEST_HEADERS,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n            else:\n                # Do a REST POST call for creation of a new license:\n                response = requests.post(\n                    url=request_url,\n                    json=licensePostBodyJson,\n                    headers=REQUEST_HEADERS,\n                    cookies=self.cookie(),\n                    timeout=None,\n                )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add product license -&gt; %s for product -&gt; %s; error -&gt; %s (%s)\",\n                    path_to_license_file,\n                    product_description,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_license_for_resource(self, resource_id: str):\n        \"\"\"Get a product license for a resource in OTDS.\n\n        Args:\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        Returns:\n            Licenses for a resource or None if the REST call fails\n\n        licenses have this format:\n        {\n          '_oTLicenseType': 'NON-PRODUCTION',\n          '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n          '_oTLicenseResourceName': 'cs',\n          '_oTLicenseProduct': 'EXTENDED_ECM',\n          'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n          'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n          'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n          'description': 'CS license',\n          'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n        }\n        \"\"\"\n\n        request_url = (\n            self.license_url()\n            + \"/assignedlicenses?resourceID=\"\n            + resource_id\n            + \"&amp;validOnly=false\"\n        )\n\n        logger.info(\n            \"Get license for resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                response_dict = self.parse_request_response(response)\n                if not response_dict:\n                    return None\n                return response_dict[\"licenseObjects\"][\"_licenses\"]\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get license for resource -&gt; %s; error -&gt; %s (%s)\",\n                    resource_id,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def delete_license_from_resource(self, resource_id: str, license_id: str) -&gt; bool:\n        \"\"\"Delete a product license for a resource in OTDS.\n\n        Args:\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_id (str): OTDS license ID (this is the ID not the license name!)\n        Returns:\n            bool: True if successful or False if the REST call fails\n        \"\"\"\n\n        request_url = \"{}/{}\".format(self.license_url(), license_id)\n\n        logger.info(\n            \"Deleting product license -&gt; %s from resource -&gt; %s; calling -&gt; %s\",\n            license_id,\n            resource_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.delete(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to delete license -&gt; %s for resource -&gt; %s; error -&gt; %s (%s)\",\n                    license_id,\n                    resource_id,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def assign_user_to_license(\n        self,\n        partition: str,\n        user_id: str,\n        resource_id: str,\n        license_feature: str,\n        license_name: str,\n        license_type: str = \"Full\",\n    ) -&gt; bool:\n        \"\"\"Assign an OTDS user to a product license (feature) in OTDS.\n\n        Args:\n            partition (str): user partition in OTDS, e.g. \"Content Server Members\"\n            user_id (str): ID of the user (= login name)\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature\n            license_name (str): name of the license to assign\n            license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n        Returns:\n            bool: True if successful or False if the REST call fails or the license is not found\n        \"\"\"\n\n        licenses = self.get_license_for_resource(resource_id)\n\n        for lic in licenses:\n            if lic[\"_oTLicenseProduct\"] == license_name:\n                license_location = lic[\"id\"]\n\n        try:\n            license_location\n        except UnboundLocalError:\n            logger.error(\n                \"Cannot find license -&gt; %s for resource -&gt; %s\",\n                license_name,\n                resource_id,\n            )\n            return False\n\n        user = self.get_user(partition, user_id)\n        if user:\n            user_location = user[\"location\"]\n        else:\n            logger.error(\"Cannot find location for user -&gt; %s\", user_id)\n            return False\n\n        licensePostBodyJson = {\n            \"_oTLicenseType\": license_type,\n            \"_oTLicenseProduct\": \"users\",\n            \"name\": user_location,\n            \"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n        }\n\n        request_url = self.license_url() + \"/object/\" + license_location\n\n        logger.info(\n            \"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to user -&gt; %s; calling -&gt; %s\",\n            license_feature,\n            license_location,\n            resource_id,\n            user_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=licensePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                logger.info(\n                    \"Added license feature -&gt; %s for user -&gt; %s\",\n                    license_feature,\n                    user_id,\n                )\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add license feature -&gt; %s associated with resource -&gt; %s to user -&gt; %s; error -&gt; %s (%s)\",\n                    license_feature,\n                    resource_id,\n                    user_id,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def assign_partition_to_license(\n        self,\n        partition_name: str,\n        resource_id: str,\n        license_feature: str,\n        license_name: str,\n        license_type: str = \"Full\",\n    ) -&gt; bool:\n        \"\"\"Assign an OTDS partition to a product license (feature).\n\n        Args:\n            partition_name (str): user partition in OTDS, e.g. \"Content Server Members\"\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n            license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n        Returns:\n            bool: True if successful or False if the REST call fails or the license is not found\n        \"\"\"\n\n        licenses = self.get_license_for_resource(resource_id)\n        if not licenses:\n            logger.error(\n                \"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n            )\n            return False\n\n        # licenses have this format:\n        # {\n        #   '_oTLicenseType': 'NON-PRODUCTION',\n        #   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n        #   '_oTLicenseResourceName': 'cs',\n        #   '_oTLicenseProduct': 'EXTENDED_ECM',\n        #   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n        #   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n        #   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n        #   'description': 'CS license',\n        #   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n        # }\n        for lic in licenses:\n            if lic[\"_oTLicenseProduct\"] == license_name:\n                license_location = lic[\"id\"]\n\n        try:\n            license_location\n        except UnboundLocalError:\n            logger.error(\n                \"Cannot find license -&gt; %s for resource -&gt; %s\",\n                license_name,\n                resource_id,\n            )\n            return False\n\n        licensePostBodyJson = {\n            \"_oTLicenseType\": license_type,\n            \"_oTLicenseProduct\": \"partitions\",\n            \"name\": partition_name,\n            \"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n        }\n\n        request_url = self.license_url() + \"/object/\" + license_location\n\n        logger.info(\n            \"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\n            license_feature,\n            license_location,\n            resource_id,\n            partition_name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=licensePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                logger.info(\n                    \"Added license feature -&gt; %s for partition -&gt; %s\",\n                    license_feature,\n                    partition_name,\n                )\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add license feature -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; error -&gt; %s (%s)\",\n                    license_feature,\n                    resource_id,\n                    partition_name,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def get_licensed_objects(\n        self,\n        resource_id: str,\n        license_feature: str,\n        license_name: str,\n    ) -&gt; dict | None:\n        \"\"\"Return the licensed objects (users, groups, partitions) in OTDS for a license + license feature\n           associated with an OTDS resource (like \"cs\").\n\n        Args:\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n        Returns:\n            dict: data structure of licensed objects\n\n            Example return value:\n            {\n                'status': 0,\n                'displayString': 'Success',\n                'exceptions': None,\n                'retValue': 0,\n                'listGroupsResults': {'groups': [...], 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n                'listUsersResults': {'users': [...], 'actualPageSize': 53, 'nextPageCookie': None, 'requestedPageSize': 250},\n                'listUserPartitionResult': {'_userPartitions': [...], 'warningMessage': None, 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n                'version': 1\n            }\n        \"\"\"\n\n        licenses = self.get_license_for_resource(resource_id)\n        if not licenses:\n            logger.error(\n                \"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n            )\n            return False\n\n        # licenses have this format:\n        # {\n        #   '_oTLicenseType': 'NON-PRODUCTION',\n        #   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n        #   '_oTLicenseResourceName': 'cs',\n        #   '_oTLicenseProduct': 'EXTENDED_ECM',\n        #   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n        #   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n        #   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n        #   'description': 'CS license',\n        #   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n        # }\n        for lic in licenses:\n            if lic[\"_oTLicenseProduct\"] == license_name:\n                license_location = lic[\"location\"]\n\n        try:\n            license_location\n        except UnboundLocalError:\n            logger.error(\n                \"Cannot find license -&gt; %s for resource -&gt; %s\",\n                license_name,\n                resource_id,\n            )\n            return False\n\n        request_url = (\n            self.license_url()\n            + \"/object/\"\n            + license_location\n            + \"?counter=\"\n            + license_feature\n        )\n\n        logger.info(\n            \"Get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; calling -&gt; %s\",\n            license_name,\n            license_feature,\n            resource_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; error -&gt; %s (%s)\",\n                    license_name,\n                    license_feature,\n                    resource_id,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def is_user_licensed(\n        self, user_name: str, resource_id: str, license_feature: str, license_name: str\n    ) -&gt; bool:\n        \"\"\"Check if a user is licensed for a license and license feature associated with a particular OTDS resource.\n\n        Args:\n            user_name (str): login name of the OTDS user\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n\n        Returns:\n            bool: True if the user is licensed and False otherwise\n        \"\"\"\n\n        response = self.get_licensed_objects(\n            resource_id=resource_id,\n            license_feature=license_feature,\n            license_name=license_name,\n        )\n\n        if not response or not response[\"listUsersResults\"]:\n            return False\n\n        users = response[\"listUsersResults\"][\"users\"]\n\n        if not users:\n            return False\n\n        user = next(\n            (item for item in users if item[\"name\"] == user_name),\n            None,\n        )\n\n        if user:\n            return True\n\n        return False\n\n    # end method definition\n\n    def is_group_licensed(\n        self, group_name: str, resource_id: str, license_feature: str, license_name: str\n    ) -&gt; bool:\n        \"\"\"Check if a group is licensed for a license and license feature associated with a particular OTDS resource.\n\n        Args:\n            group_name (str): name of the OTDS user group\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n\n        Returns:\n            bool: True if the group is licensed and False otherwise\n        \"\"\"\n\n        response = self.get_licensed_objects(\n            resource_id=resource_id,\n            license_feature=license_feature,\n            license_name=license_name,\n        )\n\n        if not response or not response[\"listGroupsResults\"]:\n            return False\n\n        groups = response[\"listGroupsResults\"][\"groups\"]\n\n        if not groups:\n            return False\n\n        group = next(\n            (item for item in groups if item[\"name\"] == group_name),\n            None,\n        )\n\n        if group:\n            return True\n\n        return False\n\n    # end method definition\n\n    def is_partition_licensed(\n        self,\n        partition_name: str,\n        resource_id: str,\n        license_feature: str,\n        license_name: str,\n    ) -&gt; bool:\n        \"\"\"Check if a partition is licensed for a license and license feature associated with a particular OTDS resource.\n\n        Args:\n            partition_name (str): name of the OTDS user partition, e.g. \"Content Server Members\"\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n\n        Returns:\n            bool: True if the partition is licensed and False otherwise\n        \"\"\"\n\n        response = self.get_licensed_objects(\n            resource_id=resource_id,\n            license_feature=license_feature,\n            license_name=license_name,\n        )\n\n        if not response or not response[\"listUserPartitionResult\"]:\n            return False\n\n        partitions = response[\"listUserPartitionResult\"][\"_userPartitions\"]\n\n        if not partitions:\n            return False\n\n        partition = next(\n            (item for item in partitions if item[\"name\"] == partition_name),\n            None,\n        )\n\n        if partition:\n            return True\n\n        return False\n\n    # end method definition\n\n    def add_partition(self, name: str, description: str) -&gt; dict | None:\n        \"\"\"Add a new user partition to OTDS\n\n        Args:\n            name (str): name of the new partition\n            description (str): description of the new partition\n        Returns:\n            dict: Request response or None if the creation fails.\n        \"\"\"\n\n        partitionPostBodyJson = {\"name\": name, \"description\": description}\n\n        request_url = self.partition_url()\n\n        logger.info(\n            \"Adding user partition -&gt; %s (%s); calling -&gt; %s\",\n            name,\n            description,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=partitionPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add user partition -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_partition(self, name: str, show_error: bool = True) -&gt; dict | None:\n        \"\"\"Get an existing user partition from OTDS\n\n        Args:\n            name (str): name of the partition to retrieve\n            show_error (bool, optional): whether or not we want to log an error\n                                         if partion is not found\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\n\n        request_url = \"{}/{}\".format(self.config()[\"partitionUrl\"], name)\n\n        logger.info(\"Getting user partition -&gt; %s; calling -&gt; %s\", name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get partition -&gt; %s; warning -&gt; %s (%s)\",\n                        name,\n                        response.text,\n                        response.status_code,\n                    )\n                return None\n\n    # end method definition\n\n    def add_user(\n        self,\n        partition: str,\n        name: str,\n        description: str = \"\",\n        first_name: str = \"\",\n        last_name: str = \"\",\n        email: str = \"\",\n    ) -&gt; dict | None:\n        \"\"\"Add a new user to a user partition in OTDS\n\n        Args:\n            partition (str): name of the OTDS user partition (needs to exist)\n            name (str): login name of the new user\n            description (str, optional): description of the new user\n            first_name (str, optional): first name of the new user\n            last_name (str, optional): last name of the new user\n            email (str, optional): email address of the new user\n        Returns:\n            dict: Request response or None if the creation fails.\n        \"\"\"\n\n        userPostBodyJson = {\n            \"userPartitionID\": partition,\n            \"values\": [\n                {\"name\": \"sn\", \"values\": [last_name]},\n                {\"name\": \"givenName\", \"values\": [first_name]},\n                {\"name\": \"mail\", \"values\": [email]},\n            ],\n            \"name\": name,\n            \"description\": description,\n        }\n\n        request_url = self.users_url()\n\n        logger.info(\n            \"Adding user -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\n            name,\n            partition,\n            request_url,\n        )\n        logger.debug(\"User Attributes -&gt; %s\", str(userPostBodyJson))\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=userPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add user -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_user(self, partition: str, user_id: str) -&gt; dict | None:\n        \"\"\"Get a user by its partition and user ID\n\n        Args:\n            partition (str): name of the partition\n            user_id (str): ID of the user (= login name)\n        Returns:\n            dict: Request response or None if the user was not found.\n        \"\"\"\n\n        request_url = self.users_url() + \"/\" + user_id + \"@\" + partition\n\n        logger.info(\n            \"Get user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\n            user_id,\n            partition,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get user -&gt; %s; error -&gt; %s (%s)\",\n                    user_id,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_users(self, partition: str = \"\", limit: int | None = None) -&gt; dict | None:\n        \"\"\"Get all users in a partition partition\n\n        Args:\n            partition (str, optional): name of the partition\n            limit (int): maximum number of users to return\n        Returns:\n            dict: Request response or None if the user was not found.\n        \"\"\"\n\n        # Add query parameters (these are NOT passed via JSon body!)\n        query = {}\n        if limit:\n            query[\"limit\"] = limit\n        if partition:\n            query[\"where_partition_name\"] = partition\n\n        encodedQuery = urllib.parse.urlencode(query, doseq=True)\n\n        request_url = self.users_url()\n        if query:\n            request_url += \"?{}\".format(encodedQuery)\n\n        if partition:\n            logger.info(\n                \"Get all users in partition -&gt; %s (limit -&gt; %s); calling -&gt; %s\",\n                partition,\n                limit,\n                request_url,\n            )\n        else:\n            logger.info(\n                \"Get all users (limit -&gt; %s); calling -&gt; %s\",\n                limit,\n                request_url,\n            )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if partition:\n                    logger.error(\n                        \"Failed to get users in partition -&gt; %s; error -&gt; %s (%s)\",\n                        partition,\n                        response.text,\n                        response.status_code,\n                    )\n                else:\n                    logger.error(\n                        \"Failed to get users; error -&gt; %s (%s)\",\n                        response.text,\n                        response.status_code,\n                    )\n                return None\n\n    # end method definition\n\n    def update_user(\n        self, partition: str, user_id: str, attribute_name: str, attribute_value: str\n    ) -&gt; dict | None:\n        \"\"\"Update a user attribute with a new value\n\n        Args:\n            partition (str): name of the partition\n            user_id (str): ID of the user (= login name)\n            attribute_name (str): name of the attribute\n            attribute_value (str): new value of the attribute\n        Return:\n            dict: Request response or None if the update fails.\n        \"\"\"\n\n        if attribute_name in [\"description\"]:\n            userPatchBodyJson = {\n                \"userPartitionID\": partition,\n                attribute_name: attribute_value,\n            }\n        else:\n            userPatchBodyJson = {\n                \"userPartitionID\": partition,\n                \"values\": [{\"name\": attribute_name, \"values\": [attribute_value]}],\n            }\n\n        request_url = self.users_url() + \"/\" + user_id\n\n        logger.info(\n            \"Update user -&gt; %s attribute -&gt; %s to value -&gt; %s; calling -&gt; %s\",\n            user_id,\n            attribute_name,\n            attribute_value,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.patch(\n                url=request_url,\n                json=userPatchBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update user -&gt; %s; error -&gt; %s (%s)\",\n                    user_id,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def delete_user(self, partition: str, user_id: str) -&gt; bool:\n        \"\"\"Delete an existing user\n\n        Args:\n            partition (str): name of the partition\n            user_id (str): Id (= login name) of the user\n        Returns:\n            bool: True = success, False = error\n        \"\"\"\n\n        request_url = self.users_url() + \"/\" + user_id + \"@\" + partition\n\n        logger.info(\n            \"Delete user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\n            user_id,\n            partition,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.delete(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to delete user -&gt; %s; error -&gt; %s (%s)\",\n                    user_id,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def reset_user_password(self, user_id: str, password: str) -&gt; bool:\n        \"\"\"Reset a password of an existing user\n\n        Args:\n            user_id (str): Id (= login name) of the user\n            password (str): new password of the user\n        Returns:\n            bool: True = success, False = error.\n        \"\"\"\n\n        userPostBodyJson = {\"newPassword\": password}\n\n        request_url = \"{}/{}/password\".format(self.users_url(), user_id)\n\n        logger.info(\n            \"Resetting password for user -&gt; %s; calling -&gt; %s\", user_id, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                json=userPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to reset password for user -&gt; %s; error -&gt; %s (%s)\",\n                    user_id,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def add_group(self, partition: str, name: str, description: str) -&gt; dict | None:\n        \"\"\"Add a new user group to a user partition in OTDS\n\n        Args:\n            partition (str): name of the OTDS user partition (needs to exist)\n            name (str): name of the new group\n            description (str): description of the new group\n        Returns:\n            dict: Request response (json) or None if the creation fails.\n        \"\"\"\n\n        groupPostBodyJson = {\n            \"userPartitionID\": partition,\n            \"name\": name,\n            \"description\": description,\n        }\n\n        request_url = self.groups_url()\n\n        logger.info(\n            \"Adding group -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\n            name,\n            partition,\n            request_url,\n        )\n        logger.debug(\"Group Attributes -&gt; %s\", str(groupPostBodyJson))\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=groupPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add group -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_group(self, group: str) -&gt; dict | None:\n        \"\"\"Get a OTDS group by its group name\n\n        Args:\n            group (str): ID of the group (= group name)\n        Return:\n            dict: Request response or None if the group was not found.\n            Example values:\n            {\n                'numMembers': 7,\n                'userPartitionID': 'Content Server Members',\n                'name': 'Sales',\n                'location': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net',\n                'id': 'Sales@Content Server Members',\n                'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...],\n                'description': None,\n                'uuid': '3f921294-b92a-4c9e-bf7c-b50df16bb937',\n                'objectClass': 'oTGroup',\n                'customAttributes': None,\n                'originUUID': None,\n                'urlId': 'Sales@Content Server Members',\n                'urlLocation': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net'\n            }\n        \"\"\"\n\n        request_url = self.groups_url() + \"/\" + group\n\n        logger.info(\"Get group -&gt; %s; calling -&gt; %s\", group, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get group -&gt; %s; error -&gt; %s (%s)\",\n                    group,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def add_user_to_group(self, user: str, group: str) -&gt; bool:\n        \"\"\"Add an existing user to an existing group in OTDS\n\n        Args:\n            user (str): name of the OTDS user (needs to exist)\n            group (str): name of the OTDS group (needs to exist)\n        Returns:\n            bool: True, if request is successful, False otherwise.\n        \"\"\"\n\n        userToGroupPostBodyJson = {\"stringList\": [group]}\n\n        request_url = self.users_url() + \"/\" + user + \"/memberof\"\n\n        logger.info(\n            \"Adding user -&gt; %s to group -&gt; %s; calling -&gt; %s\", user, group, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=userToGroupPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add user -&gt; %s to group -&gt; %s; error -&gt; %s (%s)\",\n                    user,\n                    group,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def add_group_to_parent_group(self, group: str, parent_group: str) -&gt; bool:\n        \"\"\"Add an existing group to an existing parent group in OTDS\n\n        Args:\n            group (str): name of the OTDS group (needs to exist)\n            parent_group (str): name of the OTDS parent group (needs to exist)\n        Returns:\n            bool: True, if request is successful, False otherwise.\n        \"\"\"\n\n        groupToParentGroupPostBodyJson = {\"stringList\": [parent_group]}\n\n        request_url = self.groups_url() + \"/\" + group + \"/memberof\"\n\n        logger.info(\n            \"Adding group -&gt; %s to parent group -&gt; %s; calling -&gt; %s\",\n            group,\n            parent_group,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=groupToParentGroupPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add group -&gt; %s to parent group -&gt; %s; error -&gt; %s (%s)\",\n                    group,\n                    parent_group,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def add_resource(\n        self,\n        name: str,\n        description: str,\n        display_name: str,\n        additional_payload: dict | None = None,\n    ) -&gt; dict | None:\n        \"\"\"Add an OTDS resource\n\n        Args:\n            name (str): name of the new OTDS resource\n            description (str): description of the new OTDS resource\n            display_name (str): display name of the OTDS resource\n            additional_payload (dict, optional): additional values for the json payload\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\n\n        resourcePostBodyJson = {\n            \"resourceName\": name,\n            \"description\": description,\n            \"displayName\": display_name,\n        }\n\n        # Check if there's additional payload for the body provided to handle special cases:\n        if additional_payload:\n            # Merge additional payload:\n            resourcePostBodyJson.update(additional_payload)\n\n        request_url = self.config()[\"resourceUrl\"]\n\n        logger.info(\n            \"Adding resource -&gt; %s (%s); calling -&gt; %s\", name, description, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=resourcePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add resource -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_resource(self, name: str, show_error: bool = False) -&gt; dict | None:\n        \"\"\"Get an existing OTDS resource\n\n        Args:\n            name (str): name of the new OTDS resource\n            show_error (bool, optional): treat as error if resource is not found\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\n\n        request_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\n\n        logger.info(\"Retrieving resource -&gt; %s; calling -&gt; %s\", name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                # We don't necessarily want to log an error as this function\n                # is also used in wait loops:\n                if show_error:\n                    logger.warning(\n                        \"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\n                        name,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"Resource -&gt; %s not found.\", name)\n                return None\n\n    # end method definition\n\n    def update_resource(\n        self, name: str, resource: object, show_error: bool = True\n    ) -&gt; dict | None:\n        \"\"\"Update an existing OTDS resource\n\n        Args:\n            name (str): name of the new OTDS resource\n            resource (object): updated resource object of get_resource called before\n            show_error (bool, optional): treat as error if resource is not found\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\n\n        request_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\n\n        logger.info(\"Updating resource -&gt; %s; calling -&gt; %s\", name, request_url)\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                json=resource,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                # We don't necessarily want to log an error as this function\n                # is also used in wait loops:\n                if show_error:\n                    logger.warning(\n                        \"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\n                        name,\n                        response.text,\n                    )\n                else:\n                    logger.info(\"Resource -&gt; %s not found.\", name)\n                return None\n\n    # end method definition\n\n    def activate_resource(self, resource_id: str) -&gt; dict | None:\n        \"\"\"Activate an OTDS resource\n\n        Args:\n            resource_id (str): ID of the OTDS resource\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\n\n        resourcePostBodyJson = {}\n\n        request_url = \"{}/{}/activate\".format(self.config()[\"resourceUrl\"], resource_id)\n\n        logger.info(\n            \"Activating resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=resourcePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to activate resource -&gt; %s; error -&gt; %s (%s)\",\n                    resource_id,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_access_roles(self) -&gt; dict | None:\n        \"\"\"Get a list of all OTDS access roles\n\n        Args:\n            None\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\n\n        request_url = self.config()[\"accessRoleUrl\"]\n\n        logger.info(\"Retrieving access roles; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to retrieve access roles; error -&gt; %s (%s)\",\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_access_role(self, access_role: str) -&gt; dict | None:\n        \"\"\"Get an OTDS access role\n\n        Args:\n            name (str): name of the access role\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\n\n        request_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role\n\n        logger.info(\n            \"Retrieving access role -&gt; %s; calling -&gt; %s\", access_role, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to retrieve access role -&gt; %s; error -&gt; %s (%s)\",\n                    access_role,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def add_partition_to_access_role(\n        self, access_role: str, partition: str, location: str = \"\"\n    ) -&gt; bool:\n        \"\"\"Add an OTDS partition to an OTDS access role\n\n        Args:\n            access_role (str): name of the OTDS access role\n            partition (str): name of the partition\n            location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                      most of the times you will want to keep it to empty string (\"\")\n        Returns:\n            bool: True if partition is in access role or has been successfully added.\n                  False if partition has been not been added (error)\n        \"\"\"\n\n        accessRolePostBodyJson = {\n            \"userPartitions\": [{\"name\": partition, \"location\": location}]\n        }\n\n        request_url = \"{}/{}/members\".format(\n            self.config()[\"accessRoleUrl\"], access_role\n        )\n\n        logger.info(\n            \"Add user partition -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\n            partition,\n            access_role,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=accessRolePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add partition -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\n                    partition,\n                    access_role,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def add_user_to_access_role(\n        self, access_role: str, user_id: str, location: str = \"\"\n    ) -&gt; bool:\n        \"\"\"Add an OTDS user to an OTDS access role\n\n        Args:\n            access_role (str): name of the OTDS access role\n            user_id (str): ID of the user (= login name)\n            location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                      most of the times you will want to keep it to empty string (\"\")\n        Returns:\n            bool: True if user is in access role or has been successfully added.\n                  False if user has not been added (error)\n        \"\"\"\n\n        # get existing members to check if user is already a member:\n        accessRolesGetResponse = self.get_access_role(access_role)\n\n        if not accessRolesGetResponse:\n            return False\n\n        # Checking if user already added to access role\n        accessRoleUsers = accessRolesGetResponse[\"accessRoleMembers\"][\"users\"]\n        for user in accessRoleUsers:\n            if user[\"displayName\"] == user_id:\n                logger.info(\n                    \"User -&gt; %s already added to access role -&gt; %s\",\n                    user_id,\n                    access_role,\n                )\n                return True\n\n        logger.info(\n            \"User -&gt; %s is not yet in access role -&gt; %s - adding...\",\n            user_id,\n            access_role,\n        )\n\n        # create payload for REST call:\n        accessRolePostBodyJson = {\"users\": [{\"name\": user_id, \"location\": location}]}\n\n        request_url = \"{}/{}/members\".format(\n            self.config()[\"accessRoleUrl\"], access_role\n        )\n\n        logger.info(\n            \"Add user -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\n            user_id,\n            access_role,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=accessRolePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add user -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\n                    user_id,\n                    access_role,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def add_group_to_access_role(\n        self, access_role: str, group: str, location: str = \"\"\n    ) -&gt; bool:\n        \"\"\"Add an OTDS group to an OTDS access role\n\n        Args:\n            access_role (str): name of the OTDS access role\n            group (str): name of the group\n            location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                      most of the times you will want to keep it to empty string (\"\")\n        Returns:\n            bool: True if group is in access role or has been successfully added.\n                  False if group has been not been added (error)\n        \"\"\"\n\n        # get existing members to check if user is already a member:\n        accessRolesGetResponse = self.get_access_role(access_role)\n        if not accessRolesGetResponse:\n            return False\n\n        # Checking if group already added to access role\n        accessRoleGroups = accessRolesGetResponse[\"accessRoleMembers\"][\"groups\"]\n        for accessRoleGroup in accessRoleGroups:\n            if accessRoleGroup[\"name\"] == group:\n                logger.info(\n                    \"Group -&gt; %s already added to access role -&gt; %s\", group, access_role\n                )\n                return True\n\n        logger.info(\n            \"Group -&gt; %s is not yet in access role -&gt; %s - adding...\",\n            group,\n            access_role,\n        )\n\n        # create payload for REST call:\n        accessRolePostBodyJson = {\"groups\": [{\"name\": group, \"location\": location}]}\n\n        request_url = \"{}/{}/members\".format(\n            self.config()[\"accessRoleUrl\"], access_role\n        )\n\n        logger.info(\n            \"Add group -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\n            group,\n            access_role,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=accessRolePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add group -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\n                    group,\n                    access_role,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def update_access_role_attributes(\n        self, name: str, attribute_list: list\n    ) -&gt; dict | None:\n        \"\"\"Update some attributes of an existing OTDS Access Role\n\n        Args:\n            name (str): name of the existing access role\n            attribute_list (list): list of attribute name and attribute value pairs\n                                   The values need to be a list as well. Example:\n                                   [{name: \"pushAllGroups\", values: [\"True\"]}]\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\n\n        # Return if list is empty:\n        if not attribute_list:\n            return None\n\n        # create payload for REST call:\n        access_role = self.get_access_role(name)\n        if not access_role:\n            logger.error(\"Failed to get access role -&gt; %s\", name)\n            return None\n\n        accessRolePutBodyJson = {\"attributes\": attribute_list}\n\n        request_url = \"{}/{}/attributes\".format(self.config()[\"accessRoleUrl\"], name)\n\n        logger.info(\n            \"Update access role -&gt; %s with attributes -&gt; %s; calling -&gt; %s\",\n            name,\n            accessRolePutBodyJson,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                json=accessRolePutBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update access role -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def add_system_attribute(\n        self, name: str, value: str, description: str = \"\"\n    ) -&gt; dict | None:\n        \"\"\"Add a new system attribute to OTDS\n\n        Args:\n            name (str): name of the new system attribute\n            value (str): value of the system attribute\n            description (str, optional): optional description of the system attribute\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\n\n        systemAttributePostBodyJson = {\n            \"name\": name,\n            \"value\": value,\n            \"friendlyName\": description,\n        }\n\n        request_url = \"{}/system_attributes\".format(self.config()[\"systemConfigUrl\"])\n\n        if description:\n            logger.info(\n                \"Add system attribute -&gt; %s (%s) with value -&gt; %s; calling -&gt; %s\",\n                name,\n                description,\n                value,\n                request_url,\n            )\n        else:\n            logger.info(\n                \"Add system attribute -&gt; %s with value -&gt; %s; calling -&gt; %s\",\n                name,\n                value,\n                request_url,\n            )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=systemAttributePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add system attribute -&gt; %s with value -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    value,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_trusted_sites(self) -&gt; dict | None:\n        \"\"\"Get all configured OTDS trusted sites\n\n        Args:\n            None\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\n\n        request_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\n\n        logger.info(\"Retrieving trusted sites; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to retrieve trusted sites; error -&gt; %s (%s)\",\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def add_trusted_site(self, trusted_site: str) -&gt; dict | None:\n        \"\"\"Add a new OTDS trusted site\n\n        Args:\n            trusted_site (str): name of the new trusted site\n        Return:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\n\n        trustedSitePostBodyJson = {\"stringList\": [trusted_site]}\n\n        # we need to first retrieve the existing sites and then\n        # append the new one:\n        existingTrustedSites = self.get_trusted_sites()\n\n        if existingTrustedSites:\n            trustedSitePostBodyJson[\"stringList\"].extend(\n                existingTrustedSites[\"stringList\"]\n            )\n\n        request_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\n\n        logger.info(\"Add trusted site -&gt; %s; calling -&gt; %s\", trusted_site, request_url)\n\n        response = requests.put(\n            url=request_url,\n            json=trustedSitePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if not response.ok:\n            logger.error(\n                \"Failed to add trusted site -&gt; %s; error -&gt; %s (%s)\",\n                trusted_site,\n                response.text,\n                response.status_code,\n            )\n            return None\n\n        return response  # don't parse it!\n\n    # end method definition\n\n    def enable_audit(self):\n        \"\"\"enable OTDS Audit\n\n        Args:\n            None\n        Return:\n            Request response (json) or None if the REST call fails.\n        \"\"\"\n\n        auditPutBodyJson = {\n            \"daysToKeep\": \"7\",\n            \"enabled\": \"true\",\n            \"auditTo\": \"DATABASE\",\n            \"eventIDs\": [\n                \"User Create\",\n                \"Group Create\",\n                \"User Delete\",\n                \"Group Delete\",\n                \"User Modify\",\n                \"Group Modify\",\n                \"Initial authentication successful\",\n                \"Initial authentication failed\",\n                \"Impersonation\",\n                \"Import Finished\",\n                \"Access Denied\",\n                \"Authentication code incorrect\",\n                \"Authentication code required\",\n                \"User locked out\",\n                \"Consolidate Partition with identity provider\",\n                \"Recycle Bin User Deleted\",\n                \"Recycle Bin Group Deleted\",\n                \"User Moved to Recycle Bin\",\n                \"Group Moved to Recycle Bin\",\n                \"User Restored from Recycle Bin\",\n                \"Group Restored from Recycle Bin\",\n                \"Scheduled Cleanup\",\n                \"Consolidation finished\",\n                \"Monitoring session finished\",\n                \"User Rename\",\n                \"Group Rename\",\n                \"Role Create\",\n                \"Role Delete\",\n                \"Role Modify\",\n                \"Role Rename\",\n                \"Recycle Bin Role Deleted\",\n                \"Role Moved to Recycle Bin\",\n                \"Role Restored from Recycle Bin\",\n                \"Set group members\",\n                \"Set group members for moved in objects\",\n                \"User logout\",\n                \"Password change successful\",\n                \"Password change failed\",\n                \"Add Parent Object\",\n                \"Remove Parent Object\",\n                \"OAuth Client Create\",\n                \"OAuth Client Delete\",\n                \"OAuth Client Modify\",\n                \"Tenant Create\",\n                \"Tenant Delete\",\n                \"Tenant Modify\",\n                \"Migration\",\n            ],\n        }\n\n        request_url = \"{}/audit\".format(self.config()[\"systemConfigUrl\"])\n\n        logger.info(\"Enable audit; calling -&gt; %s\", request_url)\n\n        response = requests.put(\n            url=request_url,\n            json=auditPutBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if not response.ok:\n            logger.error(\n                \"Failed to enable audit; error -&gt; %s (%s)\",\n                response.text,\n                response.status_code,\n            )\n        return response\n\n    # end method definition\n\n    def add_oauth_client(\n        self,\n        client_id: str,\n        description: str,\n        redirect_urls: list | None = None,\n        allow_impersonation: bool = True,\n        confidential: bool = True,\n        auth_scopes: list | None = None,  # None = \"Global\"\n        allowed_scopes: list | None = None,  # in OTDS UI: Permissible scopes\n        default_scopes: list | None = None,  # in OTDS UI: Default scopes\n        secret: str = \"\",\n    ) -&gt; dict | None:\n        \"\"\"Add a new OAuth client to OTDS\n\n        Args:\n            client_id (str): name of the new OAuth client (should not have blanks)\n            description (str): description of the OAuth client\n            redirect_urls (list): list of redirect URLs (strings)\n            allow_impersonation (bool, optional): allow impresonation\n            confidential (bool, optional): is confidential\n            auth_scopes (list, optional): if empty then \"Global\"\n            allowed_scopes (list, optional): in OTDS UI this is called Permissible scopes\n            default_scopes (list, optional): in OTDS UI this is called Default scopes\n            secret (str, optional): predefined OAuth client secret. If empty a new secret is generated.\n        Returns:\n            dict: Request response or None if the creation fails.\n            Example:\n            {\n                \"description\": \"string\",\n                \"redirectURLs\": [\n                    \"string\"\n                ],\n                \"id\": \"string\",\n                \"location\": \"string\",\n                \"accessTokenLifeTime\": 0,\n                \"refreshTokenLifeTime\": 0,\n                \"authCodeLifeTime\": 0,\n                \"allowRefreshToken\": true,\n                \"allowImpersonation\": true,\n                \"useSessionRefreshTokenLifeTime\": true,\n                \"allowedScopes\": [\n                    \"string\"\n                ],\n                \"defaultScopes\": [\n                    \"string\"\n                ],\n                \"impersonateList\": [\n                    \"string\"\n                ],\n                \"confidential\": true,\n                \"secret\": \"string\",\n                \"customAttributes\": [\n                    {\n                    \"type\": \"string\",\n                    \"name\": \"string\",\n                    \"value\": \"string\"\n                    }\n                ],\n                \"logoutURL\": \"string\",\n                \"logoutMethod\": \"string\",\n                \"authScopes\": [\n                    \"string\"\n                ],\n                \"uuid\": \"string\",\n                \"name\": \"string\",\n                \"urlId\": \"string\",\n                \"urlLocation\": \"string\"\n            }\n        \"\"\"\n\n        # Avoid linter warning W0102:\n        if redirect_urls is None:\n            redirect_urls = []\n        if auth_scopes is None:\n            auth_scopes = []\n        if allowed_scopes is None:\n            allowed_scopes = []\n        if default_scopes is None:\n            default_scopes = []\n\n        oauthClientPostBodyJson = {\n            \"id\": client_id,\n            \"description\": description,\n            \"redirectURLs\": redirect_urls,\n            \"accessTokenLifeTime\": 1000,\n            \"refreshTokenLifeTime\": 20000,\n            \"authCodeLifeTime\": 20000,\n            \"allowRefreshToken\": True,\n            \"allowImpersonation\": allow_impersonation,\n            \"useSessionRefreshTokenLifeTime\": True,\n            \"confidential\": confidential,\n            \"authScopes\": auth_scopes,\n            \"allowedScopes\": allowed_scopes,\n            \"defaultScopes\": default_scopes,\n        }\n\n        # Do we have a predefined client secret?\n        if secret:\n            oauthClientPostBodyJson[\"secret\"] = secret\n\n        request_url = self.oauth_client_url()\n\n        logger.info(\n            \"Adding oauth client -&gt; %s (%s); calling -&gt; %s\",\n            description,\n            client_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=oauthClientPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add OAuth client -&gt; %s; error -&gt; %s (%s)\",\n                    client_id,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def get_oauth_client(self, client_id: str, show_error: bool = True) -&gt; dict | None:\n        \"\"\"Get an existing OAuth client from OTDS\n\n        Args:\n            client_id (str): name (= ID) of the OAuth client to retrieve\n            show_error (bool): whether or not we want to log an error if partion is not found\n        Returns:\n            dict: Request response (dictionary) or None if the client is not found.\n        \"\"\"\n\n        request_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\n\n        logger.info(\"Get oauth client -&gt; %s; calling -&gt; %s\", client_id, request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get oauth client -&gt; %s; error -&gt; %s (%s)\",\n                        client_id,\n                        response.text,\n                        response.status_code,\n                    )\n                return None\n\n    # end method definition\n\n    def update_oauth_client(self, client_id: str, updates: dict) -&gt; dict | None:\n        \"\"\"Updates the OAuth client with new values\n\n        Args:\n            client_id (str): name (= ID) of the OAuth client\n            updates (dict): new values for OAuth client, e.g.\n                            {\"description\": \"this is the new value\"}\n\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\n\n        oauthClientPatchBodyJson = updates\n\n        request_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\n\n        logger.info(\n            \"Update OAuth client -&gt; %s with -&gt; %s; calling -&gt; %s\",\n            client_id,\n            updates,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.patch(\n                url=request_url,\n                json=oauthClientPatchBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update OAuth client -&gt; %s; error -&gt; %s (%s)\",\n                    client_id,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def add_oauth_clients_to_access_role(self, access_role_name: str):\n        \"\"\"Add Oauth clients user partion to an OTDS Access Role\n\n        Args:\n            access_role_name (str): name of the OTDS Access Role\n        Returns:\n            response of REST call or None in case of an error\n        \"\"\"\n\n        request_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role_name\n\n        logger.info(\n            \"Get access role -&gt; %s; calling -&gt; %s\", access_role_name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                accessRolesJson = self.parse_request_response(response)\n                break\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to retrieve role -&gt; %s; url -&gt; %s : error -&gt; %s (%s)\",\n                    access_role_name,\n                    request_url,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n        # Checking if OAuthClients partition already added to access role\n        userPartitions = accessRolesJson[\"accessRoleMembers\"][\"userPartitions\"]\n        for userPartition in userPartitions:\n            if userPartition[\"userPartition\"] == \"OAuthClients\":\n                logger.error(\n                    \"OAuthClients partition already added to role -&gt; %s\",\n                    access_role_name,\n                )\n                return None\n\n        # Getting location info for the OAuthClients partition\n        # so it can be added to access roles json\n        request_url = self.config()[\"partitionsUrl\"] + \"/OAuthClients\"\n        partitionsResponse = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if partitionsResponse.ok:\n            response_dict = self.parse_request_response(partitionsResponse)\n            if not response_dict:\n                return None\n            oauthClientLocation = response_dict[\"location\"]\n        else:\n            logger.error(\n                \"Failed to get partition info for OAuthClients; url -&gt; %s : error -&gt; %s (%s)\",\n                request_url,\n                partitionsResponse.text,\n                response.status_code,\n            )\n            return None\n\n        # adding OAuthClients info to acess roles organizational units\n        oauthClientsOuBlock = {\n            \"location\": oauthClientLocation,\n            \"name\": oauthClientLocation,\n            \"userPartition\": None,\n        }\n        accessRolesJson[\"accessRoleMembers\"][\"organizationalUnits\"].append(\n            oauthClientsOuBlock\n        )\n\n        response = requests.put(\n            url=request_url,\n            json=accessRolesJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n\n        if response.ok:\n            logger.info(\n                \"OauthClients partition successfully added to access role -&gt; %s\",\n                access_role_name,\n            )\n        else:\n            logger.warning(\n                \"Status code of -&gt; %s returned attempting to add OAuthClients to access role -&gt; %s: error -&gt; %s\",\n                response.status_code,\n                access_role_name,\n                response.text,\n            )\n        return response\n\n    # end method definition\n\n    def get_access_token(self, client_id: str, client_secret: str) -&gt; str | None:\n        \"\"\"Get the access token\n\n        Args:\n            client_id (str): OAuth client name (= ID)\n            client_secret (str): OAuth client secret. This is typically returned\n                                 by add_oauth_client() method in [\"secret\"] field\n\n        Returns:\n            str: access token, or None\n        \"\"\"\n\n        encoded_client_secret = \"{}:{}\".format(client_id, client_secret).encode(\"utf-8\")\n        accessTokenRequestHeaders = {\n            \"Authorization\": \"Basic \"\n            + base64.b64encode(encoded_client_secret).decode(\"utf-8\"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }\n\n        request_url = self.token_url()\n\n        response = requests.post(\n            url=request_url,\n            data={\"grant_type\": \"client_credentials\"},\n            headers=accessTokenRequestHeaders,\n            timeout=None,\n        )\n\n        access_token = None\n        if response.ok:\n            accessTokenJson = self.parse_request_response(response)\n\n            if \"access_token\" in accessTokenJson:\n                access_token = accessTokenJson[\"access_token\"]\n            else:\n                return None\n\n        return access_token\n\n    # end method definition\n\n    def get_auth_handler(self, name: str, show_error: bool = True) -&gt; dict | None:\n        \"\"\"Get the OTDS auth handler with a given name.\n\n        Args:\n            name (str): Name of the authentication handler\n\n        Returns:\n            dict | None: auth handler dictionary, or None\n\n            Example result:\n            {\n                '_name': 'Salesforce',\n                '_id': 'Salesforce',\n                '_description': 'Salesforce OAuth Authentication Handler',\n                '_class': 'com.opentext.otds.as.drivers.http.OAuth2Handler',\n                '_enabled': True,\n                '_credentialBased': True,\n                '_priority': 10,\n                '_scope': None,\n                '_properties': [\n                    {\n                        '_key': 'com.opentext.otds.as.drivers.http.oauth2.provider_name',\n                        '_name': 'Provider Name',\n                        '_description': 'The name of the authentication provider. This name is displayed on the login page.',\n                        '_required': True,\n                        '_fileBased': False,\n                        '_fileName': False,\n                        '_fileExtensions': None,\n                        '_value': 'Salesforce',\n                        '_allowedValues': None,\n                        ...\n                    },\n                    ...\n                ]\n                '_authPrincipalAttrNames': ['oTExtraAttr0'],\n                'createPermission': True,\n                'readPermission': True,\n                'updatePermission': True,\n                'deletePermission': True,\n                'enablePermission': True,\n            }\n\n        \"\"\"\n\n        request_url = \"{}/{}\".format(self.auth_handler_url(), name)\n\n        logger.info(\n            \"Getting authentication handler -&gt; %s; calling -&gt; %s\", name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                if show_error:\n                    logger.error(\n                        \"Failed to get authentication handler -&gt; %s; warning -&gt; %s (%s)\",\n                        name,\n                        response.text,\n                        response.status_code,\n                    )\n                return None\n\n    # end method definition\n\n    def add_auth_handler_saml(\n        self,\n        name: str,\n        description: str,\n        scope: str | None,\n        provider_name: str,\n        saml_url: str,\n        otds_sp_endpoint: str,\n        enabled: bool = True,\n        priority: int = 5,\n        active_by_default: bool = False,\n        auth_principal_attributes: list | None = None,\n        nameid_format: str = \"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\",\n    ) -&gt; dict | None:\n        \"\"\"Add a new SAML authentication handler\n\n        Args:\n            name (str): name of the new authentication handler\n            description (str): description of the new authentication handler\n            scope (str): name of the user partition (to define a scope of the auth handler)\n            provider_name (str): description of the new authentication handler\n            saml_url (str): SAML URL\n            otds_sp_endpoint (str): the external(!) service provider URL of OTDS\n            enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n            priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n            active_by_default (bool, optional): should OTDS redirect immediately to provider page\n                                                (not showing the OTDS login at all)\n            auth_principal_attributes (list, optional): List of Authentication principal attributes\n            nameid_format (str, optional): Specifies which NameID format supported by the identity provider\n                                           contains the desired user identifier. The value in this identifier\n                                           must correspond to the value of the user attribute specified for the\n                                           authentication principal attribute.\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\n\n        if auth_principal_attributes is None:\n            auth_principal_attributes = [\"oTExternalID1\", \"oTUserID1\"]\n\n        authHandlerPostBodyJson = {\n            \"_name\": name,\n            \"_description\": description,\n            \"_class\": \"com.opentext.otds.as.drivers.saml.SAML2Handler\",\n            \"_enabled\": str.lower(str(enabled)),\n            \"_priority\": str(priority),\n            \"_authPrincipalAttrNames\": auth_principal_attributes,\n            \"_scope\": scope,\n            \"_properties\": [\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.provider_name\",\n                    \"_name\": \"Identity Provider (IdP) Name\",\n                    \"_description\": \"The name of the identity provider. This should be a single word since it will be part of the metadata URL.\",\n                    \"_value\": provider_name,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.provider_metadata_description\",\n                    \"_name\": \"IdP Metadata URL\",\n                    \"_description\": \"The URL for the IdP's federation metadata. The metadata will be automatically updated by OTDS daily at midnight.\",\n                    \"_value\": saml_url,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.provider_nameid_format\",\n                    \"_name\": \"IdP NameID Format\",\n                    \"_description\": \"Specifies which NameID format supported by the identity provider contains the desired user identifier. The value in this identifier must correspond to the value of the user attribute specified for the authentication principal attribute. This value is usually set to urn:oasis:names:tc:SAML:2.0:nameid-format:persistent or urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress. Please ensure this is consistent with the identity provider's configuration.\",\n                    \"_value\": nameid_format,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml._impersonator_claim\",\n                    \"_name\": \"Claim for impersonating user\",\n                    \"_description\": \"A claim that contains the ID of the actor/impersonator for the user identified by NameID. It must be in the same format as NameID.\",\n                    \"_value\": \"loggedinuserid\",\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.sp_url\",\n                    \"_name\": \"OTDS SP Endpoint\",\n                    \"_description\": \"Specifies the service provider URL that will be used to identify OTDS to the identity provider. If not specified, the URL will be taken from the request. This generally needs to be configured for environments in which OTDS is behind a reverse-proxy.\",\n                    \"_value\": otds_sp_endpoint,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.enable_sp_sso\",\n                    \"_name\": \"Active By Default\",\n                    \"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to the IdP. If false, the user has to select the provider on the login page.\",\n                    \"_value\": active_by_default,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml._signature_alg\",\n                    \"_name\": \"XML Signature Algorithm\",\n                    \"_description\": \"Only relevant when certificate and private key are configured. Default is http://www.w3.org/2000/09/xmldsig#rsa-sha1. Valid values are defined at http://www.w3.org/TR/xmldsig-core1/#sec-AlgID.\",\n                    \"_value\": \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\",\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.use_acs_url\",\n                    \"_name\": \"Use AssertionConsumerServiceURL\",\n                    \"_description\": \"Set to true to have the SAML AuthnRequest use AssertionConsumerServiceURL instead of AssertionConsumerServiceIndex\",\n                    \"_value\": \"true\",\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.grace_period\",\n                    \"_name\": \"Grace Period\",\n                    \"_description\": 'Specifies the number of minutes to allow for \"NotBefore\" and \"NotOnOrAfter\" fields when validating assertions in order to account for time difference between the identity provider and this service provider.',\n                    \"_value\": \"5\",\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.auth_request_binding\",\n                    \"_name\": \"Auth Request Binding\",\n                    \"_description\": \"Specifies the preferred SAML binding to use for sending the AuthnRequest, provided it is supported by the identity provider.\",\n                    \"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.saml.auth_response_binding\",\n                    \"_name\": \"Auth Response Binding\",\n                    \"_description\": \"Specifies the SAML binding to use for the response to an AuthnRequest\",\n                    \"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n                },\n            ],\n        }\n\n        request_url = self.auth_handler_url()\n\n        logger.info(\n            \"Adding SAML auth handler -&gt; %s (%s); calling -&gt; %s\",\n            name,\n            description,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=authHandlerPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add SAML auth handler -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def add_auth_handler_sap(\n        self,\n        name: str,\n        description: str,\n        scope: str | None,\n        certificate_file: str,\n        certificate_password: str,\n        enabled: bool = True,\n        priority: int = 10,\n        auth_principal_attributes: list | None = None,\n    ):\n        \"\"\"Add a new SAP authentication handler\n\n        Args:\n            name (str): name of the new authentication handler\n            description (str): description of the new authentication handler\n            scope (str): name of the user partition (to define a scope of the auth handler)\n            certificate_file (str): fully qualified file name (with path) to the certificate file\n            certificate_password (str): password of the certificate\n            enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n            priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n            auth_principal_attributes (list, optional): List of Authentication principal attributes\n        Returns:\n            Request response (json) or None if the REST call fails.\n        \"\"\"\n\n        # Avoid linter warning W0102:\n        if auth_principal_attributes is None:\n            auth_principal_attributes = [\"oTExternalID1\"]\n\n        # 1. Prepare the body for the AuthHandler REST call:\n        authHandlerPostBodyJson = {\n            \"_name\": name,\n            \"_description\": description,\n            \"_class\": \"com.opentext.otds.as.drivers.sapssoext.SAPSSOEXTAuthHandler\",\n            \"_enabled\": str.lower(str(enabled)),\n            \"_priority\": str(priority),\n            \"_authPrincipalAttrNames\": auth_principal_attributes,\n            \"_scope\": scope,\n            \"_properties\": [\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_description1\",\n                    \"_name\": \"SAP Certificate 1 Description\",\n                    \"_description\": \"Specifies a custom description for the corresponding certificate.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": os.path.basename(\n                        certificate_file\n                    ),  # \"TM6_Sandbox.pse\" - file name only\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\",\n                    \"_name\": \"SAP Certificate (PSE) 1\",\n                    \"_description\": \"Specifies a certificate (.pse file) to use to decode SAP tokens. Note: The selected file does not need to reside on the server since only its contents will be stored on the server. Clear the string in this field in order to delete the certificate stored on the server.\",\n                    \"_required\": False,\n                    \"_fileBased\": True,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": [\"pse\"],\n                    \"_value\": None,\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_pass1\",\n                    \"_name\": \"SAP Certificate 1 Password\",\n                    \"_description\": \"Specifies the password for the corresponding .pse file.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": certificate_password,\n                    \"_allowedValues\": None,\n                    \"_confidential\": True,\n                    \"_keepOriginal\": False,\n                },\n            ],\n        }\n\n        # 2. Create the auth handler in OTDS\n        request_url = self.auth_handler_url()\n\n        logger.info(\n            \"Adding SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\n            name,\n            description,\n            request_url,\n        )\n\n        response = requests.post(\n            url=request_url,\n            json=authHandlerPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if not response.ok:\n            logger.error(\n                \"Failed to add SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n\n        # 3. Upload the certificate file:\n\n        # Check that the certificate (PSE) file is readable:\n        logger.info(\"Reading certificate file -&gt; %s...\", certificate_file)\n        try:\n            # PSE files are binary - so we need to open with \"rb\":\n            with open(certificate_file, \"rb\") as certFile:\n                certContent = certFile.read()\n                if not certContent:\n                    logger.error(\"No data in certificate file -&gt; %s\", certificate_file)\n                    return None\n        except IOError as exception:\n            logger.error(\n                \"Unable to open certificate file -&gt; %s; error -&gt; %s\",\n                certificate_file,\n                exception.strerror,\n            )\n            return None\n\n        # Check that we have the binary certificate file - this is what OTDS expects. If the file content is\n        # base64 encoded we will decode it and write it back into the same file\n        try:\n            # If file is not base64 encoded the next statement will throw an exception\n            # (this is good)\n            certContentDecoded = base64.b64decode(certContent, validate=True)\n            certContentEncoded = base64.b64encode(certContentDecoded).decode(\"utf-8\")\n            if certContentEncoded == certContent.decode(\"utf-8\"):\n                logger.info(\n                    \"Certificate file -&gt; %s is base64 encoded\", certificate_file\n                )\n                cert_file_encoded = True\n            else:\n                cert_file_encoded = False\n        except TypeError:\n            logger.info(\n                \"Certificate file -&gt; %s is not base64 encoded\", certificate_file\n            )\n            cert_file_encoded = False\n\n        if cert_file_encoded:\n            certificate_file = \"/tmp/\" + os.path.basename(certificate_file)\n            logger.info(\"Writing decoded certificate file -&gt; %s...\", certificate_file)\n            try:\n                # PSE files need to be binary - so we need to open with \"wb\":\n                with open(certificate_file, \"wb\") as certFile:\n                    certFile.write(base64.b64decode(certContent))\n            except IOError as exception:\n                logger.error(\n                    \"Failed writing to file -&gt; %s; error -&gt; %s\",\n                    certificate_file,\n                    exception.strerror,\n                )\n                return None\n\n        authHandlerPostData = {\n            \"file1_property\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\"\n        }\n\n        # It is important to send the file pointer and not the actual file content\n        # otherwise the file is send base64 encoded which we don't want:\n        authHandlerPostFiles = {\n            \"file1\": (\n                os.path.basename(certificate_file),\n                open(certificate_file, \"rb\"),\n                \"application/octet-stream\",\n            )\n        }\n\n        request_url = self.auth_handler_url() + \"/\" + name + \"/files\"\n\n        logger.info(\n            \"Uploading certificate file -&gt; %s for SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\n            certificate_file,\n            name,\n            description,\n            request_url,\n        )\n\n        # it is important to NOT pass the headers parameter here!\n        # Basically, if you specify a files parameter (a dictionary),\n        # then requests will send a multipart/form-data POST automatically:\n        response = requests.post(\n            url=request_url,\n            data=authHandlerPostData,\n            files=authHandlerPostFiles,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if not response.ok:\n            logger.error(\n                \"Failed to upload certificate file -&gt; %s for SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\n                certificate_file,\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n\n        return response\n\n    # end method definition\n\n    def add_auth_handler_oauth(\n        self,\n        name: str,\n        description: str,\n        scope: str | None,\n        provider_name: str,\n        client_id: str,\n        client_secret: str,\n        active_by_default: bool = False,\n        authorization_endpoint: str = \"\",\n        token_endpoint: str = \"\",\n        scope_string: str = \"\",\n        enabled: bool = True,\n        priority: int = 10,\n        auth_principal_attributes: list | None = None,\n    ) -&gt; dict | None:\n        \"\"\"Add a new OAuth authentication handler\n\n        Args:\n            name (str): name of the new authentication handler\n            description (str): description of the new authentication handler\n            scope (str): name of the user partition (to define a scope of the auth handler)\n            provider_name (str): the name of the authentication provider. This name is displayed on the login page.\n            client_id (str): the client ID\n            client_secret (str): the client secret\n            active_by_default (bool, optional): Whether to activate this handler for any request to the OTDS login page.\n                                                If True, any login request to the OTDS login page will be redirected to this OAuth provider.\n                                                If False, the user has to select the provider on the login page.\n            authorization_endpoint (str, optional): The URL to redirect the browser to for authentication.\n                                                    It is used to retrieve the authorization code or an OIDC id_token.\n            token_endpoint (str, optional): The URL from which to retrieve the access token.\n                                            Not strictly required with OpenID Connect if using the implicit flow.\n            scope_string (str, optional): Space delimited scope values to send. Include 'openid' to use OpenID Connect.\n            enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n            priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n            auth_principal_attributes (list, optional): List of Authentication principal attributes\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\n\n        # Avoid linter warning W0102:\n        if auth_principal_attributes is None:\n            auth_principal_attributes = [\"oTExtraAttr0\"]\n\n        # 1. Prepare the body for the AuthHandler REST call:\n        authHandlerPostBodyJson = {\n            \"_name\": name,\n            \"_description\": description,\n            \"_class\": \"com.opentext.otds.as.drivers.http.OAuth2Handler\",\n            \"_enabled\": str.lower(str(enabled)),\n            \"_priority\": str(priority),\n            \"_authPrincipalAttrNames\": auth_principal_attributes,\n            \"_scope\": scope,\n            \"_properties\": [\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.provider_name\",\n                    \"_name\": \"Provider Name\",\n                    \"_description\": \"The name of the authentication provider. This name is displayed on the login page.\",\n                    \"_required\": True,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": provider_name,\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.active_by_default\",\n                    \"_name\": \"Active By Default\",\n                    \"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to this OAuth provider. If false, the user has to select the provider on the login page.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": active_by_default,\n                    \"_allowedValues\": [\"true\", \"false\"],\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_id\",\n                    \"_name\": \"Client ID\",\n                    \"_description\": \"The Client ID\",\n                    \"_required\": True,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": client_id,\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_secret\",\n                    \"_name\": \"Client Secret\",\n                    \"_description\": \"The Client Secret\",\n                    \"_required\": True,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": client_secret,\n                    \"_allowedValues\": None,\n                    \"_confidential\": True,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.scope_string\",\n                    \"_name\": \"Scope String\",\n                    \"_description\": \"Space delimited scope values to send. Include 'openid' to use OpenID Connect.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": scope_string,\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_code_url\",\n                    \"_name\": \"Authorization Endpoint\",\n                    \"_description\": \"The URL to redirect the browser to for authentication. It is used to retrieve the authorization code or an OIDC id_token.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": authorization_endpoint,\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_access_token_url\",\n                    \"_name\": \"Token Endpoint\",\n                    \"_description\": \"The URL from which to retrieve the access token. Not strictly required with OpenID Connect if using the implicit flow.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": token_endpoint,\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_user_info_url\",\n                    \"_name\": \"User Info Endpoint\",\n                    \"_description\": \"The URL from which to retrieve the JSON object representing the authorized user\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"{id}\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.user_identifier\",\n                    \"_name\": \"User Identifier Field\",\n                    \"_description\": \"The field corresponding to the user's unique ID at this provider\",\n                    \"_required\": True,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"username\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field1\",\n                    \"_name\": \"Response Field 1\",\n                    \"_description\": \"A field in the JSON response that should be mapped to an OTDS attribute. This value is case sensitive. Mapped fields are only relevant for auto-provisioned accounts.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"email\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute1\",\n                    \"_name\": \"OTDS Attribute 1\",\n                    \"_description\": \"OTDS user attribute to which the response field should be mapped.\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"mail\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field2\",\n                    \"_name\": \"Response Field 2\",\n                    \"_description\": \"\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"first_name\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute2\",\n                    \"_name\": \"OTDS Attribute 2\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"givenName\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field3\",\n                    \"_name\": \"Response Field 3\",\n                    \"_description\": \"\",\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"last_name\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute3\",\n                    \"_name\": \"OTDS Attribute 3\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"sn\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute4\",\n                    \"_name\": \"OTDS Attribute 4\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"displayName\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute5\",\n                    \"_name\": \"OTDS Attribute 5\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"oTStreetAddress\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute6\",\n                    \"_name\": \"OTDS Attribute 6\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"l\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute7\",\n                    \"_name\": \"OTDS Attribute 7\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"st\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute8\",\n                    \"_name\": \"OTDS Attribute 8\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"postalCode\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute9\",\n                    \"_name\": \"OTDS Attribute 9\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"countryName\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute10\",\n                    \"_name\": \"OTDS Attribute 10\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"oTTelephoneNumber\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute11\",\n                    \"_name\": \"OTDS Attribute 11\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"oTMemberOf\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute12\",\n                    \"_name\": \"OTDS Attribute 12\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"oTDepartment\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n                {\n                    \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute13\",\n                    \"_name\": \"OTDS Attribute 13\",\n                    \"_description\": None,\n                    \"_required\": False,\n                    \"_fileBased\": False,\n                    \"_fileName\": False,\n                    \"_fileExtensions\": None,\n                    \"_value\": \"title\",\n                    \"_allowedValues\": None,\n                    \"_confidential\": False,\n                    \"_keepOriginal\": False,\n                },\n            ],\n        }\n\n        request_url = self.auth_handler_url()\n\n        logger.info(\n            \"Adding OAuth auth handler -&gt; %s (%s); calling -&gt; %s\",\n            name,\n            description,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=authHandlerPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add OAuth auth handler -&gt; %s; error -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n        # end method definition\n\n    def consolidate(self, resource_name: str) -&gt; bool:\n        \"\"\"Consolidate an OTDS resource\n\n        Args:\n            resource_name (str): resource to be consolidated\n        Returns:\n            bool: True if the consolidation succeeded or False if it failed.\n        \"\"\"\n\n        resource = self.get_resource(resource_name)\n        if not resource:\n            logger.error(\"Resource -&gt; %s not found - cannot consolidate\", resource_name)\n            return False\n\n        resource_dn = resource[\"resourceDN\"]\n        if not resource_dn:\n            logger.error(\"Resource DN is empty - cannot consolidate\")\n            return False\n\n        consolidationPostBodyJson = {\n            \"cleanupUsersInResource\": False,\n            \"cleanupGroupsInResource\": False,\n            \"resourceList\": [resource_dn],\n            \"objectToConsolidate\": resource_dn,\n        }\n\n        request_url = \"{}\".format(self.consolidation_url())\n\n        logger.info(\n            \"Consolidation of resource -&gt; %s; calling -&gt; %s\", resource_dn, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                url=request_url,\n                json=consolidationPostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to consolidate; error -&gt; %s (%s)\",\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def impersonate_resource(\n        self,\n        resource_name: str,\n        allow_impersonation: bool = True,\n        impersonation_list: list | None = None,\n    ) -&gt; bool:\n        \"\"\"Configure impersonation for an OTDS resource\n\n        Args:\n            resource_name (str): resource to be configure impersonation for\n            allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n            impersonation_list (list, optional): list of users to restrict it to\n                                                 (default = empty list = all users)\n        Returns:\n            bool: True if the impersonation setting succeeded or False if it failed.\n        \"\"\"\n\n        # Avoid linter warning W0102:\n        if impersonation_list is None:\n            impersonation_list = []\n\n        impersonationPutBodyJson = {\n            \"allowImpersonation\": allow_impersonation,\n            \"impersonateList\": impersonation_list,\n        }\n\n        request_url = \"{}/{}/impersonation\".format(self.resource_url(), resource_name)\n\n        logger.info(\n            \"Impersonation settings for resource -&gt; %s; calling -&gt; %s\",\n            resource_name,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                json=impersonationPutBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to set impersonation for resource -&gt; %s; error -&gt; %s\",\n                    resource_name,\n                    response.text,\n                )\n                return False\n\n    # end method definition\n\n    def impersonate_oauth_client(\n        self,\n        client_id: str,\n        allow_impersonation: bool = True,\n        impersonation_list: list | None = None,\n    ) -&gt; bool:\n        \"\"\"Configure impersonation for an OTDS OAuth Client\n\n        Args:\n            client_id (str): OAuth Client to be configure impersonation for\n            allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n            impersonation_list (list, optional): list of users to restrict it to; (default = empty list = all users)\n        Returns:\n            bool: True if the impersonation setting succeeded or False if it failed.\n        \"\"\"\n\n        # Avoid linter warning W0102:\n        if impersonation_list is None:\n            impersonation_list = []\n\n        impersonationPutBodyJson = {\n            \"allowImpersonation\": allow_impersonation,\n            \"impersonateList\": impersonation_list,\n        }\n\n        request_url = \"{}/{}/impersonation\".format(self.oauth_client_url(), client_id)\n\n        logger.info(\n            \"Impersonation settings for OAuth Client -&gt; %s; calling -&gt; %s\",\n            client_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                json=impersonationPutBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to set impersonation for OAuth Client -&gt; %s; error -&gt; %s (%s)\",\n                    client_id,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n\n    # end method definition\n\n    def get_password_policy(self):\n        \"\"\"Get the global password policy\n\n        Args:\n            None\n        Returns:\n            dict: Request response or None if the REST call fails.\n\n            Example response:\n            {\n                'passwordHistoryMaximumCount': 3,\n                'daysBeforeNewPasswordMayBeChanged': 1,\n                'passwordMaximumDuration': 90,\n                'daysBeforeOldPasswordMayBeReused': 0,\n                'lockoutFailureCount': 0,\n                'lockoutDuration': 15,\n                'minimumNumberOfCharacters': 8,\n                'complexPasswordValidationEnabled': True,\n                'minimumNumberOfDigits': 1,\n                'minimumNumberOfSymbols': 1,\n                'minimumNumberOfUppercase': 1,\n                'minimumNumberOfLowercase': 1,\n                'minimumChangesToPreviousPassword': 0,\n                'maxNumberOfConsecutiveANCharsInPassword': 0,\n                'blockCommonPassword': False\n                ...\n            }\n        \"\"\"\n\n        request_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\n\n        logger.info(\"Getting password policy; calling -&gt; %s\", request_url)\n\n        retries = 0\n        while True:\n            response = requests.get(\n                url=request_url,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get password policy; error -&gt; %s (%s)\",\n                    response.text,\n                    response.status_code,\n                )\n                return None\n\n    # end method definition\n\n    def update_password_policy(self, update_values: dict) -&gt; bool:\n        \"\"\"Update the global password policy\n\n        Args:\n            update_values (dict): new values for selected settings.\n                                  A value of 0 means the settings is deactivated.\n\n            Example values:\n            {\n                'passwordHistoryMaximumCount': 3,\n                'daysBeforeNewPasswordMayBeChanged': 1,\n                'passwordMaximumDuration': 90,\n                'daysBeforeOldPasswordMayBeReused': 0,\n                'lockoutFailureCount': 0,\n                'lockoutDuration': 15,\n                'minimumNumberOfCharacters': 8,\n                'complexPasswordValidationEnabled': True,\n                'minimumNumberOfDigits': 1,\n                'minimumNumberOfSymbols': 1,\n                'minimumNumberOfUppercase': 1,\n                'minimumNumberOfLowercase': 1,\n                'minimumChangesToPreviousPassword': 0,\n                'maxNumberOfConsecutiveANCharsInPassword': 0,\n                'blockCommonPassword': False\n                ...\n            }\n        Returns:\n            bool: True if the REST call succeeds, otherwise False. We use a boolean return\n                  value as the response of the REST call does not have meaningful content.\n\n        \"\"\"\n\n        request_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\n\n        logger.info(\n            \"Update password policy with these new values -&gt; %s; calling -&gt; %s\",\n            update_values,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                json=update_values,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n            if response.ok:\n                return True\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update password policy with values -&gt; %s; error -&gt; %s (%s)\",\n                    update_values,\n                    response.text,\n                    response.status_code,\n                )\n                return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.__init__","title":"<code>__init__(protocol, hostname, port, username=None, password=None, otds_ticket=None)</code>","text":"<p>Initialize the OTDS object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>either http or https</p> required <code>hostname</code> <code>str</code> <p>hostname of otds</p> required <code>port</code> <code>int</code> <p>port number - typically 80 or 443</p> required <code>username</code> <code>str</code> <p>otds user name. Optional if otds_ticket is provided.</p> <code>None</code> <code>password</code> <code>str</code> <p>otds password. Optional if otds_ticket is provided.</p> <code>None</code> <code>otds_ticket</code> <code>str</code> <p>Authentication ticket of OTDS</p> <code>None</code> Source code in <code>pyxecm/otds.py</code> <pre><code>def __init__(\n    self,\n    protocol: str,\n    hostname: str,\n    port: int,\n    username: str | None = None,\n    password: str | None = None,\n    otds_ticket: str | None = None,\n):\n    \"\"\"Initialize the OTDS object\n\n    Args:\n        protocol (str): either http or https\n        hostname (str): hostname of otds\n        port (int): port number - typically 80 or 443\n        username (str, optional): otds user name. Optional if otds_ticket is provided.\n        password (str, optional): otds password. Optional if otds_ticket is provided.\n        otds_ticket (str, optional): Authentication ticket of OTDS\n    \"\"\"\n\n    # Initialize otdsConfig as an empty dictionary\n    otds_config = {}\n\n    if hostname:\n        otds_config[\"hostname\"] = hostname\n    else:\n        otds_config[\"hostname\"] = \"otds\"\n\n    if protocol:\n        otds_config[\"protocol\"] = protocol\n    else:\n        otds_config[\"protocol\"] = \"http\"\n\n    if port:\n        otds_config[\"port\"] = port\n    else:\n        otds_config[\"port\"] = 80\n\n    if username:\n        otds_config[\"username\"] = username\n    else:\n        otds_config[\"username\"] = \"admin\"\n\n    if password:\n        otds_config[\"password\"] = password\n    else:\n        otds_config[\"password\"] = \"\"\n\n    if otds_ticket:\n        self._cookie = {\"OTDSTicket\": otds_ticket}\n\n    otdsBaseUrl = protocol + \"://\" + otds_config[\"hostname\"]\n    if str(port) not in [\"80\", \"443\"]:\n        otdsBaseUrl += \":{}\".format(port)\n    otdsBaseUrl += \"/otdsws\"\n    otds_config[\"baseUrl\"] = otdsBaseUrl\n\n    otdsRestUrl = otdsBaseUrl + \"/rest\"\n    otds_config[\"restUrl\"] = otdsRestUrl\n\n    otds_config[\"partitionUrl\"] = otdsRestUrl + \"/partitions\"\n    otds_config[\"accessRoleUrl\"] = otdsRestUrl + \"/accessroles\"\n    otds_config[\"credentialUrl\"] = otdsRestUrl + \"/authentication/credentials\"\n    otds_config[\"oauthClientUrl\"] = otdsRestUrl + \"/oauthclients\"\n    otds_config[\"tokenUrl\"] = otdsBaseUrl + \"/oauth2/token\"\n    otds_config[\"resourceUrl\"] = otdsRestUrl + \"/resources\"\n    otds_config[\"licenseUrl\"] = otdsRestUrl + \"/licensemanagement/licenses\"\n    otds_config[\"usersUrl\"] = otdsRestUrl + \"/users\"\n    otds_config[\"groupsUrl\"] = otdsRestUrl + \"/groups\"\n    otds_config[\"systemConfigUrl\"] = otdsRestUrl + \"/systemconfig\"\n    otds_config[\"authHandlerUrl\"] = otdsRestUrl + \"/authhandlers\"\n    otds_config[\"consolidationUrl\"] = otdsRestUrl + \"/consolidation\"\n\n    self._config = otds_config\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.access_role_url","title":"<code>access_role_url()</code>","text":"<p>Returns the Access Role URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Access Role URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def access_role_url(self) -&gt; str:\n    \"\"\"Returns the Access Role URL of OTDS\n\n    Returns:\n        str: Access Role URL\n    \"\"\"\n    return self.config()[\"accessRoleUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.activate_resource","title":"<code>activate_resource(resource_id)</code>","text":"<p>Activate an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>ID of the OTDS resource</p> required <p>Returns:     dict: Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def activate_resource(self, resource_id: str) -&gt; dict | None:\n    \"\"\"Activate an OTDS resource\n\n    Args:\n        resource_id (str): ID of the OTDS resource\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\n\n    resourcePostBodyJson = {}\n\n    request_url = \"{}/{}/activate\".format(self.config()[\"resourceUrl\"], resource_id)\n\n    logger.info(\n        \"Activating resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=resourcePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to activate resource -&gt; %s; error -&gt; %s (%s)\",\n                resource_id,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_auth_handler_oauth","title":"<code>add_auth_handler_oauth(name, description, scope, provider_name, client_id, client_secret, active_by_default=False, authorization_endpoint='', token_endpoint='', scope_string='', enabled=True, priority=10, auth_principal_attributes=None)</code>","text":"<p>Add a new OAuth authentication handler</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new authentication handler</p> required <code>description</code> <code>str</code> <p>description of the new authentication handler</p> required <code>scope</code> <code>str</code> <p>name of the user partition (to define a scope of the auth handler)</p> required <code>provider_name</code> <code>str</code> <p>the name of the authentication provider. This name is displayed on the login page.</p> required <code>client_id</code> <code>str</code> <p>the client ID</p> required <code>client_secret</code> <code>str</code> <p>the client secret</p> required <code>active_by_default</code> <code>bool</code> <p>Whether to activate this handler for any request to the OTDS login page.                                 If True, any login request to the OTDS login page will be redirected to this OAuth provider.                                 If False, the user has to select the provider on the login page.</p> <code>False</code> <code>authorization_endpoint</code> <code>str</code> <p>The URL to redirect the browser to for authentication.                                     It is used to retrieve the authorization code or an OIDC id_token.</p> <code>''</code> <code>token_endpoint</code> <code>str</code> <p>The URL from which to retrieve the access token.                             Not strictly required with OpenID Connect if using the implicit flow.</p> <code>''</code> <code>scope_string</code> <code>str</code> <p>Space delimited scope values to send. Include 'openid' to use OpenID Connect.</p> <code>''</code> <code>enabled</code> <code>bool</code> <p>if the handler should be enabled or disabled. Default is True = enabled.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the Authentical Handler (compared to others). Default is 5</p> <code>10</code> <code>auth_principal_attributes</code> <code>list</code> <p>List of Authentication principal attributes</p> <code>None</code> <p>Returns:     dict: Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_auth_handler_oauth(\n    self,\n    name: str,\n    description: str,\n    scope: str | None,\n    provider_name: str,\n    client_id: str,\n    client_secret: str,\n    active_by_default: bool = False,\n    authorization_endpoint: str = \"\",\n    token_endpoint: str = \"\",\n    scope_string: str = \"\",\n    enabled: bool = True,\n    priority: int = 10,\n    auth_principal_attributes: list | None = None,\n) -&gt; dict | None:\n    \"\"\"Add a new OAuth authentication handler\n\n    Args:\n        name (str): name of the new authentication handler\n        description (str): description of the new authentication handler\n        scope (str): name of the user partition (to define a scope of the auth handler)\n        provider_name (str): the name of the authentication provider. This name is displayed on the login page.\n        client_id (str): the client ID\n        client_secret (str): the client secret\n        active_by_default (bool, optional): Whether to activate this handler for any request to the OTDS login page.\n                                            If True, any login request to the OTDS login page will be redirected to this OAuth provider.\n                                            If False, the user has to select the provider on the login page.\n        authorization_endpoint (str, optional): The URL to redirect the browser to for authentication.\n                                                It is used to retrieve the authorization code or an OIDC id_token.\n        token_endpoint (str, optional): The URL from which to retrieve the access token.\n                                        Not strictly required with OpenID Connect if using the implicit flow.\n        scope_string (str, optional): Space delimited scope values to send. Include 'openid' to use OpenID Connect.\n        enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n        priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n        auth_principal_attributes (list, optional): List of Authentication principal attributes\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\n\n    # Avoid linter warning W0102:\n    if auth_principal_attributes is None:\n        auth_principal_attributes = [\"oTExtraAttr0\"]\n\n    # 1. Prepare the body for the AuthHandler REST call:\n    authHandlerPostBodyJson = {\n        \"_name\": name,\n        \"_description\": description,\n        \"_class\": \"com.opentext.otds.as.drivers.http.OAuth2Handler\",\n        \"_enabled\": str.lower(str(enabled)),\n        \"_priority\": str(priority),\n        \"_authPrincipalAttrNames\": auth_principal_attributes,\n        \"_scope\": scope,\n        \"_properties\": [\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.provider_name\",\n                \"_name\": \"Provider Name\",\n                \"_description\": \"The name of the authentication provider. This name is displayed on the login page.\",\n                \"_required\": True,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": provider_name,\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.active_by_default\",\n                \"_name\": \"Active By Default\",\n                \"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to this OAuth provider. If false, the user has to select the provider on the login page.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": active_by_default,\n                \"_allowedValues\": [\"true\", \"false\"],\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_id\",\n                \"_name\": \"Client ID\",\n                \"_description\": \"The Client ID\",\n                \"_required\": True,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": client_id,\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_secret\",\n                \"_name\": \"Client Secret\",\n                \"_description\": \"The Client Secret\",\n                \"_required\": True,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": client_secret,\n                \"_allowedValues\": None,\n                \"_confidential\": True,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.scope_string\",\n                \"_name\": \"Scope String\",\n                \"_description\": \"Space delimited scope values to send. Include 'openid' to use OpenID Connect.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": scope_string,\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_code_url\",\n                \"_name\": \"Authorization Endpoint\",\n                \"_description\": \"The URL to redirect the browser to for authentication. It is used to retrieve the authorization code or an OIDC id_token.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": authorization_endpoint,\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_access_token_url\",\n                \"_name\": \"Token Endpoint\",\n                \"_description\": \"The URL from which to retrieve the access token. Not strictly required with OpenID Connect if using the implicit flow.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": token_endpoint,\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_user_info_url\",\n                \"_name\": \"User Info Endpoint\",\n                \"_description\": \"The URL from which to retrieve the JSON object representing the authorized user\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"{id}\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.user_identifier\",\n                \"_name\": \"User Identifier Field\",\n                \"_description\": \"The field corresponding to the user's unique ID at this provider\",\n                \"_required\": True,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"username\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field1\",\n                \"_name\": \"Response Field 1\",\n                \"_description\": \"A field in the JSON response that should be mapped to an OTDS attribute. This value is case sensitive. Mapped fields are only relevant for auto-provisioned accounts.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"email\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute1\",\n                \"_name\": \"OTDS Attribute 1\",\n                \"_description\": \"OTDS user attribute to which the response field should be mapped.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"mail\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field2\",\n                \"_name\": \"Response Field 2\",\n                \"_description\": \"\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"first_name\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute2\",\n                \"_name\": \"OTDS Attribute 2\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"givenName\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field3\",\n                \"_name\": \"Response Field 3\",\n                \"_description\": \"\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"last_name\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute3\",\n                \"_name\": \"OTDS Attribute 3\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"sn\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute4\",\n                \"_name\": \"OTDS Attribute 4\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"displayName\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute5\",\n                \"_name\": \"OTDS Attribute 5\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"oTStreetAddress\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute6\",\n                \"_name\": \"OTDS Attribute 6\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"l\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute7\",\n                \"_name\": \"OTDS Attribute 7\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"st\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute8\",\n                \"_name\": \"OTDS Attribute 8\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"postalCode\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute9\",\n                \"_name\": \"OTDS Attribute 9\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"countryName\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute10\",\n                \"_name\": \"OTDS Attribute 10\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"oTTelephoneNumber\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute11\",\n                \"_name\": \"OTDS Attribute 11\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"oTMemberOf\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute12\",\n                \"_name\": \"OTDS Attribute 12\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"oTDepartment\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute13\",\n                \"_name\": \"OTDS Attribute 13\",\n                \"_description\": None,\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": \"title\",\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n        ],\n    }\n\n    request_url = self.auth_handler_url()\n\n    logger.info(\n        \"Adding OAuth auth handler -&gt; %s (%s); calling -&gt; %s\",\n        name,\n        description,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=authHandlerPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add OAuth auth handler -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_auth_handler_saml","title":"<code>add_auth_handler_saml(name, description, scope, provider_name, saml_url, otds_sp_endpoint, enabled=True, priority=5, active_by_default=False, auth_principal_attributes=None, nameid_format='urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified')</code>","text":"<p>Add a new SAML authentication handler</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new authentication handler</p> required <code>description</code> <code>str</code> <p>description of the new authentication handler</p> required <code>scope</code> <code>str</code> <p>name of the user partition (to define a scope of the auth handler)</p> required <code>provider_name</code> <code>str</code> <p>description of the new authentication handler</p> required <code>saml_url</code> <code>str</code> <p>SAML URL</p> required <code>otds_sp_endpoint</code> <code>str</code> <p>the external(!) service provider URL of OTDS</p> required <code>enabled</code> <code>bool</code> <p>if the handler should be enabled or disabled. Default is True = enabled.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the Authentical Handler (compared to others). Default is 5</p> <code>5</code> <code>active_by_default</code> <code>bool</code> <p>should OTDS redirect immediately to provider page                                 (not showing the OTDS login at all)</p> <code>False</code> <code>auth_principal_attributes</code> <code>list</code> <p>List of Authentication principal attributes</p> <code>None</code> <code>nameid_format</code> <code>str</code> <p>Specifies which NameID format supported by the identity provider                            contains the desired user identifier. The value in this identifier                            must correspond to the value of the user attribute specified for the                            authentication principal attribute.</p> <code>'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified'</code> <p>Returns:     dict: Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_auth_handler_saml(\n    self,\n    name: str,\n    description: str,\n    scope: str | None,\n    provider_name: str,\n    saml_url: str,\n    otds_sp_endpoint: str,\n    enabled: bool = True,\n    priority: int = 5,\n    active_by_default: bool = False,\n    auth_principal_attributes: list | None = None,\n    nameid_format: str = \"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\",\n) -&gt; dict | None:\n    \"\"\"Add a new SAML authentication handler\n\n    Args:\n        name (str): name of the new authentication handler\n        description (str): description of the new authentication handler\n        scope (str): name of the user partition (to define a scope of the auth handler)\n        provider_name (str): description of the new authentication handler\n        saml_url (str): SAML URL\n        otds_sp_endpoint (str): the external(!) service provider URL of OTDS\n        enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n        priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n        active_by_default (bool, optional): should OTDS redirect immediately to provider page\n                                            (not showing the OTDS login at all)\n        auth_principal_attributes (list, optional): List of Authentication principal attributes\n        nameid_format (str, optional): Specifies which NameID format supported by the identity provider\n                                       contains the desired user identifier. The value in this identifier\n                                       must correspond to the value of the user attribute specified for the\n                                       authentication principal attribute.\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\n\n    if auth_principal_attributes is None:\n        auth_principal_attributes = [\"oTExternalID1\", \"oTUserID1\"]\n\n    authHandlerPostBodyJson = {\n        \"_name\": name,\n        \"_description\": description,\n        \"_class\": \"com.opentext.otds.as.drivers.saml.SAML2Handler\",\n        \"_enabled\": str.lower(str(enabled)),\n        \"_priority\": str(priority),\n        \"_authPrincipalAttrNames\": auth_principal_attributes,\n        \"_scope\": scope,\n        \"_properties\": [\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.provider_name\",\n                \"_name\": \"Identity Provider (IdP) Name\",\n                \"_description\": \"The name of the identity provider. This should be a single word since it will be part of the metadata URL.\",\n                \"_value\": provider_name,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.provider_metadata_description\",\n                \"_name\": \"IdP Metadata URL\",\n                \"_description\": \"The URL for the IdP's federation metadata. The metadata will be automatically updated by OTDS daily at midnight.\",\n                \"_value\": saml_url,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.provider_nameid_format\",\n                \"_name\": \"IdP NameID Format\",\n                \"_description\": \"Specifies which NameID format supported by the identity provider contains the desired user identifier. The value in this identifier must correspond to the value of the user attribute specified for the authentication principal attribute. This value is usually set to urn:oasis:names:tc:SAML:2.0:nameid-format:persistent or urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress. Please ensure this is consistent with the identity provider's configuration.\",\n                \"_value\": nameid_format,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml._impersonator_claim\",\n                \"_name\": \"Claim for impersonating user\",\n                \"_description\": \"A claim that contains the ID of the actor/impersonator for the user identified by NameID. It must be in the same format as NameID.\",\n                \"_value\": \"loggedinuserid\",\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.sp_url\",\n                \"_name\": \"OTDS SP Endpoint\",\n                \"_description\": \"Specifies the service provider URL that will be used to identify OTDS to the identity provider. If not specified, the URL will be taken from the request. This generally needs to be configured for environments in which OTDS is behind a reverse-proxy.\",\n                \"_value\": otds_sp_endpoint,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.enable_sp_sso\",\n                \"_name\": \"Active By Default\",\n                \"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to the IdP. If false, the user has to select the provider on the login page.\",\n                \"_value\": active_by_default,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml._signature_alg\",\n                \"_name\": \"XML Signature Algorithm\",\n                \"_description\": \"Only relevant when certificate and private key are configured. Default is http://www.w3.org/2000/09/xmldsig#rsa-sha1. Valid values are defined at http://www.w3.org/TR/xmldsig-core1/#sec-AlgID.\",\n                \"_value\": \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\",\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.use_acs_url\",\n                \"_name\": \"Use AssertionConsumerServiceURL\",\n                \"_description\": \"Set to true to have the SAML AuthnRequest use AssertionConsumerServiceURL instead of AssertionConsumerServiceIndex\",\n                \"_value\": \"true\",\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.grace_period\",\n                \"_name\": \"Grace Period\",\n                \"_description\": 'Specifies the number of minutes to allow for \"NotBefore\" and \"NotOnOrAfter\" fields when validating assertions in order to account for time difference between the identity provider and this service provider.',\n                \"_value\": \"5\",\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.auth_request_binding\",\n                \"_name\": \"Auth Request Binding\",\n                \"_description\": \"Specifies the preferred SAML binding to use for sending the AuthnRequest, provided it is supported by the identity provider.\",\n                \"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.saml.auth_response_binding\",\n                \"_name\": \"Auth Response Binding\",\n                \"_description\": \"Specifies the SAML binding to use for the response to an AuthnRequest\",\n                \"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n            },\n        ],\n    }\n\n    request_url = self.auth_handler_url()\n\n    logger.info(\n        \"Adding SAML auth handler -&gt; %s (%s); calling -&gt; %s\",\n        name,\n        description,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=authHandlerPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add SAML auth handler -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_auth_handler_sap","title":"<code>add_auth_handler_sap(name, description, scope, certificate_file, certificate_password, enabled=True, priority=10, auth_principal_attributes=None)</code>","text":"<p>Add a new SAP authentication handler</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new authentication handler</p> required <code>description</code> <code>str</code> <p>description of the new authentication handler</p> required <code>scope</code> <code>str</code> <p>name of the user partition (to define a scope of the auth handler)</p> required <code>certificate_file</code> <code>str</code> <p>fully qualified file name (with path) to the certificate file</p> required <code>certificate_password</code> <code>str</code> <p>password of the certificate</p> required <code>enabled</code> <code>bool</code> <p>if the handler should be enabled or disabled. Default is True = enabled.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the Authentical Handler (compared to others). Default is 5</p> <code>10</code> <code>auth_principal_attributes</code> <code>list</code> <p>List of Authentication principal attributes</p> <code>None</code> <p>Returns:     Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_auth_handler_sap(\n    self,\n    name: str,\n    description: str,\n    scope: str | None,\n    certificate_file: str,\n    certificate_password: str,\n    enabled: bool = True,\n    priority: int = 10,\n    auth_principal_attributes: list | None = None,\n):\n    \"\"\"Add a new SAP authentication handler\n\n    Args:\n        name (str): name of the new authentication handler\n        description (str): description of the new authentication handler\n        scope (str): name of the user partition (to define a scope of the auth handler)\n        certificate_file (str): fully qualified file name (with path) to the certificate file\n        certificate_password (str): password of the certificate\n        enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n        priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n        auth_principal_attributes (list, optional): List of Authentication principal attributes\n    Returns:\n        Request response (json) or None if the REST call fails.\n    \"\"\"\n\n    # Avoid linter warning W0102:\n    if auth_principal_attributes is None:\n        auth_principal_attributes = [\"oTExternalID1\"]\n\n    # 1. Prepare the body for the AuthHandler REST call:\n    authHandlerPostBodyJson = {\n        \"_name\": name,\n        \"_description\": description,\n        \"_class\": \"com.opentext.otds.as.drivers.sapssoext.SAPSSOEXTAuthHandler\",\n        \"_enabled\": str.lower(str(enabled)),\n        \"_priority\": str(priority),\n        \"_authPrincipalAttrNames\": auth_principal_attributes,\n        \"_scope\": scope,\n        \"_properties\": [\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_description1\",\n                \"_name\": \"SAP Certificate 1 Description\",\n                \"_description\": \"Specifies a custom description for the corresponding certificate.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": os.path.basename(\n                    certificate_file\n                ),  # \"TM6_Sandbox.pse\" - file name only\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\",\n                \"_name\": \"SAP Certificate (PSE) 1\",\n                \"_description\": \"Specifies a certificate (.pse file) to use to decode SAP tokens. Note: The selected file does not need to reside on the server since only its contents will be stored on the server. Clear the string in this field in order to delete the certificate stored on the server.\",\n                \"_required\": False,\n                \"_fileBased\": True,\n                \"_fileName\": False,\n                \"_fileExtensions\": [\"pse\"],\n                \"_value\": None,\n                \"_allowedValues\": None,\n                \"_confidential\": False,\n                \"_keepOriginal\": False,\n            },\n            {\n                \"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_pass1\",\n                \"_name\": \"SAP Certificate 1 Password\",\n                \"_description\": \"Specifies the password for the corresponding .pse file.\",\n                \"_required\": False,\n                \"_fileBased\": False,\n                \"_fileName\": False,\n                \"_fileExtensions\": None,\n                \"_value\": certificate_password,\n                \"_allowedValues\": None,\n                \"_confidential\": True,\n                \"_keepOriginal\": False,\n            },\n        ],\n    }\n\n    # 2. Create the auth handler in OTDS\n    request_url = self.auth_handler_url()\n\n    logger.info(\n        \"Adding SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\n        name,\n        description,\n        request_url,\n    )\n\n    response = requests.post(\n        url=request_url,\n        json=authHandlerPostBodyJson,\n        headers=REQUEST_HEADERS,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n    if not response.ok:\n        logger.error(\n            \"Failed to add SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\n            name,\n            response.text,\n            response.status_code,\n        )\n        return None\n\n    # 3. Upload the certificate file:\n\n    # Check that the certificate (PSE) file is readable:\n    logger.info(\"Reading certificate file -&gt; %s...\", certificate_file)\n    try:\n        # PSE files are binary - so we need to open with \"rb\":\n        with open(certificate_file, \"rb\") as certFile:\n            certContent = certFile.read()\n            if not certContent:\n                logger.error(\"No data in certificate file -&gt; %s\", certificate_file)\n                return None\n    except IOError as exception:\n        logger.error(\n            \"Unable to open certificate file -&gt; %s; error -&gt; %s\",\n            certificate_file,\n            exception.strerror,\n        )\n        return None\n\n    # Check that we have the binary certificate file - this is what OTDS expects. If the file content is\n    # base64 encoded we will decode it and write it back into the same file\n    try:\n        # If file is not base64 encoded the next statement will throw an exception\n        # (this is good)\n        certContentDecoded = base64.b64decode(certContent, validate=True)\n        certContentEncoded = base64.b64encode(certContentDecoded).decode(\"utf-8\")\n        if certContentEncoded == certContent.decode(\"utf-8\"):\n            logger.info(\n                \"Certificate file -&gt; %s is base64 encoded\", certificate_file\n            )\n            cert_file_encoded = True\n        else:\n            cert_file_encoded = False\n    except TypeError:\n        logger.info(\n            \"Certificate file -&gt; %s is not base64 encoded\", certificate_file\n        )\n        cert_file_encoded = False\n\n    if cert_file_encoded:\n        certificate_file = \"/tmp/\" + os.path.basename(certificate_file)\n        logger.info(\"Writing decoded certificate file -&gt; %s...\", certificate_file)\n        try:\n            # PSE files need to be binary - so we need to open with \"wb\":\n            with open(certificate_file, \"wb\") as certFile:\n                certFile.write(base64.b64decode(certContent))\n        except IOError as exception:\n            logger.error(\n                \"Failed writing to file -&gt; %s; error -&gt; %s\",\n                certificate_file,\n                exception.strerror,\n            )\n            return None\n\n    authHandlerPostData = {\n        \"file1_property\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\"\n    }\n\n    # It is important to send the file pointer and not the actual file content\n    # otherwise the file is send base64 encoded which we don't want:\n    authHandlerPostFiles = {\n        \"file1\": (\n            os.path.basename(certificate_file),\n            open(certificate_file, \"rb\"),\n            \"application/octet-stream\",\n        )\n    }\n\n    request_url = self.auth_handler_url() + \"/\" + name + \"/files\"\n\n    logger.info(\n        \"Uploading certificate file -&gt; %s for SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\n        certificate_file,\n        name,\n        description,\n        request_url,\n    )\n\n    # it is important to NOT pass the headers parameter here!\n    # Basically, if you specify a files parameter (a dictionary),\n    # then requests will send a multipart/form-data POST automatically:\n    response = requests.post(\n        url=request_url,\n        data=authHandlerPostData,\n        files=authHandlerPostFiles,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n    if not response.ok:\n        logger.error(\n            \"Failed to upload certificate file -&gt; %s for SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\n            certificate_file,\n            name,\n            response.text,\n            response.status_code,\n        )\n        return None\n\n    return response\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_group","title":"<code>add_group(partition, name, description)</code>","text":"<p>Add a new user group to a user partition in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the OTDS user partition (needs to exist)</p> required <code>name</code> <code>str</code> <p>name of the new group</p> required <code>description</code> <code>str</code> <p>description of the new group</p> required <p>Returns:     dict: Request response (json) or None if the creation fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_group(self, partition: str, name: str, description: str) -&gt; dict | None:\n    \"\"\"Add a new user group to a user partition in OTDS\n\n    Args:\n        partition (str): name of the OTDS user partition (needs to exist)\n        name (str): name of the new group\n        description (str): description of the new group\n    Returns:\n        dict: Request response (json) or None if the creation fails.\n    \"\"\"\n\n    groupPostBodyJson = {\n        \"userPartitionID\": partition,\n        \"name\": name,\n        \"description\": description,\n    }\n\n    request_url = self.groups_url()\n\n    logger.info(\n        \"Adding group -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\n        name,\n        partition,\n        request_url,\n    )\n    logger.debug(\"Group Attributes -&gt; %s\", str(groupPostBodyJson))\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=groupPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add group -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_group_to_access_role","title":"<code>add_group_to_access_role(access_role, group, location='')</code>","text":"<p>Add an OTDS group to an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>access_role</code> <code>str</code> <p>name of the OTDS access role</p> required <code>group</code> <code>str</code> <p>name of the group</p> required <code>location</code> <code>str</code> <p>this is kind of a unique identifier DN (Distinguished Name)                       most of the times you will want to keep it to empty string (\"\")</p> <code>''</code> <p>Returns:     bool: True if group is in access role or has been successfully added.           False if group has been not been added (error)</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_group_to_access_role(\n    self, access_role: str, group: str, location: str = \"\"\n) -&gt; bool:\n    \"\"\"Add an OTDS group to an OTDS access role\n\n    Args:\n        access_role (str): name of the OTDS access role\n        group (str): name of the group\n        location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                  most of the times you will want to keep it to empty string (\"\")\n    Returns:\n        bool: True if group is in access role or has been successfully added.\n              False if group has been not been added (error)\n    \"\"\"\n\n    # get existing members to check if user is already a member:\n    accessRolesGetResponse = self.get_access_role(access_role)\n    if not accessRolesGetResponse:\n        return False\n\n    # Checking if group already added to access role\n    accessRoleGroups = accessRolesGetResponse[\"accessRoleMembers\"][\"groups\"]\n    for accessRoleGroup in accessRoleGroups:\n        if accessRoleGroup[\"name\"] == group:\n            logger.info(\n                \"Group -&gt; %s already added to access role -&gt; %s\", group, access_role\n            )\n            return True\n\n    logger.info(\n        \"Group -&gt; %s is not yet in access role -&gt; %s - adding...\",\n        group,\n        access_role,\n    )\n\n    # create payload for REST call:\n    accessRolePostBodyJson = {\"groups\": [{\"name\": group, \"location\": location}]}\n\n    request_url = \"{}/{}/members\".format(\n        self.config()[\"accessRoleUrl\"], access_role\n    )\n\n    logger.info(\n        \"Add group -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\n        group,\n        access_role,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=accessRolePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add group -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\n                group,\n                access_role,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_group_to_parent_group","title":"<code>add_group_to_parent_group(group, parent_group)</code>","text":"<p>Add an existing group to an existing parent group in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>name of the OTDS group (needs to exist)</p> required <code>parent_group</code> <code>str</code> <p>name of the OTDS parent group (needs to exist)</p> required <p>Returns:     bool: True, if request is successful, False otherwise.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_group_to_parent_group(self, group: str, parent_group: str) -&gt; bool:\n    \"\"\"Add an existing group to an existing parent group in OTDS\n\n    Args:\n        group (str): name of the OTDS group (needs to exist)\n        parent_group (str): name of the OTDS parent group (needs to exist)\n    Returns:\n        bool: True, if request is successful, False otherwise.\n    \"\"\"\n\n    groupToParentGroupPostBodyJson = {\"stringList\": [parent_group]}\n\n    request_url = self.groups_url() + \"/\" + group + \"/memberof\"\n\n    logger.info(\n        \"Adding group -&gt; %s to parent group -&gt; %s; calling -&gt; %s\",\n        group,\n        parent_group,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=groupToParentGroupPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add group -&gt; %s to parent group -&gt; %s; error -&gt; %s (%s)\",\n                group,\n                parent_group,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_license_to_resource","title":"<code>add_license_to_resource(path_to_license_file, product_name, product_description, resource_id, update=True)</code>","text":"<p>Add a product license to an OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_license_file</code> <code>str</code> <p>fully qualified filename of the license file</p> required <code>product_name</code> <code>str</code> <p>product name</p> required <code>product_description</code> <code>str</code> <p>product description</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>update</code> <code>bool</code> <p>whether or not an existing license should be updated (default = True)</p> <code>True</code> <p>Returns:     dict: Request response (dictionary) or None if the REST call fails</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_license_to_resource(\n    self,\n    path_to_license_file: str,\n    product_name: str,\n    product_description: str,\n    resource_id: str,\n    update: bool = True,\n) -&gt; dict | None:\n    \"\"\"Add a product license to an OTDS resource.\n\n    Args:\n        path_to_license_file (str): fully qualified filename of the license file\n        product_name (str): product name\n        product_description (str): product description\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        update (bool, optional): whether or not an existing license should be updated (default = True)\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails\n    \"\"\"\n\n    logger.info(\"Reading license file -&gt; %s...\", path_to_license_file)\n    try:\n        with open(path_to_license_file, \"rt\", encoding=\"UTF-8\") as license_file:\n            license_content = license_file.read()\n    except IOError as exception:\n        logger.error(\n            \"Error opening license file -&gt; %s; error -&gt; %s\",\n            path_to_license_file,\n            exception.strerror,\n        )\n        return None\n\n    licensePostBodyJson = {\n        \"description\": product_description,\n        \"name\": product_name,\n        \"values\": [\n            {\"name\": \"oTLicenseFile\", \"values\": license_content},\n            {\"name\": \"oTLicenseResource\", \"values\": resource_id},\n            {\"name\": \"oTLicenseFingerprintGenerator\", \"values\": [None]},\n        ],\n    }\n\n    request_url = self.license_url()\n    # Check if we want to update an existing license:\n    if update:\n        existing_license = self.get_license_for_resource(resource_id)\n        if existing_license:\n            request_url += \"/\" + existing_license[0][\"id\"]\n        else:\n            logger.info(\n                \"No existing license for resource -&gt; %s found - adding a new license...\",\n                resource_id,\n            )\n            # change strategy to create a new license:\n            update = False\n\n    logger.info(\n        \"Adding product license -&gt; %s for product -&gt; %s to resource -&gt; %s; calling -&gt; %s\",\n        path_to_license_file,\n        product_description,\n        resource_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        if update:\n            # Do a REST PUT call for update an existing license:\n            response = requests.put(\n                url=request_url,\n                json=licensePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n        else:\n            # Do a REST POST call for creation of a new license:\n            response = requests.post(\n                url=request_url,\n                json=licensePostBodyJson,\n                headers=REQUEST_HEADERS,\n                cookies=self.cookie(),\n                timeout=None,\n            )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add product license -&gt; %s for product -&gt; %s; error -&gt; %s (%s)\",\n                path_to_license_file,\n                product_description,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_oauth_client","title":"<code>add_oauth_client(client_id, description, redirect_urls=None, allow_impersonation=True, confidential=True, auth_scopes=None, allowed_scopes=None, default_scopes=None, secret='')</code>","text":"<p>Add a new OAuth client to OTDS</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>name of the new OAuth client (should not have blanks)</p> required <code>description</code> <code>str</code> <p>description of the OAuth client</p> required <code>redirect_urls</code> <code>list</code> <p>list of redirect URLs (strings)</p> <code>None</code> <code>allow_impersonation</code> <code>bool</code> <p>allow impresonation</p> <code>True</code> <code>confidential</code> <code>bool</code> <p>is confidential</p> <code>True</code> <code>auth_scopes</code> <code>list</code> <p>if empty then \"Global\"</p> <code>None</code> <code>allowed_scopes</code> <code>list</code> <p>in OTDS UI this is called Permissible scopes</p> <code>None</code> <code>default_scopes</code> <code>list</code> <p>in OTDS UI this is called Default scopes</p> <code>None</code> <code>secret</code> <code>str</code> <p>predefined OAuth client secret. If empty a new secret is generated.</p> <code>''</code> <p>Returns:     dict: Request response or None if the creation fails.     Example:     {         \"description\": \"string\",         \"redirectURLs\": [             \"string\"         ],         \"id\": \"string\",         \"location\": \"string\",         \"accessTokenLifeTime\": 0,         \"refreshTokenLifeTime\": 0,         \"authCodeLifeTime\": 0,         \"allowRefreshToken\": true,         \"allowImpersonation\": true,         \"useSessionRefreshTokenLifeTime\": true,         \"allowedScopes\": [             \"string\"         ],         \"defaultScopes\": [             \"string\"         ],         \"impersonateList\": [             \"string\"         ],         \"confidential\": true,         \"secret\": \"string\",         \"customAttributes\": [             {             \"type\": \"string\",             \"name\": \"string\",             \"value\": \"string\"             }         ],         \"logoutURL\": \"string\",         \"logoutMethod\": \"string\",         \"authScopes\": [             \"string\"         ],         \"uuid\": \"string\",         \"name\": \"string\",         \"urlId\": \"string\",         \"urlLocation\": \"string\"     }</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_oauth_client(\n    self,\n    client_id: str,\n    description: str,\n    redirect_urls: list | None = None,\n    allow_impersonation: bool = True,\n    confidential: bool = True,\n    auth_scopes: list | None = None,  # None = \"Global\"\n    allowed_scopes: list | None = None,  # in OTDS UI: Permissible scopes\n    default_scopes: list | None = None,  # in OTDS UI: Default scopes\n    secret: str = \"\",\n) -&gt; dict | None:\n    \"\"\"Add a new OAuth client to OTDS\n\n    Args:\n        client_id (str): name of the new OAuth client (should not have blanks)\n        description (str): description of the OAuth client\n        redirect_urls (list): list of redirect URLs (strings)\n        allow_impersonation (bool, optional): allow impresonation\n        confidential (bool, optional): is confidential\n        auth_scopes (list, optional): if empty then \"Global\"\n        allowed_scopes (list, optional): in OTDS UI this is called Permissible scopes\n        default_scopes (list, optional): in OTDS UI this is called Default scopes\n        secret (str, optional): predefined OAuth client secret. If empty a new secret is generated.\n    Returns:\n        dict: Request response or None if the creation fails.\n        Example:\n        {\n            \"description\": \"string\",\n            \"redirectURLs\": [\n                \"string\"\n            ],\n            \"id\": \"string\",\n            \"location\": \"string\",\n            \"accessTokenLifeTime\": 0,\n            \"refreshTokenLifeTime\": 0,\n            \"authCodeLifeTime\": 0,\n            \"allowRefreshToken\": true,\n            \"allowImpersonation\": true,\n            \"useSessionRefreshTokenLifeTime\": true,\n            \"allowedScopes\": [\n                \"string\"\n            ],\n            \"defaultScopes\": [\n                \"string\"\n            ],\n            \"impersonateList\": [\n                \"string\"\n            ],\n            \"confidential\": true,\n            \"secret\": \"string\",\n            \"customAttributes\": [\n                {\n                \"type\": \"string\",\n                \"name\": \"string\",\n                \"value\": \"string\"\n                }\n            ],\n            \"logoutURL\": \"string\",\n            \"logoutMethod\": \"string\",\n            \"authScopes\": [\n                \"string\"\n            ],\n            \"uuid\": \"string\",\n            \"name\": \"string\",\n            \"urlId\": \"string\",\n            \"urlLocation\": \"string\"\n        }\n    \"\"\"\n\n    # Avoid linter warning W0102:\n    if redirect_urls is None:\n        redirect_urls = []\n    if auth_scopes is None:\n        auth_scopes = []\n    if allowed_scopes is None:\n        allowed_scopes = []\n    if default_scopes is None:\n        default_scopes = []\n\n    oauthClientPostBodyJson = {\n        \"id\": client_id,\n        \"description\": description,\n        \"redirectURLs\": redirect_urls,\n        \"accessTokenLifeTime\": 1000,\n        \"refreshTokenLifeTime\": 20000,\n        \"authCodeLifeTime\": 20000,\n        \"allowRefreshToken\": True,\n        \"allowImpersonation\": allow_impersonation,\n        \"useSessionRefreshTokenLifeTime\": True,\n        \"confidential\": confidential,\n        \"authScopes\": auth_scopes,\n        \"allowedScopes\": allowed_scopes,\n        \"defaultScopes\": default_scopes,\n    }\n\n    # Do we have a predefined client secret?\n    if secret:\n        oauthClientPostBodyJson[\"secret\"] = secret\n\n    request_url = self.oauth_client_url()\n\n    logger.info(\n        \"Adding oauth client -&gt; %s (%s); calling -&gt; %s\",\n        description,\n        client_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=oauthClientPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add OAuth client -&gt; %s; error -&gt; %s (%s)\",\n                client_id,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_oauth_clients_to_access_role","title":"<code>add_oauth_clients_to_access_role(access_role_name)</code>","text":"<p>Add Oauth clients user partion to an OTDS Access Role</p> <p>Parameters:</p> Name Type Description Default <code>access_role_name</code> <code>str</code> <p>name of the OTDS Access Role</p> required <p>Returns:     response of REST call or None in case of an error</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_oauth_clients_to_access_role(self, access_role_name: str):\n    \"\"\"Add Oauth clients user partion to an OTDS Access Role\n\n    Args:\n        access_role_name (str): name of the OTDS Access Role\n    Returns:\n        response of REST call or None in case of an error\n    \"\"\"\n\n    request_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role_name\n\n    logger.info(\n        \"Get access role -&gt; %s; calling -&gt; %s\", access_role_name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            accessRolesJson = self.parse_request_response(response)\n            break\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to retrieve role -&gt; %s; url -&gt; %s : error -&gt; %s (%s)\",\n                access_role_name,\n                request_url,\n                response.text,\n                response.status_code,\n            )\n            return None\n\n    # Checking if OAuthClients partition already added to access role\n    userPartitions = accessRolesJson[\"accessRoleMembers\"][\"userPartitions\"]\n    for userPartition in userPartitions:\n        if userPartition[\"userPartition\"] == \"OAuthClients\":\n            logger.error(\n                \"OAuthClients partition already added to role -&gt; %s\",\n                access_role_name,\n            )\n            return None\n\n    # Getting location info for the OAuthClients partition\n    # so it can be added to access roles json\n    request_url = self.config()[\"partitionsUrl\"] + \"/OAuthClients\"\n    partitionsResponse = requests.get(\n        url=request_url,\n        headers=REQUEST_HEADERS,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n    if partitionsResponse.ok:\n        response_dict = self.parse_request_response(partitionsResponse)\n        if not response_dict:\n            return None\n        oauthClientLocation = response_dict[\"location\"]\n    else:\n        logger.error(\n            \"Failed to get partition info for OAuthClients; url -&gt; %s : error -&gt; %s (%s)\",\n            request_url,\n            partitionsResponse.text,\n            response.status_code,\n        )\n        return None\n\n    # adding OAuthClients info to acess roles organizational units\n    oauthClientsOuBlock = {\n        \"location\": oauthClientLocation,\n        \"name\": oauthClientLocation,\n        \"userPartition\": None,\n    }\n    accessRolesJson[\"accessRoleMembers\"][\"organizationalUnits\"].append(\n        oauthClientsOuBlock\n    )\n\n    response = requests.put(\n        url=request_url,\n        json=accessRolesJson,\n        headers=REQUEST_HEADERS,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n\n    if response.ok:\n        logger.info(\n            \"OauthClients partition successfully added to access role -&gt; %s\",\n            access_role_name,\n        )\n    else:\n        logger.warning(\n            \"Status code of -&gt; %s returned attempting to add OAuthClients to access role -&gt; %s: error -&gt; %s\",\n            response.status_code,\n            access_role_name,\n            response.text,\n        )\n    return response\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_partition","title":"<code>add_partition(name, description)</code>","text":"<p>Add a new user partition to OTDS</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new partition</p> required <code>description</code> <code>str</code> <p>description of the new partition</p> required <p>Returns:     dict: Request response or None if the creation fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_partition(self, name: str, description: str) -&gt; dict | None:\n    \"\"\"Add a new user partition to OTDS\n\n    Args:\n        name (str): name of the new partition\n        description (str): description of the new partition\n    Returns:\n        dict: Request response or None if the creation fails.\n    \"\"\"\n\n    partitionPostBodyJson = {\"name\": name, \"description\": description}\n\n    request_url = self.partition_url()\n\n    logger.info(\n        \"Adding user partition -&gt; %s (%s); calling -&gt; %s\",\n        name,\n        description,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=partitionPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add user partition -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_partition_to_access_role","title":"<code>add_partition_to_access_role(access_role, partition, location='')</code>","text":"<p>Add an OTDS partition to an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>access_role</code> <code>str</code> <p>name of the OTDS access role</p> required <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>location</code> <code>str</code> <p>this is kind of a unique identifier DN (Distinguished Name)                       most of the times you will want to keep it to empty string (\"\")</p> <code>''</code> <p>Returns:     bool: True if partition is in access role or has been successfully added.           False if partition has been not been added (error)</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_partition_to_access_role(\n    self, access_role: str, partition: str, location: str = \"\"\n) -&gt; bool:\n    \"\"\"Add an OTDS partition to an OTDS access role\n\n    Args:\n        access_role (str): name of the OTDS access role\n        partition (str): name of the partition\n        location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                  most of the times you will want to keep it to empty string (\"\")\n    Returns:\n        bool: True if partition is in access role or has been successfully added.\n              False if partition has been not been added (error)\n    \"\"\"\n\n    accessRolePostBodyJson = {\n        \"userPartitions\": [{\"name\": partition, \"location\": location}]\n    }\n\n    request_url = \"{}/{}/members\".format(\n        self.config()[\"accessRoleUrl\"], access_role\n    )\n\n    logger.info(\n        \"Add user partition -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\n        partition,\n        access_role,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=accessRolePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add partition -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\n                partition,\n                access_role,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_resource","title":"<code>add_resource(name, description, display_name, additional_payload=None)</code>","text":"<p>Add an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new OTDS resource</p> required <code>description</code> <code>str</code> <p>description of the new OTDS resource</p> required <code>display_name</code> <code>str</code> <p>display name of the OTDS resource</p> required <code>additional_payload</code> <code>dict</code> <p>additional values for the json payload</p> <code>None</code> <p>Returns:     dict: Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_resource(\n    self,\n    name: str,\n    description: str,\n    display_name: str,\n    additional_payload: dict | None = None,\n) -&gt; dict | None:\n    \"\"\"Add an OTDS resource\n\n    Args:\n        name (str): name of the new OTDS resource\n        description (str): description of the new OTDS resource\n        display_name (str): display name of the OTDS resource\n        additional_payload (dict, optional): additional values for the json payload\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\n\n    resourcePostBodyJson = {\n        \"resourceName\": name,\n        \"description\": description,\n        \"displayName\": display_name,\n    }\n\n    # Check if there's additional payload for the body provided to handle special cases:\n    if additional_payload:\n        # Merge additional payload:\n        resourcePostBodyJson.update(additional_payload)\n\n    request_url = self.config()[\"resourceUrl\"]\n\n    logger.info(\n        \"Adding resource -&gt; %s (%s); calling -&gt; %s\", name, description, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=resourcePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add resource -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_system_attribute","title":"<code>add_system_attribute(name, value, description='')</code>","text":"<p>Add a new system attribute to OTDS</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new system attribute</p> required <code>value</code> <code>str</code> <p>value of the system attribute</p> required <code>description</code> <code>str</code> <p>optional description of the system attribute</p> <code>''</code> <p>Returns:     dict: Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_system_attribute(\n    self, name: str, value: str, description: str = \"\"\n) -&gt; dict | None:\n    \"\"\"Add a new system attribute to OTDS\n\n    Args:\n        name (str): name of the new system attribute\n        value (str): value of the system attribute\n        description (str, optional): optional description of the system attribute\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\n\n    systemAttributePostBodyJson = {\n        \"name\": name,\n        \"value\": value,\n        \"friendlyName\": description,\n    }\n\n    request_url = \"{}/system_attributes\".format(self.config()[\"systemConfigUrl\"])\n\n    if description:\n        logger.info(\n            \"Add system attribute -&gt; %s (%s) with value -&gt; %s; calling -&gt; %s\",\n            name,\n            description,\n            value,\n            request_url,\n        )\n    else:\n        logger.info(\n            \"Add system attribute -&gt; %s with value -&gt; %s; calling -&gt; %s\",\n            name,\n            value,\n            request_url,\n        )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=systemAttributePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add system attribute -&gt; %s with value -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                value,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_trusted_site","title":"<code>add_trusted_site(trusted_site)</code>","text":"<p>Add a new OTDS trusted site</p> <p>Parameters:</p> Name Type Description Default <code>trusted_site</code> <code>str</code> <p>name of the new trusted site</p> required <p>Return:     dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_trusted_site(self, trusted_site: str) -&gt; dict | None:\n    \"\"\"Add a new OTDS trusted site\n\n    Args:\n        trusted_site (str): name of the new trusted site\n    Return:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\n\n    trustedSitePostBodyJson = {\"stringList\": [trusted_site]}\n\n    # we need to first retrieve the existing sites and then\n    # append the new one:\n    existingTrustedSites = self.get_trusted_sites()\n\n    if existingTrustedSites:\n        trustedSitePostBodyJson[\"stringList\"].extend(\n            existingTrustedSites[\"stringList\"]\n        )\n\n    request_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\n\n    logger.info(\"Add trusted site -&gt; %s; calling -&gt; %s\", trusted_site, request_url)\n\n    response = requests.put(\n        url=request_url,\n        json=trustedSitePostBodyJson,\n        headers=REQUEST_HEADERS,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n    if not response.ok:\n        logger.error(\n            \"Failed to add trusted site -&gt; %s; error -&gt; %s (%s)\",\n            trusted_site,\n            response.text,\n            response.status_code,\n        )\n        return None\n\n    return response  # don't parse it!\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_user","title":"<code>add_user(partition, name, description='', first_name='', last_name='', email='')</code>","text":"<p>Add a new user to a user partition in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the OTDS user partition (needs to exist)</p> required <code>name</code> <code>str</code> <p>login name of the new user</p> required <code>description</code> <code>str</code> <p>description of the new user</p> <code>''</code> <code>first_name</code> <code>str</code> <p>first name of the new user</p> <code>''</code> <code>last_name</code> <code>str</code> <p>last name of the new user</p> <code>''</code> <code>email</code> <code>str</code> <p>email address of the new user</p> <code>''</code> <p>Returns:     dict: Request response or None if the creation fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_user(\n    self,\n    partition: str,\n    name: str,\n    description: str = \"\",\n    first_name: str = \"\",\n    last_name: str = \"\",\n    email: str = \"\",\n) -&gt; dict | None:\n    \"\"\"Add a new user to a user partition in OTDS\n\n    Args:\n        partition (str): name of the OTDS user partition (needs to exist)\n        name (str): login name of the new user\n        description (str, optional): description of the new user\n        first_name (str, optional): first name of the new user\n        last_name (str, optional): last name of the new user\n        email (str, optional): email address of the new user\n    Returns:\n        dict: Request response or None if the creation fails.\n    \"\"\"\n\n    userPostBodyJson = {\n        \"userPartitionID\": partition,\n        \"values\": [\n            {\"name\": \"sn\", \"values\": [last_name]},\n            {\"name\": \"givenName\", \"values\": [first_name]},\n            {\"name\": \"mail\", \"values\": [email]},\n        ],\n        \"name\": name,\n        \"description\": description,\n    }\n\n    request_url = self.users_url()\n\n    logger.info(\n        \"Adding user -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\n        name,\n        partition,\n        request_url,\n    )\n    logger.debug(\"User Attributes -&gt; %s\", str(userPostBodyJson))\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=userPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add user -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_user_to_access_role","title":"<code>add_user_to_access_role(access_role, user_id, location='')</code>","text":"<p>Add an OTDS user to an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>access_role</code> <code>str</code> <p>name of the OTDS access role</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <code>location</code> <code>str</code> <p>this is kind of a unique identifier DN (Distinguished Name)                       most of the times you will want to keep it to empty string (\"\")</p> <code>''</code> <p>Returns:     bool: True if user is in access role or has been successfully added.           False if user has not been added (error)</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_user_to_access_role(\n    self, access_role: str, user_id: str, location: str = \"\"\n) -&gt; bool:\n    \"\"\"Add an OTDS user to an OTDS access role\n\n    Args:\n        access_role (str): name of the OTDS access role\n        user_id (str): ID of the user (= login name)\n        location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                  most of the times you will want to keep it to empty string (\"\")\n    Returns:\n        bool: True if user is in access role or has been successfully added.\n              False if user has not been added (error)\n    \"\"\"\n\n    # get existing members to check if user is already a member:\n    accessRolesGetResponse = self.get_access_role(access_role)\n\n    if not accessRolesGetResponse:\n        return False\n\n    # Checking if user already added to access role\n    accessRoleUsers = accessRolesGetResponse[\"accessRoleMembers\"][\"users\"]\n    for user in accessRoleUsers:\n        if user[\"displayName\"] == user_id:\n            logger.info(\n                \"User -&gt; %s already added to access role -&gt; %s\",\n                user_id,\n                access_role,\n            )\n            return True\n\n    logger.info(\n        \"User -&gt; %s is not yet in access role -&gt; %s - adding...\",\n        user_id,\n        access_role,\n    )\n\n    # create payload for REST call:\n    accessRolePostBodyJson = {\"users\": [{\"name\": user_id, \"location\": location}]}\n\n    request_url = \"{}/{}/members\".format(\n        self.config()[\"accessRoleUrl\"], access_role\n    )\n\n    logger.info(\n        \"Add user -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\n        user_id,\n        access_role,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=accessRolePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add user -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\n                user_id,\n                access_role,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_user_to_group","title":"<code>add_user_to_group(user, group)</code>","text":"<p>Add an existing user to an existing group in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>name of the OTDS user (needs to exist)</p> required <code>group</code> <code>str</code> <p>name of the OTDS group (needs to exist)</p> required <p>Returns:     bool: True, if request is successful, False otherwise.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_user_to_group(self, user: str, group: str) -&gt; bool:\n    \"\"\"Add an existing user to an existing group in OTDS\n\n    Args:\n        user (str): name of the OTDS user (needs to exist)\n        group (str): name of the OTDS group (needs to exist)\n    Returns:\n        bool: True, if request is successful, False otherwise.\n    \"\"\"\n\n    userToGroupPostBodyJson = {\"stringList\": [group]}\n\n    request_url = self.users_url() + \"/\" + user + \"/memberof\"\n\n    logger.info(\n        \"Adding user -&gt; %s to group -&gt; %s; calling -&gt; %s\", user, group, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=userToGroupPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add user -&gt; %s to group -&gt; %s; error -&gt; %s (%s)\",\n                user,\n                group,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.assign_partition_to_license","title":"<code>assign_partition_to_license(partition_name, resource_id, license_feature, license_name, license_type='Full')</code>","text":"<p>Assign an OTDS partition to a product license (feature).</p> <p>Parameters:</p> Name Type Description Default <code>partition_name</code> <code>str</code> <p>user partition in OTDS, e.g. \"Content Server Members\"</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <code>license_type</code> <code>str</code> <p>deault is \"Full\", Extended ECM also has \"Occasional\"</p> <code>'Full'</code> <p>Returns:     bool: True if successful or False if the REST call fails or the license is not found</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def assign_partition_to_license(\n    self,\n    partition_name: str,\n    resource_id: str,\n    license_feature: str,\n    license_name: str,\n    license_type: str = \"Full\",\n) -&gt; bool:\n    \"\"\"Assign an OTDS partition to a product license (feature).\n\n    Args:\n        partition_name (str): user partition in OTDS, e.g. \"Content Server Members\"\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n        license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n    Returns:\n        bool: True if successful or False if the REST call fails or the license is not found\n    \"\"\"\n\n    licenses = self.get_license_for_resource(resource_id)\n    if not licenses:\n        logger.error(\n            \"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n        )\n        return False\n\n    # licenses have this format:\n    # {\n    #   '_oTLicenseType': 'NON-PRODUCTION',\n    #   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n    #   '_oTLicenseResourceName': 'cs',\n    #   '_oTLicenseProduct': 'EXTENDED_ECM',\n    #   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n    #   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n    #   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n    #   'description': 'CS license',\n    #   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n    # }\n    for lic in licenses:\n        if lic[\"_oTLicenseProduct\"] == license_name:\n            license_location = lic[\"id\"]\n\n    try:\n        license_location\n    except UnboundLocalError:\n        logger.error(\n            \"Cannot find license -&gt; %s for resource -&gt; %s\",\n            license_name,\n            resource_id,\n        )\n        return False\n\n    licensePostBodyJson = {\n        \"_oTLicenseType\": license_type,\n        \"_oTLicenseProduct\": \"partitions\",\n        \"name\": partition_name,\n        \"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n    }\n\n    request_url = self.license_url() + \"/object/\" + license_location\n\n    logger.info(\n        \"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\n        license_feature,\n        license_location,\n        resource_id,\n        partition_name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=licensePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            logger.info(\n                \"Added license feature -&gt; %s for partition -&gt; %s\",\n                license_feature,\n                partition_name,\n            )\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add license feature -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; error -&gt; %s (%s)\",\n                license_feature,\n                resource_id,\n                partition_name,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.assign_user_to_license","title":"<code>assign_user_to_license(partition, user_id, resource_id, license_feature, license_name, license_type='Full')</code>","text":"<p>Assign an OTDS user to a product license (feature) in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>user partition in OTDS, e.g. \"Content Server Members\"</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign</p> required <code>license_type</code> <code>str</code> <p>deault is \"Full\", Extended ECM also has \"Occasional\"</p> <code>'Full'</code> <p>Returns:     bool: True if successful or False if the REST call fails or the license is not found</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def assign_user_to_license(\n    self,\n    partition: str,\n    user_id: str,\n    resource_id: str,\n    license_feature: str,\n    license_name: str,\n    license_type: str = \"Full\",\n) -&gt; bool:\n    \"\"\"Assign an OTDS user to a product license (feature) in OTDS.\n\n    Args:\n        partition (str): user partition in OTDS, e.g. \"Content Server Members\"\n        user_id (str): ID of the user (= login name)\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature\n        license_name (str): name of the license to assign\n        license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n    Returns:\n        bool: True if successful or False if the REST call fails or the license is not found\n    \"\"\"\n\n    licenses = self.get_license_for_resource(resource_id)\n\n    for lic in licenses:\n        if lic[\"_oTLicenseProduct\"] == license_name:\n            license_location = lic[\"id\"]\n\n    try:\n        license_location\n    except UnboundLocalError:\n        logger.error(\n            \"Cannot find license -&gt; %s for resource -&gt; %s\",\n            license_name,\n            resource_id,\n        )\n        return False\n\n    user = self.get_user(partition, user_id)\n    if user:\n        user_location = user[\"location\"]\n    else:\n        logger.error(\"Cannot find location for user -&gt; %s\", user_id)\n        return False\n\n    licensePostBodyJson = {\n        \"_oTLicenseType\": license_type,\n        \"_oTLicenseProduct\": \"users\",\n        \"name\": user_location,\n        \"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n    }\n\n    request_url = self.license_url() + \"/object/\" + license_location\n\n    logger.info(\n        \"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to user -&gt; %s; calling -&gt; %s\",\n        license_feature,\n        license_location,\n        resource_id,\n        user_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=licensePostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            logger.info(\n                \"Added license feature -&gt; %s for user -&gt; %s\",\n                license_feature,\n                user_id,\n            )\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add license feature -&gt; %s associated with resource -&gt; %s to user -&gt; %s; error -&gt; %s (%s)\",\n                license_feature,\n                resource_id,\n                user_id,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.auth_handler_url","title":"<code>auth_handler_url()</code>","text":"<p>Returns the Auth Handler URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Auth Handler URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def auth_handler_url(self) -&gt; str:\n    \"\"\"Returns the Auth Handler URL of OTDS\n\n    Returns:\n        str: Auth Handler URL\n    \"\"\"\n    return self.config()[\"authHandlerUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticate at Directory Services and retrieve OTCS Ticket.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determine if a re-athentication is enforced                          (e.g. if session has timed out with 401 error)</p> <code>False</code> <p>Returns:     dict: Cookie information. Also stores cookie information in self._cookie</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; dict | None:\n    \"\"\"Authenticate at Directory Services and retrieve OTCS Ticket.\n\n    Args:\n        revalidate (bool, optional): determine if a re-athentication is enforced\n                                     (e.g. if session has timed out with 401 error)\n    Returns:\n        dict: Cookie information. Also stores cookie information in self._cookie\n    \"\"\"\n\n    # Already authenticated and session still valid?\n    if self._cookie and not revalidate:\n        logger.info(\n            \"Session still valid - return existing cookie -&gt; %s\",\n            str(self._cookie),\n        )\n        return self._cookie\n\n    otds_ticket = \"NotSet\"\n\n    logger.info(\"Requesting OTDS ticket from -&gt; %s\", self.credential_url())\n\n    response = None\n    try:\n        response = requests.post(\n            url=self.credential_url(),\n            json=self.credentials(),\n            headers=REQUEST_HEADERS,\n            timeout=None,\n        )\n    except requests.exceptions.RequestException as exception:\n        logger.warning(\n            \"Unable to connect to -&gt; %s; error -&gt; %s\",\n            self.credential_url(),\n            exception.strerror,\n        )\n        logger.warning(\"OTDS service may not be ready yet.\")\n        return None\n\n    if response.ok:\n        authenticate_dict = self.parse_request_response(response)\n        if not authenticate_dict:\n            return None\n        else:\n            otds_ticket = authenticate_dict[\"ticket\"]\n            logger.info(\"Ticket -&gt; %s\", otds_ticket)\n    else:\n        logger.error(\"Failed to request an OTDS ticket; error -&gt; %s\", response.text)\n        return None\n\n    # Store authentication ticket:\n    self._cookie = {\"OTDSTicket\": otds_ticket}\n    self._otds_ticket = otds_ticket\n\n    return self._cookie\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.base_url","title":"<code>base_url()</code>","text":"<p>Returns the base URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>base URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def base_url(self) -&gt; str:\n    \"\"\"Returns the base URL of OTDS\n\n    Returns:\n        str: base URL\n    \"\"\"\n    return self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Returns the configuration dictionary\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    return self._config\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.consolidate","title":"<code>consolidate(resource_name)</code>","text":"<p>Consolidate an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>resource to be consolidated</p> required <p>Returns:     bool: True if the consolidation succeeded or False if it failed.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def consolidate(self, resource_name: str) -&gt; bool:\n    \"\"\"Consolidate an OTDS resource\n\n    Args:\n        resource_name (str): resource to be consolidated\n    Returns:\n        bool: True if the consolidation succeeded or False if it failed.\n    \"\"\"\n\n    resource = self.get_resource(resource_name)\n    if not resource:\n        logger.error(\"Resource -&gt; %s not found - cannot consolidate\", resource_name)\n        return False\n\n    resource_dn = resource[\"resourceDN\"]\n    if not resource_dn:\n        logger.error(\"Resource DN is empty - cannot consolidate\")\n        return False\n\n    consolidationPostBodyJson = {\n        \"cleanupUsersInResource\": False,\n        \"cleanupGroupsInResource\": False,\n        \"resourceList\": [resource_dn],\n        \"objectToConsolidate\": resource_dn,\n    }\n\n    request_url = \"{}\".format(self.consolidation_url())\n\n    logger.info(\n        \"Consolidation of resource -&gt; %s; calling -&gt; %s\", resource_dn, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            url=request_url,\n            json=consolidationPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to consolidate; error -&gt; %s (%s)\",\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.consolidation_url","title":"<code>consolidation_url()</code>","text":"<p>Returns the Consolidation URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Consolidation URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def consolidation_url(self) -&gt; str:\n    \"\"\"Returns the Consolidation URL of OTDS\n\n    Returns:\n        str: Consolidation URL\n    \"\"\"\n    return self.config()[\"consolidationUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.cookie","title":"<code>cookie()</code>","text":"<p>Returns the login cookie of OTDS.    This is set by the authenticate() method</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>OTDS cookie</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def cookie(self) -&gt; dict:\n    \"\"\"Returns the login cookie of OTDS.\n       This is set by the authenticate() method\n\n    Returns:\n        dict: OTDS cookie\n    \"\"\"\n    return self._cookie\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.credential_url","title":"<code>credential_url()</code>","text":"<p>Returns the Credentials URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Credentials URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def credential_url(self) -&gt; str:\n    \"\"\"Returns the Credentials URL of OTDS\n\n    Returns:\n        str: Credentials URL\n    \"\"\"\n    return self.config()[\"credentialUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.credentials","title":"<code>credentials()</code>","text":"<p>Returns the credentials (username + password)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with username and password</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def credentials(self) -&gt; dict:\n    \"\"\"Returns the credentials (username + password)\n\n    Returns:\n        dict: dictionary with username and password\n    \"\"\"\n    return {\n        \"userName\": self.config()[\"username\"],\n        \"password\": self.config()[\"password\"],\n    }\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.delete_license_from_resource","title":"<code>delete_license_from_resource(resource_id, license_id)</code>","text":"<p>Delete a product license for a resource in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_id</code> <code>str</code> <p>OTDS license ID (this is the ID not the license name!)</p> required <p>Returns:     bool: True if successful or False if the REST call fails</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def delete_license_from_resource(self, resource_id: str, license_id: str) -&gt; bool:\n    \"\"\"Delete a product license for a resource in OTDS.\n\n    Args:\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_id (str): OTDS license ID (this is the ID not the license name!)\n    Returns:\n        bool: True if successful or False if the REST call fails\n    \"\"\"\n\n    request_url = \"{}/{}\".format(self.license_url(), license_id)\n\n    logger.info(\n        \"Deleting product license -&gt; %s from resource -&gt; %s; calling -&gt; %s\",\n        license_id,\n        resource_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.delete(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to delete license -&gt; %s for resource -&gt; %s; error -&gt; %s (%s)\",\n                license_id,\n                resource_id,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.delete_user","title":"<code>delete_user(partition, user_id)</code>","text":"<p>Delete an existing user</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>user_id</code> <code>str</code> <p>Id (= login name) of the user</p> required <p>Returns:     bool: True = success, False = error</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def delete_user(self, partition: str, user_id: str) -&gt; bool:\n    \"\"\"Delete an existing user\n\n    Args:\n        partition (str): name of the partition\n        user_id (str): Id (= login name) of the user\n    Returns:\n        bool: True = success, False = error\n    \"\"\"\n\n    request_url = self.users_url() + \"/\" + user_id + \"@\" + partition\n\n    logger.info(\n        \"Delete user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\n        user_id,\n        partition,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.delete(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to delete user -&gt; %s; error -&gt; %s (%s)\",\n                user_id,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.enable_audit","title":"<code>enable_audit()</code>","text":"<p>enable OTDS Audit</p> <p>Return:     Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def enable_audit(self):\n    \"\"\"enable OTDS Audit\n\n    Args:\n        None\n    Return:\n        Request response (json) or None if the REST call fails.\n    \"\"\"\n\n    auditPutBodyJson = {\n        \"daysToKeep\": \"7\",\n        \"enabled\": \"true\",\n        \"auditTo\": \"DATABASE\",\n        \"eventIDs\": [\n            \"User Create\",\n            \"Group Create\",\n            \"User Delete\",\n            \"Group Delete\",\n            \"User Modify\",\n            \"Group Modify\",\n            \"Initial authentication successful\",\n            \"Initial authentication failed\",\n            \"Impersonation\",\n            \"Import Finished\",\n            \"Access Denied\",\n            \"Authentication code incorrect\",\n            \"Authentication code required\",\n            \"User locked out\",\n            \"Consolidate Partition with identity provider\",\n            \"Recycle Bin User Deleted\",\n            \"Recycle Bin Group Deleted\",\n            \"User Moved to Recycle Bin\",\n            \"Group Moved to Recycle Bin\",\n            \"User Restored from Recycle Bin\",\n            \"Group Restored from Recycle Bin\",\n            \"Scheduled Cleanup\",\n            \"Consolidation finished\",\n            \"Monitoring session finished\",\n            \"User Rename\",\n            \"Group Rename\",\n            \"Role Create\",\n            \"Role Delete\",\n            \"Role Modify\",\n            \"Role Rename\",\n            \"Recycle Bin Role Deleted\",\n            \"Role Moved to Recycle Bin\",\n            \"Role Restored from Recycle Bin\",\n            \"Set group members\",\n            \"Set group members for moved in objects\",\n            \"User logout\",\n            \"Password change successful\",\n            \"Password change failed\",\n            \"Add Parent Object\",\n            \"Remove Parent Object\",\n            \"OAuth Client Create\",\n            \"OAuth Client Delete\",\n            \"OAuth Client Modify\",\n            \"Tenant Create\",\n            \"Tenant Delete\",\n            \"Tenant Modify\",\n            \"Migration\",\n        ],\n    }\n\n    request_url = \"{}/audit\".format(self.config()[\"systemConfigUrl\"])\n\n    logger.info(\"Enable audit; calling -&gt; %s\", request_url)\n\n    response = requests.put(\n        url=request_url,\n        json=auditPutBodyJson,\n        headers=REQUEST_HEADERS,\n        cookies=self.cookie(),\n        timeout=None,\n    )\n    if not response.ok:\n        logger.error(\n            \"Failed to enable audit; error -&gt; %s (%s)\",\n            response.text,\n            response.status_code,\n        )\n    return response\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_access_role","title":"<code>get_access_role(access_role)</code>","text":"<p>Get an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the access role</p> required <p>Returns:     dict: Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_access_role(self, access_role: str) -&gt; dict | None:\n    \"\"\"Get an OTDS access role\n\n    Args:\n        name (str): name of the access role\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\n\n    request_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role\n\n    logger.info(\n        \"Retrieving access role -&gt; %s; calling -&gt; %s\", access_role, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to retrieve access role -&gt; %s; error -&gt; %s (%s)\",\n                access_role,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_access_roles","title":"<code>get_access_roles()</code>","text":"<p>Get a list of all OTDS access roles</p> <p>Returns:     dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_access_roles(self) -&gt; dict | None:\n    \"\"\"Get a list of all OTDS access roles\n\n    Args:\n        None\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\n\n    request_url = self.config()[\"accessRoleUrl\"]\n\n    logger.info(\"Retrieving access roles; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to retrieve access roles; error -&gt; %s (%s)\",\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_access_token","title":"<code>get_access_token(client_id, client_secret)</code>","text":"<p>Get the access token</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>OAuth client name (= ID)</p> required <code>client_secret</code> <code>str</code> <p>OAuth client secret. This is typically returned                  by add_oauth_client() method in [\"secret\"] field</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>access token, or None</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_access_token(self, client_id: str, client_secret: str) -&gt; str | None:\n    \"\"\"Get the access token\n\n    Args:\n        client_id (str): OAuth client name (= ID)\n        client_secret (str): OAuth client secret. This is typically returned\n                             by add_oauth_client() method in [\"secret\"] field\n\n    Returns:\n        str: access token, or None\n    \"\"\"\n\n    encoded_client_secret = \"{}:{}\".format(client_id, client_secret).encode(\"utf-8\")\n    accessTokenRequestHeaders = {\n        \"Authorization\": \"Basic \"\n        + base64.b64encode(encoded_client_secret).decode(\"utf-8\"),\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n    }\n\n    request_url = self.token_url()\n\n    response = requests.post(\n        url=request_url,\n        data={\"grant_type\": \"client_credentials\"},\n        headers=accessTokenRequestHeaders,\n        timeout=None,\n    )\n\n    access_token = None\n    if response.ok:\n        accessTokenJson = self.parse_request_response(response)\n\n        if \"access_token\" in accessTokenJson:\n            access_token = accessTokenJson[\"access_token\"]\n        else:\n            return None\n\n    return access_token\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_auth_handler","title":"<code>get_auth_handler(name, show_error=True)</code>","text":"<p>Get the OTDS auth handler with a given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the authentication handler</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: auth handler dictionary, or None</p> <code>dict | None</code> <p>Example result:</p> <code>dict | None</code> <p>{ '_name': 'Salesforce', '_id': 'Salesforce', '_description': 'Salesforce OAuth Authentication Handler', '_class': 'com.opentext.otds.as.drivers.http.OAuth2Handler', '_enabled': True, '_credentialBased': True, '_priority': 10, '_scope': None, '_properties': [     {         '_key': 'com.opentext.otds.as.drivers.http.oauth2.provider_name',         '_name': 'Provider Name',         '_description': 'The name of the authentication provider. This name is displayed on the login page.',         '_required': True,         '_fileBased': False,         '_fileName': False,         '_fileExtensions': None,         '_value': 'Salesforce',         '_allowedValues': None,         ...     },     ... ] '_authPrincipalAttrNames': ['oTExtraAttr0'], 'createPermission': True, 'readPermission': True, 'updatePermission': True, 'deletePermission': True, 'enablePermission': True,</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_auth_handler(self, name: str, show_error: bool = True) -&gt; dict | None:\n    \"\"\"Get the OTDS auth handler with a given name.\n\n    Args:\n        name (str): Name of the authentication handler\n\n    Returns:\n        dict | None: auth handler dictionary, or None\n\n        Example result:\n        {\n            '_name': 'Salesforce',\n            '_id': 'Salesforce',\n            '_description': 'Salesforce OAuth Authentication Handler',\n            '_class': 'com.opentext.otds.as.drivers.http.OAuth2Handler',\n            '_enabled': True,\n            '_credentialBased': True,\n            '_priority': 10,\n            '_scope': None,\n            '_properties': [\n                {\n                    '_key': 'com.opentext.otds.as.drivers.http.oauth2.provider_name',\n                    '_name': 'Provider Name',\n                    '_description': 'The name of the authentication provider. This name is displayed on the login page.',\n                    '_required': True,\n                    '_fileBased': False,\n                    '_fileName': False,\n                    '_fileExtensions': None,\n                    '_value': 'Salesforce',\n                    '_allowedValues': None,\n                    ...\n                },\n                ...\n            ]\n            '_authPrincipalAttrNames': ['oTExtraAttr0'],\n            'createPermission': True,\n            'readPermission': True,\n            'updatePermission': True,\n            'deletePermission': True,\n            'enablePermission': True,\n        }\n\n    \"\"\"\n\n    request_url = \"{}/{}\".format(self.auth_handler_url(), name)\n\n    logger.info(\n        \"Getting authentication handler -&gt; %s; calling -&gt; %s\", name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get authentication handler -&gt; %s; warning -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_group","title":"<code>get_group(group)</code>","text":"<p>Get a OTDS group by its group name</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>ID of the group (= group name)</p> required <p>Return:     dict: Request response or None if the group was not found.     Example values:     {         'numMembers': 7,         'userPartitionID': 'Content Server Members',         'name': 'Sales',         'location': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net',         'id': 'Sales@Content Server Members',         'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...],         'description': None,         'uuid': '3f921294-b92a-4c9e-bf7c-b50df16bb937',         'objectClass': 'oTGroup',         'customAttributes': None,         'originUUID': None,         'urlId': 'Sales@Content Server Members',         'urlLocation': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net'     }</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_group(self, group: str) -&gt; dict | None:\n    \"\"\"Get a OTDS group by its group name\n\n    Args:\n        group (str): ID of the group (= group name)\n    Return:\n        dict: Request response or None if the group was not found.\n        Example values:\n        {\n            'numMembers': 7,\n            'userPartitionID': 'Content Server Members',\n            'name': 'Sales',\n            'location': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net',\n            'id': 'Sales@Content Server Members',\n            'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...],\n            'description': None,\n            'uuid': '3f921294-b92a-4c9e-bf7c-b50df16bb937',\n            'objectClass': 'oTGroup',\n            'customAttributes': None,\n            'originUUID': None,\n            'urlId': 'Sales@Content Server Members',\n            'urlLocation': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net'\n        }\n    \"\"\"\n\n    request_url = self.groups_url() + \"/\" + group\n\n    logger.info(\"Get group -&gt; %s; calling -&gt; %s\", group, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get group -&gt; %s; error -&gt; %s (%s)\",\n                group,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_license_for_resource","title":"<code>get_license_for_resource(resource_id)</code>","text":"<p>Get a product license for a resource in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <p>Returns:     Licenses for a resource or None if the REST call fails</p> <p>licenses have this format: {   '_oTLicenseType': 'NON-PRODUCTION',   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',   '_oTLicenseResourceName': 'cs',   '_oTLicenseProduct': 'EXTENDED_ECM',   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',   'description': 'CS license',   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...] }</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_license_for_resource(self, resource_id: str):\n    \"\"\"Get a product license for a resource in OTDS.\n\n    Args:\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n    Returns:\n        Licenses for a resource or None if the REST call fails\n\n    licenses have this format:\n    {\n      '_oTLicenseType': 'NON-PRODUCTION',\n      '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n      '_oTLicenseResourceName': 'cs',\n      '_oTLicenseProduct': 'EXTENDED_ECM',\n      'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n      'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n      'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n      'description': 'CS license',\n      'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n    }\n    \"\"\"\n\n    request_url = (\n        self.license_url()\n        + \"/assignedlicenses?resourceID=\"\n        + resource_id\n        + \"&amp;validOnly=false\"\n    )\n\n    logger.info(\n        \"Get license for resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            response_dict = self.parse_request_response(response)\n            if not response_dict:\n                return None\n            return response_dict[\"licenseObjects\"][\"_licenses\"]\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get license for resource -&gt; %s; error -&gt; %s (%s)\",\n                resource_id,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_licensed_objects","title":"<code>get_licensed_objects(resource_id, license_feature, license_name)</code>","text":"<p>Return the licensed objects (users, groups, partitions) in OTDS for a license + license feature    associated with an OTDS resource (like \"cs\").</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:     dict: data structure of licensed objects</p> <pre><code>Example return value:\n{\n    'status': 0,\n    'displayString': 'Success',\n    'exceptions': None,\n    'retValue': 0,\n    'listGroupsResults': {'groups': [...], 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n    'listUsersResults': {'users': [...], 'actualPageSize': 53, 'nextPageCookie': None, 'requestedPageSize': 250},\n    'listUserPartitionResult': {'_userPartitions': [...], 'warningMessage': None, 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n    'version': 1\n}\n</code></pre> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_licensed_objects(\n    self,\n    resource_id: str,\n    license_feature: str,\n    license_name: str,\n) -&gt; dict | None:\n    \"\"\"Return the licensed objects (users, groups, partitions) in OTDS for a license + license feature\n       associated with an OTDS resource (like \"cs\").\n\n    Args:\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n    Returns:\n        dict: data structure of licensed objects\n\n        Example return value:\n        {\n            'status': 0,\n            'displayString': 'Success',\n            'exceptions': None,\n            'retValue': 0,\n            'listGroupsResults': {'groups': [...], 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n            'listUsersResults': {'users': [...], 'actualPageSize': 53, 'nextPageCookie': None, 'requestedPageSize': 250},\n            'listUserPartitionResult': {'_userPartitions': [...], 'warningMessage': None, 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n            'version': 1\n        }\n    \"\"\"\n\n    licenses = self.get_license_for_resource(resource_id)\n    if not licenses:\n        logger.error(\n            \"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n        )\n        return False\n\n    # licenses have this format:\n    # {\n    #   '_oTLicenseType': 'NON-PRODUCTION',\n    #   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n    #   '_oTLicenseResourceName': 'cs',\n    #   '_oTLicenseProduct': 'EXTENDED_ECM',\n    #   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n    #   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n    #   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n    #   'description': 'CS license',\n    #   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n    # }\n    for lic in licenses:\n        if lic[\"_oTLicenseProduct\"] == license_name:\n            license_location = lic[\"location\"]\n\n    try:\n        license_location\n    except UnboundLocalError:\n        logger.error(\n            \"Cannot find license -&gt; %s for resource -&gt; %s\",\n            license_name,\n            resource_id,\n        )\n        return False\n\n    request_url = (\n        self.license_url()\n        + \"/object/\"\n        + license_location\n        + \"?counter=\"\n        + license_feature\n    )\n\n    logger.info(\n        \"Get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; calling -&gt; %s\",\n        license_name,\n        license_feature,\n        resource_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; error -&gt; %s (%s)\",\n                license_name,\n                license_feature,\n                resource_id,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_oauth_client","title":"<code>get_oauth_client(client_id, show_error=True)</code>","text":"<p>Get an existing OAuth client from OTDS</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>name (= ID) of the OAuth client to retrieve</p> required <code>show_error</code> <code>bool</code> <p>whether or not we want to log an error if partion is not found</p> <code>True</code> <p>Returns:     dict: Request response (dictionary) or None if the client is not found.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_oauth_client(self, client_id: str, show_error: bool = True) -&gt; dict | None:\n    \"\"\"Get an existing OAuth client from OTDS\n\n    Args:\n        client_id (str): name (= ID) of the OAuth client to retrieve\n        show_error (bool): whether or not we want to log an error if partion is not found\n    Returns:\n        dict: Request response (dictionary) or None if the client is not found.\n    \"\"\"\n\n    request_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\n\n    logger.info(\"Get oauth client -&gt; %s; calling -&gt; %s\", client_id, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get oauth client -&gt; %s; error -&gt; %s (%s)\",\n                    client_id,\n                    response.text,\n                    response.status_code,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_partition","title":"<code>get_partition(name, show_error=True)</code>","text":"<p>Get an existing user partition from OTDS</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the partition to retrieve</p> required <code>show_error</code> <code>bool</code> <p>whether or not we want to log an error                          if partion is not found</p> <code>True</code> <p>Returns:     dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_partition(self, name: str, show_error: bool = True) -&gt; dict | None:\n    \"\"\"Get an existing user partition from OTDS\n\n    Args:\n        name (str): name of the partition to retrieve\n        show_error (bool, optional): whether or not we want to log an error\n                                     if partion is not found\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\n\n    request_url = \"{}/{}\".format(self.config()[\"partitionUrl\"], name)\n\n    logger.info(\"Getting user partition -&gt; %s; calling -&gt; %s\", name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if show_error:\n                logger.error(\n                    \"Failed to get partition -&gt; %s; warning -&gt; %s (%s)\",\n                    name,\n                    response.text,\n                    response.status_code,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_password_policy","title":"<code>get_password_policy()</code>","text":"<p>Get the global password policy</p> <p>Returns:     dict: Request response or None if the REST call fails.</p> <pre><code>Example response:\n{\n    'passwordHistoryMaximumCount': 3,\n    'daysBeforeNewPasswordMayBeChanged': 1,\n    'passwordMaximumDuration': 90,\n    'daysBeforeOldPasswordMayBeReused': 0,\n    'lockoutFailureCount': 0,\n    'lockoutDuration': 15,\n    'minimumNumberOfCharacters': 8,\n    'complexPasswordValidationEnabled': True,\n    'minimumNumberOfDigits': 1,\n    'minimumNumberOfSymbols': 1,\n    'minimumNumberOfUppercase': 1,\n    'minimumNumberOfLowercase': 1,\n    'minimumChangesToPreviousPassword': 0,\n    'maxNumberOfConsecutiveANCharsInPassword': 0,\n    'blockCommonPassword': False\n    ...\n}\n</code></pre> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_password_policy(self):\n    \"\"\"Get the global password policy\n\n    Args:\n        None\n    Returns:\n        dict: Request response or None if the REST call fails.\n\n        Example response:\n        {\n            'passwordHistoryMaximumCount': 3,\n            'daysBeforeNewPasswordMayBeChanged': 1,\n            'passwordMaximumDuration': 90,\n            'daysBeforeOldPasswordMayBeReused': 0,\n            'lockoutFailureCount': 0,\n            'lockoutDuration': 15,\n            'minimumNumberOfCharacters': 8,\n            'complexPasswordValidationEnabled': True,\n            'minimumNumberOfDigits': 1,\n            'minimumNumberOfSymbols': 1,\n            'minimumNumberOfUppercase': 1,\n            'minimumNumberOfLowercase': 1,\n            'minimumChangesToPreviousPassword': 0,\n            'maxNumberOfConsecutiveANCharsInPassword': 0,\n            'blockCommonPassword': False\n            ...\n        }\n    \"\"\"\n\n    request_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\n\n    logger.info(\"Getting password policy; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get password policy; error -&gt; %s (%s)\",\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_resource","title":"<code>get_resource(name, show_error=False)</code>","text":"<p>Get an existing OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new OTDS resource</p> required <code>show_error</code> <code>bool</code> <p>treat as error if resource is not found</p> <code>False</code> <p>Returns:     dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_resource(self, name: str, show_error: bool = False) -&gt; dict | None:\n    \"\"\"Get an existing OTDS resource\n\n    Args:\n        name (str): name of the new OTDS resource\n        show_error (bool, optional): treat as error if resource is not found\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\n\n    request_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\n\n    logger.info(\"Retrieving resource -&gt; %s; calling -&gt; %s\", name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            # We don't necessarily want to log an error as this function\n            # is also used in wait loops:\n            if show_error:\n                logger.warning(\n                    \"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\n                    name,\n                    response.text,\n                )\n            else:\n                logger.info(\"Resource -&gt; %s not found.\", name)\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_trusted_sites","title":"<code>get_trusted_sites()</code>","text":"<p>Get all configured OTDS trusted sites</p> <p>Returns:     dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_trusted_sites(self) -&gt; dict | None:\n    \"\"\"Get all configured OTDS trusted sites\n\n    Args:\n        None\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\n\n    request_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\n\n    logger.info(\"Retrieving trusted sites; calling -&gt; %s\", request_url)\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to retrieve trusted sites; error -&gt; %s (%s)\",\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_user","title":"<code>get_user(partition, user_id)</code>","text":"<p>Get a user by its partition and user ID</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <p>Returns:     dict: Request response or None if the user was not found.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_user(self, partition: str, user_id: str) -&gt; dict | None:\n    \"\"\"Get a user by its partition and user ID\n\n    Args:\n        partition (str): name of the partition\n        user_id (str): ID of the user (= login name)\n    Returns:\n        dict: Request response or None if the user was not found.\n    \"\"\"\n\n    request_url = self.users_url() + \"/\" + user_id + \"@\" + partition\n\n    logger.info(\n        \"Get user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\n        user_id,\n        partition,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get user -&gt; %s; error -&gt; %s (%s)\",\n                user_id,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_users","title":"<code>get_users(partition='', limit=None)</code>","text":"<p>Get all users in a partition partition</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> <code>''</code> <code>limit</code> <code>int</code> <p>maximum number of users to return</p> <code>None</code> <p>Returns:     dict: Request response or None if the user was not found.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_users(self, partition: str = \"\", limit: int | None = None) -&gt; dict | None:\n    \"\"\"Get all users in a partition partition\n\n    Args:\n        partition (str, optional): name of the partition\n        limit (int): maximum number of users to return\n    Returns:\n        dict: Request response or None if the user was not found.\n    \"\"\"\n\n    # Add query parameters (these are NOT passed via JSon body!)\n    query = {}\n    if limit:\n        query[\"limit\"] = limit\n    if partition:\n        query[\"where_partition_name\"] = partition\n\n    encodedQuery = urllib.parse.urlencode(query, doseq=True)\n\n    request_url = self.users_url()\n    if query:\n        request_url += \"?{}\".format(encodedQuery)\n\n    if partition:\n        logger.info(\n            \"Get all users in partition -&gt; %s (limit -&gt; %s); calling -&gt; %s\",\n            partition,\n            limit,\n            request_url,\n        )\n    else:\n        logger.info(\n            \"Get all users (limit -&gt; %s); calling -&gt; %s\",\n            limit,\n            request_url,\n        )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            url=request_url,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            if partition:\n                logger.error(\n                    \"Failed to get users in partition -&gt; %s; error -&gt; %s (%s)\",\n                    partition,\n                    response.text,\n                    response.status_code,\n                )\n            else:\n                logger.error(\n                    \"Failed to get users; error -&gt; %s (%s)\",\n                    response.text,\n                    response.status_code,\n                )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.groups_url","title":"<code>groups_url()</code>","text":"<p>Returns the Groups URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Groups URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def groups_url(self) -&gt; str:\n    \"\"\"Returns the Groups URL of OTDS\n\n    Returns:\n        str: Groups URL\n    \"\"\"\n    return self.config()[\"groupsUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.impersonate_oauth_client","title":"<code>impersonate_oauth_client(client_id, allow_impersonation=True, impersonation_list=None)</code>","text":"<p>Configure impersonation for an OTDS OAuth Client</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>OAuth Client to be configure impersonation for</p> required <code>allow_impersonation</code> <code>bool</code> <p>wether to turn on or off impersonation (default = True)</p> <code>True</code> <code>impersonation_list</code> <code>list</code> <p>list of users to restrict it to; (default = empty list = all users)</p> <code>None</code> <p>Returns:     bool: True if the impersonation setting succeeded or False if it failed.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def impersonate_oauth_client(\n    self,\n    client_id: str,\n    allow_impersonation: bool = True,\n    impersonation_list: list | None = None,\n) -&gt; bool:\n    \"\"\"Configure impersonation for an OTDS OAuth Client\n\n    Args:\n        client_id (str): OAuth Client to be configure impersonation for\n        allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n        impersonation_list (list, optional): list of users to restrict it to; (default = empty list = all users)\n    Returns:\n        bool: True if the impersonation setting succeeded or False if it failed.\n    \"\"\"\n\n    # Avoid linter warning W0102:\n    if impersonation_list is None:\n        impersonation_list = []\n\n    impersonationPutBodyJson = {\n        \"allowImpersonation\": allow_impersonation,\n        \"impersonateList\": impersonation_list,\n    }\n\n    request_url = \"{}/{}/impersonation\".format(self.oauth_client_url(), client_id)\n\n    logger.info(\n        \"Impersonation settings for OAuth Client -&gt; %s; calling -&gt; %s\",\n        client_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            json=impersonationPutBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to set impersonation for OAuth Client -&gt; %s; error -&gt; %s (%s)\",\n                client_id,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.impersonate_resource","title":"<code>impersonate_resource(resource_name, allow_impersonation=True, impersonation_list=None)</code>","text":"<p>Configure impersonation for an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>resource to be configure impersonation for</p> required <code>allow_impersonation</code> <code>bool</code> <p>wether to turn on or off impersonation (default = True)</p> <code>True</code> <code>impersonation_list</code> <code>list</code> <p>list of users to restrict it to                                  (default = empty list = all users)</p> <code>None</code> <p>Returns:     bool: True if the impersonation setting succeeded or False if it failed.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def impersonate_resource(\n    self,\n    resource_name: str,\n    allow_impersonation: bool = True,\n    impersonation_list: list | None = None,\n) -&gt; bool:\n    \"\"\"Configure impersonation for an OTDS resource\n\n    Args:\n        resource_name (str): resource to be configure impersonation for\n        allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n        impersonation_list (list, optional): list of users to restrict it to\n                                             (default = empty list = all users)\n    Returns:\n        bool: True if the impersonation setting succeeded or False if it failed.\n    \"\"\"\n\n    # Avoid linter warning W0102:\n    if impersonation_list is None:\n        impersonation_list = []\n\n    impersonationPutBodyJson = {\n        \"allowImpersonation\": allow_impersonation,\n        \"impersonateList\": impersonation_list,\n    }\n\n    request_url = \"{}/{}/impersonation\".format(self.resource_url(), resource_name)\n\n    logger.info(\n        \"Impersonation settings for resource -&gt; %s; calling -&gt; %s\",\n        resource_name,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            json=impersonationPutBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to set impersonation for resource -&gt; %s; error -&gt; %s\",\n                resource_name,\n                response.text,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.is_group_licensed","title":"<code>is_group_licensed(group_name, resource_id, license_feature, license_name)</code>","text":"<p>Check if a group is licensed for a license and license feature associated with a particular OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the OTDS user group</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the group is licensed and False otherwise</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def is_group_licensed(\n    self, group_name: str, resource_id: str, license_feature: str, license_name: str\n) -&gt; bool:\n    \"\"\"Check if a group is licensed for a license and license feature associated with a particular OTDS resource.\n\n    Args:\n        group_name (str): name of the OTDS user group\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n\n    Returns:\n        bool: True if the group is licensed and False otherwise\n    \"\"\"\n\n    response = self.get_licensed_objects(\n        resource_id=resource_id,\n        license_feature=license_feature,\n        license_name=license_name,\n    )\n\n    if not response or not response[\"listGroupsResults\"]:\n        return False\n\n    groups = response[\"listGroupsResults\"][\"groups\"]\n\n    if not groups:\n        return False\n\n    group = next(\n        (item for item in groups if item[\"name\"] == group_name),\n        None,\n    )\n\n    if group:\n        return True\n\n    return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.is_partition_licensed","title":"<code>is_partition_licensed(partition_name, resource_id, license_feature, license_name)</code>","text":"<p>Check if a partition is licensed for a license and license feature associated with a particular OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>partition_name</code> <code>str</code> <p>name of the OTDS user partition, e.g. \"Content Server Members\"</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the partition is licensed and False otherwise</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def is_partition_licensed(\n    self,\n    partition_name: str,\n    resource_id: str,\n    license_feature: str,\n    license_name: str,\n) -&gt; bool:\n    \"\"\"Check if a partition is licensed for a license and license feature associated with a particular OTDS resource.\n\n    Args:\n        partition_name (str): name of the OTDS user partition, e.g. \"Content Server Members\"\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n\n    Returns:\n        bool: True if the partition is licensed and False otherwise\n    \"\"\"\n\n    response = self.get_licensed_objects(\n        resource_id=resource_id,\n        license_feature=license_feature,\n        license_name=license_name,\n    )\n\n    if not response or not response[\"listUserPartitionResult\"]:\n        return False\n\n    partitions = response[\"listUserPartitionResult\"][\"_userPartitions\"]\n\n    if not partitions:\n        return False\n\n    partition = next(\n        (item for item in partitions if item[\"name\"] == partition_name),\n        None,\n    )\n\n    if partition:\n        return True\n\n    return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.is_user_licensed","title":"<code>is_user_licensed(user_name, resource_id, license_feature, license_name)</code>","text":"<p>Check if a user is licensed for a license and license feature associated with a particular OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> <p>login name of the OTDS user</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user is licensed and False otherwise</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def is_user_licensed(\n    self, user_name: str, resource_id: str, license_feature: str, license_name: str\n) -&gt; bool:\n    \"\"\"Check if a user is licensed for a license and license feature associated with a particular OTDS resource.\n\n    Args:\n        user_name (str): login name of the OTDS user\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n\n    Returns:\n        bool: True if the user is licensed and False otherwise\n    \"\"\"\n\n    response = self.get_licensed_objects(\n        resource_id=resource_id,\n        license_feature=license_feature,\n        license_name=license_name,\n    )\n\n    if not response or not response[\"listUsersResults\"]:\n        return False\n\n    users = response[\"listUsersResults\"][\"users\"]\n\n    if not users:\n        return False\n\n    user = next(\n        (item for item in users if item[\"name\"] == user_name),\n        None,\n    )\n\n    if user:\n        return True\n\n    return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.license_url","title":"<code>license_url()</code>","text":"<p>Returns the License URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>License URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def license_url(self) -&gt; str:\n    \"\"\"Returns the License URL of OTDS\n\n    Returns:\n        str: License URL\n    \"\"\"\n    return self.config()[\"licenseUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.oauth_client_url","title":"<code>oauth_client_url()</code>","text":"<p>Returns the OAuth Client URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>OAuth Client URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def oauth_client_url(self) -&gt; str:\n    \"\"\"Returns the OAuth Client URL of OTDS\n\n    Returns:\n        str: OAuth Client URL\n    \"\"\"\n    return self.config()[\"oauthClientUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the request response to a Python dict in a safe way    that also handles exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>print a custom error message</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>if True log an error, if False log a warning</p> <code>True</code> <p>Returns:     dict: response dictionary or None in case of an error</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def parse_request_response(\n    self,\n    response_object: object,\n    additional_error_message: str = \"\",\n    show_error: bool = True,\n) -&gt; dict | None:\n    \"\"\"Converts the request response to a Python dict in a safe way\n       that also handles exceptions.\n\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str): print a custom error message\n        show_error (bool): if True log an error, if False log a warning\n    Returns:\n        dict: response dictionary or None in case of an error\n    \"\"\"\n\n    if not response_object:\n        return None\n\n    try:\n        dict_object = json.loads(response_object.text)\n    except json.JSONDecodeError as e:\n        if additional_error_message:\n            message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                additional_error_message, e\n            )\n        else:\n            message = \"Cannot decode response as JSon; error -&gt; {}\".format(e)\n        if show_error:\n            logger.error(message)\n        else:\n            logger.warning(message)\n        return None\n    else:\n        return dict_object\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.partition_url","title":"<code>partition_url()</code>","text":"<p>Returns the Partition URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Partition URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def partition_url(self) -&gt; str:\n    \"\"\"Returns the Partition URL of OTDS\n\n    Returns:\n        str: Partition URL\n    \"\"\"\n    return self.config()[\"partitionUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.reset_user_password","title":"<code>reset_user_password(user_id, password)</code>","text":"<p>Reset a password of an existing user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Id (= login name) of the user</p> required <code>password</code> <code>str</code> <p>new password of the user</p> required <p>Returns:     bool: True = success, False = error.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def reset_user_password(self, user_id: str, password: str) -&gt; bool:\n    \"\"\"Reset a password of an existing user\n\n    Args:\n        user_id (str): Id (= login name) of the user\n        password (str): new password of the user\n    Returns:\n        bool: True = success, False = error.\n    \"\"\"\n\n    userPostBodyJson = {\"newPassword\": password}\n\n    request_url = \"{}/{}/password\".format(self.users_url(), user_id)\n\n    logger.info(\n        \"Resetting password for user -&gt; %s; calling -&gt; %s\", user_id, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            json=userPostBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to reset password for user -&gt; %s; error -&gt; %s (%s)\",\n                user_id,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.resource_url","title":"<code>resource_url()</code>","text":"<p>Returns the Resource URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Resource URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def resource_url(self) -&gt; str:\n    \"\"\"Returns the Resource URL of OTDS\n\n    Returns:\n        str: Resource URL\n    \"\"\"\n    return self.config()[\"resourceUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.rest_url","title":"<code>rest_url()</code>","text":"<p>Returns the REST URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>REST URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def rest_url(self) -&gt; str:\n    \"\"\"Returns the REST URL of OTDS\n\n    Returns:\n        str: REST URL\n    \"\"\"\n    return self.config()[\"restUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.system_config_url","title":"<code>system_config_url()</code>","text":"<p>Returns the System Config URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>System Config URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def system_config_url(self) -&gt; str:\n    \"\"\"Returns the System Config URL of OTDS\n\n    Returns:\n        str: System Config URL\n    \"\"\"\n    return self.config()[\"systemConfigUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.token_url","title":"<code>token_url()</code>","text":"<p>Returns the Token URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Token URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def token_url(self) -&gt; str:\n    \"\"\"Returns the Token URL of OTDS\n\n    Returns:\n        str: Token URL\n    \"\"\"\n    return self.config()[\"tokenUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_access_role_attributes","title":"<code>update_access_role_attributes(name, attribute_list)</code>","text":"<p>Update some attributes of an existing OTDS Access Role</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the existing access role</p> required <code>attribute_list</code> <code>list</code> <p>list of attribute name and attribute value pairs                    The values need to be a list as well. Example:                    [{name: \"pushAllGroups\", values: [\"True\"]}]</p> required <p>Returns:     dict: Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_access_role_attributes(\n    self, name: str, attribute_list: list\n) -&gt; dict | None:\n    \"\"\"Update some attributes of an existing OTDS Access Role\n\n    Args:\n        name (str): name of the existing access role\n        attribute_list (list): list of attribute name and attribute value pairs\n                               The values need to be a list as well. Example:\n                               [{name: \"pushAllGroups\", values: [\"True\"]}]\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\n\n    # Return if list is empty:\n    if not attribute_list:\n        return None\n\n    # create payload for REST call:\n    access_role = self.get_access_role(name)\n    if not access_role:\n        logger.error(\"Failed to get access role -&gt; %s\", name)\n        return None\n\n    accessRolePutBodyJson = {\"attributes\": attribute_list}\n\n    request_url = \"{}/{}/attributes\".format(self.config()[\"accessRoleUrl\"], name)\n\n    logger.info(\n        \"Update access role -&gt; %s with attributes -&gt; %s; calling -&gt; %s\",\n        name,\n        accessRolePutBodyJson,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            json=accessRolePutBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update access role -&gt; %s; error -&gt; %s (%s)\",\n                name,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_oauth_client","title":"<code>update_oauth_client(client_id, updates)</code>","text":"<p>Updates the OAuth client with new values</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>name (= ID) of the OAuth client</p> required <code>updates</code> <code>dict</code> <p>new values for OAuth client, e.g.             {\"description\": \"this is the new value\"}</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_oauth_client(self, client_id: str, updates: dict) -&gt; dict | None:\n    \"\"\"Updates the OAuth client with new values\n\n    Args:\n        client_id (str): name (= ID) of the OAuth client\n        updates (dict): new values for OAuth client, e.g.\n                        {\"description\": \"this is the new value\"}\n\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\n\n    oauthClientPatchBodyJson = updates\n\n    request_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\n\n    logger.info(\n        \"Update OAuth client -&gt; %s with -&gt; %s; calling -&gt; %s\",\n        client_id,\n        updates,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.patch(\n            url=request_url,\n            json=oauthClientPatchBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update OAuth client -&gt; %s; error -&gt; %s (%s)\",\n                client_id,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_password_policy","title":"<code>update_password_policy(update_values)</code>","text":"<p>Update the global password policy</p> <p>Parameters:</p> Name Type Description Default <code>update_values</code> <code>dict</code> <p>new values for selected settings.                   A value of 0 means the settings is deactivated.</p> required <code>Example</code> <code>values</code> required <p>Returns:     bool: True if the REST call succeeds, otherwise False. We use a boolean return           value as the response of the REST call does not have meaningful content.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_password_policy(self, update_values: dict) -&gt; bool:\n    \"\"\"Update the global password policy\n\n    Args:\n        update_values (dict): new values for selected settings.\n                              A value of 0 means the settings is deactivated.\n\n        Example values:\n        {\n            'passwordHistoryMaximumCount': 3,\n            'daysBeforeNewPasswordMayBeChanged': 1,\n            'passwordMaximumDuration': 90,\n            'daysBeforeOldPasswordMayBeReused': 0,\n            'lockoutFailureCount': 0,\n            'lockoutDuration': 15,\n            'minimumNumberOfCharacters': 8,\n            'complexPasswordValidationEnabled': True,\n            'minimumNumberOfDigits': 1,\n            'minimumNumberOfSymbols': 1,\n            'minimumNumberOfUppercase': 1,\n            'minimumNumberOfLowercase': 1,\n            'minimumChangesToPreviousPassword': 0,\n            'maxNumberOfConsecutiveANCharsInPassword': 0,\n            'blockCommonPassword': False\n            ...\n        }\n    Returns:\n        bool: True if the REST call succeeds, otherwise False. We use a boolean return\n              value as the response of the REST call does not have meaningful content.\n\n    \"\"\"\n\n    request_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\n\n    logger.info(\n        \"Update password policy with these new values -&gt; %s; calling -&gt; %s\",\n        update_values,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            json=update_values,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return True\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update password policy with values -&gt; %s; error -&gt; %s (%s)\",\n                update_values,\n                response.text,\n                response.status_code,\n            )\n            return False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_resource","title":"<code>update_resource(name, resource, show_error=True)</code>","text":"<p>Update an existing OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new OTDS resource</p> required <code>resource</code> <code>object</code> <p>updated resource object of get_resource called before</p> required <code>show_error</code> <code>bool</code> <p>treat as error if resource is not found</p> <code>True</code> <p>Returns:     dict: Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_resource(\n    self, name: str, resource: object, show_error: bool = True\n) -&gt; dict | None:\n    \"\"\"Update an existing OTDS resource\n\n    Args:\n        name (str): name of the new OTDS resource\n        resource (object): updated resource object of get_resource called before\n        show_error (bool, optional): treat as error if resource is not found\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\n\n    request_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\n\n    logger.info(\"Updating resource -&gt; %s; calling -&gt; %s\", name, request_url)\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            json=resource,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            # We don't necessarily want to log an error as this function\n            # is also used in wait loops:\n            if show_error:\n                logger.warning(\n                    \"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\n                    name,\n                    response.text,\n                )\n            else:\n                logger.info(\"Resource -&gt; %s not found.\", name)\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_user","title":"<code>update_user(partition, user_id, attribute_name, attribute_value)</code>","text":"<p>Update a user attribute with a new value</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <code>attribute_name</code> <code>str</code> <p>name of the attribute</p> required <code>attribute_value</code> <code>str</code> <p>new value of the attribute</p> required <p>Return:     dict: Request response or None if the update fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_user(\n    self, partition: str, user_id: str, attribute_name: str, attribute_value: str\n) -&gt; dict | None:\n    \"\"\"Update a user attribute with a new value\n\n    Args:\n        partition (str): name of the partition\n        user_id (str): ID of the user (= login name)\n        attribute_name (str): name of the attribute\n        attribute_value (str): new value of the attribute\n    Return:\n        dict: Request response or None if the update fails.\n    \"\"\"\n\n    if attribute_name in [\"description\"]:\n        userPatchBodyJson = {\n            \"userPartitionID\": partition,\n            attribute_name: attribute_value,\n        }\n    else:\n        userPatchBodyJson = {\n            \"userPartitionID\": partition,\n            \"values\": [{\"name\": attribute_name, \"values\": [attribute_value]}],\n        }\n\n    request_url = self.users_url() + \"/\" + user_id\n\n    logger.info(\n        \"Update user -&gt; %s attribute -&gt; %s to value -&gt; %s; calling -&gt; %s\",\n        user_id,\n        attribute_name,\n        attribute_value,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.patch(\n            url=request_url,\n            json=userPatchBodyJson,\n            headers=REQUEST_HEADERS,\n            cookies=self.cookie(),\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update user -&gt; %s; error -&gt; %s (%s)\",\n                user_id,\n                response.text,\n                response.status_code,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.users_url","title":"<code>users_url()</code>","text":"<p>Returns the Users URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Users URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def users_url(self) -&gt; str:\n    \"\"\"Returns the Users URL of OTDS\n\n    Returns:\n        str: Users URL\n    \"\"\"\n    return self.config()[\"usersUrl\"]\n</code></pre>"},{"location":"pyxecm/otiv/","title":"Intelligent Viewing (OTIV)","text":"<p>OTIV Module to keep Intelligent Viewing specific data such as connection parameters, license information ...</p> <p>Class: OTIV Methods:</p> <p>init : class initializer config : returns config data set</p>"},{"location":"pyxecm/otiv/#pyxecm.otiv.OTIV","title":"<code>OTIV</code>","text":"<p>Used to manage stettings for OpenText Intelligent Viewing.</p> Source code in <code>pyxecm/otiv.py</code> <pre><code>class OTIV:\n    \"\"\"Used to manage stettings for OpenText Intelligent Viewing.\"\"\"\n\n    _config: dict\n\n    def __init__(\n        self,\n        resource_name: str,\n        product_name: str,\n        product_description: str,\n        license_file: str,\n        default_license: str = \"FULLTIME_USERS_REGULAR\",\n    ):\n        \"\"\"Initialize the OTIV class for Intelligent Viewing\n\n        Args:\n            resource_name (str): OTDS resource name\n            product_name (str): OTDS product name for licensing\n            license_file (str): path to license file\n            default_license (str, optional): Defaults to \"FULLTIME_USERS_REGULAR\".\n        \"\"\"\n\n        # Initialize otiv_config as an empty dictionary\n        otiv_config = {}\n\n        otiv_config[\"resource\"] = resource_name\n        otiv_config[\"product\"] = product_name\n        otiv_config[\"description\"] = product_description\n        otiv_config[\"license_file\"] = license_file\n        otiv_config[\"license\"] = default_license\n\n        self._config = otiv_config\n\n    # end method definition\n\n    def config(self) -&gt; dict:\n        \"\"\"Returns the configuration dictionary\n\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\n        return self._config\n</code></pre>"},{"location":"pyxecm/otiv/#pyxecm.otiv.OTIV.__init__","title":"<code>__init__(resource_name, product_name, product_description, license_file, default_license='FULLTIME_USERS_REGULAR')</code>","text":"<p>Initialize the OTIV class for Intelligent Viewing</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>OTDS resource name</p> required <code>product_name</code> <code>str</code> <p>OTDS product name for licensing</p> required <code>license_file</code> <code>str</code> <p>path to license file</p> required <code>default_license</code> <code>str</code> <p>Defaults to \"FULLTIME_USERS_REGULAR\".</p> <code>'FULLTIME_USERS_REGULAR'</code> Source code in <code>pyxecm/otiv.py</code> <pre><code>def __init__(\n    self,\n    resource_name: str,\n    product_name: str,\n    product_description: str,\n    license_file: str,\n    default_license: str = \"FULLTIME_USERS_REGULAR\",\n):\n    \"\"\"Initialize the OTIV class for Intelligent Viewing\n\n    Args:\n        resource_name (str): OTDS resource name\n        product_name (str): OTDS product name for licensing\n        license_file (str): path to license file\n        default_license (str, optional): Defaults to \"FULLTIME_USERS_REGULAR\".\n    \"\"\"\n\n    # Initialize otiv_config as an empty dictionary\n    otiv_config = {}\n\n    otiv_config[\"resource\"] = resource_name\n    otiv_config[\"product\"] = product_name\n    otiv_config[\"description\"] = product_description\n    otiv_config[\"license_file\"] = license_file\n    otiv_config[\"license\"] = default_license\n\n    self._config = otiv_config\n</code></pre>"},{"location":"pyxecm/otiv/#pyxecm.otiv.OTIV.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otiv.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Returns the configuration dictionary\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    return self._config\n</code></pre>"},{"location":"pyxecm/otpd/","title":"PowerDocs (OTPD)","text":"<p>OTPD Module to implement functions to read / write PowerDocs objects</p> <p>Class: OTPD Methods:</p> <p>init : class initializer config : returns config data set credentials: Get credentials (username and password) set_credentials: Set new credentials hostname: Get the configured PowerDocs hostname set_hostname: Set the hostname of PowerDocs base_url : Get PowerDocs base URL rest_url : Get PowerDocs REST base URL</p> Converts the text property of a request <p>response object to a Python dict in a safe way</p> <p>authenticate : Authenticates at PowerDocs and retrieve OTCS Ticket.</p> <p>import_database: imports the PowerDocs database from a zip file apply_setting: apply a setting to a PowerDocs tenant</p>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD","title":"<code>OTPD</code>","text":"<p>Used to automate stettings in OpenText Extended ECM PowerDocs.</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>class OTPD:\n    \"\"\"Used to automate stettings in OpenText Extended ECM PowerDocs.\"\"\"\n\n    _config = None\n    _jsessionid = None\n\n    def __init__(\n        self,\n        protocol: str,\n        hostname: str,\n        port: int,\n        username: str,\n        password: str,\n    ):\n        \"\"\"Initialize the OTPD object\n\n        Args:\n            protocol (str): Either http or https.\n            hostname (str): The hostname of the PowerDocs Server Manager to communicate with.\n            port (int): The port number used to talk to the PowerDocs Server Manager.\n            username (str): The admin user name of PowerDocs Server Manager.\n            password (str): The admin password of PowerDocs Server Manager.\n        \"\"\"\n\n        otpd_config = {}\n\n        if hostname:\n            otpd_config[\"hostname\"] = hostname\n        else:\n            otpd_config[\"hostname\"] = \"\"\n\n        if protocol:\n            otpd_config[\"protocol\"] = protocol\n        else:\n            otpd_config[\"protocol\"] = \"http\"\n\n        if port:\n            otpd_config[\"port\"] = port\n        else:\n            otpd_config[\"port\"] = 80\n\n        if username:\n            otpd_config[\"username\"] = username\n        else:\n            otpd_config[\"username\"] = \"admin\"\n\n        if password:\n            otpd_config[\"password\"] = password\n        else:\n            otpd_config[\"password\"] = \"\"\n\n        otpd_base_url = protocol + \"://\" + otpd_config[\"hostname\"]\n        if str(port) not in [\"80\", \"443\"]:\n            otpd_base_url += \":{}\".format(port)\n        otpd_base_url += \"/ServerManager\"\n        otpd_config[\"baseUrl\"] = otpd_base_url\n\n        otpd_rest_url = otpd_base_url + \"/api\"\n        otpd_config[\"restUrl\"] = otpd_rest_url\n\n        otpd_config[\"settingsUrl\"] = otpd_rest_url + \"/v1/settings\"\n\n        otpd_config[\"importDatabaseUrl\"] = otpd_base_url + \"/servlet/import\"\n\n        self._config = otpd_config\n\n    def config(self) -&gt; dict:\n        \"\"\"Returns the configuration dictionary\n\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\n        return self._config\n\n    def credentials(self) -&gt; dict:\n        \"\"\"Get credentials (username + password)\n\n        Returns:\n            dict: dictionary with username and password\n        \"\"\"\n        return {\n            \"username\": self.config()[\"username\"],\n            \"password\": self.config()[\"password\"],\n        }\n\n    def set_credentials(self, username: str = \"admin\", password: str = \"\"):\n        \"\"\"Set the credentials for PowerDocs for the based on user name and password.\n\n        Args:\n            username (str, optional): Username. Defaults to \"admin\".\n            password (str, optional): Password of the user. Defaults to \"\".\n        \"\"\"\n        self.config()[\"username\"] = username\n        self.config()[\"password\"] = password\n\n    def hostname(self) -&gt; str:\n        \"\"\"Returns the hostname of PowerDocs (e.g. \"otpd\")\n\n        Returns:\n            string: hostname\n        \"\"\"\n        return self.config()[\"hostname\"]\n\n    def set_hostname(self, hostname: str):\n        \"\"\"Sets the hostname of PowerDocs\n\n        Args:\n            hostname (str): new hostname\n        \"\"\"\n        self.config()[\"hostname\"] = hostname\n\n    def base_url(self):\n        \"\"\"Returns the base URL of PowerDocs\n\n        Returns:\n            string: base URL\n        \"\"\"\n        return self.config()[\"baseUrl\"]\n\n    def rest_url(self):\n        \"\"\"Returns the REST URL of PowerDocs\n\n        Returns:\n            string: REST URL\n        \"\"\"\n        return self.config()[\"restUrl\"]\n\n    def parse_request_response(\n        self,\n        response_object: object,\n        additional_error_message: str = \"\",\n        show_error: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Converts the request response to a Python dict in a safe way\n           that also handles exceptions.\n\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str): print a custom error message\n            show_error (bool): if True log an error, if False log a warning\n        Returns:\n            dict: a python dict object or None in case of an error\n        \"\"\"\n\n        if not response_object:\n            return None\n\n        try:\n            dict_object = json.loads(response_object.text)\n        except json.JSONDecodeError as exception:\n            if additional_error_message:\n                message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                    additional_error_message, exception\n                )\n            else:\n                message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                    exception\n                )\n            if show_error:\n                logger.error(message)\n            else:\n                logger.warning(message)\n            return None\n        else:\n            return dict_object\n\n    # end method definition\n\n    # This method is currently not used and not working...\n    # It cannot handle the Request - ServerManager returns an\n    # error stating that JavaScript is not enabled...\n    def authenticate(self, revalidate: bool = False) -&gt; dict:\n        \"\"\"Authenticates at PowerDocs and retrieve session ID.\n\n        Args:\n            revalidate (bool): determinse if a re-athentication is enforced\n                               (e.g. if session has timed out with 401 error)\n        Returns:\n            dict: Cookie information of None in case of an error.\n                  Also stores cookie information in self._cookie\n        \"\"\"\n\n        # Already authenticated and session still valid?\n        if self._jsessionid and not revalidate:\n            return self._jsessionid\n\n        auth_url = (\n            self.base_url()\n            + \"/j_security_check?j_username=\"\n            + self.config()[\"username\"]\n            + \"&amp;j_password=\"\n            + self.config()[\"password\"]\n        )\n        payload = {}\n        payload[\"settingname\"] = \"LocalOtdsUrl\"\n        payload[\"settingvalue\"] = \"http://otds/otdsws\"\n\n        request_url = self.config()[\"settingsUrl\"]\n\n        ##Fetching session id will be three step process\n        # Step1: intiate a dummy request to tomcat\n        # Step2: fetch session id from the response, and hit j_security_check with proper authentication\n        # Step3: get session id from the response, add to self. It can be used for other transactions\n        session = requests.Session()\n        logger.info(\"Initiating dummy rest call to Tomcat to get initial session id\")\n        response = session.put(request_url, json=payload)\n        logger.info(response.text)\n        if response.ok:\n            logger.info(\"Url to authenticate Tomcat for Session id -&gt; %s\", auth_url)\n            session_response = session.post(auth_url)\n            if session_response.ok:\n                logger.info(\n                    \"Response for -&gt; %s is -&gt; %s\", auth_url, str(session_response)\n                )\n                session_dict = session.cookies.get_dict()\n                logger.info(\n                    \"Session id to perform Rest API calls to Tomcat -&gt; %s\",\n                    session_dict[\"JSESSIONID\"],\n                )\n                # store session ID an write it into the global requestHeaders variable:\n                self._jsessionid = session_dict[\"JSESSIONID\"]\n                requestHeaders[\"Cookie\"] = \"JSESSIONID=\" + self._jsessionid\n                return session_response\n            else:\n                logger.error(\n                    \"Fetching session id from -&gt; %s failed with j_security_check. Response -&gt; %s\",\n                    auth_url,\n                    session_response.text,\n                )\n                return None\n        else:\n            logger.error(\n                \"Fetching session id from -&gt; %s failed. Response -&gt; %s\",\n                request_url,\n                response.text,\n            )\n            return None\n\n    # end method definition\n\n    def import_database(self, filename: str):\n        \"\"\"Import PowerDocs database backup from a zip file\"\"\"\n\n        file = filename.split(\"/\")[-1]\n        file_tup = (file, open(filename, \"rb\"), \"application/zip\")\n\n        # fields attribute is set according to the other party's interface description\n        m = MultipartEncoder(fields={\"name\": file, \"zipfile\": file_tup})\n\n        request_url = self.config()[\"otpdImportDatabaseUrl\"]\n\n        logger.info(\n            \"Importing Database backup -&gt; %s, into PowerDocs ServerManager on -&gt; %s\",\n            filename,\n            request_url,\n        )\n        response = requests.post(\n            request_url, data=m, headers={\"content-type\": m.content_type}, timeout=60\n        )\n\n        if response.ok:\n            return response\n        else:\n            logger.error(\n                \"Failed to Import Database backup -&gt; %s into -&gt; %s; error -&gt; %s\",\n                filename,\n                request_url,\n                response.text,\n            )\n            return None\n\n    # end method definition\n\n    def apply_setting(\n        self, setting_name: str, setting_value: str, tenant_name: str = \"\"\n    ) -&gt; dict | None:\n        \"\"\"Appy a setting to the PowerDocs Server Manager\n\n        Args:\n            setting_name (str): name of the setting\n            setting_value (str): new value of the setting\n            tenant_name (str): name of the PowerDocs tenant - this is optional as some settings are not tenant-specific!\n        Return:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\n\n        settingsPutBody = {\n            \"settingname\": setting_name,\n            \"settingvalue\": setting_value,\n        }\n\n        if tenant_name:\n            settingsPutBody[\"tenantName\"] = tenant_name\n\n        request_url = self.config()[\"settingsUrl\"]\n\n        logger.info(\n            \"Update setting -&gt; %s with value -&gt; %s; calling -&gt; %s\",\n            setting_name,\n            setting_value,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.put(\n                url=request_url,\n                json=settingsPutBody,\n                headers=requestHeaders,\n                auth=HTTPBasicAuth(\n                    self.config()[\"username\"], self.config()[\"password\"]\n                ),\n                verify=False,  # for localhost deployments this will fail otherwise\n                timeout=None,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            # Check if Session has expired - then re-authenticate and try once more\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(True)\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to update setting -&gt; %s; error -&gt; %s\",\n                    setting_name,\n                    response.text,\n                )\n                return None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.__init__","title":"<code>__init__(protocol, hostname, port, username, password)</code>","text":"<p>Initialize the OTPD object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>Either http or https.</p> required <code>hostname</code> <code>str</code> <p>The hostname of the PowerDocs Server Manager to communicate with.</p> required <code>port</code> <code>int</code> <p>The port number used to talk to the PowerDocs Server Manager.</p> required <code>username</code> <code>str</code> <p>The admin user name of PowerDocs Server Manager.</p> required <code>password</code> <code>str</code> <p>The admin password of PowerDocs Server Manager.</p> required Source code in <code>pyxecm/otpd.py</code> <pre><code>def __init__(\n    self,\n    protocol: str,\n    hostname: str,\n    port: int,\n    username: str,\n    password: str,\n):\n    \"\"\"Initialize the OTPD object\n\n    Args:\n        protocol (str): Either http or https.\n        hostname (str): The hostname of the PowerDocs Server Manager to communicate with.\n        port (int): The port number used to talk to the PowerDocs Server Manager.\n        username (str): The admin user name of PowerDocs Server Manager.\n        password (str): The admin password of PowerDocs Server Manager.\n    \"\"\"\n\n    otpd_config = {}\n\n    if hostname:\n        otpd_config[\"hostname\"] = hostname\n    else:\n        otpd_config[\"hostname\"] = \"\"\n\n    if protocol:\n        otpd_config[\"protocol\"] = protocol\n    else:\n        otpd_config[\"protocol\"] = \"http\"\n\n    if port:\n        otpd_config[\"port\"] = port\n    else:\n        otpd_config[\"port\"] = 80\n\n    if username:\n        otpd_config[\"username\"] = username\n    else:\n        otpd_config[\"username\"] = \"admin\"\n\n    if password:\n        otpd_config[\"password\"] = password\n    else:\n        otpd_config[\"password\"] = \"\"\n\n    otpd_base_url = protocol + \"://\" + otpd_config[\"hostname\"]\n    if str(port) not in [\"80\", \"443\"]:\n        otpd_base_url += \":{}\".format(port)\n    otpd_base_url += \"/ServerManager\"\n    otpd_config[\"baseUrl\"] = otpd_base_url\n\n    otpd_rest_url = otpd_base_url + \"/api\"\n    otpd_config[\"restUrl\"] = otpd_rest_url\n\n    otpd_config[\"settingsUrl\"] = otpd_rest_url + \"/v1/settings\"\n\n    otpd_config[\"importDatabaseUrl\"] = otpd_base_url + \"/servlet/import\"\n\n    self._config = otpd_config\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.apply_setting","title":"<code>apply_setting(setting_name, setting_value, tenant_name='')</code>","text":"<p>Appy a setting to the PowerDocs Server Manager</p> <p>Parameters:</p> Name Type Description Default <code>setting_name</code> <code>str</code> <p>name of the setting</p> required <code>setting_value</code> <code>str</code> <p>new value of the setting</p> required <code>tenant_name</code> <code>str</code> <p>name of the PowerDocs tenant - this is optional as some settings are not tenant-specific!</p> <code>''</code> <p>Return:     dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def apply_setting(\n    self, setting_name: str, setting_value: str, tenant_name: str = \"\"\n) -&gt; dict | None:\n    \"\"\"Appy a setting to the PowerDocs Server Manager\n\n    Args:\n        setting_name (str): name of the setting\n        setting_value (str): new value of the setting\n        tenant_name (str): name of the PowerDocs tenant - this is optional as some settings are not tenant-specific!\n    Return:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\n\n    settingsPutBody = {\n        \"settingname\": setting_name,\n        \"settingvalue\": setting_value,\n    }\n\n    if tenant_name:\n        settingsPutBody[\"tenantName\"] = tenant_name\n\n    request_url = self.config()[\"settingsUrl\"]\n\n    logger.info(\n        \"Update setting -&gt; %s with value -&gt; %s; calling -&gt; %s\",\n        setting_name,\n        setting_value,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.put(\n            url=request_url,\n            json=settingsPutBody,\n            headers=requestHeaders,\n            auth=HTTPBasicAuth(\n                self.config()[\"username\"], self.config()[\"password\"]\n            ),\n            verify=False,  # for localhost deployments this will fail otherwise\n            timeout=None,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        # Check if Session has expired - then re-authenticate and try once more\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(True)\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to update setting -&gt; %s; error -&gt; %s\",\n                setting_name,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticates at PowerDocs and retrieve session ID.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determinse if a re-athentication is enforced                (e.g. if session has timed out with 401 error)</p> <code>False</code> <p>Returns:     dict: Cookie information of None in case of an error.           Also stores cookie information in self._cookie</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; dict:\n    \"\"\"Authenticates at PowerDocs and retrieve session ID.\n\n    Args:\n        revalidate (bool): determinse if a re-athentication is enforced\n                           (e.g. if session has timed out with 401 error)\n    Returns:\n        dict: Cookie information of None in case of an error.\n              Also stores cookie information in self._cookie\n    \"\"\"\n\n    # Already authenticated and session still valid?\n    if self._jsessionid and not revalidate:\n        return self._jsessionid\n\n    auth_url = (\n        self.base_url()\n        + \"/j_security_check?j_username=\"\n        + self.config()[\"username\"]\n        + \"&amp;j_password=\"\n        + self.config()[\"password\"]\n    )\n    payload = {}\n    payload[\"settingname\"] = \"LocalOtdsUrl\"\n    payload[\"settingvalue\"] = \"http://otds/otdsws\"\n\n    request_url = self.config()[\"settingsUrl\"]\n\n    ##Fetching session id will be three step process\n    # Step1: intiate a dummy request to tomcat\n    # Step2: fetch session id from the response, and hit j_security_check with proper authentication\n    # Step3: get session id from the response, add to self. It can be used for other transactions\n    session = requests.Session()\n    logger.info(\"Initiating dummy rest call to Tomcat to get initial session id\")\n    response = session.put(request_url, json=payload)\n    logger.info(response.text)\n    if response.ok:\n        logger.info(\"Url to authenticate Tomcat for Session id -&gt; %s\", auth_url)\n        session_response = session.post(auth_url)\n        if session_response.ok:\n            logger.info(\n                \"Response for -&gt; %s is -&gt; %s\", auth_url, str(session_response)\n            )\n            session_dict = session.cookies.get_dict()\n            logger.info(\n                \"Session id to perform Rest API calls to Tomcat -&gt; %s\",\n                session_dict[\"JSESSIONID\"],\n            )\n            # store session ID an write it into the global requestHeaders variable:\n            self._jsessionid = session_dict[\"JSESSIONID\"]\n            requestHeaders[\"Cookie\"] = \"JSESSIONID=\" + self._jsessionid\n            return session_response\n        else:\n            logger.error(\n                \"Fetching session id from -&gt; %s failed with j_security_check. Response -&gt; %s\",\n                auth_url,\n                session_response.text,\n            )\n            return None\n    else:\n        logger.error(\n            \"Fetching session id from -&gt; %s failed. Response -&gt; %s\",\n            request_url,\n            response.text,\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.base_url","title":"<code>base_url()</code>","text":"<p>Returns the base URL of PowerDocs</p> <p>Returns:</p> Name Type Description <code>string</code> <p>base URL</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def base_url(self):\n    \"\"\"Returns the base URL of PowerDocs\n\n    Returns:\n        string: base URL\n    \"\"\"\n    return self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Returns the configuration dictionary\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    return self._config\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.credentials","title":"<code>credentials()</code>","text":"<p>Get credentials (username + password)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with username and password</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def credentials(self) -&gt; dict:\n    \"\"\"Get credentials (username + password)\n\n    Returns:\n        dict: dictionary with username and password\n    \"\"\"\n    return {\n        \"username\": self.config()[\"username\"],\n        \"password\": self.config()[\"password\"],\n    }\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.hostname","title":"<code>hostname()</code>","text":"<p>Returns the hostname of PowerDocs (e.g. \"otpd\")</p> <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> <p>hostname</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def hostname(self) -&gt; str:\n    \"\"\"Returns the hostname of PowerDocs (e.g. \"otpd\")\n\n    Returns:\n        string: hostname\n    \"\"\"\n    return self.config()[\"hostname\"]\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.import_database","title":"<code>import_database(filename)</code>","text":"<p>Import PowerDocs database backup from a zip file</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def import_database(self, filename: str):\n    \"\"\"Import PowerDocs database backup from a zip file\"\"\"\n\n    file = filename.split(\"/\")[-1]\n    file_tup = (file, open(filename, \"rb\"), \"application/zip\")\n\n    # fields attribute is set according to the other party's interface description\n    m = MultipartEncoder(fields={\"name\": file, \"zipfile\": file_tup})\n\n    request_url = self.config()[\"otpdImportDatabaseUrl\"]\n\n    logger.info(\n        \"Importing Database backup -&gt; %s, into PowerDocs ServerManager on -&gt; %s\",\n        filename,\n        request_url,\n    )\n    response = requests.post(\n        request_url, data=m, headers={\"content-type\": m.content_type}, timeout=60\n    )\n\n    if response.ok:\n        return response\n    else:\n        logger.error(\n            \"Failed to Import Database backup -&gt; %s into -&gt; %s; error -&gt; %s\",\n            filename,\n            request_url,\n            response.text,\n        )\n        return None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the request response to a Python dict in a safe way    that also handles exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>print a custom error message</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>if True log an error, if False log a warning</p> <code>True</code> <p>Returns:     dict: a python dict object or None in case of an error</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def parse_request_response(\n    self,\n    response_object: object,\n    additional_error_message: str = \"\",\n    show_error: bool = True,\n) -&gt; dict | None:\n    \"\"\"Converts the request response to a Python dict in a safe way\n       that also handles exceptions.\n\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str): print a custom error message\n        show_error (bool): if True log an error, if False log a warning\n    Returns:\n        dict: a python dict object or None in case of an error\n    \"\"\"\n\n    if not response_object:\n        return None\n\n    try:\n        dict_object = json.loads(response_object.text)\n    except json.JSONDecodeError as exception:\n        if additional_error_message:\n            message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                additional_error_message, exception\n            )\n        else:\n            message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                exception\n            )\n        if show_error:\n            logger.error(message)\n        else:\n            logger.warning(message)\n        return None\n    else:\n        return dict_object\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.rest_url","title":"<code>rest_url()</code>","text":"<p>Returns the REST URL of PowerDocs</p> <p>Returns:</p> Name Type Description <code>string</code> <p>REST URL</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def rest_url(self):\n    \"\"\"Returns the REST URL of PowerDocs\n\n    Returns:\n        string: REST URL\n    \"\"\"\n    return self.config()[\"restUrl\"]\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.set_credentials","title":"<code>set_credentials(username='admin', password='')</code>","text":"<p>Set the credentials for PowerDocs for the based on user name and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username. Defaults to \"admin\".</p> <code>'admin'</code> <code>password</code> <code>str</code> <p>Password of the user. Defaults to \"\".</p> <code>''</code> Source code in <code>pyxecm/otpd.py</code> <pre><code>def set_credentials(self, username: str = \"admin\", password: str = \"\"):\n    \"\"\"Set the credentials for PowerDocs for the based on user name and password.\n\n    Args:\n        username (str, optional): Username. Defaults to \"admin\".\n        password (str, optional): Password of the user. Defaults to \"\".\n    \"\"\"\n    self.config()[\"username\"] = username\n    self.config()[\"password\"] = password\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.set_hostname","title":"<code>set_hostname(hostname)</code>","text":"<p>Sets the hostname of PowerDocs</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>new hostname</p> required Source code in <code>pyxecm/otpd.py</code> <pre><code>def set_hostname(self, hostname: str):\n    \"\"\"Sets the hostname of PowerDocs\n\n    Args:\n        hostname (str): new hostname\n    \"\"\"\n    self.config()[\"hostname\"] = hostname\n</code></pre>"},{"location":"pyxecm/payload/","title":"Payload","text":"<p>Payload Module to implement functions to process Terrarium payload</p> <p>This code processes a YAML payload file that includes various settings: * WebHooks (URLs) to call (e.g. to start-up external services or applications) * OTDS partitions and OAuth clients * OTDS trusted sites and system attributes * OTDS licenses * Extended ECM users and groups * Microsoft 365 user, groups, and teams * Extended ECM Admin Settings (LLConfig) * Extended ECM External System Connections (SAP, SuccessFactors, ...) * Extended ECM Transport Packages (scenarios and demo content) * Extended ECM CS Applications (typically based on Web Reports) * Extended ECM Web Reports to run * Extended ECM Workspaces to create (incl. members, workspace relationships) * Extended ECM user photos, user favorites and user settings * Extended ECM items to create and permissions to apply * Extended ECM items to rename * Extended ECM Documents to generate (from templates) * Extended ECM assignments (used e.g. for Government scenario) * Extended ECM Records Management settings, Security Clearance, Supplemental Markings, and Holds * SAP RFCs (Remote Function Calls) * Commands to execute in Kubernetes Pods</p> <p>This code typically runs in a container as part of the cloud automation.</p> <p>Class: Payload Methods:</p> <p>init : class initializer replace_placeholders: replace placeholder in admin config files init_payload: load and initialize the YAML payload get_payload_section: delivers a section of the payload as a list of settings get_all_group_names: construct a list of all group name</p> <p>get_status_file_name: construct the name of the status file. check_status_file: check if the payload section has been processed before write_status_file: Write a status file into the Admin Personal Workspace in Extended ECM                    to indicate that the payload section has been deployed successfully get_status_file: Retrieve the content of the status file</p> <p>determine_group_id: determine the id of a group - either from payload or from OTCS determine_user_id: determine the id of a user - either from payload or from OTCS determine_user_id_m365: determine the id of a M365 user - either from payload or from M365 via Graph API determine_workspace_id: determine the nodeID of a workspace - either from payload or from OTCS</p> <p>process_payload: process payload (main method) process_web_hooks: process list of web hooks process_partitions: process the OTDS partitions process_partition_licenses: process the licenses that should be assigned to OTDS partitions                             (this includes existing partitions) process_oauth_clients: process the OTDS OAuth clients process_auth_handlers: process the OTDS auth handlers (some are implicitly generated by external system payload) process_trusted_sites: process the OTDS trusted sites process_system_attributes: process the OTDS system attributes process_group_placeholders: collect group placeholders process_user_placeholders: collect user placeholders process_groups: process Extended ECM user groups process_groups_m365: process M365 user groups process_users: process Extended ECM users process_users_m365: process M365 users process_users_sap: process users that are SAP enabled (if SAP is enabled) process_teams_m365: process groups in payload and create matching M365 Teams cleanup_stale_teams_m365: Delete Microsoft Teams that are left-overs from former deployments.                           This method is currently not used. cleanup_all_teams_m365: Delete Microsoft Teams that are left-overs from former deployments process_admin_settings: process Extended ECM administration settings (LLConfig) process_external_systems: process Extended ECM external systems process_transport_packages: process Extended ECM transport packages process_user_photos: process Extended ECM user photos (user profile) process_user_photos_m365: process user photos in payload and assign them to Microsoft 365 users. process_business_object_types: process Extended ECM business object types                                (needs to run after process_transport_packages) process_workspace_types: process Extended ECM workspace types                          (needs to run after process_transport_packages) process_workspaces: process Extended ECM workspace instances process_workspace_relationships: process Extended ECM workspace relationships process_workspace_members: process Extended ECM workspace members (users and groups) process_workspace_member_permissions: Process workspaces members in payload and set their permissions. process_workspace_aviators: Process workspaces Content Aviator settings in payload and                             enable Aviator for selected workspaces process_web_reports: process Extended ECM Web Reports (starts them with parameters) process_cs_applications: process Extended ECM CS Applications process_user_settings: Process user settings in payload and apply themin OTDS. process_user_favorites_and_profiles: Process user favorites in payload and create them in Extended ECM process_security_clearances: process Security Clearance for users process_supplemental_markings: process Supplemental Markings for users process_user_security: process Security Clearance and Supplemental Markings for users process_records_management_settings: process Records Management settings by applying settings files process_holds: process Records Management Holds process_additional_group_members: process additional OTDS group memberships process_additional_access_role_members: process additional OTDS group memberships process_renamings: process Extended ECM node renamings process_items: process Extended ECM items (nodes) to create process_permissions: process permission changes for alist of Extended ECM items or volumes process_assignments: process assignments of workspaces / documents to users / groups process_user_licenses: process and apply licenses to all Extended ECM users (used for OTIV) process_exec_pod_commands: process Kubernetes pod commands process_document_generators: Generate documents for a defined workspace type based on template process_browser_automations: process Selenium-based browser automation payload init_sap: initalize SAP object for RFC communication process_sap_rfcs: process SAP Remote Function Calls (RFC) to trigger automation in SAP S/4HANA init_salesforce: initialize Salesforce object for Salesforce API communication</p> <p>get_payload: return the payload data structure get_users: return list of users get_groups: return list of groups get_workspaces: return list of workspaces get_otcs_frontend: return OTCS object for OTCS frontend get_otcs_backend: return OTCS object for OTCS backend get_otds: return OTDS object get_k8s: return the Kubernetes object</p>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload","title":"<code>Payload</code>","text":"<p>Used to process Terrarium payload.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>class Payload:\n    \"\"\"Used to process Terrarium payload.\"\"\"\n\n    # _debug controls whether or not transport processing is\n    # stopped if one transport fails:\n    _debug: bool = False\n    _otcs: OTCS\n    _otcs_backend: OTCS\n    _otcs_frontend: OTCS\n    _otac: OTAC | None\n    _otds: OTDS\n    _otiv: OTIV | None\n    _k8s: K8s | None\n    _web: HTTP | None\n    _m365: M365 | None\n    _sap: SAP | None\n    _salesforce: Salesforce | None\n    _browser_automation: BrowserAutomation | None\n    _custom_settings_dir = \"\"\n\n    # _payload_source (string): This is either path + filename of the yaml payload\n    # or an path + filename of the Terraform HCL payload\n    _payload_source = \"\"\n\n    # _payload is a dict of the complete payload file.\n    # It is initialized by the init_payload() method:\n    _payload = {}\n\n    # _payload_sections is a list of dicts with these keys:\n    # - name (string)\n    # - enabled (bool)\n    # - restart (bool)\n    _payload_sections = []\n\n    #\n    # Initialize payload section variables. They are all list of dicts:\n    #\n\n    # webhooks and webhooks_post: List of webHooks. List items are dicts with these key:\n    # - enabled (bool)\n    # - description (str)\n    # - url (str)\n    # - method (str) - either POST, PUT, GET\n    # - payload (dict)\n    # - headers (dict)\n    _webhooks = []\n    _webhooks_post = []\n\n    # partitions: list of dicts with these key / value pairs:\n    # - enabled (bool)\n    # - name (str)\n    # - description (str)\n    # - synced (bool)\n    # - access_role (str)\n    # - licenses (list)\n    _partitions = []\n\n    # oauth_clients: list of dicts with these key / value pairs:\n    # - enabled (bool)\n    # - name (str)\n    # - description (str)\n    # - confidential (bool)\n    # - partition (str)\n    # - redirect_urls (list)\n    # - permission_scopes (list)\n    # - default_scopes (list)\n    # - allow_impersonation (bool)\n    _oauth_clients = []\n\n    # oauth_handlers: list of dicts with these key / value pairs:\n    # - enabled (bool)\n    # - name (str)\n    # - description (str)\n    # - scope (str)\n    # - type (str) - like SAML, SAP, OAUTH\n    # - priority (int)\n    # - active_by_default (bool)\n    # - auth_principal_attributes (list)\n    # - saml_url (str)\n    # - otds_sp_endpoint (str)\n    # - nameid_format (str)\n    _auth_handlers = []\n\n    # trusted_sites: list of dicts with these key / value pairs:\n    # - enabled (bool)\n    # - url (str)\n    _trusted_sites = []\n\n    # system_attributes: list of dicts with these key / value pairs:\n    # - enabled (bool)\n    # - name (str)\n    # - value (str)\n    # - description (str)\n    _system_attributes = []\n\n    # groups: List of groups. List items are dicts with these key / value pairs:\n    # - name (str),\n    # - parent_groups (list),\n    # - enable_o365 (bool)\n    _groups = []\n\n    # users: List of users. List items are dicts with these key / value pairs:\n    # - enabled (bool)\n    # - name (str) (= login)\n    # - password (str)\n    # - firstname (str)\n    # - lastname (str)\n    # - email (str)\n    # - base_group (str)\n    # - groups (list)\n    # - favorites (list of str)\n    # - security_clearance (int)\n    # - supplemental_markings (list of str)\n    # - enable_sap (bool)\n    # - enable_o365 (bool)\n    # - m365_skus (list of str)\n    # - extra_attributes (list of dict)\n    _users = []\n\n    # admin_settings: list of admin settings (XML file to import)\n    # - enabled (bool)\n    # - description (str)\n    # - filename (str) - without path\n    _admin_settings = []\n    _admin_settings_post = []\n\n    # exec_pod_commands: list of commands to be executed in the pods\n    # list elements need to be dicts with pod name, command, etc.\n    _exec_pod_commands = []\n\n    # external_systems (list): List of external systems. Each list element is a dict with\n    # - enabled (bool)\n    # - external_system_type (str)\n    # - external_system_name (str)\n    # - external_system_number (str)\n    # - description (str)\n    # - as_url (str)\n    # - base_url (str)\n    # - client (str)\n    # - username (str)\n    # - password (str)\n    # - certificate_file (str)\n    # - certificate_password (str)\n    # - destination (str)\n    # - archive_logical_name (str)\n    # - archive_certificate_file (str)\n    _external_systems = []\n\n    # transport_packages (list): List of transport packages systems. Each list element is a\n    # dict with \"url\", \"name\", and \"description\" keys.\n    _transport_packages = []\n    _content_transport_packages = []\n    _transport_packages_post = []\n\n    _business_object_types = []\n    _workspace_types = []\n    _workspace_templates = []\n    _workspaces = []\n    _sap_rfcs = []\n    _web_reports = []\n    _web_reports_post = []\n\n    # cs_applications (list): List of Content Server Applications to deploy.\n    # - enabled (bool)\n    # - name (str)\n    # - descriptions (str)\n    _cs_applications = []\n\n    # additional_group_members: List of memberships to establish. Each element\n    # is a dict with these keys:\n    # - parent_group (string)\n    # - user_name (string)\n    # - group_name (string)\n    _additional_group_members = []\n\n    # additional_access_role_members: List of memberships to establish. Each element\n    # is a dict with these keys:\n    # - access_role (string)\n    # - user_name (string)\n    # - group_name (string)\n    # - partition_name (string)\n    _additional_access_role_members = []\n    _renamings = []\n\n    # items: List of items to create in Extended ECM\n    # - enabled (bool)\n    # - parent_nickname (str)\n    # - parent_path (list)\n    # - name (str)\n    # - description (str)\n    # - type (str)\n    # - url (str) - \"\" means not set\n    # - original_nickname\n    # - original_path (list)\n    _items = []\n    _items_post = []\n\n    # permissions: List of permissions changes to apply\n    # - path (list)\n    # - volume (int)\n    # - public_permissions (list)\n    # - groups (list)\n    #   + name (str)\n    #   + permissions (list)\n    # - users (list)\n    #   + name (str)\n    #   + permissions (list)\n    # - apply_to (int)\n    _permissions = []\n    _permissions_post = []\n\n    # assignments: List of assignments. Each element is a dict with these keys:\n    # - subject (string)\n    # - instruction (string)\n    # - workspace (string)\n    # - nickname (string)\n    # - groups (list)\n    # - users (list)\n    _assignments = []\n    _workspace_template_registrations = []\n    _security_clearances = []\n    _supplemental_markings = []\n    _records_management_settings = []\n    _holds = []\n    _doc_generators = []\n    _browser_automations = []\n    _browser_automations_post = []\n\n    _placeholder_values = {}\n\n    _otcs_restart_callback: Callable\n    _log_header_callback: Callable\n    _aviator_enabled = False\n\n    _transport_extractions: list = []\n    _transport_replacements: list = []\n\n    def __init__(\n        self,\n        payload_source: str,\n        custom_settings_dir: str,\n        k8s_object: K8s | None,\n        otds_object: OTDS,\n        otac_object: OTAC | None,\n        otcs_backend_object: OTCS,\n        otcs_frontend_object: OTCS,\n        otcs_restart_callback: Callable,\n        otiv_object: OTIV | None,\n        m365_object: M365 | None,\n        browser_automation_object: BrowserAutomation | None,\n        placeholder_values: dict,\n        log_header_callback: Callable,\n        stop_on_error: bool = False,\n        aviator_enabled: bool = False,\n    ):\n        \"\"\"Initialize the Payload object\n\n        Args:\n            payload_source (str): path or URL to payload source file\n            k8s_object (object): Kubernetes object\n            otds_object (OTDS): OTDS object\n            otac_object (OTAC): OTAC object\n            otcs_backend_object (OTCS): OTCS backend object\n            otcs_frontend_object (OTCS): OTCS frontend object\n            otcs_restart_callback (Callable): function to call if OTCS service needs a restart\n            otiv_object (object): OTIV object\n            m365_object (object): M365 object to talk to Microsoft Graph API\n            browser_automation_object (object): BrowserAutomation object to automate things which don't have a REST API\n            placeholder_values (dict): dictionary of placeholder values\n                                       to be replaced in admin settings\n            log_header_callback: prints a section break / header line into the log\n            stop_on_error (bool): controls if transport deployment should stop\n                                  if one transport fails\n            aviator_enabled (bool): whether or not the Content Aviator is enabled\n        \"\"\"\n\n        self._stop_on_error = stop_on_error\n        self._payload_source = payload_source\n        self._k8s = k8s_object\n        self._otds = otds_object\n        self._otac = otac_object\n        self._otcs = otcs_backend_object\n        self._otcs_backend = otcs_backend_object\n        self._otcs_frontend = otcs_frontend_object\n        self._otiv = otiv_object\n        self._m365 = m365_object\n        self._sap = (\n            None  # this object only exists after external systems have been processed\n        )\n        self._salesforce = None\n        self._browser_automation = browser_automation_object\n        self._custom_settings_dir = custom_settings_dir\n        self._placeholder_values = placeholder_values\n        self._otcs_restart_callback = otcs_restart_callback\n        self._log_header_callback = log_header_callback\n        self._aviator_enabled = aviator_enabled\n        self._http_object = HTTP()\n\n    # end method definition\n\n    def replace_placeholders(self, content: str) -&gt; str:\n        \"\"\"Function to replace placeholders in file content.\n           The content of the file is provided via a parameter.\n           The replacements are defined in a object variable\n           _placeholder_values (type = dictionary)\n           The placeholder values are supposed to be surrounded by\n           double % signs like %%OTAWP_RESOURCE_ID%%\n\n        Args:\n            content (str): file content to replace placeholders in\n        Returns:\n            str: updated content with all defined replacements\n        \"\"\"\n        # https://stackoverflow.com/questions/63502218/replacing-placeholders-in-a-text-file-with-python\n\n        # if no placeholders are defined we can return the\n        # initial value:\n        if not self._placeholder_values:\n            return content\n\n        try:\n            # We do a dynamic replacement here. The replacement is calculated\n            # by the lambda function that is basically a lookup of the replacement\n            # key found in the settings file with the value defined in the list\n            # of replacement values in self._placeholder_values\n            return re.sub(\n                r\"%%(\\w+?)%%\",\n                lambda match: self._placeholder_values[match.group(1)],\n                content,\n            )\n        except KeyError as key_error:\n            logger.error(\n                \"Found placeholder in settings file without a defined value; error -&gt; %s\",\n                str(key_error),\n            )\n            return content\n        except re.error as re_error:\n            logger.error(\"Regex substitution error -&gt; %s\", str(re_error))\n            return content\n\n        # end method definition\n\n    def init_payload(self) -&gt; dict | None:\n        \"\"\"Read the YAML or Terraform HCL payload file.\n\n        Args:\n            None\n        Returns:\n            dict: payload as a Python dict. Elements are the different payload sections.\n                  None in case the file couldn't be found or read.\n        \"\"\"\n\n        if not os.path.exists(self._payload_source):\n            logger.error(\"Cannot access payload file -&gt; %s\", self._payload_source)\n            return None\n\n        # Is it a YAML file?\n        if self._payload_source.endswith(\".yaml\"):\n            logger.info(\"Open payload from YAML file -&gt; %s\", self._payload_source)\n            try:\n                with open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\n                    payload_data = stream.read()\n                self._payload = yaml.safe_load(payload_data)\n            except yaml.YAMLError as exception:\n                logger.error(\n                    \"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\n                    self._payload_source,\n                    exception,\n                )\n                self._payload = {}\n        # Or is it a Terraform HCL file?\n        elif self._payload_source.endswith(\".tf\"):\n            logger.info(\n                \"Open payload from Terraform HCL file -&gt; %s\", self._payload_source\n            )\n            try:\n                with open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\n                    self._payload = hcl2.api.load(stream)\n                # If payload is wrapped into \"external_payload\" we unwrap it:\n                if self._payload.get(\"external_payload\"):\n                    self._payload = self._payload[\"external_payload\"]\n            except FileNotFoundError as exception:\n                logger.error(\n                    \"Error while reading Terraform HCL payload file -&gt; %s; error -&gt; %s\",\n                    self._payload_source,\n                    exception,\n                )\n                self._payload = {}\n\n        elif self._payload_source.endswith(\".yml.gz.b64\"):\n            logger.info(\n                \"Open payload from base64-gz-YAML file -&gt; %s\", self._payload_source\n            )\n            try:\n                with open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\n                    content = base64.b64decode(stream.read())\n                    decoded_data = gzip.decompress(content)\n\n                    self._payload = yaml.safe_load(decoded_data)\n\n            except yaml.YAMLError as exception:\n                logger.error(\n                    \"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\n                    self._payload_source,\n                    exception,\n                )\n                self._payload = {}\n\n        # If not, it is an unsupported type:\n        else:\n            logger.error(\n                \"File -&gt; %s has unsupported file type\",\n                self._payload_source,\n            )\n            self._payload = {}\n\n        if self._payload is not None:\n            self._payload_sections = self._payload[\"payloadSections\"]\n\n            if not self._payload_sections:\n                logger.error(\n                    \"Sections for payload -&gt; %s are undefined. Skipping...\",\n                    self._payload_source,\n                )\n                return None\n\n        # Retrieve all the payload sections and store them in lists:\n        self._webhooks = self.get_payload_section(\"webHooks\")\n        self._webhooks_post = self.get_payload_section(\"webHooksPost\")\n        self._partitions = self.get_payload_section(\"partitions\")\n        self._oauth_clients = self.get_payload_section(\"oauthClients\")\n        self._auth_handlers = self.get_payload_section(\"authHandlers\")\n        self._trusted_sites = self.get_payload_section(\"trustedSites\")\n        self._system_attributes = self.get_payload_section(\"systemAttributes\")\n        self._groups = self.get_payload_section(\"groups\")\n        self._users = self.get_payload_section(\"users\")\n        self._admin_settings = self.get_payload_section(\"adminSettings\")\n        self._exec_pod_commands = self.get_payload_section(\"execPodCommands\")\n        self._external_systems = self.get_payload_section(\"externalSystems\")\n        self._transport_packages = self.get_payload_section(\"transportPackages\")\n        self._content_transport_packages = self.get_payload_section(\n            \"contentTransportPackages\"\n        )\n        self._transport_packages_post = self.get_payload_section(\n            \"transportPackagesPost\"\n        )\n        self._workspace_templates = self.get_payload_section(\"workspaceTemplates\")\n        self._workspaces = self.get_payload_section(\"workspaces\")\n        self._sap_rfcs = self.get_payload_section(\"sapRFCs\")\n        self._web_reports = self.get_payload_section(\"webReports\")\n        self._web_reports_post = self.get_payload_section(\"webReportsPost\")\n        self._cs_applications = self.get_payload_section(\"csApplications\")\n        self._admin_settings_post = self.get_payload_section(\"adminSettingsPost\")\n        self._additional_group_members = self.get_payload_section(\n            \"additionalGroupMemberships\"\n        )\n        self._additional_access_role_members = self.get_payload_section(\n            \"additionalAccessRoleMemberships\"\n        )\n        self._renamings = self.get_payload_section(\"renamings\")\n        self._items = self.get_payload_section(\"items\")\n        self._items_post = self.get_payload_section(\"itemsPost\")\n        self._permissions = self.get_payload_section(\"permissions\")\n        self._permissions_post = self.get_payload_section(\"permissionsPost\")\n        self._assignments = self.get_payload_section(\"assignments\")\n        self._security_clearances = self.get_payload_section(\"securityClearances\")\n        self._supplemental_markings = self.get_payload_section(\"supplementalMarkings\")\n        self._records_management_settings = self.get_payload_section(\n            \"recordsManagementSettings\"\n        )\n        self._holds = self.get_payload_section(\"holds\")\n        self._doc_generators = self.get_payload_section(\"documentGenerators\")\n        self._browser_automations = self.get_payload_section(\"browserAutomations\")\n        self._browser_automations_post = self.get_payload_section(\n            \"browserAutomationsPost\"\n        )\n\n        return self._payload\n        # end method definition\n\n    def get_payload_section(self, payload_section_name: str) -&gt; list:\n        \"\"\"Get a defined section of the payload. The section is delivered as a list of settings.\n        It deliveres an empty list if this payload section is disabled by the corresponding\n        payload switch (this is read from the payloadSections dictionary of the payload)\n\n        Args:\n            payload_section_name (str): name of the dict element in the payload structure\n        Returns:\n            list: section of the payload as a Python list. Empty list if section does not exist\n            or section is disabled by the corresponding payload switch.\n        \"\"\"\n\n        if not isinstance(self._payload, dict):\n            return []\n\n        # if the secton is not in the payload we return an empty list:\n        if not self._payload.get(payload_section_name):\n            return []\n\n        # Check if the payload section is either enabled\n        # or the struct for payloadSection enabling is not in the payload:\n        sections = self._payload.get(\"payloadSections\")\n        if sections:\n            section = next(\n                (item for item in sections if item[\"name\"] == payload_section_name),\n                None,\n            )\n            if not section or not section[\"enabled\"]:\n                return []\n\n        return self._payload[payload_section_name]\n\n        # end method definition\n\n    def get_all_group_names(self) -&gt; list:\n        \"\"\"Construct a list of all group name\n\n        Returns:\n            list: list of all group names\n        \"\"\"\n        return [group.get(\"name\") for group in self._groups]\n\n        # end method definition\n\n    def get_status_file_name(\n        self,\n        payload_section_name: str,\n        payload_specific: bool = True,\n        prefix: str = \"success_\",\n    ) -&gt; str:\n        \"\"\"Construct the name of the status file.\n\n        Args:\n            payload_section_name (str): name of the payload section. This\n                                        is used to construct the file name\n            payload_specific (bool, optional): whether or not the success should be specific for\n                                               each payload file or if success is \"global\" - like for the deletion\n                                               of the existing M365 teams (which we don't want to execute per\n                                               payload file)\n\n        Returns:\n            str: name of the payload section file\n        \"\"\"\n\n        # Some sections are actually not payload specific like teamsM365Cleanup\n        # we don't want external payload runs to re-apply this processing:\n        if payload_specific:\n            file_name = os.path.basename(self._payload_source)  # remove directories\n            # Split once at the first occurance of a dot\n            # as the _payload_source may have multiple suffixes\n            # such as .yml.gz.b64:\n            file_name = file_name.split(\".\", 1)[0]\n            file_name = prefix + file_name + \"_\" + payload_section_name + \".json\"\n        else:\n            file_name = prefix + payload_section_name + \".json\"\n\n        return file_name\n\n        # end method definition\n\n    def check_status_file(\n        self, payload_section_name: str, payload_specific: bool = True\n    ) -&gt; bool:\n        \"\"\"Check if the payload section has been processed before. This is\n           done by checking the existance of a text file in the Admin Personal\n           workspace in Extended ECM with the name of the payload section.\n\n        Args:\n            payload_section_name (str): name of the payload section. This\n                                        is used to construct the file name\n            payload_specific (bool, optional): whether or not the success should be specific for\n                                               each payload file or if success is \"global\" - like for the deletion\n                                               of the existing M365 teams (which we don't want to execute per\n                                               payload file)\n        Returns:\n            bool: True if the payload has been processed successfully before, False otherwise\n        \"\"\"\n\n        logger.info(\n            \"Check if payload section -&gt; %s has been processed successfully before...\",\n            payload_section_name,\n        )\n\n        response = self._otcs.get_node_by_volume_and_path(\n            142\n        )  # write to Personal Workspace of Admin\n        target_folder_id = self._otcs.get_result_value(response, \"id\")\n        if not target_folder_id:\n            target_folder_id = 2004  # use Personal Workspace of Admin as fallback\n\n        file_name = self.get_status_file_name(\n            payload_section_name=payload_section_name, payload_specific=payload_specific\n        )\n\n        status_document = self._otcs.get_node_by_parent_and_name(\n            parent_id=int(target_folder_id), name=file_name, show_error=False\n        )\n        if status_document and status_document[\"results\"]:\n            name = self._otcs.get_result_value(status_document, \"name\")\n            if name == file_name:\n                logger.info(\n                    \"Payload section -&gt; %s has been processed successfully before. Skipping...\",\n                    payload_section_name,\n                )\n                return True\n        logger.info(\n            \"Payload section -&gt; %s has not been processed successfully before. Processing...\",\n            payload_section_name,\n        )\n        return False\n\n        # end method definition\n\n    def write_status_file(\n        self,\n        success: bool,\n        payload_section_name: str,\n        payload_section: list,\n        payload_specific: bool = True,\n    ) -&gt; bool:\n        \"\"\"Write a status file into the Admin Personal Workspace in Extended ECM\n           to indicate that the payload section has been deployed successfully.\n           This speeds up the customizing process in case the customizer pod\n           is restarted.\n\n        Args:\n            success (bool): True if the section was processed successful, False otherwise.\n            payload_section_name (str): name of the payload section\n            payload_section (list): payload section content - this is written as JSon into the file\n            payload_specific (bool): whether or not the success should be specific for\n                                     each payload file or if success is \"global\" - like for the deletion\n                                     of the existing M365 teams (which we don't want to execute per\n                                     payload file)\n        Returns:\n            bool: True if the status file as been upladed to Extended ECM successfully, False otherwise\n        \"\"\"\n\n        if success:\n            logger.info(\n                \"Payload section -&gt; %s has been completed successfully!\",\n                payload_section_name,\n            )\n            prefix = \"success_\"\n        else:\n            logger.error(\n                \"Payload section -&gt; %s had failures!\",\n                payload_section_name,\n            )\n            prefix = \"failure_\"\n\n        response = self._otcs.get_node_by_volume_and_path(\n            142\n        )  # write to Personal Workspace of Admin (with Volume Type ID = 142)\n        target_folder_id = self._otcs.get_result_value(response, \"id\")\n        if not target_folder_id:\n            target_folder_id = 2004  # use Personal Workspace of Admin as fallback\n\n        file_name = self.get_status_file_name(\n            payload_section_name=payload_section_name,\n            payload_specific=payload_specific,\n            prefix=prefix,\n        )\n\n        full_path = \"/tmp/\" + file_name\n\n        with open(full_path, mode=\"w\", encoding=\"utf-8\") as localfile:\n            localfile.write(json.dumps(payload_section, indent=2))\n\n        # Check if the status file has been uploaded before.\n        # This can happen if we re-run the python container.\n        # In this case we add a version to the existing document:\n        response = self._otcs.get_node_by_parent_and_name(\n            parent_id=int(target_folder_id), name=file_name, show_error=False\n        )\n        target_document_id = self._otcs.get_result_value(response, \"id\")\n        if target_document_id:\n            response = self._otcs.add_document_version(\n                node_id=int(target_document_id),\n                file_url=full_path,\n                file_name=file_name,\n                mime_type=\"text/plain\",\n                description=\"Updated status file after re-run of customization\",\n            )\n        else:\n            response = self._otcs.upload_file_to_parent(\n                file_url=full_path,\n                file_name=file_name,\n                mime_type=\"text/plain\",\n                parent_id=int(target_folder_id),\n            )\n\n        if response:\n            logger.info(\n                \"Status file -&gt; %s has been written to Personal Workspace of admin user\",\n                file_name,\n            )\n            return True\n\n        logger.error(\n            \"Failed to write status file -&gt; %s to Personal Workspace of admin user\",\n            file_name,\n        )\n\n        return False\n\n        # end method definition\n\n    def get_status_file(\n        self, payload_section_name: str, payload_specific: bool = True\n    ) -&gt; list | None:\n        \"\"\"Get the status file and read it into a dictionary.\n\n        Args:\n            payload_section_name (str): name of the payload section. This\n                                        is used to construct the file name\n            payload_specific (bool): whether or not the success should be specific for\n                                     each payload file or if success is \"global\" - like for the deletion\n                                     of the existing M365 teams (which we don't want to execute per\n                                     payload file)\n        Returns:\n            dict: content of the status file as a dictionary or None in case of an error\n        \"\"\"\n\n        logger.info(\n            \"Get the status file of the payload section -&gt; %s...\",\n            payload_section_name,\n        )\n\n        response = self._otcs.get_node_by_volume_and_path(\n            142\n        )  # read from Personal Workspace of Admin\n        source_folder_id = self._otcs.get_result_value(response, \"id\")\n        if not source_folder_id:\n            source_folder_id = 2004  # use Personal Workspace of Admin as fallback\n\n        file_name = self.get_status_file_name(\n            payload_section_name=payload_section_name, payload_specific=payload_specific\n        )\n\n        status_document = self._otcs.get_node_by_parent_and_name(\n            parent_id=int(source_folder_id), name=file_name, show_error=True\n        )\n        status_file_id = self._otcs.get_result_value(status_document, \"id\")\n        if not status_file_id:\n            logger.error(\"Cannot find status file -&gt; %s\", file_name)\n            return None\n        content = self._otcs.get_document_content(status_file_id)\n\n        try:\n            json_data = json.loads(content.decode(\"utf-8\"))\n            if isinstance(json_data, list):\n                return json_data\n            else:\n                logger.error(\"File content is in JSON format but not a list.\")\n                return None\n        except json.JSONDecodeError as e:\n            logger.error(\"File content is not in valid JSON format; error -&gt; %s\", e)\n            return None\n\n        # end method definition\n\n    def determine_group_id(self, group: dict) -&gt; int:\n        \"\"\"Determine the id of a group - either from payload or from OTCS.\n           If the group is found in OTCS write back the ID into the payload.\n\n        Args:\n            group (dict): group payload element\n\n        Returns:\n            int: group ID\n        Side Effects:\n            the group items are modified by adding an \"id\" dict element that\n            includes the technical ID of the group in Extended ECM\n        \"\"\"\n\n        # Is the ID already known in payload? (if determined before)\n        if \"id\" in group:\n            return group[\"id\"]\n\n        if not \"name\" in group:\n            logger.error(\"Group needs a name to lookup the ID.\")\n            return 0\n        group_name = group[\"name\"]\n\n        existing_groups = self._otcs.get_group(name=group_name)\n        # We use the lookup method here as get_group() could deliver more\n        # then 1 result element (in edge cases):\n        group_id = self._otcs.lookup_result_value(\n            response=existing_groups, key=\"name\", value=group_name, return_key=\"id\"\n        )\n\n        # Have we found an exact match?\n        if group_id:\n            # Write ID back into the payload:\n            group[\"id\"] = group_id\n            return group[\"id\"]\n        else:\n            logger.info(\"Did not find an existing group with name -&gt; %s\", group_name)\n            return 0\n\n        # end method definition\n\n    def determine_user_id(self, user: dict) -&gt; int:\n        \"\"\"Determine the id of a user - either from payload or from OTCS\n           If the user is found in OTCS write back the ID into the payload.\n\n        Args:\n            user (dict): user payload element\n        Returns:\n            int: user ID\n        Side Effects:\n            the user items are modified by adding an \"id\" dict element that\n            includes the technical ID of the user in Extended ECM\n        \"\"\"\n\n        # Is the ID already known in payload? (if determined before)\n        if \"id\" in user:\n            return user[\"id\"]\n\n        if not \"name\" in user:\n            logger.error(\"User needs a login name to lookup the ID.\")\n            return 0\n        user_name = user[\"name\"]\n\n        response = self._otcs.get_user(name=user_name)\n        # We use the lookup method here as get_user() could deliver more\n        # then 1 result element (in edge cases):\n        user_id = self._otcs.lookup_result_value(\n            response=response, key=\"name\", value=user_name, return_key=\"id\"\n        )\n\n        # Have we found an exact match?\n        if user_id:\n            # Write ID back into the payload\n            user[\"id\"] = user_id\n            return user[\"id\"]\n        else:\n            logger.info(\"Did not find an existing user with name -&gt; %s\", user_name)\n            return 0\n\n        # end method definition\n\n    def determine_user_id_m365(self, user: dict) -&gt; int:\n        \"\"\"Determine the id of a M365 user - either from payload or from M365 via Graph API\n           If the user is found in M365 write back the M365 user ID into the payload.\n\n        Args:\n            user (dict): user payload element\n        Returns:\n            int: M365 user ID or 0 if the user is not found.\n        Side Effects:\n            the user items are modified by adding an \"m365_id\" dict element that\n            includes the technical ID of the user in Microsoft 365\n        \"\"\"\n\n        # is the payload already updated with the M365 user ID?\n        if \"m365_id\" in user:\n            return user[\"m365_id\"]\n\n        if not \"name\" in user:\n            logger.error(\"User needs a login name to lookup the M365 user ID.\")\n            return 0\n        user_name = user[\"name\"]\n\n        m365_user_name = user_name + \"@\" + self._m365.config()[\"domain\"]\n        existing_user = self._m365.get_user(m365_user_name)\n        if existing_user:\n            logger.info(\n                \"Found existing Microsoft 365 user -&gt; %s (%s) with ID -&gt; %s. Update m365_id in payload...\",\n                existing_user[\"displayName\"],\n                existing_user[\"userPrincipalName\"],\n                existing_user[\"id\"],\n            )\n            # write back the M365 user ID into the payload\n            user[\"m365_id\"] = existing_user[\"id\"]\n            return user[\"m365_id\"]\n        else:\n            logger.info(\"Did not find an existing M365 user with name -&gt; %s\", user_name)\n            return 0\n\n        # end method definition\n\n    def determine_workspace_id(self, workspace: dict) -&gt; int:\n        \"\"\"Determine the nodeID of a workspace - either from payload or from OTCS\n\n        Args:\n            workspace (dict): workspace payload element\n\n        Returns:\n            int: workspace Node ID\n        Side Effects:\n            the workspace items are modified by adding an \"nodeId\" dict element that\n            includes the node ID of the workspace in Extended ECM\n        \"\"\"\n\n        if \"nodeId\" in workspace:\n            return workspace[\"nodeId\"]\n\n        response = self._otcs.get_workspace_by_type_and_name(\n            type_name=workspace[\"type_name\"], name=workspace[\"name\"]\n        )\n        workspace_id = self._otcs.get_result_value(response, \"id\")\n        if workspace_id:\n            # Write nodeID back into the payload\n            workspace[\"nodeId\"] = workspace_id\n            return workspace_id\n        else:\n            logger.info(\n                \"Workspace of type -&gt; %s and name -&gt; %s does not yet exist.\",\n                workspace[\"type_name\"],\n                workspace[\"name\"],\n            )\n            return 0\n\n        # end method definition\n\n    def add_transport_extractions(self, extractions: list) -&gt; int:\n        \"\"\"_summary_\n\n        Args:\n            extractions (list): list of extractions from a single transport package\n\n        Returns:\n            int: number of extractions that have actually extracted data\n        \"\"\"\n\n        counter = 0\n        for extraction in extractions:\n            if extraction.get(\"enabled\", True) and \"data\" in extraction:\n                self._transport_extractions.append(extraction)\n                counter += 1\n        logger.info(\"Added -&gt; %s transport extractions\", str(counter))\n\n        return counter\n\n        # end method definition\n\n    def process_payload(self):\n        \"\"\"Main method to process a payload file.\n\n        Args:\n            None\n        Returns:\n            None\n        \"\"\"\n\n        if not self._payload_sections:\n            return None\n\n        for payload_section in self._payload_sections:\n            match payload_section[\"name\"]:\n                case \"webHooks\":\n                    self._log_header_callback(\"Process Web Hooks\")\n                    self.process_web_hooks(webhooks=self._webhooks)\n                case \"webHooksPost\":\n                    self._log_header_callback(\"Process Web Hooks (post)\")\n                    self.process_web_hooks(\n                        webhooks=self._webhooks_post, section_name=\"webHooksPost\"\n                    )\n                case \"partitions\":\n                    self._log_header_callback(\"Process OTDS Partitions\")\n                    self.process_partitions()\n                    self._log_header_callback(\"Assign OTCS Licenses to Partitions\")\n                    self.process_partition_licenses()\n                case \"oauthClients\":\n                    self._log_header_callback(\"Process OTDS OAuth Clients\")\n                    self.process_oauth_clients()\n                case \"authHandlers\":\n                    self._log_header_callback(\"Process OTDS Auth Handlers\")\n                    self.process_auth_handlers()\n                case \"trustedSites\":\n                    self._log_header_callback(\"Process OTDS Trusted Sites\")\n                    self.process_trusted_sites()\n                case \"systemAttributes\":\n                    self._log_header_callback(\"Process OTDS System Attributes\")\n                    self.process_system_attributes()\n                case \"groups\":\n                    self._log_header_callback(\"Process OTCS Groups\")\n                    self.process_groups()\n                    # Add all groups with ID the a lookup dict for placeholder replacements\n                    # in adminSetting. This also updates the payload with group IDs from OTCS\n                    # if the group already exists in Extended ECM. This is important especially\n                    # if the customizer pod is restarted / run multiple times:\n                    self.process_group_placeholders()\n                    if self._m365 and isinstance(self._m365, M365):\n                        self._log_header_callback(\"Cleanup existing MS Teams\")\n                        self.cleanup_all_teams_m365()\n                        self._log_header_callback(\"Process M365 Groups\")\n                        self.process_groups_m365()\n                case \"users\":\n                    self._log_header_callback(\"Process OTCS Users\")\n                    self.process_users()\n                    # Add all users with ID the a lookup dict for placeholder replacements\n                    # in adminSetting. This also updates the payload with user IDs from OTCS\n                    # if the user already exists in Extended ECM. This is important especially\n                    # if the cutomizer pod is restarted / run multiple times:\n                    self.process_user_placeholders()\n                    self._log_header_callback(\"Assign OTCS Licenses to Users\")\n                    self.process_user_licenses(\n                        resource_name=self._otcs.config()[\"resource\"],\n                        license_feature=self._otcs.config()[\"license\"],\n                        license_name=\"EXTENDED_ECM\",\n                        user_specific_payload_field=\"licenses\",\n                    )\n                    self._log_header_callback(\"Assign OTIV Licenses to Users\")\n\n                    if (\n                        isinstance(self._otiv, OTIV)  # can be None in 24.1 or newer\n                        and self._otiv.config()\n                        and self._otiv.config()[\"resource\"]\n                        and self._otiv.config()[\"license\"]\n                    ):\n                        self.process_user_licenses(\n                            resource_name=self._otiv.config()[\"resource\"],\n                            license_feature=self._otiv.config()[\"license\"],\n                            license_name=\"INTELLIGENT_VIEWING\",\n                            user_specific_payload_field=\"\",\n                            section_name=\"userLicensesViewing\",  # we need a specific name here for OTIV\n                        )\n                    else:\n                        logger.info(\"Processing of OTIV licenses is disabled.\")\n                    self._log_header_callback(\"Process User Settings\")\n                    self.process_user_settings()\n                    if self._m365 and isinstance(self._m365, M365):\n                        self._log_header_callback(\"Process M365 Users\")\n                        self.process_users_m365()\n                        # We need to do the MS Teams creation after the creation of\n                        # the M365 users as we require Group Owners to create teams\n                        self._log_header_callback(\"Process M365 Teams\")\n                        self.process_teams_m365()\n                case \"adminSettings\":\n                    self._log_header_callback(\"Process Administration Settings\")\n                    restart_required = self.process_admin_settings(\n                        admin_settings=self._admin_settings\n                    )\n                    if restart_required:\n                        logger.info(\n                            \"Admin Settings require a restart of OTCS services...\",\n                        )\n                        # Restart OTCS frontend and backend pods:\n                        self._otcs_restart_callback(self._otcs_backend)\n                case \"adminSettingsPost\":\n                    self._log_header_callback(\"Process Administration Settings (post)\")\n                    restart_required = self.process_admin_settings(\n                        self._admin_settings_post, \"adminSettingsPost\"\n                    )\n                    if restart_required:\n                        logger.info(\n                            \"Admin Settings (Post) require a restart of OTCS services...\",\n                        )\n                        # Restart OTCS frontend and backend pods:\n                        self._otcs_restart_callback(self._otcs_backend)\n                case \"execPodCommands\":\n                    self._log_header_callback(\"Process Pod Commands\")\n                    self.process_exec_pod_commands()\n                case \"csApplications\":\n                    self._log_header_callback(\"Process CS Apps (backend)\")\n                    self.process_cs_applications(\n                        self._otcs_backend, section_name=\"csApplicationsBackend\"\n                    )\n                    self._log_header_callback(\"Process CS Apps (frontend)\")\n                    self.process_cs_applications(\n                        self._otcs_frontend, section_name=\"csApplicationsFrontend\"\n                    )\n                case \"externalSystems\":\n                    self._log_header_callback(\"Process External System Connections\")\n                    self.process_external_systems()\n                case \"transportPackages\":\n                    self._log_header_callback(\"Process Transport Packages\")\n                    self.process_transport_packages(self._transport_packages)\n                    # Right after the transport that create the business object types\n                    # and the workspace types we extract them and put them into\n                    # generated payload lists:\n                    self._log_header_callback(\"Process Business Object Types\")\n                    self.process_business_object_types()\n                    self._log_header_callback(\"Process Workspace Types\")\n                    self.process_workspace_types()\n                    if self._m365 and isinstance(self._m365, M365):\n                        # Right after the transport that creates the top level folders\n                        # we can add the M365 Teams apps for Extended ECM as its own tab:\n                        self._log_header_callback(\"Process M365 Teams apps\")\n                        self.process_teams_m365_apps()\n                case \"contentTransportPackages\":\n                    self._log_header_callback(\"Process Content Transport Packages\")\n                    self.process_transport_packages(\n                        transport_packages=self._content_transport_packages,\n                        section_name=\"contentTransportPackages\",\n                    )\n                    # Process workspace permissions after content may have been added:\n                    self._log_header_callback(\"Process Workspace Permissions\")\n                    self.process_workspace_member_permissions()\n                case \"transportPackagesPost\":\n                    self._log_header_callback(\"Process Transport Packages (post)\")\n                    self.process_transport_packages(\n                        transport_packages=self._transport_packages_post,\n                        section_name=\"transportPackagesPost\",\n                    )\n                case \"workspaceTemplates\":\n                    # If a payload file (e.g. additional ones) does not have\n                    # transportPackages then it can happen that the\n                    # self._workspace_types is not yet initialized. As we need\n                    # this structure for workspaceTemnplates we initialize it here:\n                    if not self._business_object_types:\n                        self._log_header_callback(\"Process Business Object Types\")\n                        self.process_business_object_types()\n                    if not self._workspace_types:\n                        self._log_header_callback(\"Process Workspace Types\")\n                        self.process_workspace_types()\n\n                    self._log_header_callback(\n                        \"Process Workspace Templates (Template Role Assignments)\"\n                    )\n                    self.process_workspace_templates()\n                case \"workspaces\":\n                    # If a payload file (e.g. additional ones) does not have\n                    # transportPackages then it can happen that the self._business_object_types and\n                    # self._workspace_types are not yet initialized. As we need\n                    # these structures for workspaces we initialize it here:\n                    if not self._business_object_types:\n                        self._log_header_callback(\"Process Business Object Types\")\n                        self.process_business_object_types()\n                    if not self._workspace_types:\n                        self._log_header_callback(\"Process Workspace Types\")\n                        self.process_workspace_types()\n\n                    self._log_header_callback(\"Process Workspaces\")\n                    self.process_workspaces()\n                    self._log_header_callback(\"Process Workspace Relationships\")\n                    self.process_workspace_relationships()\n                    self._log_header_callback(\"Process Workspace Memberships\")\n                    self.process_workspace_members()\n\n                    # This has to run after the processing of webReports that are\n                    # used to enable Content Aviator in KINI database table:\n                    if self._aviator_enabled:\n                        self._log_header_callback(\"Process Workspace Aviators\")\n                        self.process_workspace_aviators()\n                case \"sapRFCs\":\n                    self._log_header_callback(\"Process SAP RFCs\")\n\n                    sap_external_system = {}\n                    if self._external_systems:\n                        sap_external_system = next(\n                            (\n                                item\n                                for item in self._external_systems\n                                if item.get(\"external_system_type\")\n                                and item[\"external_system_type\"] == \"SAP\"\n                            ),\n                            {},\n                        )\n                    if not sap_external_system:\n                        logger.warning(\n                            \"SAP RFC in payload but SAP external system is configured. RFCs will not be processed.\"\n                        )\n                    elif not sap_external_system.get(\"enabled\"):\n                        logger.warning(\n                            \"SAP RFC in payload but SAP external system is disabled. RFCs will not be processed.\"\n                        )\n                    # if the external system is not marked reachable we check it once more as this could be fooled\n                    # by customizer pod restarts\n                    elif not sap_external_system.get(\n                        \"reachable\"\n                    ) and not self.check_external_system(sap_external_system):\n                        logger.warning(\n                            \"SAP RFC in payload but SAP external system is not reachable. RFCs will not be processed.\"\n                        )\n                    else:\n                        if self._sap:\n                            self.process_sap_rfcs(self._sap)\n                            self._log_header_callback(\"Process SAP Users\")\n                            self.process_users_sap(self._sap)\n                        else:\n                            logger.error(\n                                \"SAP object is not yet initialized. Something is wrong with payload section ordering.\"\n                            )\n                case \"webReports\":\n                    self._log_header_callback(\"Process Web Reports\")\n                    restart_required = self.process_web_reports(\n                        web_reports=self._web_reports\n                    )\n                    if restart_required:\n                        logger.info(\n                            \"Web Reports require a restart of OTCS services...\",\n                        )\n                        # Restart OTCS frontend and backend pods:\n                        self._otcs_restart_callback(self._otcs_backend)\n                case \"webReportsPost\":\n                    self._log_header_callback(\"Process Web Reports (post)\")\n                    restart_required = self.process_web_reports(\n                        web_reports=self._web_reports_post,\n                        section_name=\"webReportsPost\",\n                    )\n                    if restart_required:\n                        logger.info(\n                            \"WebReports (Post) require a restart of OTCS services...\",\n                        )\n                        # Restart OTCS frontend and backend pods:\n                        self._otcs_restart_callback(self._otcs_backend)\n                case \"additionalGroupMemberships\":\n                    self._log_header_callback(\n                        \"Process additional group members for OTDS\"\n                    )\n                    self.process_additional_group_members()\n                case \"additionalAccessRoleMemberships\":\n                    self._log_header_callback(\n                        \"Process additional access role members for OTDS\"\n                    )\n                    self.process_additional_access_role_members()\n                case \"renamings\":\n                    self._log_header_callback(\"Process Node Renamings\")\n                    self.process_renamings()\n                case \"items\":\n                    self._log_header_callback(\"Process Items\")\n                    self.process_items(items=self._items)\n                case \"itemsPost\":\n                    self._log_header_callback(\"Process Items (post)\")\n                    self.process_items(items=self._items_post, section_name=\"itemsPost\")\n                case \"permissions\":\n                    self._log_header_callback(\"Process Permissions\")\n                    self.process_permissions(permissions=self._permissions)\n                case \"permissionsPost\":\n                    self._log_header_callback(\"Process Permissions (post)\")\n                    self.process_permissions(\n                        permissions=self._permissions_post,\n                        section_name=\"permissionsPost\",\n                    )\n                case \"assignments\":\n                    self._log_header_callback(\"Process Assignments\")\n                    self.process_assignments()\n                case \"securityClearances\":\n                    self._log_header_callback(\"Process Security Clearances\")\n                    self.process_security_clearances()\n                case \"supplementalMarkings\":\n                    self._log_header_callback(\"Process Supplemental Markings\")\n                    self.process_supplemental_markings()\n                case \"recordsManagementSettings\":\n                    self._log_header_callback(\"Process Records Management Settings\")\n                    self.process_records_management_settings()\n                case \"holds\":\n                    self._log_header_callback(\"Process Records Management Holds\")\n                    self.process_holds()\n                case \"documentGenerators\":\n                    # If a payload file (e.g. additional ones) does not have\n                    # transportPackages then it can happen that the\n                    # self._workspace_types is not yet initialized. As we need\n                    # this structure for documentGenerators we initialize it here:\n                    if not self._workspace_types:\n                        self._log_header_callback(\"Process Workspace Types\")\n                        self.process_workspace_types()\n\n                    self._log_header_callback(\"Process Document Generators\")\n                    self.process_document_generators()\n                case \"browserAutomations\":\n                    self._log_header_callback(\"Process Browser Automations\")\n                    self.process_browser_automations(\n                        browser_automations=self._browser_automations\n                    )\n                case \"browserAutomationsPost\":\n                    self._log_header_callback(\"Process Browser Automations (post)\")\n                    self.process_browser_automations(\n                        browser_automations=self._browser_automations_post,\n                        section_name=\"browserAutomationsPost\",\n                    )\n                case _:\n                    logger.error(\n                        \"Illegal payload section name -&gt; %s in payloadSections!\",\n                        payload_section[\"name\"],\n                    )\n            payload_section_restart = payload_section.get(\"restart\", False)\n            if payload_section_restart:\n                logger.info(\n                    \"Payload section -&gt; %s requests a restart of OTCS services...\",\n                    payload_section[\"name\"],\n                )\n                # Restart OTCS frontend and backend pods:\n                self._otcs_restart_callback(self._otcs_backend)\n            else:\n                logger.info(\n                    \"Payload section -&gt; %s does not require a restart of OTCS services\",\n                    payload_section[\"name\"],\n                )\n\n        if self._users:\n            self._log_header_callback(\"Process User Profile Photos\")\n            self.process_user_photos()\n            if self._m365 and isinstance(self._m365, M365):\n                self._log_header_callback(\"Process M365 User Profile Photos\")\n                self.process_user_photos_m365()\n            self._log_header_callback(\"Process User Favorites and Profiles\")\n            self.process_user_favorites_and_profiles()\n            self._log_header_callback(\"Process User Security\")\n            self.process_user_security()\n\n        # end method definition\n\n    def process_web_hooks(self, webhooks: list, section_name: str = \"webHooks\") -&gt; bool:\n        \"\"\"Process Web Hooks in payload and do HTTP requests.\n\n        Args:\n            webhooks (list): list of web hook payload settings\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not webhooks:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n\n        # WE LET THIS RUN EACH TIME!\n        #        if self.check_status_file(section_name):\n        #            return True\n\n        success: bool = True\n\n        for webhook in webhooks:\n            url = webhook.get(\"url\")\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            enabled = webhook.get(\"enabled\", True)\n\n            if not enabled and not url:\n                logger.info(\"Payload for Web Hook is disabled. Skipping...\")\n                continue\n            elif not url:\n                logger.info(\"Web Hook does not have a url. Skipping...\")\n                success = False\n                continue\n            elif not enabled:\n                logger.info(\"Payload for Web Hook -&gt; %s is disabled. Skipping...\", url)\n                continue\n\n            description = webhook.get(\"description\")\n\n            method = webhook.get(\"method\", \"POST\")\n\n            payload = webhook.get(\"payload\", {})\n\n            headers = webhook.get(\"headers\", {})\n\n            if description:\n                logger.info(\"Calling Web Hook -&gt; %s: %s (%s)\", method, url, description)\n            else:\n                logger.info(\"Calling Web Hook -&gt; %s: %s\", method, url)\n\n            response = self._http_object.http_request(\n                url=url,\n                method=method,\n                payload=payload,\n                headers=headers,\n                retries=webhook.get(\"retries\", 0),\n                wait_time=webhook.get(\"wait_time\", 0),\n            )\n            if not response or not response.ok:\n                success = False\n\n        self.write_status_file(success, section_name, webhooks)\n\n        return success\n\n        # end method definition\n\n    def process_partitions(self, section_name: str = \"partitions\") -&gt; bool:\n        \"\"\"Process OTDS partitions in payload and create them in OTDS.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections). This\n                                          name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._partitions:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for partition in self._partitions:\n            partition_name = partition.get(\"name\")\n            if not partition_name:\n                logger.error(\"Partition does not have a name. Skipping...\")\n                success = False\n                continue\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in partition and not partition[\"enabled\"]:\n                logger.info(\n                    \"Payload for Partition -&gt; %s is disabled. Skipping...\",\n                    partition_name,\n                )\n                continue\n\n            partition_description = partition.get(\"description\")\n\n            # Check if Partition does already exist\n            # (in an attempt to make the code idem-potent)\n            logger.info(\n                \"Check if OTDS partition -&gt; %s does already exist...\", partition_name\n            )\n            response = self._otds.get_partition(partition_name, show_error=False)\n            if response:\n                logger.info(\n                    \"Partition -&gt; %s does already exist. Skipping...\", partition_name\n                )\n                continue\n\n            # Only continue if Partition does not exist already\n            logger.info(\"Partition -&gt; %s does not exist. Creating...\", partition_name)\n\n            response = self._otds.add_partition(partition_name, partition_description)\n            if response:\n                logger.info(\"Added OTDS partition -&gt; %s\", partition_name)\n            else:\n                logger.error(\"Failed to add OTDS partition -&gt; %s\", partition_name)\n                success = False\n                continue\n\n            access_role = partition.get(\"access_role\")\n            if access_role:\n                response = self._otds.add_partition_to_access_role(\n                    access_role, partition_name\n                )\n                if response:\n                    logger.info(\n                        \"Added OTDS partition -&gt; %s to access role -&gt; %s\",\n                        partition_name,\n                        access_role,\n                    )\n                else:\n                    logger.error(\n                        \"Failed to add OTDS partition -&gt; %s to access role -&gt; %s\",\n                        partition_name,\n                        access_role,\n                    )\n                    success = False\n                    continue\n\n            # Partions may have an optional list of licenses in\n            # the payload. Assign the partition to all these licenses:\n            partition_specific_licenses = partition.get(\"licenses\")\n            if partition_specific_licenses:\n                # We assume these licenses are Extended ECM licenses!\n                otcs_resource_name = self._otcs.config()[\"resource\"]\n                otcs_resource = self._otds.get_resource(otcs_resource_name)\n                if not otcs_resource:\n                    logger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\n                    success = False\n                    continue\n                otcs_resource_id = otcs_resource[\"resourceID\"]\n                license_name = \"EXTENDED_ECM\"\n                for license_feature in partition_specific_licenses:\n                    assigned_license = self._otds.assign_partition_to_license(\n                        partition_name,\n                        otcs_resource_id,\n                        license_feature,\n                        license_name,\n                    )\n\n                    if not assigned_license:\n                        logger.error(\n                            \"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\n                            partition_name,\n                            license_feature,\n                            license_name,\n                        )\n                        success = False\n                    else:\n                        logger.info(\n                            \"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\n                            partition_name,\n                            license_feature,\n                            license_name,\n                        )\n\n        self.write_status_file(success, section_name, self._partitions)\n\n        return success\n\n        # end method definition\n\n    def process_partition_licenses(\n        self, section_name: str = \"partitionLicenses\"\n    ) -&gt; bool:\n        \"\"\"Process the licenses that should be assigned to OTDS partitions\n           (this includes existing partitions).\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._partitions:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for partition in self._partitions:\n            partition_name = partition.get(\"name\")\n            if not partition_name:\n                logger.error(\"Partition does not have a name. Skipping...\")\n                success = False\n                continue\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in partition and not partition[\"enabled\"]:\n                logger.info(\n                    \"Payload for Partition -&gt; %s is disabled. Skipping...\",\n                    partition_name,\n                )\n                continue\n\n            response = self._otds.get_partition(partition_name, show_error=True)\n            if not response:\n                logger.error(\n                    \"Partition -&gt; %s does not exist. Skipping...\", partition_name\n                )\n                success = False\n                continue\n\n            # Partions may have an optional list of licenses in\n            # the payload. Assign the partition to all these licenses:\n            partition_specific_licenses = partition.get(\"licenses\")\n            if partition_specific_licenses:\n                # We assume these licenses are Extended ECM licenses!\n                otcs_resource_name = self._otcs.config()[\"resource\"]\n                otcs_resource = self._otds.get_resource(otcs_resource_name)\n                if not otcs_resource:\n                    logger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\n                    success = False\n                    continue\n                otcs_resource_id = otcs_resource[\"resourceID\"]\n                license_name = \"EXTENDED_ECM\"\n                for license_feature in partition_specific_licenses:\n                    if self._otds.is_partition_licensed(\n                        partition_name=partition_name,\n                        resource_id=otcs_resource_id,\n                        license_feature=license_feature,\n                        license_name=license_name,\n                    ):\n                        logger.info(\n                            \"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\n                            partition_name,\n                            license_name,\n                            license_feature,\n                        )\n                        continue\n                    assigned_license = self._otds.assign_partition_to_license(\n                        partition_name,\n                        otcs_resource_id,\n                        license_feature,\n                        license_name,\n                    )\n\n                    if not assigned_license:\n                        logger.error(\n                            \"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\n                            partition_name,\n                            license_feature,\n                            license_name,\n                        )\n                        success = False\n                    else:\n                        logger.info(\n                            \"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\n                            partition_name,\n                            license_feature,\n                            license_name,\n                        )\n\n        self.write_status_file(success, section_name, self._partitions)\n\n        return success\n\n        # end method definition\n\n    def process_oauth_clients(self, section_name: str = \"oauthClients\") -&gt; bool:\n        \"\"\"Process OTDS OAuth clients in payload and create them in OTDS.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._oauth_clients:\n            logger.info(\"Payload section -&gt; % is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for oauth_client in self._oauth_clients:\n            client_name = oauth_client.get(\"name\")\n            if not client_name:\n                logger.error(\"OAuth client does not have a name. Skipping...\")\n                success = False\n                continue\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in oauth_client and not oauth_client[\"enabled\"]:\n                logger.info(\n                    \"Payload for OAuthClient -&gt; %s is disabled. Skipping...\",\n                    client_name,\n                )\n                continue\n\n            client_description = oauth_client.get(\"description\")\n            client_confidential = oauth_client.get(\"confidential\")\n            client_partition = oauth_client.get(\"partition\")\n            if client_partition == \"Global\":\n                client_partition = []\n            client_redirect_urls = oauth_client.get(\"redirect_urls\")\n            client_permission_scopes = oauth_client.get(\"permission_scopes\")\n            client_default_scopes = oauth_client.get(\"default_scopes\")\n            client_allow_impersonation = oauth_client.get(\"allow_impersonation\")\n            client_secret = oauth_client.get(\"secret\", \"\")\n\n            # Check if OAuth client does already exist\n            # (in an attempt to make the code idem-potent)\n            logger.info(\n                \"Check if OTDS OAuth Client -&gt; %s does already exist...\", client_name\n            )\n            response = self._otds.get_oauth_client(client_name, show_error=False)\n            if response:\n                logger.info(\n                    \"OAuth Client -&gt; %s does already exist. Skipping...\", client_name\n                )\n                continue\n            else:\n                logger.info(\n                    \"OAuth Client -&gt; %s does not exist. Creating...\", client_name\n                )\n\n            response = self._otds.add_oauth_client(\n                client_id=client_name,\n                description=client_description,\n                redirect_urls=client_redirect_urls,\n                allow_impersonation=client_allow_impersonation,\n                confidential=client_confidential,\n                auth_scopes=client_partition,\n                allowed_scopes=client_permission_scopes,\n                default_scopes=client_default_scopes,\n                secret=client_secret,\n            )\n            if response:\n                logger.info(\"Added OTDS OAuth client -&gt; %s\", client_name)\n            else:\n                logger.error(\"Failed to add OTDS OAuth client -&gt; %s\", client_name)\n                success = False\n                continue\n\n            # in case the secret has not been provided in the payload we retrieve\n            # the automatically created secret:\n            client_secret = response.get(\"secret\")\n            if not client_secret:\n                logger.error(\"OAuth client -&gt; %s does not have a secret!\", client_name)\n                continue\n\n            client_description += \" Client Secret: \" + str(client_secret)\n            response = self._otds.update_oauth_client(\n                client_name, {\"description\": client_description}\n            )\n            # Write the secret back into the payload\n            oauth_client[\"secret\"] = client_secret\n\n        self.write_status_file(success, section_name, self._oauth_clients)\n\n        return success\n\n    #        self._otds.add_oauth_clients_to_access_role()\n\n    # end method definition\n\n    def process_auth_handlers(self, section_name: str = \"authHandlers\") -&gt; bool:\n        \"\"\"Process OTDS authorization handlers in payload and create them in OTDS.\n           An authorization handler defined the connection to an Identity Provider (IdP).\n\n            The payload section is a list of dicts with these items:\n            {\n                enabled: True or False to enable or disable the payload item\n                name: Name of the authorization handler. This is shown in the first\n                      column of the Auth Handler list in OTDS.\n                description: Description of the handler. This is shown in the second\n                             column of the Auth Handler\n                type: type of the handler. Possible values are SALM, SAP, OAUTH\n                priority: a numeric value to order different handlers in OTDS by priority\n                active_by_default: Whether to activate this handler for any request to the\n                                   OTDS login page. If True, any login request to the OTDS\n                                   login page will be redirected to the IdP. If false, the\n                                   user has to select the provider on the login page.\n                provider_name: The name of the identity provider. This should be a single word\n                               since it will be part of the metadata URL. This is what is\n                               shown as a button on the OTDS login page.\n                auth_principal_attributes: Authentication principal attributes (list)\n                nameid_format: Specifies which NameID format supported by the identity provider\n                               contains the desired user identifier. The value in this identifier\n                               must correspond to the value of the user attribute specified for the\n                               authentication principal attribute.\n                saml_url: Required for SAML Authentication Handler. The URL for the IdP's federation metadata.\n                otds_sp_endpoint: Used for SAML Authentication Handler. Specifies the service provider URL that will\n                                  be used to identify OTDS to the identity provider.\n                certificate_file: Required for SAP Authentication Handler (SAPSSOEXT).\n                                  Fully qualified file name (with path) to the certificate file (URI)\n                certificate_password: Required for SAP Authentication Handler (SAPSSOEXT).\n                                      Password of the certificate file.\n                client_id: Client ID. Required for OAUTH authentication handler.\n                client_secret: Client Secret. Required for OAUTH authentication handler.\n                authorization_endpoint: Required for OAUTH authentication handler.\n                                        The URL to redirect the browser to for authentication.\n                                        It is used to retrieve the authorization code or an OIDC id_token.\n                token_endpoint: Used for OAUTH authentication handler. The URL from which to retrieve the access token.\n                                Not strictly required with OpenID Connect if using the implicit flow.\n                scope_string: Used for OAUTH authentication handler. Space delimited scope values to send.\n                              Include 'openid' to use OpenID Connect.\n            }\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._auth_handlers:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for auth_handler in self._auth_handlers:\n            handler_name = auth_handler.get(\"name\")\n\n            if not handler_name:\n                logger.error(\"Auth handler does not have a name. Skipping...\")\n                success = False\n                continue\n\n            # Check if Auth Handler does already exist (e.g. after a restart of\n            # the customizer pod):\n            if self._otds.get_auth_handler(handler_name, show_error=False):\n                logger.info(\"Auth handler -&gt; %s does already exist. Skipping...\")\n                continue\n\n            handler_description = auth_handler.get(\"description\")\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in auth_handler and not auth_handler[\"enabled\"]:\n                logger.info(\n                    \"Payload for OTDS Authorization Handler -&gt; %s is disabled. Skipping...\",\n                    handler_name,\n                )\n                continue\n\n            handler_scope = auth_handler.get(\"scope\")\n            if not handler_scope:\n                # Make sure to pass None also if scope is empty string\n                handler_scope = None\n\n            handler_type = auth_handler.get(\"type\")\n            if not handler_type:\n                logger.error(\n                    \"OTDS Authorization handler does not have a type. Skipping...\"\n                )\n                success = False\n                continue\n\n            priority = auth_handler.get(\"priority\")\n            active_by_default = auth_handler.get(\"active_by_default\")\n            if not active_by_default:\n                active_by_default = False\n\n            match handler_type:\n                case \"SAML\":\n                    provider_name = auth_handler.get(\"provider_name\")\n                    if not provider_name:\n                        logger.error(\n                            \"SAML Authorization handler needs a provider. Skipping...\"\n                        )\n                        success = False\n                        continue\n                    saml_url = auth_handler.get(\"saml_url\")\n                    if not saml_url:\n                        logger.error(\n                            \"SAML Authorization handler needs a SAML URL. Skipping...\"\n                        )\n                        success = False\n                        continue\n                    otds_sp_endpoint = auth_handler.get(\"otds_sp_endpoint\")\n                    if not otds_sp_endpoint:\n                        logger.error(\n                            \"SAML Authorization handler needs a OTDS SP Endpoint. Skipping...\"\n                        )\n                        success = False\n                        continue\n                    auth_principal_attributes = auth_handler.get(\n                        \"auth_principal_attributes\"\n                    )\n                    nameid_format = auth_handler.get(\"nameid_format\")\n                    response = self._otds.add_auth_handler_saml(\n                        name=handler_name,\n                        description=handler_description,\n                        scope=handler_scope,\n                        provider_name=provider_name,\n                        saml_url=saml_url,\n                        otds_sp_endpoint=otds_sp_endpoint,\n                        priority=priority,\n                        active_by_default=active_by_default,\n                        auth_principal_attributes=auth_principal_attributes,\n                        nameid_format=nameid_format,\n                    )\n                case \"SAP\":\n                    certificate_file = auth_handler.get(\"certificate_file\")\n                    if not certificate_file:\n                        logger.error(\n                            \"SAP Authorization handler -&gt; %s (%s) requires a certificate file name. Skipping...\",\n                            handler_name,\n                            handler_type,\n                        )\n                        success = False\n                        continue\n                    certificate_password = auth_handler.get(\"certificate_password\")\n                    if not certificate_password:\n                        # This is not an error - we canhave this key with empty string!\n                        logger.info(\n                            \"SAP Authorization handler -&gt; %s (%s) does not have a certificate password - this can be OK.\",\n                            handler_name,\n                            handler_type,\n                        )\n                    response = self._otds.add_auth_handler_sap(\n                        name=handler_name,\n                        description=handler_description,\n                        scope=handler_scope,\n                        certificate_file=certificate_file,\n                        certificate_password=certificate_password,\n                        priority=priority,\n                    )\n                case \"OAUTH\":\n                    provider_name = auth_handler.get(\"provider_name\")\n                    if not provider_name:\n                        logger.error(\n                            \"OAUTH Authorization handler -&gt; %s (%s) requires a provider name. Skipping...\",\n                            handler_name,\n                            handler_type,\n                        )\n                        success = False\n                        continue\n                    client_id = auth_handler.get(\"client_id\")\n                    if not client_id:\n                        logger.error(\n                            \"OAUTH Authorization handler -&gt; %s (%s) requires a client ID. Skipping...\",\n                            handler_name,\n                            handler_type,\n                        )\n                        success = False\n                        continue\n                    client_secret = auth_handler.get(\"client_secret\")\n                    if not client_secret:\n                        logger.error(\n                            \"OAUTH Authorization handler -&gt; %s (%s) requires a client secret. Skipping...\",\n                            handler_name,\n                            handler_type,\n                        )\n                        success = False\n                        continue\n                    authorization_endpoint = auth_handler.get(\"authorization_endpoint\")\n                    if not authorization_endpoint:\n                        logger.error(\n                            \"OAUTH Authorization handler -&gt; %s (%s) requires a authorization endpoint. Skipping...\",\n                            handler_name,\n                            handler_type,\n                        )\n                        success = False\n                        continue\n                    token_endpoint = auth_handler.get(\"token_endpoint\")\n                    if not token_endpoint:\n                        logger.warning(\n                            \"OAUTH Authorization handler -&gt; %s (%s) does not have a token endpoint.\",\n                            handler_name,\n                            handler_type,\n                        )\n                    scope_string = auth_handler.get(\"scope_string\")\n                    response = self._otds.add_auth_handler_oauth(\n                        name=handler_name,\n                        description=handler_description,\n                        scope=handler_scope,\n                        provider_name=provider_name,\n                        client_id=client_id,\n                        client_secret=client_secret,\n                        priority=priority,\n                        active_by_default=active_by_default,\n                        authorization_endpoint=authorization_endpoint,\n                        token_endpoint=token_endpoint,\n                        scope_string=scope_string,\n                    )\n                case _:\n                    logger.error(\n                        \"Unsupported authorization handler type -&gt; %s\", handler_type\n                    )\n                    return False\n\n            if response:\n                logger.info(\n                    \"Successfully added OTDS authorization handler -&gt; %s (%s)\",\n                    handler_name,\n                    handler_type,\n                )\n            else:\n                logger.error(\n                    \"Failed to add OTDS authorization handler -&gt; %s (%s)\",\n                    handler_name,\n                    handler_type,\n                )\n                success = False\n\n        self.write_status_file(success, section_name, self._auth_handlers)\n\n        return success\n\n        # end method definition\n\n    def process_trusted_sites(self, section_name: str = \"trustedSites\") -&gt; bool:\n        \"\"\"Process OTDS trusted sites in payload and create them in OTDS.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._trusted_sites:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for trusted_site in self._trusted_sites:\n            # old payload may still have trusted sites as list of string\n            # we changed also the trusted sites to dict with 23.3\n            # We want to be backwards compatible so we handle both cases:\n            if isinstance(trusted_site, dict):\n                url = trusted_site.get(\"url\")\n            elif isinstance(trusted_site, str):\n                url = trusted_site\n            if not url:\n                logger.error(\"OTDS Trusted site does not have a URL. Skipping...\")\n                success = False\n                continue\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if (\n                isinstance(trusted_site, dict)\n                and \"enabled\" in trusted_site\n                and not trusted_site[\"enabled\"]\n            ):\n                logger.info(\n                    \"Payload for OTDS Trusted Site -&gt; %s is disabled. Skipping...\",\n                    url,\n                )\n                continue\n\n            response = self._otds.add_trusted_site(url)\n            if response:\n                logger.info(\"Added OTDS trusted site -&gt; %s\", trusted_site)\n            else:\n                logger.error(\"Failed to add trusted site -&gt; %s\", trusted_site)\n                success = False\n\n        self.write_status_file(success, section_name, self._trusted_sites)\n\n        return success\n\n        # end method definition\n\n    def process_system_attributes(self, section_name: str = \"systemAttributes\") -&gt; bool:\n        \"\"\"Process OTDS system attributes in payload and create them in OTDS.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._system_attributes:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for system_attribute in self._system_attributes:\n            # Check if there's a matching formal parameter defined on the Web Report node:\n            if not system_attribute.get(\"name\"):\n                logger.error(\"OTDS System Attribute needs a name. Skipping...\")\n                success = False\n                continue\n            attribute_name = system_attribute[\"name\"]\n\n            if \"enabled\" in system_attribute and not system_attribute[\"enabled\"]:\n                logger.info(\n                    \"Payload for OTDS System Attribute -&gt; %s is disabled. Skipping...\",\n                    attribute_name,\n                )\n                continue\n\n            if not system_attribute.get(\"value\"):\n                logger.error(\"OTDS System Attribute needs a value. Skipping...\")\n                continue\n\n            attribute_value = system_attribute[\"value\"]\n            attribute_description = system_attribute.get(\"description\")\n            response = self._otds.add_system_attribute(\n                attribute_name, attribute_value, attribute_description\n            )\n            if response:\n                logger.info(\n                    \"Added OTDS system attribute -&gt; %s with value -&gt; %s\",\n                    attribute_name,\n                    attribute_value,\n                )\n            else:\n                logger.error(\n                    \"Failed to add OTDS system attribute -&gt; %s with value -&gt; %s\",\n                    attribute_name,\n                    attribute_value,\n                )\n                success = False\n\n        self.write_status_file(success, section_name, self._system_attributes)\n\n        return success\n\n        # end method definition\n\n    def process_group_placeholders(self):\n        \"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n        with the actual ID of the Extended ECM group. For this we prepare a lookup dict.\n        The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n        OTDS resource IDs (see main.py)\n        \"\"\"\n\n        for group in self._groups:\n            if not \"name\" in group:\n                logger.error(\n                    \"Group needs a name for placeholder definition. Skipping...\"\n                )\n                continue\n            group_name = group[\"name\"]\n            # Check if group has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in group and not group[\"enabled\"]:\n                logger.info(\n                    \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n                )\n                continue\n\n            # Now we determine the ID. Either it is in the payload section from\n            # the current customizer run or we try to look it up in the system.\n            # The latter case may happen if the customizer pod got restarted.\n            group_id = self.determine_group_id(group)\n            if not group_id:\n                logger.warning(\n                    \"Group needs an ID for placeholder definition. Skipping...\"\n                )\n                continue\n\n            # Add Group with its ID to the dict self._placeholder_values:\n            self._placeholder_values[\n                \"OTCS_GROUP_ID_\"\n                + group_name.upper().replace(\" &amp; \", \"_\").replace(\" \", \"_\")\n            ] = str(group_id)\n\n        logger.debug(\n            \"Placeholder values after group processing = %s\", self._placeholder_values\n        )\n\n        # end method definition\n\n    def process_user_placeholders(self):\n        \"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n        with the actual ID of the Extended ECM user. For this we prepare a lookup dict.\n        The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n        OTDS resource IDs (see customizer.py)\n        \"\"\"\n\n        for user in self._users:\n            if not \"name\" in user:\n                logger.error(\n                    \"User needs a name for placeholder definition. Skipping...\"\n                )\n                continue\n            user_name = user[\"name\"]\n            # Check if user has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            # Now we determine the ID. Either it is in the payload section from\n            # the current customizer run or we try to look it up in the system.\n            # The latter case may happen if the customizer pod got restarted.\n            user_id = self.determine_user_id(user)\n            if not user_id:\n                logger.warning(\n                    \"User needs an ID for placeholder definition. Skipping...\"\n                )\n                continue\n\n            # Add user with its ID to the dict self._placeholder_values:\n            self._placeholder_values[\"OTCS_USER_ID_%s\", user_name.upper()] = str(\n                user_id\n            )\n\n        logger.debug(\n            \"Placeholder values after user processing = %s\", self._placeholder_values\n        )\n\n        # end method definition\n\n    def process_groups(self, section_name: str = \"groups\") -&gt; bool:\n        \"\"\"Process groups in payload and create them in Extended ECM.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            the group items are modified by adding an \"id\" dict element that\n            includes the technical ID of the group in Extended ECM\n        \"\"\"\n\n        if not self._groups:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # First run through groups: create all groups in payload\n        # and store the IDs of the created groups:\n        for group in self._groups:\n            if not \"name\" in group:\n                logger.error(\"Group needs a name. Skipping...\")\n                success = False\n                continue\n            group_name = group[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in group and not group[\"enabled\"]:\n                logger.info(\n                    \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n                )\n                continue\n\n            # Check if the group does already exist (e.g. if job is restarted)\n            # as this is a pattern search it could return multiple groups:\n            group_id = self.determine_group_id(group)\n            if group_id:\n                logger.info(\n                    \"Found existing group -&gt; %s (%s). Skipping to next group...\",\n                    group_name,\n                    group_id,\n                )\n                continue\n\n            logger.info(\"Did not find an existing group - creating a new group...\")\n\n            # Now we know it is a new group...\n            new_group = self._otcs.add_group(group_name)\n            if new_group:\n                new_group_id = self._otcs.get_result_value(new_group, \"id\")\n                logger.debug(\"New group -&gt; %s\", new_group)\n                group[\"id\"] = new_group_id\n            else:\n                logger.error(\"Failed to create group -&gt; %s\", group_name)\n                success = False\n                continue\n\n        logger.debug(\"Groups = %s\", self._groups)\n\n        # Second run through groups: create all group memberships\n        # (nested groups) based on the IDs created in first run:\n        for group in self._groups:\n            if not \"id\" in group:\n                logger.error(\"Group -&gt; %s does not have an ID.\", group[\"name\"])\n                success = False\n                continue\n            parent_group_names = group[\"parent_groups\"]\n            for parent_group_name in parent_group_names:\n                # First, try to find parent group in payload by parent group name:\n                parent_group = next(\n                    (\n                        item\n                        for item in self._groups\n                        if item[\"name\"] == parent_group_name\n                    ),\n                    None,\n                )\n                if parent_group is None:\n                    # If this didn't work, try to get the parent group from OTCS. This covers\n                    # cases where the parent group is system generated or part\n                    # of a former payload processing run:\n                    parent_group = self._otcs.get_group(parent_group_name)\n                    parent_group_id = self._otcs.get_result_value(parent_group, \"id\")\n                    if not parent_group_id:\n                        logger.error(\n                            \"Parent Group -&gt; %s not found. Skipping...\",\n                            parent_group_name,\n                        )\n                        success = False\n                        continue\n                elif not \"id\" in parent_group:\n                    logger.error(\n                        \"Parent Group -&gt; %s does not have an ID. Cannot establish group nesting. Skipping...\",\n                        parent_group[\"name\"],\n                    )\n                    success = False\n                    continue\n                else:  # we can read the ID from the\n                    parent_group_id = parent_group[\"id\"]\n\n                # retrieve all members of the parent group (1 = get only groups)\n                # to check if the current group is already a member in the parent group:\n                members = self._otcs.get_group_members(parent_group_id, 1)\n                if self._otcs.exist_result_item(members, \"id\", group[\"id\"]):\n                    logger.info(\n                        \"Group -&gt; %s (%s) is already a member of parent group -&gt; %s (%s). Skipping to next parent group...\",\n                        group[\"name\"],\n                        group[\"id\"],\n                        parent_group_name,\n                        parent_group_id,\n                    )\n                else:\n                    logger.info(\n                        \"Add group -&gt; %s (%s) to parent group -&gt; %s (%s)\",\n                        group[\"name\"],\n                        group[\"id\"],\n                        parent_group_name,\n                        parent_group_id,\n                    )\n                    self._otcs.add_group_member(group[\"id\"], parent_group_id)\n\n        self.write_status_file(success, section_name, self._groups)\n\n        return success\n\n        # end method definition\n\n    def process_groups_m365(self, section_name: str = \"groupsM365\") -&gt; bool:\n        \"\"\"Process groups in payload and create them in Microsoft 365.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n        if not isinstance(self._m365, M365):\n            logger.error(\n                \"Office 365 connection not setup properly. Skipping payload section %s...\",\n                section_name,\n            )\n            return False\n\n        if not self._groups:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # First run through groups: create all groups in payload\n        # and store the IDs of the created groups:\n        for group in self._groups:\n            if not \"name\" in group:\n                logger.error(\"Group needs a name. Skipping...\")\n                success = False\n                continue\n            group_name = group[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in group and not group[\"enabled\"]:\n                logger.info(\n                    \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n                )\n                continue\n            if not \"enable_o365\" in group or not group[\"enable_o365\"]:\n                logger.info(\n                    \"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\n                    group_name,\n                )\n                continue\n\n            # Check if the group does already exist (e.g. if job is restarted)\n            # as this is a pattern search it could return multiple groups:\n            existing_groups = self._m365.get_group(group_name)\n\n            if existing_groups and existing_groups[\"value\"]:\n                logger.debug(\n                    \"Found existing Microsoft 365 groups -&gt; %s\",\n                    existing_groups[\"value\"],\n                )\n                # Get list of all matching groups:\n                existing_groups_list = existing_groups[\"value\"]\n                # Find the group with the exact match of the name:\n                existing_group = next(\n                    (\n                        item\n                        for item in existing_groups_list\n                        if item[\"displayName\"] == group_name\n                    ),\n                    None,\n                )\n                # Have we found an exact match?\n                if existing_group is not None:\n                    logger.info(\n                        \"Found existing Microsoft 365 group -&gt; %s (%s) - skip creation of group...\",\n                        existing_group[\"displayName\"],\n                        existing_group[\"id\"],\n                    )\n                    # Write M365 group ID back into the payload (for the success file)\n                    group[\"m365_id\"] = existing_group[\"id\"]\n                    continue\n                logger.info(\n                    \"Did not find an exact match for the group - creating a new Microsoft 365 group...\"\n                )\n            else:\n                logger.info(\n                    \"Did not find any matching group - creating a new Microsoft 365 group...\"\n                )\n\n            # Now we know it is a new group...\n            new_group = self._m365.add_group(group_name)\n            if new_group is not None:\n                # Store the Microsoft 365 group ID in payload:\n                group[\"m365_id\"] = new_group[\"id\"]\n                logger.info(\n                    \"New Microsoft 365 group -&gt; %s with ID -&gt; %s has been created\",\n                    group_name,\n                    group[\"m365_id\"],\n                )\n            else:\n                success = False\n\n        self.write_status_file(success, section_name, self._groups)\n\n        return success\n\n        # end method definition\n\n    def process_users(self, section_name: str = \"users\") -&gt; bool:\n        \"\"\"Process users in payload and create them in Extended ECM.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            the user items are modified by adding an \"id\" dict element that\n            includes the technical ID of the user in Extended ECM\n        \"\"\"\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        #        if self.check_status_file(section_name):\n        #            return True\n\n        success: bool = True\n\n        # Add all users in payload and establish membership in\n        # specified groups:\n        for user in self._users:\n            # Sanity checks:\n            if not \"name\" in user:\n                logger.error(\"User is missing a login. Skipping to next user...\")\n                success = False\n                continue\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            # Sanity checks:\n            if (\n                not \"password\" in user\n                or user[\"password\"] is None\n                or user[\"password\"] == \"\"\n            ):\n                logger.info(\n                    \"User -&gt; %s no password defined in payload, generating random password...\",\n                    user_name,\n                )\n                user[\"password\"] = self.generate_password(\n                    length=10, use_special_chars=True\n                )\n\n                description_attribue = {\n                    \"name\": \"description\",\n                    \"value\": \"initial password: \" + user[\"password\"],\n                }\n\n                try:\n                    user[\"extra_attributes\"].append(description_attribue)\n                except KeyError:\n                    user[\"extra_attributes\"] = [description_attribue]\n\n            # Sanity checks:\n            if not \"base_group\" in user:\n                logger.warning(\n                    \"User -&gt; %s is missing a base group - setting to default group\",\n                    user_name,\n                )\n                user[\"base_group\"] = \"DefaultGroup\"\n\n            # Check if the user does already exist (e.g. if job is restarted)\n            # determine_user_id() also writes back the user ID into the payload\n            # if it has gathered it from OTCS.\n            user_id = self.determine_user_id(user)\n            if user_id:\n                logger.info(\n                    \"Found existing user -&gt; %s (%s). Skipping to next user...\",\n                    user_name,\n                    user_id,\n                )\n                continue\n            logger.info(\"Did not find an existing user - creating a new user...\")\n\n            # Find the base group of the user. Assume 'Default Group' (= 1001) if not found:\n            base_group = next(\n                (\n                    item[\"id\"]\n                    for item in self._groups\n                    if item[\"name\"] == user[\"base_group\"] and item.get(\"id\")\n                ),\n                1001,\n            )\n\n            # Now we know it is a new user...\n            new_user = self._otcs.add_user(\n                name=user_name,\n                password=user[\"password\"],\n                first_name=user.get(\"firstname\", \"\"),  # be careful - can be empty\n                last_name=user.get(\"lastname\", \"\"),  # be careful - can be empty\n                email=user.get(\"email\", \"\"),  # be careful - can be empty\n                title=user.get(\"title\", \"\"),  # be careful - can be empty\n                base_group=base_group,\n                privileges=user.get(\"privileges\", [\"Login\", \"Public Access\"]),\n            )\n\n            # Process group memberships of new user:\n            if new_user is not None:\n                new_user_id = self._otcs.get_result_value(new_user, \"id\")\n                logger.info(\n                    \"New user -&gt; %s with ID -&gt; %s has been created\",\n                    user_name,\n                    new_user_id,\n                )\n                # Write back user ID into payload\n                user[\"id\"] = new_user_id\n\n                user_groups = user[\"groups\"]  # list of groups the user is in\n                for user_group in user_groups:\n                    # Try to find the group dictionary item in the payload\n                    # for user group name:\n                    group = next(\n                        (item for item in self._groups if item[\"name\"] == user_group),\n                        None,\n                    )\n                    if group:\n                        group_id = group.get(\"id\")  # Careful ID may not exist\n                        group_name = group[\"name\"]\n                    else:\n                        # if group is not in payload try to find group in OTCS\n                        # in case it is a pre-existing group:\n                        group = self._otcs.get_group(user_group)\n                        group_id = self._otcs.get_result_value(group, \"id\")\n                        if group_id is None:\n                            logger.error(\n                                \"Group -&gt; %s not found. Skipping...\", user_group\n                            )\n                            success = False\n                            continue\n                        group_name = self._otcs.get_result_value(group, \"name\")\n\n                    if group_id is None:\n                        logger.error(\n                            \"Group -&gt; %s does not have an ID. Cannot add user -&gt; %s to this group. Skipping...\",\n                            group_name,\n                            user[\"name\"],\n                        )\n                        success = False\n                        continue\n\n                    logger.info(\n                        \"Add user -&gt; %s (%s) to group -&gt; %s (%s)\",\n                        user[\"name\"],\n                        user[\"id\"],\n                        group_name,\n                        group_id,\n                    )\n                    response = self._otcs.add_group_member(user[\"id\"], group_id)\n                    if not response:\n                        success = False\n                # for some unclear reason the user is not added to its base group in OTDS\n                # so we do this explicitly:\n                response = self._otds.add_user_to_group(\n                    user[\"name\"], user[\"base_group\"]\n                )\n                if not response:\n                    success = False\n\n                # Extra OTDS attributes for the user can be provided in \"extra_attributes\"\n                # as part of the user payload.\n                if \"extra_attributes\" in user:\n                    extra_attributes = user[\"extra_attributes\"]\n                    for extra_attribute in extra_attributes:\n                        attribute_name = extra_attribute.get(\"name\")\n                        attribute_value = extra_attribute.get(\"value\")\n                        if not attribute_name or not attribute_value:\n                            logger.error(\n                                \"User attribute is missing a name or value. Skipping...\"\n                            )\n                            success = False\n                            continue\n                        logger.info(\n                            \"Set user attribute -&gt; %s to -&gt; %s\",\n                            attribute_name,\n                            attribute_value,\n                        )\n                        user_partition = self._otcs.config()[\"partition\"]\n                        if not user_partition:\n                            logger.error(\"User partition not found!\")\n                            success = False\n                            continue\n                        self._otds.update_user(\n                            user_partition,\n                            user[\"name\"],\n                            attribute_name,\n                            attribute_value,\n                        )\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_users_sap(\n        self, sap_object: SAP, section_name: str = \"usersSAP\"\n    ) -&gt; bool:\n        \"\"\"Process users in payload and sync them with SAP (passwords for now).\n\n        Args:\n            sap_object (SAP): SAP object\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            the user items are modified by adding an \"id\" dict element that\n            includes the technical ID of the user in Extended ECM\n        \"\"\"\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        rfc_name = \"ZFM_TERRA_RFC_CHNG_USR_PW\"\n        rfc_description = \"RFC to update the SAP user password\"\n        rfc_call_options = ()\n\n        # Add all users in payload and establish membership in\n        # specified groups:\n        for user in self._users:\n            # Sanity checks:\n            if not \"name\" in user:\n                logger.error(\"User is missing a login. Skipping to next user...\")\n                success = False\n                continue\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            # Check if the user is enabled for SAP:\n            if not \"enable_sap\" in user or not user[\"enable_sap\"]:\n                logger.info(\"User -&gt; %s is not enabled for SAP. Skipping...\", user_name)\n                continue\n\n            # Sanity checks:\n            if not \"password\" in user:\n                logger.error(\n                    \"User -&gt; %s is missing a password. Cannot sync with SAP. Skipping to next user...\",\n                    user_name,\n                )\n                success = False\n                continue\n            user_password = user[\"password\"]\n\n            rfc_params = {\n                \"USERNAME\": user_name,\n                \"PASSWORD\": user_password,\n            }\n\n            logger.info(\n                \"Updating password of user -&gt; %s in SAP. Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\n                user_name,\n                rfc_name,\n                rfc_description,\n                rfc_params,\n            )\n\n            result = sap_object.call(rfc_name, rfc_call_options, rfc_params)\n            if result is None:\n                logger.error(\n                    \"Failed to call SAP RFC -&gt; %s to update password of user -&gt; %s\",\n                    rfc_name,\n                    user_name,\n                )\n                success = False\n            elif result.get(\"RESULT\") != \"OK\":\n                logger.error(\n                    \"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\n                    rfc_name,\n                    str(result.get(\"FAILED\")),\n                    str(result),\n                )\n                success = False\n                # Save result for status file content\n                user[\"sap_sync_result\"] = result\n            else:\n                logger.info(\n                    \"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n                )\n                # Save result for status file content\n                user[\"sap_sync_result\"] = result\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_users_m365(self, section_name: str = \"usersM365\") -&gt; bool:\n        \"\"\"Process users in payload and create them in Microsoft 365 via MS Graph API.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not isinstance(self._m365, M365):\n            logger.error(\n                \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n                section_name,\n            )\n            return False\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # Add all users in payload and establish membership in\n        # specified groups:\n        for user in self._users:\n            # Sanity checks:\n            if not \"name\" in user:\n                logger.error(\"User is missing a login. Skipping to next user...\")\n                success = False\n                continue\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n            if not \"enable_o365\" in user or not user[\"enable_o365\"]:\n                logger.info(\n                    \"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\n                    user_name,\n                )\n                continue\n\n            # Sanity checks:\n            if not \"password\" in user:\n                logger.error(\n                    \"User -&gt; %s is missing a password. Skipping to next user...\",\n                    user_name,\n                )\n                success = False\n                continue\n            user_password = user[\"password\"]\n            # be careful with the following fields - they could be empty\n            user_department = user.get(\"base_group\", \"\")\n            user_first_name = user.get(\"firstname\", \"\")\n            user_last_name = user.get(\"lastname\", \"\")\n            user_location = user.get(\"location\", \"US\")\n            user_email = user.get(\"email\", user_name)\n\n            # Check if the user does already exist in M365 (e.g. if job is restarted)\n            m365_user_id = self.determine_user_id_m365(user)\n            if not m365_user_id:\n                logger.info(\n                    \"Did not find existing Micosoft 365 user - creating user %s...\",\n                    user_email,\n                )\n\n                # Now we know it is a new user...\n                new_user = self._m365.add_user(\n                    email=user_email,\n                    password=user_password,\n                    first_name=user_first_name,\n                    last_name=user_last_name,\n                    location=user_location,\n                    department=user_department,\n                )\n                if new_user is not None:\n                    # Store the Microsoft 365 user ID in payload:\n                    user[\"m365_id\"] = new_user[\"id\"]\n                    logger.info(\n                        \"New Microsoft 365 user -&gt; %s with ID -&gt; %s has been created\",\n                        user_name,\n                        user[\"m365_id\"],\n                    )\n                else:\n                    logger.error(\n                        \"Failed to create new Microsoft 365 user -&gt; %s. Skipping...\",\n                        user_name,\n                    )\n                    success = False\n                    continue\n\n            # Now we assign a license to the new M365 user.\n            # First we see if there's a M365 SKU list in user\n            # payload - if not we wrap the default SKU configured\n            # for the m365 object into a single item list:\n            existing_user_licenses = self._m365.get_user_licenses(user[\"m365_id\"])\n            sku_list = user.get(\"m365_skus\", [self._m365.config()[\"skuId\"]])\n            for sku_id in sku_list:\n                # Check if the M365 user already has this license:\n                if not self._m365.exist_result_item(\n                    existing_user_licenses, \"skuId\", sku_id\n                ):\n                    response = self._m365.assign_license_to_user(\n                        user[\"m365_id\"], sku_id\n                    )\n                    if not response:\n                        logger.error(\n                            \"Failed to assign license -&gt; %s to Microsoft 365 user -&gt; %s\",\n                            sku_id,\n                            user_name,\n                        )\n                        success = False\n                    else:\n                        if (\n                            not \"m365_skus\" in user\n                        ):  # this is only True if the default license from the m365 object is taken\n                            user[\"m365_skus\"] = [sku_id]\n                        logger.info(\n                            \"License -&gt; %s has been assigned to Microsoft 365 user -&gt; %s\",\n                            sku_id,\n                            user_name,\n                        )\n                else:\n                    logger.info(\n                        \"Microsoft 365 user -&gt; %s already has the license -&gt; %s\",\n                        user_name,\n                        sku_id,\n                    )\n\n            # Now we assign the Extended ECM Teams App to the new M365 user.\n            # First we check if the app is already assigned to the user.\n            # If not we install / assign the app. If the user already has\n            # the Extended ECM app we try to uprade it:\n            app_name = self._m365.config()[\"teamsAppName\"]\n            response = self._m365.get_teams_apps_of_user(\n                user[\"m365_id\"],\n                f\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n            )\n            if self._m365.exist_result_item(\n                response, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n            ):\n                logger.info(\n                    \"App -&gt; %s is already installed for M365 user -&gt; %s (%s). Trying to upgrade app...\",\n                    app_name,\n                    user_name,\n                    user[\"m365_id\"],\n                )\n                response = self._m365.upgrade_teams_app_of_user(\n                    user[\"m365_id\"], app_name\n                )\n            else:\n                logger.info(\n                    \"Install M365 Teams app -&gt; %s for M365 user -&gt; %s\",\n                    app_name,\n                    user_name,\n                )\n                response = self._m365.assign_teams_app_to_user(\n                    user[\"m365_id\"], app_name\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to install the App -&gt; %s for M365 user -&gt; %s\",\n                        app_name,\n                        user_name,\n                    )\n                    success = False\n                    continue\n\n            # Process Microsoft 365 group memberships of new user:\n            if \"m365_id\" in user:\n                user_id = user[\"m365_id\"]\n                # don't forget the base group (department) !\n                group_names = user[\"groups\"]\n                if user_department:\n                    group_names.append(user_department)\n                logger.info(\n                    \"User -&gt; %s has these groups in payload -&gt; %s (including base group -&gt; %s). Checking if they are Microsoft 365 Groups...\",\n                    user_name,\n                    group_names,\n                    user_department,\n                )\n                # Go through all group names:\n                for group_name in group_names:\n                    # Find the group payload item to the parent group name:\n                    group = next(\n                        (item for item in self._groups if item[\"name\"] == group_name),\n                        None,\n                    )\n                    if not group:\n                        # if group is not in payload then this membership\n                        # is not relevant for Microsoft 365. This could be system generated\n                        # groups like \"PageEdit\" or \"Business Administrators\".\n                        # In this case we do \"continue\" as we can't process parent groups\n                        # either:\n                        logger.info(\n                            \"No payload found for Group -&gt; %s. Skipping...\", group_name\n                        )\n                        continue\n                    elif not \"enable_o365\" in group or not group[\"enable_o365\"]:\n                        # If Microsoft 365 is not enabled for this group in\n                        # the payload we don't create a M365 but we do NOT continue\n                        # as there may still be parent groups that are M365 enabled\n                        # we want to put the user in (see below):\n                        logger.info(\n                            \"Payload Group -&gt; %s is not enabled for M365.\", group_name\n                        )\n                    else:\n                        response = self._m365.get_group(group_name)\n                        if (\n                            response is None\n                            or not \"value\" in response\n                            or not response[\"value\"]\n                        ):\n                            logger.error(\n                                \"Microsoft 365 Group -&gt; %s not found. Skipping...\",\n                                group_name,\n                            )\n                            success = False\n                        else:\n                            group_id = response[\"value\"][0][\"id\"]\n\n                            # Check if user is already a member. We don't want\n                            # to throw an error if the user is not found as a member\n                            # so we pass show_error=False:\n                            if self._m365.is_member(\n                                group_id, user_id, show_error=False\n                            ):\n                                logger.info(\n                                    \"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\n                                    user[\"name\"],\n                                    user_id,\n                                    group_name,\n                                    group_id,\n                                )\n                            else:\n                                logger.info(\n                                    \"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\n                                    user[\"name\"],\n                                    user_id,\n                                    group_name,\n                                    group_id,\n                                )\n                                response = self._m365.add_group_member(\n                                    group_id, user_id\n                                )\n                                if not response:\n                                    logger.error(\n                                        \"Failed to add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\n                                        user[\"name\"],\n                                        user_id,\n                                        group_name,\n                                        group_id,\n                                    )\n                                    success = False\n\n                                # As each group should have at least one owner in M365\n                                # we set all users also as owners for now. Later we\n                                # may want to configure this via payload:\n                                logger.info(\n                                    \"Make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\n                                    user[\"name\"],\n                                    user_id,\n                                    group_name,\n                                    group_id,\n                                )\n                                response = self._m365.add_group_owner(group_id, user_id)\n                                if not response:\n                                    logger.error(\n                                        \"Failed to make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\n                                        user[\"name\"],\n                                        user_id,\n                                        group_name,\n                                        group_id,\n                                    )\n                                    success = False\n\n                    # As M365 groups are flat (not nested) we also add the\n                    # user as member to the parent groups of the current group\n                    # if the parent group is enabled for M365:\n                    parent_group_names = group.get(\"parent_groups\")\n                    logger.info(\n                        \"Group -&gt; %s has the following parent groups -&gt; %s\",\n                        group_name,\n                        parent_group_names,\n                    )\n                    for parent_group_name in parent_group_names:\n                        # Find the group dictionary item to the parent group name:\n                        parent_group = next(\n                            (\n                                item\n                                for item in self._groups\n                                if item[\"name\"] == parent_group_name\n                            ),\n                            None,\n                        )\n                        if (\n                            parent_group is None\n                            or not \"enable_o365\" in parent_group\n                            or not parent_group[\"enable_o365\"]\n                        ):\n                            # if parent group is not in payload then this membership\n                            # is not relevant for Microsoft 365.\n                            # If Office 365 is not enabled for this parent group in\n                            # the payload we can also skip:\n                            logger.info(\n                                \"Parent Group -&gt; %s is not enabled for M365. Skipping...\",\n                                group_name,\n                            )\n                            continue\n\n                        response = self._m365.get_group(parent_group_name)\n                        if (\n                            response is None\n                            or not \"value\" in response\n                            or not response[\"value\"]\n                        ):\n                            logger.error(\n                                \"Microsoft 365 Group -&gt; %s not found. Skipping...\",\n                                group_name,\n                            )\n                            success = False\n                            continue\n                        parent_group_id = response[\"value\"][0][\"id\"]\n\n                        # Check if user is already a member. We don't want\n                        # to throw an error if the user is not found as a member:\n                        if self._m365.is_member(\n                            parent_group_id, user_id, show_error=False\n                        ):\n                            logger.info(\n                                \"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\n                                user[\"name\"],\n                                user_id,\n                                parent_group_name,\n                                parent_group_id,\n                            )\n                            continue\n\n                        logger.info(\n                            \"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\n                            user[\"name\"],\n                            user_id,\n                            parent_group_name,\n                            parent_group_id,\n                        )\n                        self._m365.add_group_member(parent_group_id, user_id)\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_teams_m365(self, section_name: str = \"teamsM365\") -&gt; bool:\n        \"\"\"Process groups in payload and create matching Teams in Microsoft 365.\n           We need to do this after the creation of the M365 users as wie require\n           Group Owners to create teams.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not isinstance(self._m365, M365):\n            logger.error(\n                \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n                section_name,\n            )\n            return False\n\n        if not self._groups:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for group in self._groups:\n            if not \"name\" in group:\n                logger.error(\"Team needs a name. Skipping...\")\n                success = False\n                continue\n            group_name = group[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in group and not group[\"enabled\"]:\n                logger.info(\n                    \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n                )\n                continue\n            if not \"enable_o365\" in group or not group[\"enable_o365\"]:\n                logger.info(\n                    \"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\n                    group_name,\n                )\n                continue\n\n            # Check if the M365 group does not exist (this should actually never happen at this point)\n            if not \"m365_id\" in group:\n                # The \"m365_id\" value is set by the method process_groups_m365()\n                logger.error(\n                    \"No M365 Group exist for group -&gt; %s (M365 Group creation may have failed). Skipping...\",\n                    group_name,\n                )\n                success = False\n                continue\n\n            if self._m365.has_team(group_name):\n                logger.info(\n                    \"M365 group -&gt; %s already has an MS Team connected. Skipping...\",\n                    group_name,\n                )\n                continue\n\n            logger.info(\n                \"Create M365 Team -&gt; %s for existing M365 Group -&gt; %s...\",\n                group_name,\n                group_name,\n            )\n            # Now \"upgrading\" this group to a MS Team:\n            new_team = self._m365.add_team(group_name)\n            if not new_team:\n                success = False\n                continue\n\n        self.write_status_file(success, section_name, self._groups)\n\n        return success\n\n        # end method definition\n\n    def process_teams_m365_apps(\n        self, section_name: str = \"teamsM365Apps\", tab_name: str = \"Extended ECM\"\n    ) -&gt; bool:\n        \"\"\"Process groups in payload and configure Extended ECM Teams Apps\n           as a tab called \"Extended ECM\".\n           We need to do this after the transport as we need top level folders\n           we can point the Extended ECM teams app to.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n            tab_name (str, optional): Name of the Extended ECM tab. Default is \"Extended ECM\".\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not isinstance(self._m365, M365):\n            logger.error(\n                \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n                section_name,\n            )\n            return False\n\n        if not self._groups:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # Determine the ID of the Extended ECM App:\n        app_name = self._m365.config()[\"teamsAppName\"]\n        response = self._m365.get_teams_apps(f\"contains(displayName, '{app_name}')\")\n        # Get the App catalog ID:\n        app_catalog_id = self._m365.get_result_value(response, \"id\", 0)\n        if not app_catalog_id:\n            logger.error(\"M365 App -&gt; %s not found in catalog!\", app_name)\n            return False\n\n        for group in self._groups:\n            if not \"name\" in group:\n                logger.error(\"Team needs a name. Skipping...\")\n                success = False\n                continue\n            group_name = group[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in group and not group[\"enabled\"]:\n                logger.info(\n                    \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n                )\n                continue\n            if not \"enable_o365\" in group or not group[\"enable_o365\"]:\n                logger.info(\n                    \"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\n                    group_name,\n                )\n                continue\n\n            #\n            # Now we create a tab in the \"General\" channel for the Extended ECM Teams App\n            #\n\n            # 1. Check if the tab is already assigned to the General channel.\n            # This determines if we need to create or update the tab / app:\n            app_name = self._m365.config()[\"teamsAppName\"]\n            response = self._m365.get_team_channel_tabs(\n                team_name=group_name, channel_name=\"General\"\n            )\n            # Check if tab is already there:\n            if self._m365.exist_result_item(response, \"displayName\", tab_name):\n                logger.info(\n                    \"M365 Teams app -&gt; %s is already configured for M365 Team -&gt; %s. Updating it with new URLs and IDs...\",\n                    app_name,\n                    tab_name,\n                )\n                update = True  # update existing tab\n            else:\n                logger.info(\n                    \"Add tab -&gt; %s to channel -&gt; General of M365 Team -&gt; %s for app -&gt; %s\",\n                    tab_name,\n                    group_name,\n                    app_name,\n                )\n                update = False  # create new tab\n\n            # 2. Determine the M365 Team ID. If the team is not found then skip:\n            response = self._m365.get_team(group_name)\n            team_id = self._m365.get_result_value(response, \"id\", 0)\n            if not team_id:\n                logger.error(\"M365 Team -&gt; %s not found!\", group_name)\n                success = False\n                continue\n\n            # 3. Install the App for the particular M365 Team (if it is not yet installed):\n            response = self._m365.get_teams_apps_of_team(\n                team_id,\n                f\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n            )\n            if self._m365.exist_result_item(\n                response, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n            ):\n                logger.info(\n                    \"App -&gt; %s is already installed for M365 Team -&gt; %s (%s). Trying to upgrade app...\",\n                    app_name,\n                    group_name,\n                    team_id,\n                )\n                response = self._m365.upgrade_teams_app_of_team(team_id, app_name)\n                if not response:\n                    logger.error(\n                        \"Failed to upgrade the existing app -&gt; %s for the M365 Team -&gt; %s\",\n                        app_name,\n                        group_name,\n                    )\n                    success = False\n                    continue\n            else:\n                logger.info(\n                    \"Install M365 Teams app -&gt; %s for M365 team -&gt; %s\",\n                    app_name,\n                    group_name,\n                )\n                response = self._m365.assign_teams_app_to_team(\n                    team_id=team_id, app_id=app_catalog_id\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to install App -&gt; %s (%s) for M365 Team -&gt; %s\",\n                        app_name,\n                        app_catalog_id,\n                        group_name,\n                    )\n                    success = False\n                    continue\n\n            # 4. Create a Tab in the \"General\" channel of the M365 Team:\n            if group_name == \"Innovate\":\n                # Use the Enterprise Workspace for the\n                # top-level group \"Innovate\":\n                node_id = 2000\n            else:\n                # We assume the departmental group names are identical to\n                # top-level folders in the Enterprise volume\n                node = self._otcs.get_node_by_parent_and_name(2000, group_name)\n                node_id = self._otcs.get_result_value(node, \"id\")\n                if not node_id:\n                    logger.warning(\n                        \"Cannot find a top-level container for group -&gt; %s. Cannot configure M365 Teams app. Skipping...\",\n                        group_name,\n                    )\n                    continue\n\n            app_url = (\n                self._otcs_frontend.cs_support_public_url()\n            )  # it is important to use the frontend pod URL here\n            app_url += \"/xecmoffice/teamsapp.html?nodeId=\"\n            app_url += (\n                str(node_id) + \"&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=\"\n            )\n            app_url += self._otcs_frontend.cs_public_url()\n            app_url += \"&amp;appId=\" + app_catalog_id\n\n            if update:\n                # App / Tab exist but needs to be updated with new\n                # IDs for the new deployment of Extended ECM\n                # as the M365 Teams survive between Terrarium deployments:\n\n                logger.info(\n                    \"Updating tab -&gt; %s of M365 Team channel -&gt; General for app -&gt; %s (%s) with new URLs and node IDs\",\n                    tab_name,\n                    app_name,\n                    app_catalog_id,\n                )\n\n                response = self._m365.update_teams_app_of_channel(\n                    team_name=group_name,\n                    channel_name=\"General\",\n                    tab_name=tab_name,\n                    app_url=app_url,\n                    cs_node_id=node_id,\n                )\n            else:\n                # Tab does not exist in \"General\" channel so we\n                # add / configure it freshly:\n\n                logger.info(\n                    \"Adding tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\n                    tab_name,\n                    app_name,\n                    app_catalog_id,\n                )\n\n                response = self._m365.add_teams_app_to_channel(\n                    team_name=group_name,\n                    channel_name=\"General\",\n                    app_id=app_catalog_id,\n                    tab_name=tab_name,\n                    app_url=app_url,\n                    cs_node_id=node_id,\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to add tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\n                        tab_name,\n                        app_name,\n                        app_catalog_id,\n                    )\n\n        self.write_status_file(success, section_name, self._groups)\n\n        return success\n\n        # end method definition\n\n    def cleanup_stale_teams_m365(self, workspace_types: list) -&gt; bool:\n        \"\"\"Delete Microsoft Teams that are left-overs from former deployments.\n           This method is currently not used.\n\n        Args:\n            workspace_types (list): list of all workspace types\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\n\n        if not isinstance(self._m365, M365):\n            logger.error(\n                \"Office 365 connection not setup properly. Skipping cleanup...\",\n            )\n            return False\n\n        if workspace_types == []:\n            logger.error(\"Empty workspace type list!\")\n            return False\n\n        for workspace_type in workspace_types:\n            if not \"name\" in workspace_type:\n                logger.error(\n                    \"Workspace type -&gt; %s does not have a name. Skipping...\",\n                    workspace_type,\n                )\n                continue\n            response = self._otcs.get_workspace_instances(workspace_type[\"name\"])\n            workspace_instances = response[\"results\"]\n            if not workspace_instances:\n                logger.info(\n                    \"Workspace type -&gt; %s does not have any instances!\",\n                    workspace_type[\"name\"],\n                )\n                continue\n            for workspace_instance in workspace_instances:\n                workspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\n                logger.info(\n                    \"Check if stale Microsoft 365 Teams with name -&gt; %s exist...\",\n                    workspace_name,\n                )\n                response = self._m365.delete_teams(workspace_name)\n\n        return True\n\n        # end method definition\n\n    def cleanup_all_teams_m365(self, section_name: str = \"teamsM365Cleanup\") -&gt; bool:\n        \"\"\"Delete Microsoft Teams that are left-overs from former deployments\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if teams have been deleted, False otherwise\n        \"\"\"\n\n        if not isinstance(self._m365, M365):\n            logger.error(\n                \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n                section_name,\n            )\n            return False\n\n        # We want this cleanup to only run once even if we have\n        # multiple payload files - so we pass payload_specific=False here:\n        if self.check_status_file(\n            payload_section_name=section_name, payload_specific=False\n        ):\n            logger.info(\n                \"Payload section -&gt; %s has been processed successfully before. Skip cleanup of M365 teams...\",\n                section_name,\n            )\n            return True\n\n        logger.info(\"Processing payload section -&gt; %s...\", section_name)\n\n        # We don't want to delete MS Teams that are matching the regular OTCS Group Names (like \"Sales\")\n        exception_list = self.get_all_group_names()\n\n        # These are the patterns that each MS Teams needs to match at least one of to be deleted\n        # Pattern 1: all MS teams with a name that has a number in brackets, line \"(1234)\"\n        # Pattern 2: all MS Teams with a name that starts with a number followed by a space,\n        #            followed by a \"-\" and followed by another space\n        # Pattern 3: all MS Teams with a name that starts with \"WS\" and a 1-4 digit number\n        #            (these are the workspaces for Purchase Contracts generated for Intelligent Filing)\n        # Pattern 4: all MS Teams with a name that ends with a 1-2 character + a number in brackets, like (US-1000)\n        #            this is a specialization of pattern 1\n        # Pattern 5: remove the teams that are created for the dummy copy&amp;paste template for the\n        #            Intelligent Filing workspaces\n        pattern_list = [\n            r\"\\(\\d+\\)\",\n            r\"\\d+\\s-\\s\",\n            r\"^WS\\d{1,4}$\",\n            r\"^.+?\\s\\(.{1,2}-\\d+\\)$\",\n            r\"Purchase\\sContract\\s\\(Template\\sfor\\sIntelligent\\sFiling\\)\",\n        ]\n\n        result = self._m365.delete_all_teams(exception_list, pattern_list)\n\n        # We want this cleanup to only run once even if we have\n        # multiple payload files - so we pass payload_specific=False here:\n        self.write_status_file(\n            success=True,\n            payload_section_name=section_name,\n            payload_section=exception_list + pattern_list,\n            payload_specific=False,\n        )\n\n        return result\n\n        # end method definition\n\n    def process_admin_settings(\n        self, admin_settings: list, section_name: str = \"adminSettings\"\n    ) -&gt; bool:\n        \"\"\"Process admin settings in payload and import them to Extended ECM.\n\n            The payload section is a list of dicts with these items:\n            {\n                enabled: True or False to enable or disable the payload item\n                filename: The filename of the XML file with admin settings.\n                          It needs to be the plain filename like \"admin.xml\".\n                          The files reside inside the container in /settings root\n                          directory. They are placed there by the Terraform automation\n                          and are taken from the ./settings/payload directory.\n                description: Some description about the purpose of the settings.\n                             Just for information and optional.\n            }\n\n        Args:\n            admin_settings (list): list of admin settings. We need this parameter\n                                   as we process two different lists.\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"adminSettingsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if a restart of the OTCS pods is required. False otherwise.\n        \"\"\"\n\n        if not admin_settings:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n        # If this payload section has been processed successfully before we\n        # can return False and skip processing it once more:\n        if self.check_status_file(section_name):\n            return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n        restart_required: bool = False\n        success: bool = True\n\n        for admin_setting in admin_settings:\n            # Sanity checks:\n            if not \"filename\" in admin_setting:\n                logger.error(\"Filename is missing. Skipping to next admin setting...\")\n                continue\n            filename = admin_setting[\"filename\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in admin_setting and not admin_setting[\"enabled\"]:\n                logger.info(\n                    \"Payload for setting file -&gt; %s is disabled. Skipping...\", filename\n                )\n                continue\n\n            settings_file = self._custom_settings_dir + filename\n            if os.path.exists(settings_file):\n                description = admin_setting.get(\"description\")\n                if description:\n                    logger.info(description)\n\n                # Read the config file:\n                with open(settings_file, \"r\", encoding=\"utf-8\") as file:\n                    file_content = file.read()\n\n                logger.debug(\n                    \"Replace Placeholder -&gt; %s in file -&gt; %s\",\n                    self._placeholder_values,\n                    file_content,\n                )\n\n                file_content = self.replace_placeholders(file_content)\n\n                # Write the updated config file:\n                tmpfile = \"/tmp/\" + os.path.basename(settings_file)\n                with open(tmpfile, \"w\", encoding=\"utf-8\") as file:\n                    file.write(file_content)\n\n                response = self._otcs.apply_config(tmpfile)\n                if response and response[\"results\"][\"data\"][\"restart\"]:\n                    logger.info(\"A restart of Extended ECM service is required.\")\n                    restart_required = True\n            else:\n                logger.error(\"Admin settings file -&gt; %s not found.\", settings_file)\n                success = False\n\n        self.write_status_file(success, section_name, admin_settings)\n\n        return restart_required\n\n        # end method definition\n\n    def check_external_system(self, external_system: dict) -&gt; bool:\n        \"\"\"Check if external system is reachable\n\n        Args:\n            external_system (dict): payload data structure of external system.\n                                    We assume here that sanity check for\n                                    valid data is already done before.\n\n        Returns:\n            bool: True = system is reachable, False otherwise\n        \"\"\"\n\n        as_url = external_system[\"as_url\"]\n\n        # Extract the hostname:\n        external_system_hostname = urlparse(as_url).hostname\n        # Write this information back into the data structure:\n        external_system[\"external_system_hostname\"] = external_system_hostname\n        # Extract the port:\n        external_system_port = urlparse(as_url).port if urlparse(as_url).port else 80\n        # Write this information back into the data structure:\n        external_system[\"external_system_port\"] = external_system_port\n\n        if self._http_object.check_host_reachable(\n            external_system_hostname, external_system_port\n        ):\n            logger.info(\n                \"Mark external system -&gt; %s as reachable for later workspace creation and SAP RFC processing...\",\n                external_system[\"external_system_name\"],\n            )\n            external_system[\"reachable\"] = True\n            return True\n        else:\n            external_system[\"reachable\"] = False\n            return False\n\n    def process_external_systems(self, section_name: str = \"externalSystems\") -&gt; bool:\n        \"\"\"Process external systems in payload and create them in Extended ECM.\n\n            The payload section is a list of dicts (each representing one external\n            system) with these items:\n            {\n                enabled: True or False to enable or disable the payload item\n                external_system_name: Name of the external systen.\n                external_system_type: Type of the external system.\n                                      Possible values are\n                                      * SAP\n                                      * SuccessFactors\n                                      * Salesforce\n                                      * AppWorks Platform\n                base_url: Base URL of the external system\n                as_url: Application Server URL of the external system\n                username: (Technical) User Name for the connection\n                password: Passord of the (technical) user\n                oauth_client_id: OAuth client ID\n                oauth_client_secret: OAuth client secret\n                archive_logical_name: Logical name of Archive for SAP\n                archive_certificate_file: Path and filename to certificate file.\n                                          This file is inside the customizer\n                                          pof file system.\n            }\n            If OAuth Client ID and Client Secret are provided then username\n            and password are no longer used.\n\n            In the payload for SAP external systems there are additional\n            items \"client\", \"destination\" that are processed by init_sap()\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            - based on system_type different other settings in the dict are set\n            - reachability is tested and a flag is set in the payload dict\n        \"\"\"\n\n        if not self._external_systems:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # WE DON'T WANT TO DO THIS AS WE NEED TO INITIALIZE\n        # DATASTRUCTURES LIKE self._sap and self._salesforce!!\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        # if self.check_status_file(section_name):\n        #   return True\n\n        success: bool = True\n\n        for external_system in self._external_systems:\n            #\n            # 1: Do sanity checks for the payload:\n            #\n            if not \"external_system_name\" in external_system:\n                logger.error(\n                    \"External System connection needs a logical system name! Skipping to next external system...\"\n                )\n                success = False\n                continue\n            system_name = external_system[\"external_system_name\"]\n\n            if not \"external_system_type\" in external_system:\n                logger.error(\n                    \"External System connection -&gt; %s needs a type (SAP, Salesfoce, SuccessFactors, AppWorks Platform)! Skipping to next external system...\",\n                    system_name,\n                )\n                success = False\n                continue\n            system_type = external_system[\"external_system_type\"]\n\n            if \"enabled\" in external_system and not external_system[\"enabled\"]:\n                logger.info(\n                    \"Payload for External System -&gt; %s (%s) is disabled. Skipping...\",\n                    system_name,\n                    system_type,\n                )\n                continue\n\n            # Possible Connection Types for external systems:\n            # \"Business Scenario Sample\" (Business Scenarios Sample Adapter)\n            # \"ot.sap.c4c.SpiAdapter\" (SAP C4C SPI Adapter)\n            # \"ot.sap.c4c.SpiAdapterV2\" (C4C SPI Adapter V2)\n            # \"HTTP\" (Default WebService Adapter)\n            # \"ot.sap.S4HANAAdapter\" (S/4HANA SPI Adapter)\n            # \"SF\" (SalesForce Adapter)\n            # \"SFInstance\" (SFWebService)\n\n            # Set the default settings for the different system types:\n            match system_type:\n                # Check if we have a SuccessFactors system:\n                case \"SuccessFactors\":\n                    connection_type = \"SFInstance\"\n                    auth_method = \"OAUTH\"\n                    username = None\n                    password = None\n                case \"SAP\":\n                    connection_type = \"HTTP\"\n                    auth_method = \"BASIC\"\n                    oauth_client_id = None\n                    oauth_client_secret = None\n                case \"Salesforce\":\n                    connection_type = \"SF\"\n                    auth_method = \"OAUTH\"\n                    username = None\n                    password = None\n                case \"AppWorks Platform\":\n                    connection_type = \"HTTP\"\n                    auth_method = \"BASIC\"\n                    oauth_client_id = None\n                    oauth_client_secret = None\n                case \"Business Scenario Sample\":\n                    connection_type = \"Business Scenario Sample\"\n                    auth_method = \"BASIC\"\n                    oauth_client_id = None\n                    oauth_client_secret = None\n                case _:\n                    logger.error(\"Unsupported system_type defined -&gt; %s\", system_type)\n                    return False\n\n            if not \"base_url\" in external_system:\n                base_url = \"\"  # baseUrl is optional\n            else:\n                base_url = external_system[\"base_url\"]\n\n            if not \"as_url\" in external_system:\n                logger.warning(\n                    \"External System connection -&gt; %s needs an Application Server URL! Skipping to next external system...\",\n                    system_name,\n                )\n                success = False\n                continue\n            as_url = external_system[\"as_url\"]\n\n            # Check if external system is reachable and\n            # update the payload dict with a \"reachable\" key/value pair:\n            self.check_external_system(external_system)\n\n            # Read either username/password (BASIC) or client ID / secret (OAuth)\n            match auth_method:\n                case \"BASIC\":\n                    if not \"username\" in external_system:\n                        logger.warning(\n                            \"External System connection -&gt; %s needs a user name for BASIC authentication! Skipping to next external system...\",\n                            system_name,\n                        )\n                        continue\n                    if not \"password\" in external_system:\n                        logger.warning(\n                            \"External System connection -&gt; %s needs a password for BASIC authentication! Skipping to next external system...\",\n                            system_name,\n                        )\n                        continue\n                    username = external_system[\"username\"]\n                    password = external_system[\"password\"]\n                    oauth_client_id = \"\"\n                    oauth_client_secret = \"\"\n\n                case \"OAUTH\":\n                    if not \"oauth_client_id\" in external_system:\n                        logger.error(\n                            \"External System connection -&gt; %s is missing OAuth client ID! Skipping to next external system...\",\n                            system_name,\n                        )\n                        success = False\n                        continue\n                    if not \"oauth_client_secret\" in external_system:\n                        logger.error(\n                            \"External System connection -&gt; %s is missing OAuth client secret! Skipping to next external system...\",\n                            system_name,\n                        )\n                        success = False\n                        continue\n                    oauth_client_id = external_system[\"oauth_client_id\"]\n                    oauth_client_secret = external_system[\"oauth_client_secret\"]\n                    # For backward compatibility we also read username/password\n                    # with OAuth settings:\n                    username = (\n                        external_system[\"username\"]\n                        if external_system.get(\"username\")\n                        else None\n                    )\n                    password = (\n                        external_system[\"password\"]\n                        if external_system.get(\"password\")\n                        else None\n                    )\n                case _:\n                    logger.error(\n                        \"Unsupported authorization method specified (%s) , Skipping ... \",\n                        auth_method,\n                    )\n                    return False\n\n            # We do this existance test late in this function to make sure the payload\n            # datastructure is properly updated for debugging purposes.\n            logger.info(\n                \"Test if external system -&gt; %s does already exist...\", system_name\n            )\n            if self._otcs.get_external_system_connection(system_name):\n                logger.info(\n                    \"External System connection -&gt; %s already exists!\",\n                    system_name,\n                )\n                # This is for handling re-runs of customizer pod where the transports\n                # are skipped and thus self._sap or self._salesforce may not be initialized:\n                if system_type == \"SAP\" and not self._sap:\n                    logger.info(\n                        \"Re-Initialize SAP connection for external system -&gt; %s.\",\n                        system_name,\n                    )\n                    # Initialize SAP object responsible for communication to SAP:\n                    self._sap = self.init_sap(external_system)\n                if system_type == \"Salesforce\" and not self._salesforce:\n                    logger.info(\n                        \"Re-Initialize Salesforce connection for external system -&gt; %s.\",\n                        system_name,\n                    )\n                    # Initialize Salesforce object responsible for communication to Salesforce:\n                    self._salesforce = self.init_salesforce(external_system)\n                logger.info(\"Skip to next external system...\")\n                continue\n\n            #\n            # Create External System:\n            #\n            logger.info(\n                \"Create external system -&gt; %s; type -&gt; %s\", system_name, connection_type\n            )\n            response = self._otcs.add_external_system_connection(\n                connection_name=system_name,\n                connection_type=connection_type,\n                as_url=as_url,\n                base_url=base_url,\n                username=str(username),\n                password=str(password),\n                authentication_method=auth_method,\n                client_id=oauth_client_id,\n                client_secret=oauth_client_secret,\n            )\n            if response is None:\n                logger.error(\n                    \"Failed to create external system -&gt; %s; type -&gt; %s\",\n                    system_name,\n                    connection_type,\n                )\n                success = False\n            else:\n                logger.info(\"Successfully created external system -&gt; %s\", system_name)\n\n            #\n            # In case of an SAP external system we also initialize the SAP object\n            # and do some SAP-specific Archiving config:\n            #\n            if system_type == \"SAP\":\n                # Initialize SAP object responsible for communication to SAP:\n                self._sap = self.init_sap(external_system)\n                if (\n                    \"archive_logical_name\" in external_system\n                    and \"archive_certificate_file\" in external_system\n                    and self._otac\n                ):\n                    logger.info(\n                        \"Put certificate file -&gt; %s for logical archive -&gt; %s into Archive Center\",\n                        external_system[\"archive_certificate_file\"],\n                        external_system[\"archive_logical_name\"],\n                    )\n                    response = self._otac.put_cert(\n                        external_system[\"external_system_name\"],\n                        external_system[\"archive_logical_name\"],\n                        external_system[\"archive_certificate_file\"],\n                    )\n                    logger.info(\n                        \"Enable certificate file -&gt; %s for logical archive -&gt; %s\",\n                        external_system[\"archive_certificate_file\"],\n                        external_system[\"archive_logical_name\"],\n                    )\n                    response = self._otac.enable_cert(\n                        external_system[\"external_system_name\"],\n                        external_system[\"archive_logical_name\"],\n                        True,\n                    )\n\n            #\n            # In case of an Salesforce external system we also initialize the Salesforce object\n            #\n            if system_type == \"Salesforce\":\n                # Initialize Salesforce object responsible for communication to Salesforce:\n                self._salesforce = self.init_salesforce(external_system)\n\n        self.write_status_file(success, section_name, self._external_systems)\n\n        return success\n\n        # end method definition\n\n    def process_transport_packages(\n        self, transport_packages: list, section_name: str = \"transportPackages\"\n    ) -&gt; bool:\n        \"\"\"Process transport packages in payload and import them to Extended ECM.\n\n        Args:\n            transport_packages (list): list of transport packages. As we\n                                       have three different lists (transport,\n                                       content_transport, transport_post) so\n                                       we need a parameter\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"transportPackagesPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not transport_packages:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for transport_package in transport_packages:\n            if not \"name\" in transport_package:\n                logger.error(\n                    \"Transport Package needs a name! Skipping to next transport...\"\n                )\n                success = False\n                continue\n            name = transport_package[\"name\"]\n\n            if \"enabled\" in transport_package and not transport_package[\"enabled\"]:\n                logger.info(\n                    \"Payload for Transport Package -&gt; %s is disabled. Skipping...\", name\n                )\n                continue\n\n            if not \"url\" in transport_package:\n                logger.error(\n                    \"Transport Package -&gt; %s needs a URL! Skipping to next transport...\",\n                    name,\n                )\n                success = False\n                continue\n            if not \"description\" in transport_package:\n                logger.warning(\"Transport Package -&gt; %s is missing a description\", name)\n            url = transport_package[\"url\"]\n            description = transport_package[\"description\"]\n\n            # For some transports there can be string replacements\n            # configured:\n            if \"replacements\" in transport_package:\n                replacements = transport_package[\"replacements\"]\n            else:\n                replacements = None\n\n            # For some transports there can be data extractions\n            # configured:\n            if \"extractions\" in transport_package:\n                extractions = transport_package[\"extractions\"]\n            else:\n                extractions = None\n\n            logger.info(\"Deploy transport -&gt; %s; URL -&gt; %s\", description, url)\n            if replacements:\n                logger.info(\"Use replacements -&gt; %s\", str(replacements))\n            if extractions:\n                logger.info(\"Use extractions -&gt; %s\", str(extractions))\n\n            response = self._otcs.deploy_transport(\n                url, name, description, replacements, extractions\n            )\n            if response is None:\n                logger.error(\"Failed to deploy transport -&gt; %s; URL -&gt; %s\", name, url)\n                success = False\n                if self._stop_on_error:\n                    break\n            else:\n                logger.info(\"Successfully deployed transport -&gt; %s\", name)\n                # Save the extractions for later processing, e.g. in process_business_object_types()\n                if extractions:\n                    self.add_transport_extractions(extractions)\n\n        self.write_status_file(success, section_name, transport_packages)\n        self.write_status_file(\n            success, section_name + \"Extractions\", self._transport_extractions\n        )\n\n        return success\n\n        # end method definition\n\n    def process_user_photos(self, section_name: str = \"userPhotos\") -&gt; bool:\n        \"\"\"Process user photos in payload and assign them to Extended ECM users.\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # we assume the nickname of the photo item equals the login name of the user\n        # we also assume that the photos have been uploaded / transported into the target system\n        for user in self._users:\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            if not \"id\" in user:\n                logger.error(\n                    \"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\n                    user_name,\n                )\n                success = False\n                continue\n\n            user_id = user[\"id\"]\n\n            response = self._otcs.get_node_from_nickname(user_name)\n            if response is None:\n                logger.warning(\n                    \"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\n                    user_name,\n                )\n                continue\n            photo_id = self._otcs.get_result_value(response, \"id\")\n            response = self._otcs.update_user_photo(user_id, photo_id)\n            if not response:\n                logger.error(\"Failed to add photo for user -&gt; %s\", user_name)\n                success = False\n            else:\n                logger.info(\"Successfully added photo for user -&gt; %s\", user_name)\n\n        # Check if Admin has a photo as well (nickname needs to be \"admin\"):\n        response = self._otcs.get_node_from_nickname(\"admin\")\n        if response is None:\n            logger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\n        else:\n            photo_id = self._otcs.get_result_value(response, \"id\")\n            response = self._otcs.update_user_photo(1000, photo_id)\n            if response is None:\n                logger.warning(\"Failed to add photo for admin\")\n            else:\n                logger.info(\"Successfully added photo for admin\")\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_user_photos_m365(self, section_name: str = \"userPhotosM365\") -&gt; bool:\n        \"\"\"Process user photos in payload and assign them to Microsoft 365 users.\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not isinstance(self._m365, M365):\n            logger.error(\n                \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n                section_name,\n            )\n            return False\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # we assume the nickname of the photo item equals the login name of the user\n        # we also assume that the photos have been uploaded / transported into the target system\n        for user in self._users:\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            if not \"id\" in user:\n                logger.error(\n                    \"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\n                    user_name,\n                )\n                success = False\n                continue\n\n            if not \"enable_o365\" in user or not user[\"enable_o365\"]:\n                logger.info(\n                    \"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\n                    user_name,\n                )\n                continue\n\n            # If the customizer pod is restarted it may be that\n            # the M365 user exists even if the M365 user ID is\n            # not yet written back into the payload. So we use the\n            # determine_user_id_m365() method that handles both cases\n            # and updates the payload if the user exists in M365 already.\n            user_m365_id = self.determine_user_id_m365(user)\n            if not user_m365_id:\n                logger.error(\"M365 user -&gt; %s does not exist. Skipping...\", user_name)\n                success = False\n                continue\n\n            if self._m365.get_user_photo(user_m365_id, show_error=False):\n                logger.info(\n                    \"User -&gt; %s (%s) has already a photo in Microsoft 365. Skipping...\",\n                    user_name,\n                    user_m365_id,\n                )\n                continue\n            else:\n                logger.info(\n                    \"User -&gt; %s (%s) has not yet a photo in Microsoft 365. Uploading...\",\n                    user_name,\n                    user_m365_id,\n                )\n\n            response = self._otcs.get_node_from_nickname(user_name)\n            if response is None:\n                logger.warning(\n                    \"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\n                    user_name,\n                )\n                continue\n            photo_id = self._otcs.get_result_value(response, \"id\")\n            photo_name = self._otcs.get_result_value(response, \"name\")\n            photo_path = \"/tmp/\" + str(photo_name)\n            response = self._otcs.download_document(photo_id, photo_path)\n            if response is None:\n                logger.warning(\n                    \"Failed to download photo for user -&gt; %s from Extended ECM\",\n                    user_name,\n                )\n                success = False\n                continue\n            else:\n                logger.info(\n                    \"Successfully downloaded photo for user -&gt; %s from Extended ECM to file -&gt; %s\",\n                    user_name,\n                    photo_path,\n                )\n\n            # Upload photo to M365:\n            response = self._m365.update_user_photo(user_m365_id, photo_path)\n            if response is None:\n                logger.error(\n                    \"Failed to upload photo for user -&gt; %s to Microsoft 365\", user_name\n                )\n                success = False\n            else:\n                logger.info(\n                    \"Successfully uploaded photo for user -&gt; %s to Microsoft 365\",\n                    user_name,\n                )\n\n        # Check if Admin has a photo as well (nickname needs to be \"admin\")\n        # Then we want this to be applied in M365 as well:\n        response = self._otcs.get_node_from_nickname(\"admin\")\n        if response is None:\n            logger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\n        else:\n            photo_id = self._otcs.get_result_value(response, \"id\")\n            photo_name = self._otcs.get_result_value(response, \"name\")\n            photo_path = \"/tmp/\" + str(photo_name)\n            response = self._otcs.download_document(photo_id, photo_path)\n            if response is None:\n                logger.warning(\n                    \"Failed to download photo for admin user from Extended ECM\",\n                )\n                success = False\n            else:\n                logger.info(\n                    \"Successfully downloaded photo for admin from Extended ECM to file -&gt; %s\",\n                    photo_path,\n                )\n                m365_admin_email = \"admin@\" + self._m365.config()[\"domain\"]\n                response = self._m365.update_user_photo(m365_admin_email, photo_path)\n                if response is None:\n                    logger.warning(\"Failed to add photo for %s\", m365_admin_email)\n                else:\n                    logger.info(\"Successfully added photo for %s\", m365_admin_email)\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_business_object_types(\n        self, section_name: str = \"businessObjectTypes\"\n    ) -&gt; list:\n        \"\"\"Create a data structure for all business object types in the Extended ECM system.\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            list: list of business object types. Each list element is a dict with these values:\n                - id (str)\n                - name (str)\n                - type (str)\n                - ext_system_id (str)\n                - business_properties (list)\n                - business_property_groups (list)\n        \"\"\"\n\n        # If this payload section has been processed successfully before we\n        # still need to read the data structure from the status file and\n        # initialize self._workspace_types:\n        if self.check_status_file(section_name):\n            # read the list from the json file in admin Home\n            # this is important for restart of customizer pod\n            # as this data structure is used later on for workspace processing\n            logger.info(\n                \"Re-Initialize business object types list from status file -&gt; %s for later use...\",\n                self.get_status_file_name(payload_section_name=section_name),\n            )\n            self._business_object_types = self.get_status_file(section_name)\n            logger.info(\n                \"Found -&gt; %s business object types.\",\n                str(len(self._business_object_types)),\n            )\n            logger.debug(\n                \"Business object types -&gt; %s\", str(self._business_object_types)\n            )\n            return self._business_object_types\n\n        success: bool = True\n\n        # get all workspace types (these have been created by the transports and are not in the payload!)\n        # we need to do this each time as it needs to work across potential multiple payload files...\n        response = self._otcs.get_business_object_types()\n        if response is None:\n            logger.info(\"No business object types found!\")\n            self._business_object_types = []\n        else:\n            self._business_object_types = response[\"results\"]\n            logger.info(\n                \"Found -&gt; %s business object types.\",\n                str(len(self._business_object_types)),\n            )\n            logger.debug(\n                \"Business object types -&gt; %s\", str(self._business_object_types)\n            )\n\n        # now we enrich the workspace_type list elments (which are dicts)\n        # with additional dict elements for further processing:\n        for business_object_type in self._business_object_types:\n            # Get BO Type (e.g. KNA1):\n            bo_type = business_object_type[\"data\"][\"properties\"][\"bo_type\"]\n            logger.info(\"Business Object Type -&gt; %s\", bo_type)\n            business_object_type[\"type\"] = bo_type\n            # Get BO Type ID:\n            bo_type_id = business_object_type[\"data\"][\"properties\"][\"bo_type_id\"]\n            logger.info(\"Business Object Type ID -&gt; %s\", bo_type_id)\n            business_object_type[\"id\"] = bo_type_id\n            # Get BO Type Name:\n            bo_type_name = business_object_type[\"data\"][\"properties\"][\"bo_type_name\"]\n            logger.info(\"Business Object Type Name -&gt; %s\", bo_type_name)\n            business_object_type[\"name\"] = bo_type_name\n            # Get External System ID:\n            ext_system_id = business_object_type[\"data\"][\"properties\"][\"ext_system_id\"]\n            logger.info(\"External System ID -&gt; %s\", ext_system_id)\n            business_object_type[\"ext_system_id\"] = ext_system_id\n\n            # Get additional information per BO Type (this REST API is severly\n            # limited) - it does not return Property names from External System\n            # and is also missing Business Property Groups:\n            # if not \"/\" in bo_type:\n            #     response = self._otcs.get_business_object_type(\n            #         external_system_id=ext_system_id, type_name=bo_type\n            #     )\n            #     if response is None or not response[\"results\"]:\n            #         logger.warning(\n            #             \"Cannot retrieve additional information for business object type -&gt; %s. Skipping...\",\n            #             bo_type,\n            #         )\n            #         continue\n            #     business_properties = response[\"results\"][\"data\"][\n            #         \"business_object_type\"\n            #     ][\"data\"][\"businessProperties\"]\n            #     business_object_type[\"business_properties\"] = business_properties\n            # else:\n            #     logger.warning(\n            #         \"Business Object Type -&gt; %s does not have a proper name to call REST API.\",\n            #         bo_type,\n            #     )\n            #     business_object_type[\"business_properties\"] = []\n\n            business_object_type[\"business_properties\"] = []\n            business_object_type[\"business_property_groups\"] = []\n\n            # Now we complete the data with what we have extracted from the transport packages\n            # for Business Object Types. This is a workaround for the insufficient REST API\n            # implementation (see otcs.get_business_object_type)\n            if self._transport_extractions:\n                logger.info(\n                    \"Enrich Business Object Types with data extractions from transport packages (found %s extractions)...\",\n                    str(len(self._transport_extractions)),\n                )\n            else:\n                logger.info(\n                    \"No transport extractions are recorded. This may be because of customizer restart.\"\n                )\n                extraction_status_file = \"transportPackagesExtractions\"\n                if self.check_status_file(extraction_status_file):\n                    logger.info(\n                        \"Try to load extractions from success file -&gt; %s...\",\n                        extraction_status_file,\n                    )\n                    self._transport_extractions = self.get_status_file(\n                        extraction_status_file\n                    )\n\n            for extraction in self._transport_extractions:\n                xpath = extraction.get(\"data\")\n                data_list = extraction.get(\"data\")\n                if not data_list:\n                    logger.error(\n                        \"Extraction -&gt; %s is missing the data element. Skipping...\",\n                        xpath,\n                    )\n                    success = False\n                    continue\n                if not isinstance(data_list, list):\n                    logger.warning(\n                        \"Extracted data for -&gt; %s is not a list. Cannot process it. Skipping...\",\n                        xpath,\n                    )\n                    continue\n\n                # The following loop processes a dictionasry of this structure:\n\n                # llnode: {\n                #     '@created': '2017-11-23T16:43:35',\n                #     '@createdby': '1000',\n                #     '@createdbyname': 'Terrarium Admin',\n                #     '@description': '',\n                #     '@id': '16013',\n                #     '@modified': '2023-12-09T12:08:21',\n                #     '@name': 'SFDC Order',\n                #     '@objname': 'Business Object Type',\n                #     '@objtype': '889',\n                #     '@ownedby': '1000',\n                #     '@ownedbyname': 'Terrarium Admin',\n                #     '@parentguid': '95F96645-057D-4EAF-9083-BE9F24C0CB6C',\n                #     '@parentid': '2898',\n                #     '@parentname': 'Business Object Types',\n                #     ...\n                #     'Nickname': {'@domain': ''},\n                #     'name': {'@xml:lang': 'en', '#text': 'SFDC Order'},\n                #     'description': {'@xml:lang': 'en'},\n                #     'businessObjectTypeInfo': {\n                #         'basicInfo': {\n                #             '@businessObjectId': '9',\n                #             '@businessobjectType': 'Order',\n                #             '@deleted': 'false',\n                #             '@name': 'SFDC Order',\n                #             '@subtype': '889',\n                #             '@useBusWorkspace': 'true',\n                #             'displayUrl': {...}\n                #         },\n                #         'businessApplication': {\n                #             'businessObjectTypeReference': {...}},\n                #             'businessAttachmentInfo': {\n                #                 '@automaticAddingOfBusinessObject': 'false',\n                #                 '@canbeAddedAsBusinessObject': 'false',\n                #                 '@enableBADIBeforeAddingBO': 'false',\n                #                 '@enableBADIBeforeRemovingBO': 'false',\n                #                 '@enableMetadataMapping': 'false'\n                #             },\n                #             'managedObjectTypes': {\n                #                 'managedObjectType': [...]\n                #             },\n                #             'multilingualNames': {'language': [...]},\n                #             'callbacks': {'callback': [...]},\n                #             'workspaceTypeReference': {'@isDefaultDisplay': 'false', '@isDefaultSearch': 'false', 'businessObjectTypeReference': {...}},\n                #             'businessPropertyMappings': {\n                #                 'propertyMapping': [...]\n                #             },\n                #             'businessPropertyGroupMappings': {\n                #                 'propertyGroupMapping': [...]\n                #             },\n                #             'documentTypes': {\n                #                 'documentType': [...]\n                #             },\n                #             'CustomBOTypeInfo': None\n                #         }\n                # }\n\n                for data in data_list:\n                    #\n                    # Level 1: llnode\n                    #\n                    llnode = data.get(\"llnode\")\n                    if not llnode:\n                        logger.error(\"Missing llnode structure in data. Skipping...\")\n                        success = False\n                        continue\n\n                    #\n                    # Level 2: businessobjectTypeInfo\n                    #\n                    business_object_type_info = llnode.get(\n                        \"businessobjectTypeInfo\", None\n                    )\n                    if not business_object_type_info:\n                        logger.error(\n                            \"Information is missing for Business Object Type -&gt; %s. Skipping...\",\n                            bo_type_name,\n                        )\n                        success = False\n                        continue\n\n                    # Check if this extraction is for the current business object type:\n                    basic_info = business_object_type_info.get(\"basicInfo\", None)\n                    if not basic_info:\n                        logger.error(\n                            \"Cannot find Basic Info of Business Object Type -&gt; %s. Skipping...\",\n                            bo_type_name,\n                        )\n                        success = False\n                        continue\n                    name = basic_info.get(\"@businessobjectType\", \"\")\n                    if not name:\n                        logger.error(\n                            \"Cannot find name of Business Object Type -&gt; %s. Skipping...\",\n                            bo_type_name,\n                        )\n                        success = False\n                        continue\n                    obj_type = llnode.get(\"@objtype\", None)\n                    # we need to compare bo_type and NOT bo_type_name here!\n                    # Otherwise we don't find the SAP and SuccessFactors data:\n                    if name != bo_type or obj_type != \"889\":\n                        continue\n\n                    #\n                    # Level 3: businessPropertyMappings - plain, non-grouped properties\n                    #\n                    business_property_mappings = business_object_type_info.get(\n                        \"businessPropertyMappings\", None\n                    )\n                    if not business_property_mappings:\n                        logger.info(\n                            \"No Property Mapping for Business Object Type -&gt; %s. Skipping...\",\n                            bo_type_name,\n                        )\n                    else:\n                        property_mappings = business_property_mappings.get(\n                            \"propertyMapping\", []\n                        )\n                        # This can happen if there's only 1 propertyMapping;\n                        if not isinstance(property_mappings, list):\n                            logger.info(\n                                \"Found a single property mapping in a dictionary (not in a list). Package it into a list...\",\n                            )\n                            property_mappings = [property_mappings]\n\n                        for property_mapping in property_mappings:\n                            property_name = property_mapping.get(\"@propertyName\")\n                            attribute_name = property_mapping.get(\"@attributeName\")\n                            category_id = property_mapping.get(\"@categoryId\")\n                            mapping_type = property_mapping.get(\"@type\")\n                            logger.info(\n                                \"%s Property Mapping for Business Object -&gt; %s: property -&gt; %s is mapped to attribute -&gt; %s (category -&gt; %s)\",\n                                mapping_type,\n                                bo_type_name,\n                                property_name,\n                                attribute_name,\n                                category_id,\n                            )\n                            business_object_type[\"business_properties\"].append(\n                                property_mapping\n                            )\n\n                    #\n                    # Level 3: businessPropertyGroupMappings - grouped properties\n                    #\n                    business_property_group_mappings = business_object_type_info.get(\n                        \"businessPropertyGroupMappings\", None\n                    )\n                    if not business_property_group_mappings:\n                        logger.info(\n                            \"No Property Group Mapping for Business Object Type -&gt; %s. Skipping...\",\n                            bo_type_name,\n                        )\n                        continue\n\n                    property_group_mappings = business_property_group_mappings.get(\n                        \"propertyGroupMapping\", []\n                    )\n                    # This can happen if there's only 1 propertyMapping;\n                    if isinstance(property_group_mappings, dict):\n                        logger.info(\n                            \"Found a single property group mapping in a dictionary (not in a list). Pack it into a list...\",\n                        )\n                        property_group_mappings = [property_group_mappings]\n\n                    for property_group_mapping in property_group_mappings:\n                        group_name = property_group_mapping.get(\"@groupName\")\n                        set_name = property_group_mapping.get(\"@setName\")\n                        category_id = property_group_mapping.get(\"@categoryId\")\n                        mapping_type = property_group_mapping.get(\"@type\")\n                        logger.info(\n                            \"%s Property Group Mapping for Business Object -&gt; %s: group -&gt; %s is mapped to set -&gt; %s (category -&gt; %s)\",\n                            mapping_type,\n                            bo_type_name,\n                            group_name,\n                            set_name,\n                            category_id,\n                        )\n\n                        property_mappings = property_group_mapping.get(\n                            \"propertyMapping\", []\n                        )\n                        # This can happen if there's only 1 propertyMapping;\n                        if not isinstance(property_mappings, list):\n                            logger.info(\n                                \"Found a single property mapping in a dictionary (not in a list). Package it into a list...\",\n                            )\n                            property_mappings = [property_mappings]\n\n                        for property_mapping in property_mappings:\n                            # for nested mappings we only have 2 fields - the rest is on the group level - see above\n                            property_name = property_mapping.get(\"@propertyName\")\n                            attribute_name = property_mapping.get(\"@attributeName\")\n                            logger.info(\n                                \"%s Property Mapping inside group for Business Object -&gt; %s: group -&gt; %s, property -&gt; %s is mapped to set -&gt; %s, attribute -&gt; %s (category -&gt; %s)\",\n                                mapping_type,\n                                bo_type_name,\n                                group_name,\n                                property_name,\n                                set_name,\n                                attribute_name,\n                                category_id,\n                            )\n                            # we write the group / set information also in the property mapping\n                            # tp have a plain list with all information:\n                            property_mapping[\"@groupName\"] = group_name\n                            property_mapping[\"@setName\"] = set_name\n                            property_mapping[\"@type\"] = mapping_type\n                            business_object_type[\"business_property_groups\"].append(\n                                property_mapping\n                            )\n\n        self.write_status_file(success, section_name, self._business_object_types)\n\n        return self._business_object_types\n\n        # end method definition\n\n    def get_business_object_properties(self, bo_type_name: str) -&gt; dict:\n        \"\"\"Get a dictionary with all property mapping of a business object type.\n           We contruct this dictionary from the two lists for the given\n           business object types (property mapping and property group mappings)\n           These two lists have been created before by process_business_object_types()\n\n           This method is used for creation of business objects in Salesforce.\n\n        Args:\n            bo_type_name (str): Name of the business object type\n\n        Returns:\n            dict: dictionary with keys that are either the attribute name or\n                  a key that is contructed like this: st name + \"-\" + attribute name.\n                  This allows for an easy lookup in mthods that have access to\n                  the category data of business workspaces.\n        \"\"\"\n\n        # Find the matching business object type:\n        business_object_type = next(\n            (\n                item\n                for item in self._business_object_types\n                if item[\"name\"] == bo_type_name\n            ),\n            None,\n        )\n        if not business_object_type:\n            return None\n\n        business_properties = business_object_type.get(\"business_properties\")\n        business_property_groups = business_object_type.get(\"business_property_groups\")\n\n        lookup_dict = {}\n\n        for mapping in business_properties:\n            attribute_name = mapping.get(\"@attributeName\")\n            lookup_dict[attribute_name] = mapping\n\n        for mapping in business_property_groups:\n            set_name = mapping.get(\"@setName\")\n            attribute_name = mapping.get(\"@attributeName\")\n            lookup_dict[set_name + \"-\" + attribute_name] = mapping\n\n        return lookup_dict\n\n        # end method definition\n\n    def process_workspace_types(self, section_name: str = \"workspaceTypes\") -&gt; list:\n        \"\"\"Create a data structure for all workspace types in the Extended ECM system.\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            list: list of workspace types. Each list element is a dict with these values:\n                - id (str)\n                - name (str)\n                - templates (list)\n                    + name (str)\n                    + id\n        \"\"\"\n\n        # If this payload section has been processed successfully before we\n        # still need to read the data structure from the status file and\n        # initialize self._workspace_types:\n        if self.check_status_file(section_name):\n            # read the list from the json file in admin Home\n            # this is important for restart of customizer pod\n            # as this data structure is used later on for workspace processing\n            logger.info(\n                \"Re-Initialize workspace types list from status file -&gt; %s for later use...\",\n                self.get_status_file_name(payload_section_name=section_name),\n            )\n            self._workspace_types = self.get_status_file(section_name)\n            logger.info(\"Found -&gt; %s workspace types.\", str(len(self._workspace_types)))\n            logger.debug(\"Workspace types -&gt; %s\", str(self._workspace_types))\n            return self._workspace_types\n\n        # get all workspace types (these have been created by the transports and are not in the payload!)\n        # we need to do this each time as it needs to work across potential multiple payload files...\n        response = self._otcs.get_workspace_types()\n        if response is None:\n            logger.error(\"No workspace types found!\")\n            self._workspace_types = []\n        else:\n            self._workspace_types = response[\"results\"]\n            logger.info(\"Found -&gt; %s workspace types.\", str(len(self._workspace_types)))\n            logger.debug(\"Workspace types -&gt; %s\", str(self._workspace_types))\n\n        # now we enrich the workspace_type list elments (which are dicts)\n        # with additional dict elements for further processing:\n        for workspace_type in self._workspace_types:\n            workspace_type_id = workspace_type[\"data\"][\"properties\"][\"wksp_type_id\"]\n            logger.info(\"Workspace Type ID -&gt; %s\", workspace_type_id)\n            workspace_type[\"id\"] = workspace_type_id\n            workspace_type_name = workspace_type[\"data\"][\"properties\"][\"wksp_type_name\"]\n            logger.info(\"Workspace Type Name -&gt; %s\", workspace_type_name)\n            workspace_type[\"name\"] = workspace_type_name\n            workspace_templates = workspace_type[\"data\"][\"properties\"][\"templates\"]\n            # Create empty lists of dicts with template names and node IDs:\n            workspace_type[\"templates\"] = []\n            if workspace_templates:\n                # Determine available templates per workspace type (there can be multiple!)\n                for workspace_template in workspace_templates:\n                    workspace_template_id = workspace_template[\"id\"]\n                    workspace_template_name = workspace_template[\"name\"]\n                    logger.info(\n                        \"Found workspace template with name -&gt; %s and ID -&gt; %s\",\n                        workspace_template_name,\n                        workspace_template_id,\n                    )\n                    template = {\n                        \"name\": workspace_template_name,\n                        \"id\": workspace_template_id,\n                    }\n                    workspace_type[\"templates\"].append(template)\n\n                    # Workaround for problem with workspace role inheritance\n                    # which may be related to Transport or REST API: to work-around this we\n                    # push down the workspace roles to the workspace folders explicitly:\n                    response = self._otcs.get_workspace_roles(workspace_template_id)\n\n                    for roles in response[\"results\"]:\n                        role_name = roles[\"data\"][\"properties\"][\"name\"]\n                        role_id = roles[\"data\"][\"properties\"][\"id\"]\n                        permissions = roles[\"data\"][\"properties\"][\"perms\"]\n                        # as get_workspace_roles() delivers permissions as a value (bit encoded)\n                        # we need to convert it to a permissions string list:\n                        permission_string_list = (\n                            self._otcs.convert_permission_value_to_permission_string(\n                                permissions\n                            )\n                        )\n\n                        logger.info(\n                            \"Inherit permissions of workspace template -&gt; %s and role -&gt; %s to workspace folders...\",\n                            workspace_template_name,\n                            role_name,\n                        )\n\n                        # Inherit permissions to folders of workspace template:\n                        response = self._otcs.assign_workspace_permissions(\n                            workspace_template_id,\n                            role_id,\n                            permission_string_list,\n                            1,  # Only sub items - workspace node itself is OK\n                        )\n\n            else:\n                logger.warning(\n                    \"Workspace Types Name -&gt; %s has no templates!\", workspace_type_name\n                )\n                continue\n\n        self.write_status_file(True, section_name, self._workspace_types)\n\n        return self._workspace_types\n\n        # end method definition\n\n    def process_workspace_templates(\n        self, section_name: str = \"workspaceTemplates\"\n    ) -&gt; bool:\n        \"\"\"Process Workspace Template playload. This allows to define role members on\n           template basis. This avoids having to \"pollute\" workspace template templates\n           with user or group information and instead controls this via payload.\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for workspace_template in self._workspace_templates:\n            # Read Workspace Type Name from payload:\n            if not \"type_name\" in workspace_template:\n                logger.error(\n                    \"Workspace template needs a type name! Skipping to next workspace template...\",\n                )\n                success = False\n                continue\n            type_name = workspace_template[\"type_name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in workspace_template and not workspace_template[\"enabled\"]:\n                logger.info(\n                    \"Payload for Workspace Template -&gt; %s is disabled. Skipping to next workspace template...\",\n                    type_name,\n                )\n                continue\n\n            # Read Workspace Template Name from payload:\n            if not \"template_name\" in workspace_template:\n                logger.error(\n                    \"Workspace Template for Workspace Type -&gt; %s needs a template name! Skipping to next workspace template...\",\n                    type_name,\n                )\n                success = False\n                continue\n            template_name = workspace_template[\"template_name\"]\n\n            # Read members from payload:\n            if not \"members\" in workspace_template:\n                logger.info(\n                    \"Workspace template with type -&gt; %s and name -&gt; %s has no members in payload. Skipping to next workspace...\",\n                    type_name,\n                    template_name,\n                )\n                continue\n            members = workspace_template[\"members\"]\n\n            # Find the workspace type with the name given in the _workspace_types\n            # datastructure that has been generated by process_workspace_types() method before:\n            workspace_type = next(\n                (item for item in self._workspace_types if item[\"name\"] == type_name),\n                None,\n            )\n            if workspace_type is None:\n                logger.error(\n                    \"Workspace Type -&gt; %s not found. Skipping to next workspace template...\",\n                    type_name,\n                )\n                success = False\n                continue\n            if workspace_type[\"templates\"] == []:\n                logger.error(\n                    \"Workspace Type -&gt; %s does not have templates. Skipping to next workspace template...\",\n                    type_name,\n                )\n                success = False\n                continue\n\n            workspace_template = next(\n                (\n                    item\n                    for item in workspace_type[\"templates\"]\n                    if item[\"name\"] == template_name\n                ),\n                None,\n            )\n            if workspace_template:  # does this template exist?\n                logger.info(\n                    \"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\n                    template_name,\n                )\n            else:\n                logger.error(\n                    \"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\n                    template_name,\n                )\n                logger.error(\n                    \"Workspace Type -&gt; %s has only these templates -&gt; %s\",\n                    type_name,\n                    workspace_type[\"templates\"],\n                )\n                success = False\n                continue\n\n            template_id = workspace_template[\"id\"]\n\n            workspace_roles = self._otcs.get_workspace_roles(template_id)\n            if workspace_roles is None:\n                logger.info(\n                    \"Workspace Template %s with node Id -&gt; %s has no roles. Skipping to next workspace...\",\n                    template_name,\n                    template_id,\n                )\n                continue\n\n            for member in members:\n                # read user list and role name from payload:\n                member_users = (\n                    member[\"users\"] if member.get(\"users\") else []\n                )  # be careful to avoid key errors as users are optional\n                member_groups = (\n                    member[\"groups\"] if member.get(\"groups\") else []\n                )  # be careful to avoid key errors as groups are optional\n                member_role_name = member[\"role\"]\n\n                if member_role_name == \"\":  # role name is required\n                    logger.error(\n                        \"Members of workspace template -&gt; %s is missing the role name.\",\n                        template_name,\n                    )\n                    success = False\n                    continue\n                if (\n                    member_users == [] and member_groups == []\n                ):  # we either need users or groups (or both)\n                    logger.warning(\n                        \"Role -&gt; %s of workspace template -&gt; %s does not have any members (no users nor groups).\",\n                        member_role_name,\n                        template_name,\n                    )\n                    continue\n\n                role_id = self._otcs.lookup_result_value(\n                    workspace_roles, \"name\", member_role_name, \"id\"\n                )\n                if role_id is None:\n                    #    if member_role is None:\n                    logger.error(\n                        \"Workspace template -&gt; %s does not have a role with name -&gt; %s\",\n                        template_name,\n                        member_role_name,\n                    )\n                    success = False\n                    continue\n                logger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n\n                # Process users as workspace template members:\n                for member_user in member_users:\n                    # find member user in current payload:\n                    member_user_id = next(\n                        (item for item in self._users if item[\"name\"] == member_user),\n                        {},\n                    )\n                    if member_user_id:\n                        user_id = member_user_id[\"id\"]\n                    else:\n                        # If this didn't work, try to get the member user from OTCS. This covers\n                        # cases where the user is system generated or part\n                        # of a former payload processing (thus not in the current payload):\n                        logger.info(\n                            \"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\n                            member_user,\n                        )\n                        response = self._otcs.get_user(member_user)\n                        user_id = self._otcs.lookup_result_value(\n                            response, key=\"name\", value=member_user, return_key=\"id\"\n                        )\n                        if not user_id:\n                            logger.error(\n                                \"Cannot find member user with login -&gt; %s. Skipping...\",\n                                member_user,\n                            )\n                            success = False\n                            continue\n\n                    # Add member if it does not yet exists - suppress warning\n                    # message if user is already in role:\n                    response = self._otcs.add_member_to_workspace(\n                        template_id, int(role_id), user_id, False\n                    )\n                    if response is None:\n                        logger.error(\n                            \"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                            member_user,\n                            user_id,\n                            member_role_name,\n                            template_name,\n                        )\n                        success = False\n                    else:\n                        logger.info(\n                            \"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                            member_user,\n                            user_id,\n                            member_role_name,\n                            template_name,\n                        )\n\n                # Process groups as workspace template members:\n                for member_group in member_groups:\n                    member_group_id = next(\n                        (item for item in self._groups if item[\"name\"] == member_group),\n                        None,\n                    )\n                    if member_group_id is None:\n                        logger.error(\"Cannot find group with name -&gt; %s\", member_group)\n                        success = False\n                        continue\n                    group_id = member_group_id[\"id\"]\n\n                    response = self._otcs.add_member_to_workspace(\n                        template_id, int(role_id), group_id\n                    )\n                    if response is None:\n                        logger.error(\n                            \"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                            member_group_id[\"name\"],\n                            group_id,\n                            member_role_name,\n                            template_name,\n                        )\n                        success = False\n                    else:\n                        logger.info(\n                            \"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                            member_group_id[\"name\"],\n                            group_id,\n                            member_role_name,\n                            template_name,\n                        )\n\n        self.write_status_file(success, section_name, self._workspace_types)\n\n        return success\n\n        # end method definition\n\n    def prepare_workspace_create_form(\n        self,\n        categories: list,\n        template_id: int,\n        ext_system_id: int,\n        bo_type: int,\n        bo_id: int,\n        parent_workspace_node_id: int,\n    ) -&gt; dict | None:\n        \"\"\"Prepare the category structure for the workspace creation.\n\n        Args:\n            categories (list): categories list from workspace payload\n            template_id (int): workspace template ID\n            ext_system_id (int): External system ID\n            bo_type (int): Business Object Type ID\n            bo_id (int): Business Object ID\n            parent_workspace_node_id (int): Parent Workspace ID\n\n        Returns:\n            dict | None: category structure for workspace creation or None\n                         in case of an error.\n        \"\"\"\n\n        category_create_data = {\"categories\": {}}\n\n        response = self._otcs.get_workspace_create_form(\n            template_id=template_id,\n            external_system_id=ext_system_id,\n            bo_type=bo_type,\n            bo_id=bo_id,\n            parent_id=parent_workspace_node_id,\n        )\n        if response is None:\n            logger.error(\n                \"Failed to retrieve create information for template -&gt; %s\",\n                template_id,\n            )\n            return None\n\n        logger.info(\n            \"Successfully retrieved create information for template -&gt; %s\",\n            template_id,\n        )\n\n        # Process category information\n        forms = response[\"forms\"]\n\n        categories_form = {}\n\n        # Typically the the create workspace form delivers 3 forms:\n        # 1. Form for System Attributes (has no role name)\n        # 2. Form for Category Data (role name = \"categories\")\n        # 3. Form for Classifications (role name = \"classifications\")\n        # First we extract these 3 forms:\n        for form in forms:\n            if \"role_name\" in form and form[\"role_name\"] == \"categories\":\n                categories_form = form\n                logger.debug(\"Found Categories form -&gt; %s\", form)\n                continue\n            if \"role_name\" in form and form[\"role_name\"] == \"classifications\":\n                logger.debug(\"Found Classification form -&gt; %s\", form)\n                continue\n            # the remaining option is that this form is the system attributes form:\n            logger.debug(\"Found System Attributes form -&gt; %s\", form)\n\n        # We are just interested in the single category data set (role_name = \"categories\"):\n        data = categories_form[\"data\"]\n        logger.debug(\"Categories data found -&gt; %s\", data)\n        schema = categories_form[\"schema\"][\"properties\"]\n        logger.debug(\"Categories schema found -&gt; %s\", schema)\n        # parallel loop over category data and schema\n        for cat_data, cat_schema in zip(data, schema):\n            logger.info(\"Category ID -&gt; %s\", cat_data)\n            data_attributes = data[cat_data]\n            logger.debug(\"Data Attributes -&gt; %s\", data_attributes)\n            schema_attributes = schema[cat_schema][\"properties\"]\n            logger.debug(\"Schema Attributes -&gt; %s\", schema_attributes)\n            cat_name = schema[cat_schema][\"title\"]\n            logger.info(\"Category name -&gt; %s\", cat_name)\n            # parallel loop over attribute data and schema\n            # Sets with one (fixed) row have type = object\n            # Multi-value Sets with (multiple) rows have type = array and \"properties\" in \"items\" schema\n            # Multi-value attributes have also type = array but NO \"properties\" in \"items\" schema\n            for attr_data, attr_schema in zip(data_attributes, schema_attributes):\n                logger.debug(\"Attribute ID -&gt; %s\", attr_data)\n                logger.debug(\"Attribute Data -&gt; %s\", data_attributes[attr_data])\n                logger.debug(\"Attribute Schema -&gt; %s\", schema_attributes[attr_schema])\n                attr_type = schema_attributes[attr_schema][\"type\"]\n                logger.debug(\"Attribute Type -&gt; %s\", attr_type)\n                if not \"title\" in schema_attributes[attr_schema]:\n                    logger.debug(\"Attribute has no title. Skipping...\")\n                    continue\n                # Check if it is an multi-line set:\n                if attr_type == \"array\" and (\n                    \"properties\" in schema_attributes[attr_schema][\"items\"]\n                ):\n                    set_name = schema_attributes[attr_schema][\"title\"]\n                    logger.info(\"Multi-line Set -&gt; %s\", set_name)\n                    set_data_attributes = data_attributes[\n                        attr_data\n                    ]  # this is a list []\n                    logger.debug(\"Set Data Attributes -&gt; %s\", set_data_attributes)\n                    set_schema_attributes = schema_attributes[attr_schema][\"items\"][\n                        \"properties\"\n                    ]\n                    logger.debug(\"Set Schema Attributes -&gt; %s\", set_schema_attributes)\n                    set_schema_max_rows = schema_attributes[attr_schema][\"items\"][\n                        \"maxItems\"\n                    ]\n                    logger.debug(\"Set Schema Max Rows -&gt; %s\", set_schema_max_rows)\n                    set_data_max_rows = len(set_data_attributes)\n                    logger.debug(\"Set Data Max Rows -&gt; %s\", set_data_max_rows)\n                    row = 1\n                    # it can happen that the payload contains more rows than the\n                    # initial rows in the set data structure. In this case we use\n                    # a copy of the data structure from row 0 as template...\n                    first_row = dict(set_data_attributes[0])\n                    # We don't know upfront how many rows of data we will find in payload\n                    # but we at max process the maxItems specified in the schema:\n                    while row &lt;= set_schema_max_rows:\n                        # Test if we have any payload for this row:\n                        attribute = next(\n                            (\n                                item\n                                for item in categories\n                                if (\n                                    item[\"name\"] == cat_name\n                                    and \"set\"\n                                    in item  # not all items may have a \"set\" key\n                                    and item[\"set\"] == set_name\n                                    and \"row\"\n                                    in item  # not all items may have a \"row\" key\n                                    and item[\"row\"] == row\n                                )\n                            ),\n                            None,\n                        )\n                        # stop if there's no payload for the row:\n                        if attribute is None:\n                            logger.info(\n                                \"No payload found for set -&gt; %s, row -&gt; %s\",\n                                set_name,\n                                row,\n                            )\n                            # we assume that if there's no payload for row n there will be no payload for rows &gt; n\n                            # and break the while loop:\n                            break\n                        # do we need to create a new row in the data set?\n                        elif row &gt; set_data_max_rows:\n                            # use the row we stored above to create a new empty row:\n                            logger.info(\n                                \"Found payload for row -&gt; %s, we need a new data row for it\",\n                                row,\n                            )\n                            logger.info(\n                                \"Adding an additional row -&gt; %s to set data -&gt; %s\",\n                                row,\n                                set_name,\n                            )\n                            # add the empty dict to the list:\n                            set_data_attributes.append(dict(first_row))\n                            set_data_max_rows += 1\n                        else:\n                            logger.info(\n                                \"Found payload for row -&gt; %s %s we can store in existing data row\",\n                                row,\n                                set_name,\n                            )\n                        # traverse all attributes in a single row:\n                        for set_attr_schema in set_schema_attributes:\n                            logger.debug(\n                                \"Set Attribute ID -&gt; %s (row -&gt; %s)\",\n                                set_attr_schema,\n                                row,\n                            )\n                            logger.debug(\n                                \"Set Attribute Schema -&gt; %s (row -&gt; %s)\",\n                                set_schema_attributes[set_attr_schema],\n                                row,\n                            )\n                            set_attr_type = set_schema_attributes[set_attr_schema][\n                                \"type\"\n                            ]\n                            logger.debug(\n                                \"Set Attribute Type -&gt; %s (row -&gt; %s)\",\n                                set_attr_type,\n                                row,\n                            )\n                            set_attr_name = set_schema_attributes[set_attr_schema][\n                                \"title\"\n                            ]\n                            logger.debug(\n                                \"Set Attribute Name -&gt; %s (row -&gt; %s)\",\n                                set_attr_name,\n                                row,\n                            )\n                            # Lookup the attribute with the right category, set, attribute name, and row number in payload:\n                            attribute = next(\n                                (\n                                    item\n                                    for item in categories\n                                    if (\n                                        item[\"name\"] == cat_name\n                                        and \"set\"\n                                        in item  # not all items may have a \"set\" key\n                                        and item[\"set\"] == set_name\n                                        and item[\"attribute\"] == set_attr_name\n                                        and \"row\"\n                                        in item  # not all items may have a \"row\" key\n                                        and item[\"row\"] == row\n                                    )\n                                ),\n                                None,\n                            )\n                            if attribute is None:\n                                logger.warning(\n                                    \"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s not found in payload.\",\n                                    set_name,\n                                    set_attr_name,\n                                    row,\n                                )\n\n                                # need to use row - 1 as index starts with 0 but payload rows start with 1\n                                set_data_attributes[row - 1][set_attr_schema] = \"\"\n                            else:\n                                logger.info(\n                                    \"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s found in payload, value -&gt; %s\",\n                                    set_name,\n                                    set_attr_name,\n                                    row,\n                                    attribute[\"value\"],\n                                )\n                                # Put the value from the payload into data structure\n                                # need to use row - 1 as index starts with 0 but payload rows start with 1\n                                set_data_attributes[row - 1][set_attr_schema] = (\n                                    attribute[\"value\"]\n                                )\n                        row += 1  # continue the while loop with the next row\n                # Check if it is single-line set:\n                elif attr_type == \"object\":\n                    set_name = schema_attributes[attr_schema][\"title\"]\n                    logger.info(\"Single-line Set -&gt; %s\", set_name)\n                    set_data_attributes = data_attributes[attr_data]\n                    logger.debug(\"Set Data Attributes -&gt; %s\", set_data_attributes)\n\n                    set_schema_attributes = schema_attributes[attr_schema][\"properties\"]\n                    logger.debug(\"Set Schema Attributes -&gt; %s\", set_schema_attributes)\n                    for set_attr_data, set_attr_schema in zip(\n                        set_data_attributes, set_schema_attributes\n                    ):\n                        logger.debug(\"Set Attribute ID -&gt; %s\", set_attr_data)\n                        logger.debug(\n                            \"Set Attribute Data -&gt; %s\",\n                            set_data_attributes[set_attr_data],\n                        )\n                        logger.debug(\n                            \"Set Attribute Schema -&gt; %s\",\n                            set_schema_attributes[set_attr_schema],\n                        )\n                        set_attr_type = set_schema_attributes[set_attr_schema][\"type\"]\n                        logger.debug(\"Set Attribute Type -&gt; %s\", set_attr_type)\n                        set_attr_name = set_schema_attributes[set_attr_schema][\"title\"]\n                        logger.debug(\"Set Attribute Name -&gt; %s\", set_attr_name)\n                        # Lookup the attribute with the right category, set and attribute name in payload:\n                        attribute = next(\n                            (\n                                item\n                                for item in categories\n                                if (\n                                    item[\"name\"] == cat_name\n                                    and \"set\"\n                                    in item  # not all items may have a \"set\" key\n                                    and item[\"set\"] == set_name\n                                    and item[\"attribute\"] == set_attr_name\n                                )\n                            ),\n                            None,\n                        )\n                        if attribute is None:\n                            logger.warning(\n                                \"Set -&gt; %s, Attribute -&gt; %s not found in payload.\",\n                                set_name,\n                                set_attr_name,\n                            )\n                            set_data_attributes[set_attr_data] = \"\"\n                        else:\n                            logger.info(\n                                \"Set -&gt; %s, Attribute -&gt; %s found in payload, value -&gt; %s\",\n                                set_name,\n                                set_attr_name,\n                                attribute[\"value\"],\n                            )\n                            # Put the value from the payload into data structure\n                            set_data_attributes[set_attr_data] = attribute[\"value\"]\n                # It is a plain attribute (not inside a set) or it is a multi-value attribute (not inside a set):\n                else:\n                    attr_name = schema_attributes[attr_schema][\"title\"]\n                    logger.debug(\"Attribute Name -&gt; %s\", attr_name)\n                    # Lookup the attribute with the right category and attribute name in payload:\n                    attribute = next(\n                        (\n                            item\n                            for item in categories\n                            if (\n                                item[\"name\"] == cat_name\n                                and item[\"attribute\"] == attr_name\n                            )\n                        ),\n                        None,\n                    )\n                    if attribute is None:\n                        logger.warning(\n                            \"Attribute -&gt; %s not found in payload.\", attr_name\n                        )\n                        data_attributes[attr_data] = \"\"\n                    else:\n                        logger.info(\n                            \"Attribute -&gt; %s found in payload, value -&gt; %s\",\n                            attr_name,\n                            attribute[\"value\"],\n                        )\n                        # We need to handle a very special case here for Extended ECM for Government\n                        # which has an attribute type \"Organizational Unit\" (OU). This is referring to a group ID\n                        # which is not stable across deployments. So we need to lookup the Group ID and add it\n                        # to the data structure. This expects that the payload has the Group Name and not the Group ID\n                        if attr_type == str(11480):\n                            logger.info(\n                                \"Attribute -&gt; %s is is of type -&gt; Organizational Unit (%s). Looking up group ID for group name -&gt; %s\",\n                                attr_name,\n                                attr_type,\n                                attribute[\"value\"],\n                            )\n                            group = self._otcs.get_group(attribute[\"value\"])\n                            group_id = self._otcs.lookup_result_value(\n                                group, \"name\", attribute[\"value\"], \"id\"\n                            )\n\n                            if group_id:\n                                logger.info(\n                                    \"Group for Organizational Unit -&gt; %s has ID -&gt; %s\",\n                                    attribute[\"value\"],\n                                    group_id,\n                                )\n                                # Put the group ID into data structure\n                                data_attributes[attr_data] = str(group_id)\n                            else:\n                                logger.error(\n                                    \"Group for Organizational Unit -&gt; %s does not exist!\",\n                                    attribute[\"value\"],\n                                )\n                                # Clear the value to avoid workspace create failure\n                                data_attributes[attr_data] = \"\"\n                        # handle special case where attribute type is a user picker.\n                        # we expect that the payload includes the login name for this\n                        # (as user IDs are not stable across systems) but then we need\n                        # to lookup the real user ID here:\n                        elif attr_type == \"otcs_user_picker\":\n                            logger.info(\n                                \"Attribute -&gt; %s is is of type -&gt; User Picker (%s). Looking up user ID for user login name -&gt; %s\",\n                                attr_name,\n                                attr_type,\n                                attribute[\"value\"],\n                            )\n                            user = self._otcs.get_user(attribute[\"value\"])\n                            user_id = self._otcs.lookup_result_value(\n                                response=user,\n                                key=\"name\",\n                                value=attribute[\"value\"],\n                                return_key=\"id\",\n                            )\n                            if user_id:\n                                # User has been found - determine ID:\n                                logger.info(\n                                    \"User -&gt; %s has ID -&gt; %s\",\n                                    attribute[\"value\"],\n                                    user_id,\n                                )\n                                # Put the user ID into data structure\n                                data_attributes[attr_data] = str(user_id)\n                            else:\n                                logger.error(\n                                    \"User with login name -&gt; %s does not exist!\",\n                                    attribute[\"value\"],\n                                )\n                                # Clear the value to avoid workspace create failure\n                                data_attributes[attr_data] = \"\"\n                        else:\n                            # Put the value from the payload into data structure\n                            data_attributes[attr_data] = attribute[\"value\"]\n            category_create_data[\"categories\"][cat_data] = data_attributes\n\n        logger.debug(\"Category Create Data -&gt; %s\", category_create_data)\n\n        return category_create_data\n\n        # end method definition\n\n    def get_salesforce_business_object(\n        self, workspace: dict, object_type: str, search_field: str, search_value: str\n    ) -&gt; str | None:\n        \"\"\"_summary_\n\n        Args:\n            workspace (dict): Workspace payload\n            object_type (str): Business Object Type\n            search_field (str): Search field to find business object in external system.\n            search_value (str): Search value to find business object in external system.\n\n        Returns:\n            str | None: technical ID of the business object\n        \"\"\"\n\n        if not self._salesforce:\n            logger.error(\n                \"Salesforce connection not initialized! Cannot connect to Salesforce API!\"\n            )\n            return None\n\n        logger.info(\n            \"Workspaces is connected to Salesforce and we need to lookup the BO ID...\"\n        )\n        salesforce_token = self._salesforce.authenticate()\n        if not salesforce_token:\n            logger.error(\"Failed to authenticate with Salesforce!\")\n            return None\n\n        response = self._salesforce.get_object(\n            object_type=object_type,\n            search_field=search_field,\n            search_value=search_value,\n            result_fields=[\"Id\"],\n        )\n        bo_id = self._salesforce.get_result_value(response, \"Id\")\n        if not bo_id:\n            logger.warning(\n                \"Business object of type -&gt; %s and %s = %s does not exist in Salesforce!\",\n                object_type,\n                search_field,\n                search_value,\n            )\n            logger.info(\"We try to create the Salesforce object...\")\n\n            # Geta helper dict to quickly lookup Salesforce properties\n            # for given set + attribute name:\n            property_lookup = self.get_business_object_properties(\n                bo_type_name=object_type\n            )\n            categories = workspace.get(\"categories\", [])\n            parameter_dict = {}\n            # We process all category entries in workspace payload\n            # and see if we have a matching mapping to a business property\n            # in the BO Type definition:\n            for category in categories:\n                # generate the lookup key:\n                key = \"\"\n                if \"set\" in category:\n                    key += category[\"set\"] + \"-\"\n                key += category.get(\"attribute\")\n                # get the attribute value:\n                value = category.get(\"value\")\n                # lookup the mapping\n                mapping = property_lookup.get(key, None)\n                # Check if we have a mapping:\n                if mapping:\n                    property_name = mapping.get(\"@propertyName\", None)\n                    logger.info(\n                        \"Found business property -&gt; %s for attribute -&gt; %s\",\n                        property_name,\n                        category.get(\"attribute\"),\n                    )\n                    parameter_dict[property_name] = value\n                else:\n                    logger.info(\n                        \"Attribute -&gt; %s (key -&gt; %s) does not have a mapped business property.\",\n                        category.get(\"attribute\"),\n                        key,\n                    )\n\n            if not parameter_dict:\n                logger.warning(\"Cannot create Salesforce object - no parameters found\")\n                return None\n\n            logger.info(\n                \"Create Salesforce object of type -&gt; %s with parameters -&gt; %s\",\n                object_type,\n                str(parameter_dict),\n            )\n            #\n            # Now we try to create the Salesforce object\n            #\n            response = self._salesforce.add_object(\n                object_type=object_type, **parameter_dict\n            )\n            bo_id = self._salesforce.get_result_value(response, \"id\")\n            if bo_id:\n                logger.info(\n                    \"Created Salesforce business object with ID -&gt; %s of type -&gt; %s \",\n                    bo_id,\n                    object_type,\n                )\n            else:\n                logger.error(\n                    \"Failed to create Salesforce business object of type -&gt; %s\",\n                    object_type,\n                )\n        else:\n            logger.info(\n                \"Retrieved ID -&gt; %s for Salesforce object type -&gt; %s (looking up -&gt; %s in field -&gt; %s)\",\n                bo_id,\n                object_type,\n                search_field,\n                search_value,\n            )\n\n        return bo_id\n\n        # end method definition\n\n    def prepare_workspace_business_objects(\n        self, workspace: dict, business_objects: list\n    ) -&gt; list | None:\n        \"\"\"Prepare the business object data for the workspace creation.\n           This supports multiple external system connections. This methods\n           also checks if the external system is reachable and tries to create\n           missing business objects in the leading system if they are missing.\n\n        Args:\n            workspace (dict): Payload data for the Workspace\n            business_objects (list): Payload data for the business object connections.\n\n        Returns:\n            list | None: list of business object data connections (dicts)\n        \"\"\"\n\n        business_object_list = []\n\n        for business_object_data in business_objects:\n            business_object = {}\n\n            name = workspace.get(\"name\")\n\n            # Read business object data from workspace payload.\n            # business_object_data is a dict with 3-5 elements:\n            if \"external_system\" in business_object_data:\n                ext_system_id = business_object_data[\"external_system\"]\n            else:\n                logger.error(\n                    \"Missing External System in Business Object payload for workspace -&gt; %s.\",\n                    name,\n                )\n                continue\n            if \"bo_type\" in business_object_data:\n                bo_type = business_object_data[\"bo_type\"]\n            else:\n                logger.error(\n                    \"Missing Type in Business Object payload for workspace -&gt; %s.\",\n                    name,\n                )\n                continue\n\n            if \"bo_id\" in business_object_data:\n                bo_id = business_object_data[\"bo_id\"]\n                bo_search_field = None\n                bo_search_value = None\n            elif (\n                not \"bo_search_field\" in business_object_data\n                or not \"bo_search_value\" in business_object_data\n            ):\n                logger.error(\n                    \"Missing BO search fields (bo_search_field, bo_search_value) in Business Object payload for workspace -&gt; %s.\",\n                    name,\n                )\n                continue\n            else:\n                bo_search_field = business_object_data[\"bo_search_field\"]\n                bo_search_value = business_object_data[\"bo_search_value\"]\n                bo_id = None\n\n            # Check if external system has been declared in payload:\n            external_system = next(\n                (\n                    item\n                    for item in self._external_systems\n                    if (item[\"external_system_name\"] == ext_system_id)\n                ),\n                None,\n            )\n\n            if not external_system:\n                logger.warning(\n                    \"External System -&gt; %s does not exist. Cannot connect workspace -&gt; %s to -&gt; %s. Create workspace without connection.\",\n                    ext_system_id,\n                    name,\n                    ext_system_id,\n                )\n                continue\n            elif not external_system.get(\"reachable\"):\n                logger.warning(\n                    \"External System -&gt; %s is not reachable. Cannot connect workspace -&gt; %s to -&gt; (%s, %s, %s, %s, %s). Create workspace without connection...\",\n                    ext_system_id,\n                    name,\n                    ext_system_id,\n                    bo_type,\n                    bo_id,\n                    bo_search_field,\n                    bo_search_value,\n                )\n                continue\n            external_system_type = external_system.get(\"external_system_type\", \"\")\n\n            logger.info(\n                \"Workspace -&gt; %s will be connected with external system -&gt; %s (%s) with (type -&gt; %s, id -&gt; %s, search_field -&gt; %s, search_value -&gt; %s)\",\n                name,\n                external_system_type,\n                ext_system_id,\n                bo_type,\n                bo_id,\n                bo_search_field,\n                bo_search_value,\n            )\n\n            # For Salesforce we need to determine the actual business object ID (technical ID):\n            if external_system_type == \"Salesforce\" and not bo_id:\n                bo_id = self.get_salesforce_business_object(\n                    workspace,\n                    object_type=bo_type,\n                    search_field=bo_search_field,\n                    search_value=bo_search_value,\n                )\n                if not bo_id:\n                    continue\n\n            business_object[\"ext_system_id\"] = ext_system_id\n            business_object[\"bo_type\"] = bo_type\n            business_object[\"bo_id\"] = bo_id\n\n            logger.info(\"Add external system -&gt; %s to list.\", bo_type)\n            business_object_list.append(business_object)\n\n        return business_object_list\n\n    def process_workspaces(self, section_name: str = \"workspaces\") -&gt; bool:\n        \"\"\"Process workspaces in payload and create them in Extended ECM.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"workspacesPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n\n        Side Effects:\n            Set workspace[\"nodeId] to the node ID of the created workspace\n        \"\"\"\n\n        if not self._workspaces:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for workspace in self._workspaces:\n            # Read name from payload:\n            if not \"name\" in workspace:\n                logger.error(\"Workspace needs a name! Skipping to next workspace...\")\n                success = False\n                continue\n            name = workspace[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in workspace and not workspace[\"enabled\"]:\n                logger.info(\n                    \"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n                )\n                continue\n\n            # Read Type Name from payload:\n            if not \"type_name\" in workspace:\n                logger.error(\n                    \"Workspace -&gt; %s needs a type name! Skipping to next workspace...\",\n                    name,\n                )\n                success = False\n                continue\n            type_name = workspace[\"type_name\"]\n\n            # We need to do this early to find out if we have a cross-application workspace\n            # and need to continue even if the workspace does exist...\n            if \"business_objects\" in workspace and workspace[\"business_objects\"]:\n                business_objects = workspace[\"business_objects\"]\n\n                business_object_list = self.prepare_workspace_business_objects(\n                    workspace=workspace, business_objects=business_objects\n                )\n                # Check if any of the external systems are avaiable:\n                if business_object_list:\n                    logger.info(\n                        \"Workspace -&gt; %s will be connected to -&gt; %s business object(s).\",\n                        name,\n                        str(len(business_object_list)),\n                    )\n            else:\n                logger.info(\n                    \"Workspace -&gt; %s is not connected to any business object.\", name\n                )\n                business_object_list = []\n\n            # Intialize cross-application workspace to \"off\":\n            ibo_workspace_id = None\n\n            # check if the workspace has been created before (effort to make the customizing code idem-potent)\n            logger.info(\n                \"Check if workspace -&gt; %s of type -&gt; %s does already exist...\",\n                name,\n                type_name,\n            )\n            # Check if workspace does already exist\n            # In case the workspace exists, determine_workspace_id()\n            # also stores the node ID into workspace[\"nodeId\"]\n            workspace_id = self.determine_workspace_id(workspace)\n            if workspace_id:\n                logger.info(\n                    \"Workspace -&gt; %s of type -&gt; %s does already exist and has ID -&gt; %s!\",\n                    name,\n                    type_name,\n                    workspace_id,\n                )\n                # Check if we have an existing workspace that is cross-application.\n                # In this case we cannot just continue.\n                if len(business_object_list) &gt; 1:\n                    ibo_workspace_id = workspace_id\n                    logger.info(\n                        \"This is a cross-application workspace so we cannot skip the creation...\"\n                    )\n                    # We assume the workspace is already conntected to the first BO in the list\n                    # This is a simplifiying assumption and should be enahcned in the future.\n                    business_object_list.pop(0)\n                else:\n                    logger.info(\n                        \"This workspace is NOT a cross-application workspace so we can skip the creation...\"\n                    )\n                    continue\n\n            logger.info(\n                \"Creating new Workspace -&gt; %s; Workspace Type -&gt; %s...\", name, type_name\n            )\n\n            # Read optional description from payload:\n            if not \"description\" in workspace:\n                description = \"\"\n            else:\n                description = workspace[\"description\"]\n\n            # Parent ID is optional and only required if workspace type does not specify a create location.\n            # This is typically the case if it is a nested workspace or workspaces of the same type can be created\n            # in different locations in the Enterprise Workspace:\n            parent_id = workspace[\"parent_id\"] if workspace.get(\"parent_id\") else None\n\n            if parent_id is not None:\n                parent_workspace = next(\n                    (item for item in self._workspaces if item[\"id\"] == parent_id), None\n                )\n                if parent_workspace is None:\n                    logger.error(\n                        \"Parent Workspace with logical ID -&gt; %s not found.\", parent_id\n                    )\n                    success = False\n                    continue\n\n                parent_workspace_node_id = self.determine_workspace_id(parent_workspace)\n                if not parent_workspace_node_id:\n                    logger.warning(\n                        \"Parent Workspace without node ID (parent workspace creation may have failed). Skipping to next workspace...\"\n                    )\n                    success = False\n                    continue\n\n                logger.info(\n                    \"Parent Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\n                    parent_id,\n                    parent_workspace_node_id,\n                )\n            else:\n                # if no parent_id is specified the workspace location is determined by the workspace type definition\n                # and we pass None as parent ID to the get_workspace_create_form and create_workspace methods below:\n                parent_workspace_node_id = None\n\n            # Find the workspace type with the name given in the payload:\n            workspace_type = next(\n                (item for item in self._workspace_types if item[\"name\"] == type_name),\n                None,\n            )\n            if workspace_type is None:\n                logger.error(\n                    \"Workspace Type -&gt; %s not found. Skipping to next workspace...\",\n                    type_name,\n                )\n                success = False\n                continue\n            if workspace_type[\"templates\"] == []:\n                logger.error(\n                    \"Workspace Type -&gt; %s does not have templates. Skipping to next workspace...\",\n                    type_name,\n                )\n                success = False\n                continue\n\n            # check if the template to be used is specified in the payload:\n            if \"template_name\" in workspace:\n                template_name = workspace[\"template_name\"]\n                workspace_template = next(\n                    (\n                        item\n                        for item in workspace_type[\"templates\"]\n                        if item[\"name\"] == template_name\n                    ),\n                    None,\n                )\n                if workspace_template:  # does this template exist?\n                    logger.info(\n                        \"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\n                        template_name,\n                    )\n                else:\n                    logger.error(\n                        \"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\n                        template_name,\n                    )\n                    logger.error(\n                        \"Workspace Type -&gt; %s has only these templates -&gt; %s\",\n                        type_name,\n                        workspace_type[\"templates\"],\n                    )\n                    success = False\n                    continue\n            # template to be used is NOT specified in the payload - then we just take the first one:\n            else:\n                workspace_template = workspace_type[\"templates\"][0]\n                logger.info(\n                    \"Workspace Template has not been specified in payload - we just take the first one (%s)\",\n                    workspace_template,\n                )\n\n            template_id = workspace_template[\"id\"]\n            template_name = workspace_template[\"name\"]\n            workspace_type_id = workspace_type[\"id\"]\n\n            logger.info(\n                \"Create Workspace -&gt; %s (type -&gt; %s) from workspace template -&gt; %s (ID -&gt; %s)\",\n                name,\n                type_name,\n                template_name,\n                template_id,\n            )\n\n            # Handle the case where the workspace is not connected\n            # to any external system / business object:\n            if not business_object_list:\n                business_object_list.append(\n                    {\n                        \"ext_system_id\": None,\n                        \"bo_type\": None,\n                        \"bo_id\": None,\n                    }\n                )\n\n            for business_object in business_object_list:\n                # Read categories from payload:\n                if not \"categories\" in workspace:\n                    logger.info(\n                        \"Workspace payload has no category data! Will leave category attributes empty...\"\n                    )\n                    category_create_data = {}\n                else:\n                    categories = workspace[\"categories\"]\n                    category_create_data = self.prepare_workspace_create_form(\n                        categories=categories,\n                        template_id=template_id,\n                        ext_system_id=business_object[\"ext_system_id\"],\n                        bo_type=business_object[\"bo_type\"],\n                        bo_id=business_object[\"bo_id\"],\n                        parent_workspace_node_id=parent_workspace_node_id,\n                    )\n\n                if ibo_workspace_id:\n                    logger.info(\n                        \"Connect existing workspace to an additional business object (IBO)\"\n                    )\n                # Create the workspace with all provided information:\n                response = self._otcs.create_workspace(\n                    workspace_template_id=template_id,\n                    workspace_name=name,\n                    workspace_description=description,\n                    workspace_type=workspace_type_id,\n                    category_data=category_create_data,\n                    external_system_id=business_object[\"ext_system_id\"],\n                    bo_type=business_object[\"bo_type\"],\n                    bo_id=business_object[\"bo_id\"],\n                    parent_id=parent_workspace_node_id,\n                    ibo_workspace_id=ibo_workspace_id,\n                    show_error=(\n                        not self._sap\n                    ),  # if SAP is active it may produce workspaces concurrently (race condition). Then we don't want to issue errors.\n                )\n                if response is None:\n                    # Check if workspace has been concurrently created by some other\n                    # process (e.g. via SAP or Salesforce). This would be a race condition\n                    # that seems to really occur.\n                    workspace_id = self.determine_workspace_id(workspace)\n                    if workspace_id:\n                        logger.info(\n                            \"Workspace -&gt; %s of type -&gt; %s has been created by an external process and has ID -&gt; %s!\",\n                            name,\n                            type_name,\n                            workspace_id,\n                        )\n                    else:\n                        logger.error(\n                            \"Failed to create workspace -&gt; %s of type -&gt; %s!\",\n                            name,\n                            type_name,\n                        )\n                        success = False\n                        continue\n                else:\n                    # Now we add the node ID of the new workspace to the payload data structure\n                    # This will be reused when creating the workspace relationships!\n                    if not ibo_workspace_id:\n                        workspace[\"nodeId\"] = self._otcs.get_result_value(\n                            response, \"id\"\n                        )\n                        ibo_workspace_id = workspace[\"nodeId\"]\n\n                        # We also get the name the workspace was finally created with.\n                        # This can be different form the name in the payload as additional\n                        # naming conventions from the Workspace Type definitions may apply.\n                        # This is important to make the python container idem-potent.\n                        response = self._otcs.get_workspace(workspace[\"nodeId\"])\n                        workspace[\"name\"] = self._otcs.get_result_value(\n                            response, \"name\"\n                        )\n\n                        logger.info(\n                            \"Successfully created workspace with final name -&gt; %s and node ID -&gt; %s\",\n                            workspace[\"name\"],\n                            workspace[\"nodeId\"],\n                        )\n\n            # Check if there's an workspace nickname configured:\n            if \"nickname\" in workspace:\n                nickname = workspace[\"nickname\"]\n                logger.info(\n                    \"Assign nickname %s to workspace -&gt; %s (%s)...\",\n                    nickname,\n                    name,\n                    workspace[\"nodeId\"],\n                )\n                response = self._otcs.set_node_nickname(\n                    node_id=workspace[\"nodeId\"], nickname=nickname, show_error=True\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to assign nickname -&gt; %s to workspace -&gt; %s\",\n                        nickname,\n                        name,\n                    )\n\n            # Check if there's an workspace icon/image configured:\n            if \"image_nickname\" in workspace:\n                image_nickname = workspace[\"image_nickname\"]\n\n                response = self._otcs.get_node_from_nickname(image_nickname)\n                node_id = self._otcs.get_result_value(response, \"id\")\n                if node_id:\n                    mime_type = self._otcs.get_result_value(response, \"mime_type\")\n                    if not mime_type:\n                        logger.warning(\n                            \"Missing mime type information - assuming image/png\"\n                        )\n                        mime_type = \"image/png\"\n                    file_path = \"/tmp/\" + image_nickname\n                    self._otcs.download_document(node_id=node_id, file_path=file_path)\n                    response = self._otcs.update_workspace_icon(\n                        workspace_id=workspace[\"nodeId\"],\n                        file_path=file_path,\n                        file_mimetype=mime_type,\n                    )\n                    if not response:\n                        logger.error(\n                            \"Failed to assign icon -&gt; %s to workspace -&gt; %s from file -&gt; %s \",\n                            image_nickname,\n                            name,\n                            file_path,\n                        )\n                else:\n                    logger.error(\n                        \"Cannot find workspace image with nickname -&gt; %s for workspace -&gt; %s\",\n                        image_nickname,\n                        name,\n                    )\n\n            # Check if an RM classification is specified for the workspace:\n            # RM Classification is specified as list of path elements (top-down)\n            if (\n                \"rm_classification_path\" in workspace\n                and workspace[\"rm_classification_path\"] != []\n            ):\n                rm_class_node = self._otcs.get_node_by_volume_and_path(\n                    198, workspace[\"rm_classification_path\"]\n                )\n                rm_class_node_id = self._otcs.get_result_value(rm_class_node, \"id\")\n                if rm_class_node_id:\n                    response = self._otcs.assign_rm_classification(\n                        workspace[\"nodeId\"], rm_class_node_id, False\n                    )\n                    if response is None:\n                        logger.error(\n                            \"Failed to assign RM classification -&gt; %s (%s) to workspace -&gt; %s\",\n                            workspace[\"rm_classification_path\"][-1],\n                            rm_class_node_id,\n                            name,\n                        )\n                    else:\n                        logger.info(\n                            \"Assigned RM Classification -&gt; %s to workspace -&gt; %s\",\n                            workspace[\"rm_classification_path\"][-1],\n                            name,\n                        )\n            # Check if one or multiple classifications are specified for the workspace\n            # Classifications are specified as list of path elements (top-down)\n            if (\n                \"classification_pathes\" in workspace\n                and workspace[\"classification_pathes\"] != []\n            ):\n                for classification_path in workspace[\"classification_pathes\"]:\n                    class_node = self._otcs.get_node_by_volume_and_path(\n                        198, classification_path\n                    )\n                    class_node_id = self._otcs.get_result_value(class_node, \"id\")\n                    if class_node_id:\n                        response = self._otcs.assign_classification(\n                            workspace[\"nodeId\"], [class_node_id], False\n                        )\n                        if response is None:\n                            logger.error(\n                                \"Failed to assign classification -&gt; %s to workspace -&gt; %s\",\n                                class_node_id,\n                                name,\n                            )\n                        else:\n                            logger.info(\n                                \"Assigned Classification -&gt; %s to workspace -&gt; %s\",\n                                classification_path[-1],\n                                name,\n                            )\n\n        self.write_status_file(success, section_name, self._workspaces)\n\n        return success\n\n        # end method definition\n\n    def process_workspace_relationships(\n        self, section_name: str = \"workspaceRelationships\"\n    ) -&gt; bool:\n        \"\"\"Process workspaces relationships in payload and create them in Extended ECM.\n\n        Relationships can only be created if all workspaces have been created before.\n        Once a workspace got created, the node ID of that workspaces has been added\n        to the payload[\"workspaces\"] data structure (see process_workspaces())\n        Relationships are created between the node IDs of two business workspaces\n        (and not the logical IDs in the inital payload specification)\n\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._workspaces:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for workspace in self._workspaces:\n            # Read name from payload:\n            if not \"name\" in workspace:\n                continue\n            name = workspace[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in workspace and not workspace[\"enabled\"]:\n                logger.info(\n                    \"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n                )\n                continue\n\n            # Read relationships from payload:\n            if not \"relationships\" in workspace:\n                logger.info(\n                    \"Workspace -&gt; %s has no relationships. Skipping to next workspace...\",\n                    name,\n                )\n                continue\n\n            # Check that workspaces actually have a logical ID -\n            # otherwise we cannot establish the relationship:\n            if not \"id\" in workspace:\n                logger.warning(\n                    \"Workspace without ID cannot have a relationship. Skipping to next workspace...\"\n                )\n                continue\n\n            workspace_id = workspace[\"id\"]\n            logger.info(\"Workspace -&gt; %s has relationships - creating...\", name)\n\n            workspace_node_id = self.determine_workspace_id(workspace)\n            if not workspace_node_id:\n                logger.warning(\n                    \"Workspace without node ID cannot have a relationship (workspace creation may have failed). Skipping to next workspace...\"\n                )\n                continue\n            # now determine the actual node IDs of the workspaces (have been created above):\n            logger.info(\n                \"Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\n                workspace_id,\n                workspace_node_id,\n            )\n\n            for related_workspace_id in workspace[\"relationships\"]:\n                # Find the workspace type with the name given in the payload:\n                related_workspace = next(\n                    (\n                        item\n                        for item in self._workspaces\n                        if item[\"id\"] == related_workspace_id\n                    ),\n                    None,\n                )\n                if related_workspace is None:\n                    logger.error(\n                        \"Related Workspace with logical ID -&gt; %s not found.\",\n                        related_workspace_id,\n                    )\n                    success = False\n                    continue\n\n                if \"enabled\" in related_workspace and not related_workspace[\"enabled\"]:\n                    logger.info(\n                        \"Payload for Related Workspace -&gt; %s is disabled. Skipping...\",\n                        related_workspace[\"name\"],\n                    )\n                    continue\n\n                related_workspace_node_id = self.determine_workspace_id(\n                    related_workspace\n                )\n                if not related_workspace_node_id:\n                    logger.warning(\n                        \"Related Workspace without node ID (workspaces creation may have failed). Skipping to next workspace...\"\n                    )\n                    continue\n\n                logger.info(\n                    \"Related Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\n                    related_workspace_id,\n                    related_workspace_node_id,\n                )\n\n                logger.info(\n                    \"Create Workspace Relationship between workspace node ID -&gt; %s and workspace node ID -&gt; %s\",\n                    workspace_node_id,\n                    related_workspace_node_id,\n                )\n\n                # Check if relationship does already exists:\n                response = self._otcs.get_workspace_relationships(workspace_node_id)\n\n                existing_workspace_relationship = self._otcs.exist_result_item(\n                    response, \"id\", related_workspace_node_id\n                )\n                if existing_workspace_relationship:\n                    logger.info(\n                        \"Workspace relationship between workspace ID -&gt; %s and related workspace ID -&gt; %s does already exist. Skipping...\",\n                        workspace_node_id,\n                        related_workspace_node_id,\n                    )\n                    continue\n\n                response = self._otcs.create_workspace_relationship(\n                    workspace_node_id, related_workspace_node_id\n                )\n                if not response:\n                    logger.error(\"Failed to create workspace relationship.\")\n                    success = False\n                else:\n                    logger.info(\"Successfully created workspace relationship.\")\n\n        self.write_status_file(success, section_name, self._workspaces)\n\n        return success\n\n        # end method definition\n\n    def process_workspace_members(self, section_name: str = \"workspaceMembers\") -&gt; bool:\n        \"\"\"Process workspaces members in payload and create them in Extended ECM.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._workspaces:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for workspace in self._workspaces:\n            # Read name from payload (just for logging):\n            if not \"name\" in workspace:\n                continue\n            workspace_name = workspace[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in workspace and not workspace[\"enabled\"]:\n                logger.info(\n                    \"Payload for Workspace -&gt; %s is disabled. Skipping...\",\n                    workspace_name,\n                )\n                continue\n\n            # Read members from payload:\n            if not \"members\" in workspace:\n                logger.info(\n                    \"Workspace -&gt; %s has no members in payload. Skipping to next workspace...\",\n                    workspace_name,\n                )\n                continue\n            members = workspace[\"members\"]\n\n            workspace_id = workspace[\"id\"]\n            logger.info(\n                \"Workspace -&gt; %s has memberships in payload - establishing...\",\n                workspace_name,\n            )\n\n            workspace_node_id = int(self.determine_workspace_id(workspace))\n            if not workspace_node_id:\n                logger.warning(\n                    \"Workspace without node ID cannot have members (workspaces creation may have failed). Skipping to next workspace...\"\n                )\n                continue\n\n            # now determine the actual node IDs of the workspaces (have been created by process_workspaces()):\n            workspace_node = self._otcs.get_node(workspace_node_id)\n            workspace_owner_id = self._otcs.get_result_value(\n                workspace_node, \"owner_user_id\"\n            )\n            workspace_owner_name = self._otcs.get_result_value(workspace_node, \"owner\")\n\n            workspace_roles = self._otcs.get_workspace_roles(workspace_node_id)\n            if workspace_roles is None:\n                logger.info(\n                    \"Workspace with ID -&gt; %s and node Id -&gt; %s has no roles. Skipping to next workspace...\",\n                    workspace_id,\n                    workspace_node_id,\n                )\n                continue\n\n            # We don't want the workspace creator to be in the leader role\n            # of automatically created workspaces - this can happen because the\n            # creator gets added to the leader role automatically:\n            leader_role_id = self._otcs.lookup_result_value(\n                workspace_roles, \"leader\", True, \"id\"\n            )\n\n            if leader_role_id:\n                leader_role_name = self._otcs.lookup_result_value(\n                    workspace_roles, \"leader\", True, \"name\"\n                )\n                response = self._otcs.remove_member_from_workspace(\n                    workspace_node_id, leader_role_id, workspace_owner_id, False\n                )\n                if response:\n                    logger.info(\n                        \"Removed creator user -&gt; %s (%s) from leader role -&gt; {%s (%s) of workspace -&gt; %s\",\n                        workspace_owner_name,\n                        workspace_owner_id,\n                        leader_role_name,\n                        leader_role_id,\n                        workspace_name,\n                    )\n\n            logger.info(\n                \"Adding members to workspace with ID -&gt; %s and node ID -&gt; %s defined in payload...\",\n                workspace_id,\n                workspace_node_id,\n            )\n\n            for member in members:\n                # read user list and role name from payload:\n                member_users = (\n                    member[\"users\"] if member.get(\"users\") else []\n                )  # be careful to avoid key errors as users are optional\n                member_groups = (\n                    member[\"groups\"] if member.get(\"groups\") else []\n                )  # be careful to avoid key errors as groups are optional\n                member_role_name = member[\"role\"]\n\n                if member_role_name == \"\":  # role name is required\n                    logger.error(\n                        \"Members of workspace -&gt; %s is missing the role name.\",\n                        workspace_name,\n                    )\n                    success = False\n                    continue\n                if (\n                    member_users == [] and member_groups == []\n                ):  # we either need users or groups (or both)\n                    logger.warning(\n                        \"Role -&gt; %s of workspace -&gt; %s does not have any members (no users nor groups).\",\n                        member_role_name,\n                        workspace_name,\n                    )\n                    continue\n\n                role_id = self._otcs.lookup_result_value(\n                    workspace_roles, \"name\", member_role_name, \"id\"\n                )\n                if role_id is None:\n                    #    if member_role is None:\n                    logger.error(\n                        \"Workspace -&gt; %s does not have a role with name -&gt; %s\",\n                        workspace_name,\n                        member_role_name,\n                    )\n                    success = False\n                    continue\n                logger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n\n                # Process users as workspaces members:\n                for member_user in member_users:\n                    # find member user in current payload:\n                    member_user_id = next(\n                        (item for item in self._users if item[\"name\"] == member_user),\n                        {},\n                    )\n                    if member_user_id:\n                        user_id = member_user_id[\"id\"]\n                    else:\n                        # If this didn't work, try to get the member user from OTCS. This covers\n                        # cases where the user is system generated or part\n                        # of a former payload processing (thus not in the current payload):\n                        logger.info(\n                            \"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\n                            member_user,\n                        )\n                        response = self._otcs.get_user(member_user)\n                        user_id = self._otcs.lookup_result_value(\n                            response, key=\"name\", value=member_user, return_key=\"id\"\n                        )\n                        if not user_id:\n                            logger.error(\n                                \"Cannot find member user with login -&gt; %s. Skipping...\",\n                                member_user,\n                            )\n                            continue\n\n                    # Add member if it does not yet exists - suppress warning\n                    # message if user is already in role:\n                    response = self._otcs.add_member_to_workspace(\n                        workspace_node_id, int(role_id), user_id, False\n                    )\n                    if response is None:\n                        logger.error(\n                            \"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                            member_user,\n                            user_id,\n                            member_role_name,\n                            workspace_name,\n                        )\n                        success = False\n                    else:\n                        logger.info(\n                            \"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                            member_user,  # member_user_id[\"name\"],\n                            user_id,\n                            member_role_name,\n                            workspace_name,\n                        )\n\n                # Process groups as workspaces members:\n                for member_group in member_groups:\n                    member_group_id = next(\n                        (item for item in self._groups if item[\"name\"] == member_group),\n                        None,\n                    )\n                    if member_group_id is None:\n                        logger.error(\"Cannot find group with name -&gt; %s\", member_group)\n                        success = False\n                        continue\n                    group_id = member_group_id[\"id\"]\n\n                    response = self._otcs.add_member_to_workspace(\n                        workspace_node_id, int(role_id), group_id\n                    )\n                    if response is None:\n                        logger.error(\n                            \"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                            member_group_id[\"name\"],\n                            group_id,\n                            member_role_name,\n                            workspace_name,\n                        )\n                        success = False\n                    else:\n                        logger.info(\n                            \"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                            member_group_id[\"name\"],\n                            group_id,\n                            member_role_name,\n                            workspace_name,\n                        )\n\n                # Optionally the payload may have a permission list for the role\n                # to change the default permission from the workspace template\n                # to something more specific:\n                member_permissions = member.get(\"permissions\", [])\n                if member_permissions == []:\n                    logger.info(\n                        \"No permission change for workspace -&gt; %s and role -&gt; %s.\",\n                        workspace_name,\n                        member_role_name,\n                    )\n                    continue\n\n                logger.info(\n                    \"Update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s\",\n                    workspace_name,\n                    str(workspace_node_id),\n                    member_role_name,\n                    str(member_permissions),\n                )\n                response = self._otcs.assign_permission(\n                    node_id=workspace_node_id,\n                    assignee_type=\"custom\",\n                    assignee=role_id,\n                    permissions=member_permissions,\n                    apply_to=2,\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s.\",\n                        workspace_name,\n                        str(workspace_node_id),\n                        member_role_name,\n                        str(member_permissions),\n                    )\n                    success = False\n\n        self.write_status_file(success, section_name, self._workspaces)\n\n        return success\n\n        # end method definition\n\n    def process_workspace_member_permissions(\n        self, section_name: str = \"workspaceMemberPermissions\"\n    ) -&gt; bool:\n        \"\"\"Process workspaces members in payload and set their permissions.\n           We need this separate from process_workspace_members() with also\n           sets permissions (if in payload) as we add documents to workspaces with\n           content transports and these documents don't inherit role permissions\n           (this is a transport limitation)\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._workspaces:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for workspace in self._workspaces:\n            # Read name from payload (just for logging):\n            if not \"name\" in workspace:\n                continue\n            workspace_name = workspace[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in workspace and not workspace[\"enabled\"]:\n                logger.info(\n                    \"Payload for Workspace -&gt; %s is disabled. Skipping...\",\n                    workspace_name,\n                )\n                continue\n\n            # Read members from payload:\n            if not \"members\" in workspace:\n                logger.info(\n                    \"Workspace -&gt; %s has no members in payload. No need to update permissions. Skipping to next workspace...\",\n                    workspace_name,\n                )\n                continue\n            members = workspace[\"members\"]\n\n            workspace_id = workspace[\"id\"]\n            workspace_node_id = int(self.determine_workspace_id(workspace))\n            if not workspace_node_id:\n                logger.warning(\n                    \"Workspace without node ID cannot cannot get permission changes (workspaces creation may have failed). Skipping to next workspace...\"\n                )\n                continue\n\n            workspace_roles = self._otcs.get_workspace_roles(workspace_node_id)\n            if workspace_roles is None:\n                logger.info(\n                    \"Workspace with ID -&gt; %s and node Id -&gt; %s has no roles to update permissions. Skipping to next workspace...\",\n                    workspace_id,\n                    workspace_node_id,\n                )\n                continue\n\n            for member in members:\n                # read user list and role name from payload:\n                member_users = (\n                    member[\"users\"] if member.get(\"users\") else []\n                )  # be careful to avoid key errors as users are optional\n                member_groups = (\n                    member[\"groups\"] if member.get(\"groups\") else []\n                )  # be careful to avoid key errors as groups are optional\n                member_role_name = member[\"role\"]\n\n                if member_role_name == \"\":  # role name is required\n                    logger.error(\n                        \"Members of workspace -&gt; %s is missing the role name.\",\n                        workspace_name,\n                    )\n                    success = False\n                    continue\n                if (\n                    member_users == [] and member_groups == []\n                ):  # we either need users or groups (or both)\n                    logger.warning(\n                        \"Role -&gt; %s of workspace -&gt; %s does not have any members (no users nor groups).\",\n                        member_role_name,\n                        workspace_name,\n                    )\n                    continue\n\n                role_id = self._otcs.lookup_result_value(\n                    workspace_roles, \"name\", member_role_name, \"id\"\n                )\n                if role_id is None:\n                    logger.error(\n                        \"Workspace -&gt; %s does not have a role with name -&gt; %s\",\n                        workspace_name,\n                        member_role_name,\n                    )\n                    success = False\n                    continue\n                logger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n\n                member_permissions = member.get(\"permissions\", [])\n                if member_permissions == []:\n                    logger.info(\n                        \"No permission change for workspace -&gt; %s and role -&gt; %s.\",\n                        workspace_name,\n                        member_role_name,\n                    )\n                    continue\n\n                logger.info(\n                    \"Update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s\",\n                    workspace_name,\n                    str(workspace_node_id),\n                    member_role_name,\n                    str(member_permissions),\n                )\n                response = self._otcs.assign_permission(\n                    node_id=workspace_node_id,\n                    assignee_type=\"custom\",\n                    assignee=role_id,\n                    permissions=member_permissions,\n                    apply_to=2,\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s.\",\n                        workspace_name,\n                        str(workspace_node_id),\n                        member_role_name,\n                        str(member_permissions),\n                    )\n                    success = False\n\n        self.write_status_file(success, section_name, self._workspaces)\n\n        return success\n\n        # end method definition\n\n    def process_workspace_aviators(\n        self, section_name: str = \"workspaceAviators\"\n    ) -&gt; bool:\n        \"\"\"Process workspaces Content Aviator settings in payload and enable Aviator for selected workspaces.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._workspaces:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for workspace in self._workspaces:\n            # Read name from payload (just for logging):\n            if not \"name\" in workspace:\n                continue\n            workspace_name = workspace[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in workspace and not workspace[\"enabled\"]:\n                logger.info(\n                    \"Payload for Workspace -&gt; %s is disabled. Skipping...\",\n                    workspace_name,\n                )\n                continue\n\n            # Read Aviator setting from payload:\n            if not \"enable_aviator\" in workspace or not workspace[\"enable_aviator\"]:\n                logger.info(\n                    \"Aviator is not enabled for Workspace -&gt; %s. Skipping to next workspace...\",\n                    workspace_name,\n                )\n                continue\n\n            # We cannot just lookup with workspace.get(\"nodeId\") as the customizer\n            # may have been restarted inbetween - so we use our proper determine_workspace_id\n            # here...\n            workspace_id = self.determine_workspace_id(workspace)\n            if not workspace_id:\n                logger.error(\n                    \"Cannot find node ID for workspace -&gt; %s. Workspace creation may have failed. Skipping to next workspace...\",\n                    workspace_name,\n                )\n                success = False\n                continue\n\n            # Make code idem-potent and check if Aviator is already enabled\n            # for this workspace:\n            if self._otcs.check_workspace_aviator(workspace_id=workspace_id):\n                logger.info(\n                    \"Skip workspace -&gt; %s (%s) as Aviator is already enabled...\",\n                    workspace_name,\n                    workspace_id,\n                )\n                continue\n\n            # Now enable the Content Aviator for the workspace:\n            response = self._otcs.update_workspace_aviator(workspace_id, True)\n            if not response:\n                logger.error(\n                    \"Failed to enable Content Aviator for workspace -&gt; %s (%s)\",\n                    workspace_name,\n                    workspace_id,\n                )\n                success = False\n                continue\n\n        self.write_status_file(success, section_name, self._workspaces)\n\n        return success\n\n        # end method definition\n\n    def process_web_reports(\n        self, web_reports: list, section_name: str = \"webReports\"\n    ) -&gt; bool:\n        \"\"\"Process web reports in payload and run them in Extended ECM.\n\n        Args:\n            web_reports (list): list of web reports. As we have two different list (pre and post)\n                                we need to pass the actual list as parameter.\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webReportsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if a restart of the OTCS pods is required. False otherwise.\n        \"\"\"\n\n        if not web_reports:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n        # If this payload section has been processed successfully before we\n        # can return False and skip processing it once more:\n        if self.check_status_file(section_name):\n            return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n        restart_required: bool = False\n        success: bool = True\n\n        for web_report in web_reports:\n            nick_name = web_report[\"nickname\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in web_report and not web_report[\"enabled\"]:\n                logger.info(\n                    \"Payload for Web Report -&gt; %s is disabled. Skipping...\", nick_name\n                )\n                continue\n\n            description = web_report[\"description\"]\n            restart = web_report.get(\"restart\", False)\n\n            if not self._otcs.get_node_from_nickname(nick_name):\n                logger.error(\n                    \"Web Report with nickname -&gt; %s does not exist! Skipping...\",\n                    nick_name,\n                )\n                success = False\n                continue\n\n            # be careful to avoid key errors as Web Report parameters are optional:\n            actual_params = (\n                web_report[\"parameters\"] if web_report.get(\"parameters\") else {}\n            )\n            formal_params = self._otcs.get_web_report_parameters(nick_name)\n            if actual_params:\n                logger.info(\n                    \"Running Web Report -&gt; %s (%s) with parameters -&gt; %s ...\",\n                    nick_name,\n                    description,\n                    actual_params,\n                )\n                # Do some sanity checks to see if the formal and actual parameters are matching...\n                # Check 1: are there formal parameters at all?\n                if not formal_params:\n                    logger.error(\n                        \"Web Report -&gt; %s is called with actual parameters but it does not expect parameters! Skipping...\",\n                        nick_name,\n                    )\n                    success = False\n                    continue\n                lets_continue = False\n                # Check 2: Iterate through the actual parameters given in the payload\n                # and see if there's a matching formal parameter expected by the Web Report:\n                for key, value in actual_params.items():\n                    # Check if there's a matching formal parameter defined on the Web Report node:\n                    formal_param = next(\n                        (item for item in formal_params if item[\"parm_name\"] == key),\n                        None,\n                    )\n                    if formal_param is None:\n                        logger.error(\n                            \"Web Report -&gt; %s is called with parameter -&gt; %s that is not expected! Value: %s) Skipping...\",\n                            nick_name,\n                            key,\n                            value,\n                        )\n                        success = False\n                        lets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n                # Check 3: Iterate through the formal parameters and validate there's a matching\n                # actual parameter defined in the payload for each mandatory formal parameter\n                # that does not have a default value:\n                for formal_param in formal_params:\n                    if (\n                        (formal_param[\"mandatory\"] is True)\n                        and (formal_param[\"default_value\"] is None)\n                        and not actual_params.get(formal_param[\"parm_name\"])\n                    ):\n                        logger.error(\n                            \"Web Report -&gt; %s is called without mandatory parameter -&gt; %s! Skipping...\",\n                            nick_name,\n                            formal_param[\"parm_name\"],\n                        )\n                        success = False\n                        lets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n                # Did any of the checks fail?\n                if lets_continue:\n                    continue\n                # Actual parameters are validated, we can run the Web Report:\n                response = self._otcs.run_web_report(nick_name, actual_params)\n            else:\n                logger.info(\n                    \"Running Web Report -&gt; %s (%s) without parameters...\",\n                    nick_name,\n                    description,\n                )\n                # Check if there's a formal parameter that is mandatory but\n                # does not have a default value:\n                if formal_params:\n                    required_param = next(\n                        (\n                            item\n                            for item in formal_params\n                            if (item[\"mandatory\"] is True)\n                            and (not item[\"default_value\"])\n                        ),\n                        None,\n                    )\n                    if required_param:\n                        logger.error(\n                            \"Web Report -&gt; %s is called without parameters but has a mandatory parameter -&gt; %s without a default value! Skipping...\",\n                            nick_name,\n                            required_param[\"parm_name\"],\n                        )\n                        success = False\n                        continue\n                    else:  # we are good to proceed!\n                        logger.debug(\n                            \"Web Report -&gt; %s does not have a mandatory parameter without a default value!\",\n                            nick_name,\n                        )\n                response = self._otcs.run_web_report(nick_name)\n            if response is None:\n                logger.error(\"Failed to run web report -&gt; %s\", nick_name)\n                success = False\n\n            if restart:\n                restart_required = True\n\n        self.write_status_file(success, section_name, web_reports)\n\n        return restart_required\n\n        # end method definition\n\n    def process_cs_applications(\n        self, otcs_object: OTCS, section_name: str = \"csApplications\"\n    ) -&gt; bool:\n        \"\"\"Process CS applications in payload and install them in Extended ECM.\n        The CS Applications need to be installed in all frontend and backends.\n\n        Args:\n            otcs_object (object): this can either be the OTCS frontend or OTCS backend. If None\n                                  then the otcs_backend is used.\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._cs_applications:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # OTCS backend is the default:\n        if not otcs_object:\n            otcs_object = self._otcs_backend\n\n        for cs_application in self._cs_applications:\n            application_name = cs_application[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in cs_application and not cs_application[\"enabled\"]:\n                logger.info(\n                    \"Payload for CS Application -&gt; %s is disabled. Skipping...\",\n                    application_name,\n                )\n                continue\n\n            application_description = cs_application[\"description\"]\n\n            logger.info(\n                \"Install CS Application -&gt; %s (%s)...\",\n                application_name,\n                application_description,\n            )\n            response = otcs_object.install_cs_application(application_name)\n            if response is None:\n                logger.error(\n                    \"Failed to install CS Application -&gt; %s!\", application_name\n                )\n                success = False\n\n        self.write_status_file(success, section_name, self._cs_applications)\n\n        return success\n\n        # end method definition\n\n    def process_user_settings(self, section_name: str = \"userSettings\") -&gt; bool:\n        \"\"\"Process user settings in payload and apply themin OTDS.\n           This includes password settings and user display settings.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for user in self._users:\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            user_partition = self._otcs.config()[\"partition\"]\n            if not user_partition:\n                logger.error(\"User partition not found!\")\n                success = False\n                continue\n\n            # Set the OTDS display name. Extended ECM does not use this but\n            # it makes AppWorks display users correctly (and it doesn't hurt)\n            # We only set this if firstname _and_ last name are in the payload:\n            if \"firstname\" in user and \"lastname\" in user:\n                user_display_name = user[\"firstname\"] + \" \" + user[\"lastname\"]\n                response = self._otds.update_user(\n                    user_partition, user_name, \"displayName\", user_display_name\n                )\n                if response:\n                    logger.info(\n                        \"Display name for user -&gt; %s has been updated to -&gt; %s\",\n                        user_name,\n                        user_display_name,\n                    )\n                else:\n                    logger.error(\n                        \"Display name for user -&gt; %s could not be updated to -&gt; %s\",\n                        user_name,\n                        user_display_name,\n                    )\n                    success = False\n\n            # Don't enforce the user to reset password at first login (settings in OTDS):\n            logger.info(\"Don't enforce password change for user -&gt; %s...\", user_name)\n            response = self._otds.update_user(\n                user_partition, user_name, \"UserMustChangePasswordAtNextSignIn\", \"False\"\n            )\n            if not response:\n                success = False\n\n            response = self._otds.update_user(\n                user_partition, user_name, \"UserCannotChangePassword\", \"True\"\n            )\n            if not response:\n                success = False\n\n            # Set user password to never expire\n            response = self._otds.update_user(\n                user_partition, user_name, \"PasswordNeverExpires\", \"True\"\n            )\n            if not response:\n                success = False\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_user_favorites_and_profiles(\n        self, section_name: str = \"userFavoritesAndProfiles\"\n    ) -&gt; bool:\n        \"\"\"Process user favorites in payload and create them in Extended ECM.\n           This method also simulates browsing the favorites to populate the\n           widgets on the landing pages and sets personal preferences.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # We can only set favorites if we impersonate / authenticate as the user.\n        # The following code (for loop) will change the authenticated user - we need to\n        # switch it back to admin user later so we safe the admin credentials for this:\n\n        if self._users:\n            # save admin credentials for later switch back to admin user:\n            admin_credentials = self._otcs.credentials()\n        else:\n            admin_credentials = {}\n\n        for user in self._users:\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            user_password = user[\"password\"]\n\n            # we change the otcs credentials to the user:\n            self._otcs.set_credentials(user_name, user_password)\n\n            # we re-authenticate as the user:\n            logger.info(\"Authenticate user -&gt; %s...\", user_name)\n            # True = force new login with new user\n            cookie = self._otcs.authenticate(revalidate=True)\n            if not cookie:\n                logger.error(\"Couldn't authenticate user -&gt; %s\", user_name)\n                success = False\n                continue\n\n            # we update the user profile to activate responsive (dynamic) containers:\n            response = self._otcs.update_user_profile(\n                field=\"responsiveContainerMode\",\n                value=True,\n                config_section=\"SmartUI\",\n            )\n            if response is None:\n                logger.warning(\n                    \"Profile for user -&gt; %s couldn't be updated with responsive container mode'!\",\n                    user_name,\n                )\n            else:\n                logger.info(\n                    \"Profile for user -&gt; %s has been updated to enable responsive container mode.\",\n                    user_name,\n                )\n            response = self._otcs.update_user_profile(\n                field=\"responsiveContainerMessageMode\",\n                value=True,\n                config_section=\"SmartUI\",\n            )\n            if response is None:\n                logger.warning(\n                    \"Profile for user -&gt; %s couldn't be updated with responsive container message mode'!\",\n                    user_name,\n                )\n            else:\n                logger.info(\n                    \"Profile for user -&gt; %s has been updated to enable messages for responsive container mode.\",\n                    user_name,\n                )\n\n            # we work through the list of favorites defined for the user:\n            favorites = user[\"favorites\"]\n            for favorite in favorites:\n                # check if favorite is a logical workspace name\n                favorite_item = next(\n                    (item for item in self._workspaces if item[\"id\"] == favorite), None\n                )\n                is_workspace = False\n                if favorite_item:\n                    logger.info(\n                        \"Found favorite item (workspace) in payload -&gt; %s\",\n                        favorite_item[\"name\"],\n                    )\n                    favorite_id = self.determine_workspace_id(favorite_item)\n                    if not favorite_id:\n                        logger.warning(\n                            \"Workspace of type -&gt; %s and name -&gt; %s does not exist. Cannot create favorite. Skipping...\",\n                            favorite_item[\"type_name\"],\n                            favorite_item[\"name\"],\n                        )\n                        continue\n\n                    is_workspace = True\n                else:\n                    # alternatively try to find the item as a nickname:\n                    favorite_item = self._otcs.get_node_from_nickname(favorite)\n                    favorite_id = self._otcs.get_result_value(favorite_item, \"id\")\n                    #                    if favorite_item is None:\n                    if favorite_id is None:\n                        logger.warning(\n                            \"Favorite -&gt; %s neither found as workspace ID nor as nickname. Skipping to next favorite...\",\n                            favorite,\n                        )\n                        continue\n\n                response = self._otcs.add_favorite(favorite_id)\n                if response is None:\n                    logger.warning(\n                        \"Favorite ID -&gt; %s couldn't be added for user -&gt; %s!\",\n                        favorite_id,\n                        user_name,\n                    )\n                else:\n                    logger.info(\n                        \"Added favorite for user -&gt; %s, node ID -&gt; %s.\",\n                        user_name,\n                        favorite_id,\n                    )\n                    logger.info(\n                        \"Simulate user -&gt; %s browsing node ID -&gt; %s.\",\n                        user_name,\n                        favorite_id,\n                    )\n                    # simulate a browse by the user to populate recently accessed items\n                    if is_workspace:\n                        response = self._otcs.get_workspace(favorite_id)\n                    else:\n                        response = self._otcs.get_node(favorite_id)\n\n            # we work through the list of proxies defined for the user\n            # (we need to consider that not all users have the proxies element):\n            proxies = user[\"proxies\"] if user.get(\"proxies\") else []\n\n            for proxy in proxies:\n                proxy_user = next(\n                    (item for item in self._users if item[\"name\"] == proxy),\n                    None,\n                )\n                if not proxy_user or not \"id\" in proxy_user:\n                    logger.error(\n                        \"The proxy -&gt; %s for user -&gt; %s does not exist! Skipping proxy...\",\n                        proxy,\n                        user_name,\n                    )\n                    success = False\n                    continue\n                proxy_user_id = proxy_user[\"id\"]\n\n                # Check if the proxy is already set:\n                if not self._otcs.is_proxy(proxy):\n                    logger.info(\n                        \"Set user -&gt; %s (%s) as proxy for user -&gt; %s.\",\n                        proxy,\n                        proxy_user_id,\n                        user_name,\n                    )\n                    # set the user proxy - currently we don't support time based proxies in payload.\n                    # The called method is ready to support this.\n                    response = self._otcs.add_user_proxy(proxy_user_id)\n                else:\n                    logger.info(\n                        \"User -&gt; %s (%s) is already proxy for user -&gt; %s. Skipping...\",\n                        proxy,\n                        proxy_user_id,\n                        user_name,\n                    )\n        if self._users:\n            # Set back admin credentials:\n            self._otcs.set_credentials(\n                admin_credentials[\"username\"], admin_credentials[\"password\"]\n            )\n\n            # we re-authenticate as the admin user:\n            logger.info(\n                \"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n            )\n            # True = force new login with new user\n            cookie = self._otcs.authenticate(revalidate=True)\n\n        # Also for the admin user we want to update the user profile to activate responsive (dynamic) containers:\n        response = self._otcs.update_user_profile(\n            field=\"responsiveContainerMode\",\n            value=True,\n            config_section=\"SmartUI\",\n        )\n        if response is None:\n            logger.warning(\n                \"Profile for admin user couldn't be updated with responsive container mode'!\",\n            )\n        else:\n            logger.info(\n                \"Profile for admin user has been updated to enable responsive container mode.\",\n            )\n        response = self._otcs.update_user_profile(\n            field=\"responsiveContainerMessageMode\",\n            value=True,\n            config_section=\"SmartUI\",\n        )\n        if response is None:\n            logger.warning(\n                \"Profile for admin user couldn't be updated with responsive container message mode'!\",\n            )\n        else:\n            logger.info(\n                \"Profile for admin user has been updated to enable messages for responsive container mode.\",\n            )\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_security_clearances(\n        self, section_name: str = \"securityClearances\"\n    ) -&gt; bool:\n        \"\"\"Process Security Clearances for Extended ECM.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._security_clearances:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for security_clearance in self._security_clearances:\n            clearance_level = security_clearance.get(\"level\")\n            clearance_name = security_clearance.get(\"name\")\n\n            if \"enabled\" in security_clearance and not security_clearance[\"enabled\"]:\n                logger.info(\n                    \"Payload for Security Clearance -&gt; %s is disabled. Skipping...\",\n                    clearance_name,\n                )\n                continue\n\n            clearance_description = security_clearance.get(\"description\")\n            if not clearance_description:\n                clearance_description = \"\"\n            if clearance_level and clearance_name:\n                logger.info(\n                    \"Creating Security Clearance -&gt; %s : %s\",\n                    clearance_level,\n                    clearance_name,\n                )\n                self._otcs.run_web_report(\n                    \"web_report_security_clearance\", security_clearance\n                )\n            else:\n                logger.error(\n                    \"Cannot create Security Clearance - either level or name is missing!\"\n                )\n                success = False\n\n        self.write_status_file(success, section_name, self._security_clearances)\n\n        return success\n\n        # end method definition\n\n    def process_supplemental_markings(\n        self, section_name: str = \"supplementalMarkings\"\n    ) -&gt; bool:\n        \"\"\"Process Supplemental Markings for Extended ECM.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._supplemental_markings:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for supplemental_marking in self._supplemental_markings:\n            code = supplemental_marking.get(\"code\")\n\n            if (\n                \"enabled\" in supplemental_marking\n                and not supplemental_marking[\"enabled\"]\n            ):\n                logger.info(\n                    \"Payload for Supplemental Marking -&gt; %s is disabled. Skipping...\",\n                    code,\n                )\n                continue\n\n            description = supplemental_marking.get(\"description\")\n            if not description:\n                description = \"\"\n            if code:\n                logger.info(\n                    \"Creating Supplemental Marking -&gt; %s : %s\", code, description\n                )\n                self._otcs.run_web_report(\n                    \"web_report_supplemental_marking\", supplemental_marking\n                )\n            else:\n                logger.error(\n                    \"Cannot create Supplemental Marking - either code or description is missing!\"\n                )\n                success = False\n\n        self.write_status_file(success, section_name, self._supplemental_markings)\n\n        return success\n\n        # end method definition\n\n    def process_user_security(self, section_name: str = \"userSecurity\"):\n        \"\"\"Process Security Clearance and Supplemental Markings for Extended ECM users.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for user in self._users:\n            user_id = user.get(\"id\")\n            user_name = user.get(\"name\")\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            # Read security clearance from user payload (it is optional!)\n            user_security_clearance = user.get(\"security_clearance\")\n            if user_id and user_security_clearance:\n                self._otcs.assign_user_security_clearance(\n                    user_id, user_security_clearance\n                )\n\n            # Read supplemental markings from user payload (it is optional!)\n            user_supplemental_markings = user.get(\"supplemental_markings\")\n            if user_id and user_supplemental_markings:\n                self._otcs.assign_user_supplemental_markings(\n                    user_id, user_supplemental_markings\n                )\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_records_management_settings(\n        self, section_name: str = \"recordsManagementSettings\"\n    ) -&gt; bool:\n        \"\"\"Process Records Management Settings for Extended ECM.\n        The setting files need to be placed in the OTCS file system file via\n        a transport into the Support Asset Volume.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._records_management_settings:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        if (\n            \"records_management_system_settings\" in self._records_management_settings\n            and self._records_management_settings[\"records_management_system_settings\"]\n            != \"\"\n        ):\n            filename = (\n                self._custom_settings_dir\n                + self._records_management_settings[\n                    \"records_management_system_settings\"\n                ]\n            )\n            response = self._otcs.import_records_management_settings(filename)\n            if not response:\n                success = False\n\n        if (\n            \"records_management_codes\" in self._records_management_settings\n            and self._records_management_settings[\"records_management_codes\"] != \"\"\n        ):\n            filename = (\n                self._custom_settings_dir\n                + self._records_management_settings[\"records_management_codes\"]\n            )\n            response = self._otcs.import_records_management_codes(filename)\n            if not response:\n                success = False\n\n        if (\n            \"records_management_rsis\" in self._records_management_settings\n            and self._records_management_settings[\"records_management_rsis\"] != \"\"\n        ):\n            filename = (\n                self._custom_settings_dir\n                + self._records_management_settings[\"records_management_rsis\"]\n            )\n            response = self._otcs.import_records_management_rsis(filename)\n            if not response:\n                success = False\n\n        if (\n            \"physical_objects_system_settings\" in self._records_management_settings\n            and self._records_management_settings[\"physical_objects_system_settings\"]\n            != \"\"\n        ):\n            filename = (\n                self._custom_settings_dir\n                + self._records_management_settings[\"physical_objects_system_settings\"]\n            )\n            response = self._otcs.import_physical_objects_settings(filename)\n            if not response:\n                success = False\n\n        if (\n            \"physical_objects_codes\" in self._records_management_settings\n            and self._records_management_settings[\"physical_objects_codes\"] != \"\"\n        ):\n            filename = (\n                self._custom_settings_dir\n                + self._records_management_settings[\"physical_objects_codes\"]\n            )\n            response = self._otcs.import_physical_objects_codes(filename)\n            if not response:\n                success = False\n\n        if (\n            \"physical_objects_locators\" in self._records_management_settings\n            and self._records_management_settings[\"physical_objects_locators\"] != \"\"\n        ):\n            filename = (\n                self._custom_settings_dir\n                + self._records_management_settings[\"physical_objects_locators\"]\n            )\n            response = self._otcs.import_physical_objects_locators(filename)\n            if not response:\n                success = False\n\n        if (\n            \"security_clearance_codes\" in self._records_management_settings\n            and self._records_management_settings[\"security_clearance_codes\"] != \"\"\n        ):\n            filename = (\n                self._custom_settings_dir\n                + self._records_management_settings[\"security_clearance_codes\"]\n            )\n            response = self._otcs.import_security_clearance_codes(filename)\n            if not response:\n                success = False\n\n        self.write_status_file(success, section_name, self._records_management_settings)\n\n        return success\n\n        # end method definition\n\n    def process_holds(self, section_name: str = \"holds\") -&gt; bool:\n        \"\"\"Process Records Management Holds for Extended ECM users.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._holds:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for hold in self._holds:\n            if not \"name\" in hold:\n                logger.error(\"Cannot create Hold without a name! Skipping...\")\n                continue\n            hold_name = hold[\"name\"]\n\n            if not \"type\" in hold:\n                logger.error(\n                    \"Cannot create Hold -&gt; %s without a type! Skipping...\", hold_name\n                )\n                success = False\n                continue\n            hold_type = hold[\"type\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in hold and not hold[\"enabled\"]:\n                logger.info(\n                    \"Payload for Hold -&gt; %s is disabled. Skipping...\", hold_name\n                )\n                continue\n\n            hold_group = hold.get(\"group\")\n            hold_comment = hold.get(\"comment\")\n            hold_alternate_id = hold.get(\"alternate_id\")\n            hold_date_applied = hold.get(\"date_applied\")\n            hold_date_suspend = hold.get(\"date_to_remove\")\n\n            # 550 is the RM Volume\n            response = self._otcs.get_node_by_volume_and_path(550, [\"Hold Maintenance\"])\n            if not response:\n                logger.error(\"Cannot find Records Management Volume!\")\n                continue\n            holds_maintenance_id = self._otcs.get_result_value(response, \"id\")\n            if not holds_maintenance_id:\n                logger.error(\n                    \"Cannot find Holds Maintenance folder in Records Management Volume!\"\n                )\n                continue\n\n            if hold_group:\n                # Check if the Hold Group (folder) does already exist.\n                response = self._otcs.get_node_by_parent_and_name(\n                    holds_maintenance_id, hold_group\n                )\n                parent_id = self._otcs.get_result_value(response, \"id\")\n                if not parent_id:\n                    response = self._otcs.create_item(\n                        holds_maintenance_id, \"833\", hold_group\n                    )\n                    parent_id = self._otcs.get_result_value(response, \"id\")\n                    if not parent_id:\n                        logger.error(\"Failed to create hold group -&gt; %s\", hold_group)\n                        continue\n            else:\n                parent_id = holds_maintenance_id\n\n            # Holds are special - they ahve folders that cannot be traversed\n            # in the normal way - we need to get the whole list of holds and use\n            # specialparameters for the exist_result_items() method as the REST\n            # API calls delivers a results-&gt;data-&gt;holds structure (not properties)\n            response = self._otcs.get_records_management_holds()\n            if self._otcs.exist_result_item(\n                response, \"HoldName\", hold_name, property_name=\"holds\"\n            ):\n                logger.info(\"Hold -&gt; %s does already exist. Skipping...\", hold_name)\n                continue\n\n            hold = self._otcs.create_records_management_hold(\n                hold_type,\n                hold_name,\n                hold_comment,\n                hold_alternate_id,\n                int(parent_id),\n                hold_date_applied,\n                hold_date_suspend,\n            )\n\n            if hold and hold[\"holdID\"]:\n                logger.info(\n                    \"Successfully created hold -&gt; %s with ID -&gt; %s\",\n                    hold_name,\n                    hold[\"holdID\"],\n                )\n            else:\n                success = False\n\n        self.write_status_file(success, section_name, self._holds)\n\n        return success\n\n        # end method definition\n\n    def process_additional_group_members(\n        self, section_name: str = \"additionalGroupMemberships\"\n    ) -&gt; bool:\n        \"\"\"Process additional groups memberships we want to have in OTDS.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._additional_group_members:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for additional_group_member in self._additional_group_members:\n            if not \"parent_group\" in additional_group_member:\n                logger.error(\"Missing parent_group! Skipping...\")\n                continue\n            parent_group = additional_group_member[\"parent_group\"]\n\n            if (\n                \"enabled\" in additional_group_member\n                and not additional_group_member[\"enabled\"]\n            ):\n                logger.info(\n                    \"Payload for Additional Group Member with Parent Group -&gt; %s is disabled. Skipping...\",\n                    parent_group,\n                )\n                continue\n\n            if (not \"user_name\" in additional_group_member) and (\n                not \"group_name\" in additional_group_member\n            ):\n                logger.error(\n                    \"Either group_name or user_name need to be specified! Skipping...\"\n                )\n                success = False\n                continue\n            if \"group_name\" in additional_group_member:\n                group_name = additional_group_member[\"group_name\"]\n                logger.info(\n                    \"Adding group -&gt; %s to parent group -&gt; %s in OTDS.\",\n                    group_name,\n                    parent_group,\n                )\n                response = self._otds.add_group_to_parent_group(\n                    group_name, parent_group\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to add group -&gt; %s to parent group -&gt; %s in OTDS.\",\n                        group_name,\n                        parent_group,\n                    )\n                    success = False\n            elif \"user_name\" in additional_group_member:\n                user_name = additional_group_member[\"user_name\"]\n                logger.info(\n                    \"Adding user -&gt; %s to group -&gt; %s in OTDS.\", user_name, parent_group\n                )\n                response = self._otds.add_user_to_group(user_name, parent_group)\n                if not response:\n                    logger.error(\n                        \"Failed to add user -&gt; %s to group -&gt; %s in OTDS.\",\n                        user_name,\n                        parent_group,\n                    )\n                    success = False\n\n        self.write_status_file(success, section_name, self._additional_group_members)\n\n        return success\n\n        # end method definition\n\n    def process_additional_access_role_members(\n        self, section_name: str = \"additionalAccessRoleMemberships\"\n    ) -&gt; bool:\n        \"\"\"Process additional access role memberships we want to have in OTDS.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._additional_access_role_members:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for additional_access_role_member in self._additional_access_role_members:\n            if not \"access_role\" in additional_access_role_member:\n                logger.error(\"Missing access_role! Skipping...\")\n                continue\n            access_role = additional_access_role_member[\"access_role\"]\n\n            if (\n                \"enabled\" in additional_access_role_member\n                and not additional_access_role_member[\"enabled\"]\n            ):\n                logger.info(\n                    \"Payload for Additional Member for AccessRole -&gt; %s is disabled. Skipping...\",\n                    access_role,\n                )\n                continue\n\n            if (\n                (not \"user_name\" in additional_access_role_member)\n                and (not \"group_name\" in additional_access_role_member)\n                and (not \"partition_name\" in additional_access_role_member)\n            ):\n                logger.error(\n                    \"Either group_name or user_name need to be specified! Skipping...\"\n                )\n                success = False\n                continue\n            if \"group_name\" in additional_access_role_member:\n                group_name = additional_access_role_member[\"group_name\"]\n                logger.info(\n                    \"Adding group -&gt; %s to access role -&gt; %s in OTDS.\",\n                    group_name,\n                    access_role,\n                )\n                response = self._otds.add_group_to_access_role(access_role, group_name)\n                if not response:\n                    logger.error(\n                        \"Failed to add group -&gt; %s to access role -&gt; %s in OTDS.\",\n                        group_name,\n                        access_role,\n                    )\n                    success = False\n            elif \"user_name\" in additional_access_role_member:\n                user_name = additional_access_role_member[\"user_name\"]\n                logger.info(\n                    \"Adding user -&gt; %s to access role -&gt; %s in OTDS.\",\n                    user_name,\n                    access_role,\n                )\n                response = self._otds.add_user_to_access_role(access_role, user_name)\n                if not response:\n                    logger.error(\n                        \"Failed to add user -&gt; %s to access role -&gt; %s in OTDS.\",\n                        user_name,\n                        access_role,\n                    )\n                    success = False\n            elif \"partition_name\" in additional_access_role_member:\n                partition_name = additional_access_role_member[\"partition_name\"]\n                logger.info(\n                    \"Adding partition -&gt; %s to access role -&gt; %s in OTDS.\",\n                    partition_name,\n                    access_role,\n                )\n                response = self._otds.add_partition_to_access_role(\n                    access_role, partition_name\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to add partition -&gt; %s to access role -&gt; %s in OTDS.\",\n                        partition_name,\n                        access_role,\n                    )\n                    success = False\n\n        self.write_status_file(\n            success, section_name, self._additional_access_role_members\n        )\n\n        return success\n\n        # end method definition\n\n    def process_renamings(self, section_name: str = \"renamings\") -&gt; bool:\n        \"\"\"Process renamings specified in payload and rename existing Extended ECM items.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._renamings:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for renaming in self._renamings:\n            if not \"nodeid\" in renaming:\n                if not \"volume\" in renaming:\n                    logger.error(\n                        \"Renamings require either a node ID or a volume! Skipping to next renaming...\"\n                    )\n                    continue\n                # Determine object ID of volume:\n                volume = self._otcs.get_volume(renaming[\"volume\"])\n                node_id = self._otcs.get_result_value(volume, \"id\")\n            else:\n                node_id = renaming[\"nodeid\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in renaming and not renaming[\"enabled\"]:\n                logger.info(\"Payload for Renaming is disabled. Skipping...\")\n                continue\n\n            response = self._otcs.rename_node(\n                int(node_id), renaming[\"name\"], renaming[\"description\"]\n            )\n            if not response:\n                logger.error(\n                    \"Failed to rename node ID -&gt; %s to new name -&gt; %s.\",\n                    node_id,\n                    renaming[\"name\"],\n                )\n                success = False\n\n        self.write_status_file(success, section_name, self._renamings)\n\n        return success\n\n        # end method definition\n\n    def process_items(self, items: list, section_name: str = \"items\") -&gt; bool:\n        \"\"\"Process items specified in payload and create them in Extended ECM.\n\n        Args:\n            items (list): list of items to create (need this as parameter as we\n                          have multiple lists)\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"itemsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not items:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for item in items:\n            if not \"name\" in item:\n                logger.error(\"Item needs a name. Skipping...\")\n                continue\n            item_name = item[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in item and not item[\"enabled\"]:\n                logger.info(\n                    \"Payload for Item -&gt; %s is disabled. Skipping...\", item_name\n                )\n                continue\n\n            if not \"description\" in item:\n                item_description = \"\"\n            else:\n                item_description = item[\"description\"]\n\n            parent_nickname = item.get(\"parent_nickname\")\n            parent_path = item.get(\"parent_path\")\n\n            if parent_nickname:\n                parent_node = self._otcs.get_node_from_nickname(parent_nickname)\n                parent_id = self._otcs.get_result_value(parent_node, \"id\")\n                # if not parent_node:\n                if not parent_id:\n                    logger.error(\n                        \"Item -&gt; %s has a parent nickname -&gt; %s that does not exist. Skipping...\",\n                        item_name,\n                        parent_nickname,\n                    )\n                    success = False\n                    continue\n            else:  # use parent_path and Enterprise Volume\n                parent_node = self._otcs.get_node_by_volume_and_path(141, parent_path)\n                parent_id = self._otcs.get_result_value(parent_node, \"id\")\n                if not parent_id:\n                    # if not parent_node:\n                    logger.error(\n                        \"Item -&gt; %s has a parent path that does not exist. Skipping...\",\n                        item_name,\n                    )\n                    success = False\n                    continue\n\n            original_nickname = item.get(\"original_nickname\")\n            original_path = item.get(\"original_path\")\n\n            if original_nickname:\n                original_node = self._otcs.get_node_from_nickname(original_nickname)\n                original_id = self._otcs.get_result_value(original_node, \"id\")\n                if not original_id:\n                    # if not original_node:\n                    logger.error(\n                        \"Item -&gt; %s has a original nickname -&gt; %s that does not exist. Skipping...\",\n                        item_name,\n                        original_nickname,\n                    )\n                    success = False\n                    continue\n            elif original_path:\n                original_node = self._otcs.get_node_by_volume_and_path(\n                    141, original_path\n                )\n                original_id = self._otcs.get_result_value(original_node, \"id\")\n                if not original_id:\n                    # if not original_node:\n                    logger.error(\n                        \"Item -&gt; %s has a original path that does not exist. Skipping...\",\n                        item_name,\n                    )\n                    success = False\n                    continue\n            else:\n                original_id = 0\n\n            if not \"type\" in item:\n                logger.error(\"Item -&gt; %s needs a type. Skipping...\", item_name)\n                success = False\n                continue\n\n            item_type = item.get(\"type\")\n            item_url = item.get(\"url\")\n\n            # check that we have the required information\n            # for the given item type:\n            match item_type:\n                case 140:  # URL\n                    if item_url == \"\":\n                        logger.error(\n                            \"Item -&gt; %s has type URL but the URL is not in the payload. Skipping...\",\n                            item_name,\n                        )\n                        success = False\n                        continue\n                case 1:  # Shortcut\n                    if original_id == 0:\n                        logger.error(\n                            \"Item -&gt; %s has type Shortcut but the original item is not in the payload. Skipping...\",\n                            item_name,\n                        )\n                        success = False\n                        continue\n\n            # Check if an item with the same name does already exist.\n            # This can also be the case if the python container runs a 2nd time.\n            # For this reason we are also not issuing an error but just an info (False):\n            response = self._otcs.get_node_by_parent_and_name(\n                int(parent_id), item_name, show_error=False\n            )\n            if self._otcs.get_result_value(response, \"name\") == item_name:\n                logger.info(\n                    \"Item with name -&gt; %s does already exist in parent folder with ID -&gt; %s\",\n                    item_name,\n                    parent_id,\n                )\n                continue\n            response = self._otcs.create_item(\n                int(parent_id),\n                str(item_type),\n                item_name,\n                item_description,\n                item_url,\n                int(original_id),\n            )\n            if not response:\n                logger.error(\"Failed to create item -&gt; %s.\", item_name)\n                success = False\n\n        self.write_status_file(success, section_name, items)\n\n        return success\n\n        # end method definition\n\n    def process_permissions(\n        self, permissions: list, section_name: str = \"permissions\"\n    ) -&gt; bool:\n        \"\"\"Process items specified in payload and upadate permissions.\n\n        Args:\n            permissions (list): list of items to apply permissions to.\n                         Each list item in the payload is a dict with this structure:\n                            {\n                                nodeid = \"...\"\n                                volume = \"...\"\n                                nickname = \"...\"\n                                public_access_permissions = [\"see\", \"see_content\", ...]\n                                owner_permissions = []\n                                owner_group_permissions = []\n                                groups = [\n                                {\n                                    name = \"...\"\n                                    permissions = []\n                                }\n                                ]\n                                users = [\n                                {\n                                    name = \"...\"\n                                    permissions = []\n                                }\n                                ]\n                                apply_to = 2\n                            }\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"permissionsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not permissions:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for permission in permissions:\n            if (\n                not \"path\" in permission\n                and not \"volume\" in permission\n                and not \"nickname\" in permission\n            ):\n                logger.error(\n                    \"Item to change permission is not specified (needs path, volume, or nickname). Skipping...\"\n                )\n                success = False\n                continue\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in permission and not permission[\"enabled\"]:\n                logger.info(\"Payload for Permission is disabled. Skipping...\")\n                continue\n\n            node_id = 0\n\n            # Check if \"volume\" is in payload and not empty string\n            # we try to get the node ID from the volume type:\n            if \"volume\" in permission and permission[\"volume\"]:\n                volume_type = permission[\"volume\"]\n                logger.info(\n                    \"Found volume type -&gt; %s in permission definition. Determine volume ID...\",\n                    volume_type,\n                )\n                node = self._otcs.get_volume(volume_type)\n                node_id = self._otcs.get_result_value(node, \"id\")\n                if not node_id:\n                    logger.error(\n                        \"Illegal volume -&gt; %s in permission specification. Skipping...\",\n                        volume_type,\n                    )\n                    success = False\n                    continue\n            else:\n                # the following path block requires\n                # a value for the volume - if it is\n                # not specified we take the Enterprise Workspace (141):\n                volume_type = 141\n\n            # Check if \"path\" is in payload and not empty list\n            # (path can be combined with volume so we need to take volume into account):\n            if \"path\" in permission and permission[\"path\"]:\n                path = permission[\"path\"]\n                logger.info(\n                    \"Found path -&gt; %s in permission definition. Determine node ID...\",\n                    path,\n                )\n                node = self._otcs.get_node_by_volume_and_path(volume_type, path)\n                node_id = self._otcs.get_result_value(node, \"id\")\n                if not node_id:\n                    logger.error(\"Path -&gt; %s does not exist. Skipping...\", path)\n                    success = False\n                    continue\n\n            # Check if \"nickname\" is in payload and not empty string:\n            if \"nickname\" in permission and permission[\"nickname\"]:\n                nickname = permission[\"nickname\"]\n                logger.info(\n                    \"Found nickname -&gt; %s in permission definition. Determine node ID...\",\n                    nickname,\n                )\n                node = self._otcs.get_node_from_nickname(nickname)\n                node_id = self._otcs.get_result_value(node, \"id\")\n                if not node_id:\n                    logger.error(\"Nickname -&gt; {} does not exist. Skipping...\")\n                    success = False\n                    continue\n\n            # Now we should have a value for node_id:\n            if not node_id:\n                logger.error(\"No node ID found! Skipping permission...\")\n                success = False\n                continue\n\n            node_name = self._otcs.get_result_value(node, \"name\")\n            logger.info(\n                \"Found node -&gt; %s with ID -&gt; %s to apply permission to.\",\n                node_name,\n                node_id,\n            )\n            # write node information back into payload\n            # for better debugging\n            permission[\"node_name\"] = node_name\n            permission[\"node_id\"] = node_id\n\n            if \"apply_to\" in permission:\n                apply_to = permission[\"apply_to\"]\n            else:\n                apply_to = 2  # make item + sub-items the default\n\n            # 1. Process Owner Permissions (list canbe empty!)\n            if \"owner_permissions\" in permission:\n                owner_permissions = permission[\"owner_permissions\"]\n                logger.info(\n                    \"Update owner permissions for item -&gt; %s (%s) to -&gt; %s\",\n                    node_name,\n                    str(node_id),\n                    str(owner_permissions),\n                )\n                response = self._otcs.assign_permission(\n                    int(node_id), \"owner\", 0, owner_permissions, apply_to\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to update owner permissions for item -&gt; %s (%s).\",\n                        node_name,\n                        str(node_id),\n                    )\n                    success = False\n\n            # 2. Process Owner Group Permissions\n            if \"owner_group_permissions\" in permission:\n                owner_group_permissions = permission[\"owner_group_permissions\"]\n                logger.info(\n                    \"Update owner group permissions for item -&gt; %s (%s) to -&gt; %s\",\n                    node_name,\n                    str(node_id),\n                    str(owner_group_permissions),\n                )\n                response = self._otcs.assign_permission(\n                    int(node_id), \"group\", 0, owner_group_permissions, apply_to\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to update group permissions for item -&gt; %s (%s).\",\n                        node_name,\n                        str(node_id),\n                    )\n                    success = False\n\n            # 3. Process Public Permissions\n            if \"public_permissions\" in permission:\n                public_permissions = permission[\"public_permissions\"]\n                logger.info(\n                    \"Update public permissions for item -&gt; %s (%s) to -&gt; %s\",\n                    node_name,\n                    str(node_id),\n                    str(public_permissions),\n                )\n                response = self._otcs.assign_permission(\n                    int(node_id), \"public\", 0, public_permissions, apply_to\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to update public permissions for item -&gt; %s (%s).\",\n                        str(node_id),\n                        node_name,\n                    )\n                    success = False\n                    continue\n\n            # 4. Process Assigned User Permissions (if specified and not empty)\n            if \"users\" in permission and permission[\"users\"]:\n                users = permission[\"users\"]\n                for user in users:\n                    if not \"name\" in user or not \"permissions\" in user:\n                        logger.error(\n                            \"Missing user name or permissions in user permission specificiation. Cannot set user permissions. Skipping...\"\n                        )\n                        success = False\n                        continue\n                    user_name = user[\"name\"]\n                    user_permissions = user[\"permissions\"]\n                    response = self._otcs.get_user(user_name, True)\n                    user_id = self._otcs.get_result_value(response=response, key=\"id\")\n                    if not user_id:\n                        logger.error(\n                            \"Cannot find user with name -&gt; %s; cannot set user permissions. Skipping user...\",\n                            user_name,\n                        )\n                        success = False\n                        continue\n                    user[\"id\"] = user_id  # write ID back into payload\n\n                    logger.info(\n                        \"Update permission of user -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\n                        user_name,\n                        node_name,\n                        str(node_id),\n                        str(user_permissions),\n                    )\n                    response = self._otcs.assign_permission(\n                        int(node_id), \"custom\", user_id, user_permissions, apply_to\n                    )\n                    if not response:\n                        logger.error(\n                            \"Failed to update assigned user permissions for item -&gt; %s.\",\n                            node_id,\n                        )\n                        success = False\n\n            # 5. Process Assigned Group Permissions (if specified and not empty)\n            if \"groups\" in permission and permission[\"groups\"]:\n                groups = permission[\"groups\"]\n                for group in groups:\n                    if not \"name\" in group or not \"permissions\" in group:\n                        logger.error(\n                            \"Missing group name or permissions in group permission specificiation. Cannot set group permissions. Skipping...\"\n                        )\n                        continue\n                    group_name = group[\"name\"]\n                    group_permissions = group[\"permissions\"]\n                    logger.info(\n                        \"Update permissions of group -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\n                        group_name,\n                        node_name,\n                        str(node_id),\n                        str(group_permissions),\n                    )\n                    otcs_group = self._otcs.get_group(group_name, True)\n                    group_id = self._otcs.get_result_value(otcs_group, \"id\")\n                    if not group_id:\n                        logger.error(\n                            \"Cannot find group with name -&gt; %s; cannot set group permissions. Skipping group...\",\n                            group_name,\n                        )\n                        success = False\n                        continue\n                    group[\"id\"] = group_id  # write ID back into payload\n                    response = self._otcs.assign_permission(\n                        int(node_id), \"custom\", group_id, group_permissions, apply_to\n                    )\n                    if not response:\n                        logger.error(\n                            \"Failed to update assigned group permissions for item -&gt; %s (%s).\",\n                            node_name,\n                            str(node_id),\n                        )\n                        success = False\n\n        self.write_status_file(success, section_name, permissions)\n\n        return success\n\n        # end method definition\n\n    def process_assignments(self, section_name: str = \"assignments\") -&gt; bool:\n        \"\"\"Process assignments specified in payload and assign items (such as workspaces and\n        items with nicknames) to users or groups.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._assignments:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for assignment in self._assignments:\n            # Sanity check: we need a subject - it's mandatory:\n            if not \"subject\" in assignment:\n                logger.error(\"Assignment needs a subject! Skipping assignment...\")\n                success = False\n                continue\n            subject = assignment[\"subject\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in assignment and not assignment[\"enabled\"]:\n                logger.info(\n                    \"Payload for Assignment -&gt; %s is disabled. Skipping...\", subject\n                )\n                continue\n\n            # instruction is optional but we give a warning if they are missing:\n            if not \"instruction\" in assignment:\n                logger.warning(\"Assignment -&gt; %s should have an instruction!\", subject)\n                instruction = \"\"\n            else:\n                instruction = assignment[\"instruction\"]\n            # Sanity check: we either need users or groups (or both):\n            if not \"groups\" in assignment and not \"users\" in assignment:\n                logger.error(\n                    \"Assignment -&gt; %s needs groups or users! Skipping assignment...\",\n                    subject,\n                )\n                success = False\n                continue\n            # Check if a workspace is specified for the assignment and check it does exist:\n            if \"workspace\" in assignment and assignment[\"workspace\"]:\n                workspace = next(\n                    (\n                        item\n                        for item in self._workspaces\n                        if item[\"id\"] == assignment[\"workspace\"]\n                    ),\n                    None,\n                )\n                if not workspace:\n                    logger.error(\n                        \"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\n                        subject,\n                        assignment[\"workspace\"],\n                    )\n                    success = False\n                    continue\n                node_id = self.determine_workspace_id(workspace)\n                if not node_id:\n                    logger.error(\n                        \"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\n                        subject,\n                        assignment[\"workspace\"],\n                    )\n                    success = False\n                    continue\n            # If we don't have a workspace then check if a nickname is specified for the assignment:\n            elif \"nickname\" in assignment:\n                response = self._otcs.get_node_from_nickname(assignment[\"nickname\"])\n                node_id = self._otcs.get_result_value(response, \"id\")\n                if not node_id:\n                    # if response == None:\n                    logger.error(\n                        \"Assignment item with nickname -&gt; %s not found\",\n                        assignment[\"nickname\"],\n                    )\n                    success = False\n                    continue\n            else:\n                logger.error(\n                    \"Assignment -&gt; %s needs a workspace or nickname! Skipping assignment...\",\n                    subject,\n                )\n                success = False\n                continue\n\n            assignees = []\n\n            if \"groups\" in assignment:\n                group_assignees = assignment[\"groups\"]\n                for group_assignee in group_assignees:\n                    # find the group in the group list\n                    group = next(\n                        (\n                            item\n                            for item in self._groups\n                            if item[\"name\"] == group_assignee\n                        ),\n                        None,\n                    )\n                    if not group:\n                        logger.error(\n                            \"Assignment group -&gt; %s does not exist! Skipping group...\",\n                            group_assignee,\n                        )\n                        success = False\n                        continue\n                    if not \"id\" in group:\n                        logger.error(\n                            \"Assignment group -&gt; %s does not have an ID. Skipping group...\",\n                            group_assignee,\n                        )\n                        success = False\n                        continue\n                    group_id = group[\"id\"]\n                    # add the group ID to the assignee list:\n                    assignees.append(group_id)\n\n            if \"users\" in assignment:\n                user_assignees = assignment[\"users\"]\n                for user_assignee in user_assignees:\n                    # find the user in the user list\n                    user = next(\n                        (item for item in self._users if item[\"name\"] == user_assignee),\n                        None,\n                    )\n                    if not user:\n                        logger.error(\n                            \"Assignment user -&gt; %s does not exist! Skipping user...\",\n                            user_assignee,\n                        )\n                        success = False\n                        continue\n                    if not \"id\" in user:\n                        logger.error(\n                            \"Assignment user -&gt; %s does not have an ID. Skipping user...\",\n                            user_assignee,\n                        )\n                        success = False\n                        continue\n                    user_id = user[\"id\"]\n                    # add the group ID to the assignee list:\n                    assignees.append(user_id)\n\n            if not assignees:\n                logger.error(\n                    \"Cannot add assignment -&gt; %s for node ID -&gt; %s because no assignee was found.\",\n                    subject,\n                    node_id,\n                )\n                success = False\n                continue\n\n            response = self._otcs.assign_item_to_user_group(\n                int(node_id), subject, instruction, assignees\n            )\n            if not response:\n                logger.error(\n                    \"Failed to add assignment -&gt; %s for node ID -&gt; %s with assignees -&gt; %s.\",\n                    subject,\n                    node_id,\n                    assignees,\n                )\n                success = False\n\n        self.write_status_file(success, section_name, self._assignments)\n\n        return success\n\n        # end method definition\n\n    def process_user_licenses(\n        self,\n        resource_name: str,\n        license_feature: str,\n        license_name: str,\n        user_specific_payload_field: str = \"licenses\",\n        section_name: str = \"userLicenses\",\n    ) -&gt; bool:\n        \"\"\"Assign a specific OTDS license feature to all Extended ECM users.\n           This method is used for OTIV and Extended ECM licenses.\n\n        Args:\n            resource_name (str): name of the OTDS resource\n            license_feature (str): license feature to assign to the user (product specific)\n            license_name (str): Name of the license Key (e.g. \"EXTENDED_ECM\" or \"INTELLIGENT_VIEWING\")\n            user_specific_payload_field (str, optional): name of the user specific field in payload\n                                                         (if empty it will be ignored)\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._users:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        otds_resource = self._otds.get_resource(resource_name)\n        if not otds_resource:\n            logger.error(\n                \"OTDS Resource -&gt; {} not found. Cannot assign licenses to users.\"\n            )\n            return False\n\n        user_partition = self._otcs.config()[\"partition\"]\n        if not user_partition:\n            logger.error(\"OTCS user partition not found in OTDS!\")\n            return False\n\n        for user in self._users:\n            user_name = user[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in user and not user[\"enabled\"]:\n                logger.info(\n                    \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n                )\n                continue\n\n            if user_specific_payload_field and user_specific_payload_field in user:\n                logger.info(\n                    \"Found specific license feature -&gt; %s for User -&gt; %s. Overwriting default license feature -&gt; %s\",\n                    user[user_specific_payload_field],\n                    user_name,\n                    license_feature,\n                )\n                user_license_feature = user[user_specific_payload_field]\n            else:  # use the default feature from the actual parameter\n                user_license_feature = [license_feature]\n\n            for license_feature in user_license_feature:\n                if self._otds.is_user_licensed(\n                    user_name=user_name,\n                    resource_id=otds_resource[\"resourceID\"],\n                    license_feature=license_feature,\n                    license_name=license_name,\n                ):\n                    logger.info(\n                        \"User -&gt; %s is already licensed for -&gt; %s (%s)\",\n                        user_name,\n                        license_name,\n                        license_feature,\n                    )\n                    continue\n                assigned_license = self._otds.assign_user_to_license(\n                    user_partition,\n                    user_name,  # we want the plain login name here\n                    otds_resource[\"resourceID\"],\n                    license_feature,\n                    license_name,\n                )\n\n                if not assigned_license:\n                    logger.error(\n                        \"Failed to assign license feature -&gt; %s to user -&gt; %s!\",\n                        license_feature,\n                        user_name,\n                    )\n                    success = False\n\n        self.write_status_file(success, section_name, self._users)\n\n        return success\n\n        # end method definition\n\n    def process_exec_pod_commands(self, section_name: str = \"execPodCommands\") -&gt; bool:\n        \"\"\"Process commands that should be executed in the Kubernetes pods.\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not isinstance(self._k8s, K8s):\n            logger.error(\"K8s not setup properly -&gt; Skipping %s...\", section_name)\n            return False\n\n        if not self._exec_pod_commands:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for exec_pod_command in self._exec_pod_commands:\n            if not \"pod_name\" in exec_pod_command:\n                logger.error(\n                    \"To execute a command in a pod the pod name needs to be specified in the payload! Skipping to next pod command...\"\n                )\n                success = False\n                continue\n            pod_name = exec_pod_command[\"pod_name\"]\n\n            if not \"command\" in exec_pod_command or not exec_pod_command.get(\"command\"):\n                logger.error(\n                    \"Pod command is not specified for pod -&gt; %s! It needs to be a non-empty list! Skipping to next pod command...\",\n                    pod_name,\n                )\n                success = False\n                continue\n            command = exec_pod_command[\"command\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in exec_pod_command and not exec_pod_command[\"enabled\"]:\n                logger.info(\n                    \"Payload for Exec Pod Command in pod -&gt; %s is disabled. Skipping...\",\n                    pod_name,\n                )\n                continue\n\n            if not \"description\" in exec_pod_command:\n                logger.info(\"Executing command -&gt; %s in pod -&gt; %s\", command, pod_name)\n\n            else:\n                description = exec_pod_command[\"description\"]\n                logger.info(\n                    \"Executing command -&gt; %s in pod -&gt; %s (%s)\",\n                    command,\n                    pod_name,\n                    description,\n                )\n\n            if (\n                not \"interactive\" in exec_pod_command\n                or exec_pod_command[\"interactive\"] is False\n            ):\n                result = self._k8s.exec_pod_command(pod_name, command)\n            else:\n                if not \"timeout\" in exec_pod_command:\n                    result = self._k8s.exec_pod_command_interactive(pod_name, command)\n                else:\n                    timeout = exec_pod_command[\"timeout\"]\n                    result = self._k8s.exec_pod_command_interactive(\n                        pod_name, command, timeout\n                    )\n\n            # we need to differentiate 3 cases here:\n            # 1. result = None is returned - this is an error (exception)\n            # 2. result is empty string - this is OK\n            # 3. result is a non-empty string - this is OK - print it to log\n            if result is None:\n                logger.error(\n                    \"Execution of command -&gt; %s in pod -&gt; %s failed\",\n                    command,\n                    pod_name,\n                )\n                success = False\n            elif result != \"\":\n                logger.info(\n                    \"Execution of command -&gt; %s in pod -&gt; %s returned result -&gt; %s\",\n                    command,\n                    pod_name,\n                    result,\n                )\n            else:\n                # It is not an error if no result is returned. It depends on the nature of the command\n                # if a result is written to stdout or stderr.\n                logger.info(\n                    \"Execution of command -&gt; %s in pod -&gt; %s did not return a result\",\n                    command,\n                    pod_name,\n                )\n\n        self.write_status_file(success, section_name, self._exec_pod_commands)\n\n        return success\n\n        # end method definition\n\n    def process_document_generators(\n        self, section_name: str = \"documentGenerators\"\n    ) -&gt; bool:\n        \"\"\"Generate documents for a defined workspace type based on template\n\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not self._doc_generators:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        # save admin credentials for later switch back to admin user:\n        admin_credentials = self._otcs.credentials()\n        authenticated_user = \"admin\"\n\n        for doc_generator in self._doc_generators:\n            if not \"workspace_type\" in doc_generator:\n                logger.error(\n                    \"To generate documents for workspaces the workspace type needs to be specified in the payload! Skipping to next document generator...\"\n                )\n                success = False\n                continue\n            workspace_type = doc_generator[\"workspace_type\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in doc_generator and not doc_generator[\"enabled\"]:\n                logger.info(\n                    \"Payload for document generator of workspace type -&gt; %s is disabled. Skipping...\",\n                    workspace_type,\n                )\n                continue\n\n            if not \"template_path\" in doc_generator:\n                logger.error(\n                    \"To generate documents for workspaces of type -&gt; %s the path to the document template needs to be specified in the payload! Skipping to next document generator...\",\n                    workspace_type,\n                )\n                success = False\n                continue\n            template_path = doc_generator[\"template_path\"]\n            # 20541 is the ID of the Document Template Volume which\n            # (we hope) is stable:\n            template = self._otcs.get_node_by_volume_and_path(20541, template_path)\n            if not template:\n                logger.error(\n                    \"Cannot find document template in path -&gt; %s. Skipping to next document generator...\",\n                    template_path,\n                )\n                success = False\n                continue\n            template_id = self._otcs.get_result_value(template, \"id\")\n            template_name = self._otcs.get_result_value(template, \"name\")\n\n            if not \"classification_path\" in doc_generator:\n                logger.error(\n                    \"To generate documents for workspaces of type -&gt; %s the path to the document classification needs to be specified in the payload! Skipping to next document generator...\",\n                    workspace_type,\n                )\n                success = False\n                continue\n            classification_path = doc_generator[\"classification_path\"]\n            classification = self._otcs.get_node_by_volume_and_path(\n                198, classification_path\n            )\n            if not classification:\n                logger.error(\n                    \"Cannot find document classification in path -&gt; %s. Skipping to next document generator...\",\n                    classification_path,\n                )\n                success = False\n                continue\n            classification_id = self._otcs.get_result_value(classification, \"id\")\n\n            # \"category_name\" is optional. But if it is specified\n            # then also \"attributes\" needs to be specified:\n            if not \"category_name\" in doc_generator:\n                logger.info(\n                    \"No metadata (category name) specified in the payload for this document generator.\",\n                )\n                category_name = \"\"\n                attributes = {}\n                category_data = {}\n            else:\n                category_name = doc_generator[\"category_name\"]\n                if not \"attributes\" in doc_generator:\n                    logger.error(\n                        \"To generate documents for workspaces of type -&gt; %s with metadata, the attributes needs to be specified in the payload! Skipping to next document generator...\",\n                        workspace_type,\n                    )\n                    success = False\n                    continue\n                attributes = doc_generator[\"attributes\"]\n\n                # The following method returns two values: the category ID and\n                # a dict of the attributes. If the category is not found\n                # on the document template it returns -1 for the category ID\n                # and an empty dict for the attribute definitions:\n                (\n                    category_id,\n                    attribute_definitions,\n                ) = self._otcs.get_node_category_definition(template_id, category_name)\n                if category_id == -1:\n                    logger.error(\n                        \"The document template -&gt; %s does not have the specified category -&gt; %s. Skipping to next document generator...\",\n                        template_name,\n                        category_name,\n                    )\n                    success = False\n                    continue\n\n                category_data = {str(category_id): {}}\n\n                # now we fill the prepared (but empty) category_data\n                # with the actual attribute values from the payload:\n                for attribute in attributes:\n                    attribute_name = attribute[\"name\"]\n                    attribute_value = attribute[\"value\"]\n                    attribute_type = attribute_definitions[attribute_name][\"type\"]\n                    attribute_id = attribute_definitions[attribute_name][\"id\"]\n\n                    # Special treatment for type user: determine the ID for the login name.\n                    # the ID is the actual value we have to put in the attribute:\n                    if attribute_type == \"user\":\n                        user = self._otcs.get_user(attribute_value, show_error=True)\n                        user_id = self._otcs.get_result_value(response=user, key=\"id\")\n                        if not user_id:\n                            logger.error(\n                                \"Cannot find user with login name -&gt; %s. Skipping...\",\n                                attribute_value,\n                            )\n                            success = False\n                            continue\n                        attribute_value = user_id\n                    category_data[str(category_id)][attribute_id] = attribute_value\n\n            if not \"workspace_folder_path\" in doc_generator:\n                logger.info(\n                    \"No workspace folder path defined for workspaces of type -&gt; %s. Documents will be stored in workspace root.\",\n                    workspace_type,\n                )\n                workspace_folder_path = []\n            else:\n                workspace_folder_path = doc_generator[\"workspace_folder_path\"]\n\n            if \"exec_as_user\" in doc_generator:\n                exec_as_user = doc_generator[\"exec_as_user\"]\n\n                # Find the user in the users payload:\n                exec_user = next(\n                    (item for item in self._users if item[\"name\"] == exec_as_user),\n                    None,\n                )\n                # Have we found the user in the payload?\n                if exec_user is not None:\n                    logger.info(\n                        \"Executing document generator with user -&gt; %s\", exec_as_user\n                    )\n                    # we change the otcs credentials to the user:\n                    self._otcs.set_credentials(exec_user[\"name\"], exec_user[\"password\"])\n\n                    # we re-authenticate as the user:\n                    logger.info(\"Authenticate user -&gt; %s...\", exec_as_user)\n                    # True = force new login with new user\n                    cookie = self._otcs.authenticate(revalidate=True)\n                    if not cookie:\n                        logger.error(\"Couldn't authenticate user -&gt; %s\", exec_as_user)\n                        continue\n                    admin_context = False\n                    authenticated_user = exec_as_user\n                else:\n                    logger.error(\n                        \"Cannot find user with login name -&gt; %s for executing. Executing as admin...\",\n                        exec_as_user,\n                    )\n                    admin_context = True\n                    success = False\n            else:\n                admin_context = True\n                exec_as_user = \"admin\"\n\n            if admin_context and authenticated_user != \"admin\":\n                # Set back admin credentials:\n                self._otcs.set_credentials(\n                    admin_credentials[\"username\"], admin_credentials[\"password\"]\n                )\n\n                # we re-authenticate as the admin user:\n                logger.info(\n                    \"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n                )\n                # True = force new login with new user\n                cookie = self._otcs.authenticate(revalidate=True)\n                authenticated_user = \"admin\"\n\n            if category_data:\n                logger.info(\n                    \"Generate documents for workspace type -&gt; %s based on template -&gt; %s with metadata -&gt; %s...\",\n                    workspace_type,\n                    template_name,\n                    category_data,\n                )\n            else:\n                logger.info(\n                    \"Generate documents for workspace type -&gt; %s based on template -&gt; %s without metadata...\",\n                    workspace_type,\n                    template_name,\n                )\n\n            # Find the workspace type with the name given in the _workspace_types\n            # datastructure that has been generated by process_workspace_types() method before:\n            workspace_type_id = next(\n                (\n                    item[\"id\"]\n                    for item in self._workspace_types\n                    if item[\"name\"] == workspace_type\n                ),\n                None,\n            )\n            workspace_instances = self._otcs.get_workspace_instances(\n                type_name=workspace_type, type_id=workspace_type_id\n            )\n            if not workspace_instances or not workspace_instances[\"results\"]:\n                logger.warning(\n                    \"No workspace instances found for workspace type -&gt; %s (%s)\",\n                    workspace_type,\n                    workspace_type_id,\n                )\n            for workspace_instance in workspace_instances[\"results\"]:\n                workspace_id = workspace_instance[\"data\"][\"properties\"][\"id\"]\n                workspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\n                if workspace_folder_path:\n                    workspace_folder = self._otcs.get_node_by_workspace_and_path(\n                        workspace_id, workspace_folder_path\n                    )\n                    if workspace_folder:\n                        workspace_folder_id = self._otcs.get_result_value(\n                            workspace_folder, \"id\"\n                        )\n                    else:\n                        # If the workspace template is not matching\n                        # the path we may have an error here. Then\n                        # we fall back to workspace root level.\n                        logger.warning(\n                            \"Folder path does not exist in workspace -&gt; %s. Using workspace root level instead...\",\n                            workspace_name,\n                        )\n                        workspace_folder_id = workspace_id\n                else:\n                    workspace_folder_id = workspace_id\n\n                document_name = workspace_name + \" - \" + template_name\n                logger.info(\"Generate document -&gt; %s\", document_name)\n\n                response = self._otcs.check_node_name(\n                    int(workspace_folder_id), document_name\n                )\n                if response[\"results\"]:\n                    logger.warning(\n                        \"Node with name -&gt; %s does already exist in workspace folder with ID -&gt; %s\",\n                        document_name,\n                        workspace_folder_id,\n                    )\n                    continue\n                response = self._otcs.create_document_from_template(\n                    int(template_id),\n                    int(workspace_folder_id),\n                    int(classification_id),\n                    category_data,\n                    document_name,\n                    \"This document has been auto-generated by Terrarium\",\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to generate document -&gt; %s in workspace -&gt; %s (%s) as user -&gt; %s\",\n                        document_name,\n                        workspace_name,\n                        workspace_id,\n                        exec_as_user,\n                    )\n                    success = False\n                else:\n                    logger.info(\n                        \"Successfully generated document -&gt; %s in workspace -&gt; %s\",\n                        document_name,\n                        workspace_name,\n                    )\n\n        if authenticated_user != \"admin\":\n            # Set back admin credentials:\n            self._otcs.set_credentials(\n                admin_credentials[\"username\"], admin_credentials[\"password\"]\n            )\n\n            # we authenticate back as the admin user:\n            logger.info(\n                \"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n            )\n            # True = force new login with new user\n            cookie = self._otcs.authenticate(revalidate=True)\n\n        self.write_status_file(success, section_name, self._doc_generators)\n\n        return success\n\n        # end method definition\n\n    def process_browser_automations(\n        self,\n        browser_automations: list,\n        section_name: str = \"browserAutomations\",\n        check_status: bool = True,\n    ) -&gt; bool:\n        \"\"\"Process Selenium-based browser automations.\n\n        Args:\n            browser_automations (list): list of browser_automations (need this as parameter as we\n                                        have multiple lists)\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n            check_status (bool, optional): defines whether or not this needs to re-run\n                                           for each customizer run (even if it has been successful before).\n                                           If check_status is True (default) then it is only re-run\n                                           if it has NOT been successfully before.\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not browser_automations:\n            logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n            return True\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if check_status and self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for browser_automation in browser_automations:\n            description = browser_automation.get(\"description\", \"\")\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in browser_automation and not browser_automation[\"enabled\"]:\n                logger.info(\n                    \"Payload for Browser Automation -&gt; %s is disabled. Skipping...\",\n                    description,\n                )\n                continue\n\n            if not \"name\" in browser_automation:\n                logger.error(\"Browser automation is missing a unique name. Skipping...\")\n                success = False\n                continue\n            name = browser_automation.get(\"name\")\n\n            if description:\n                logger.info(\n                    \"Processing Browser Automation -&gt; %s (%s)...\",\n                    name,\n                    description,\n                )\n            else:\n                logger.info(\"Processing Browser Automation -&gt; %s...\", name)\n\n            if not \"base_url\" in browser_automation:\n                logger.error(\"Browser automation is missing base_url. Skipping...\")\n                success = False\n                continue\n            base_url = browser_automation.get(\"base_url\")\n\n            if not \"user_name\" in browser_automation:\n                logger.info(\"Browser automation is not having user name.\")\n            user_name = browser_automation.get(\"user_name\", \"\")\n\n            if not \"password\" in browser_automation:\n                logger.info(\"Browser automation is not having password.\")\n            password = browser_automation.get(\"password\", \"\")\n\n            if not \"automations\" in browser_automation:\n                logger.error(\n                    \"Browser automation is missing list of automations. Skipping...\"\n                )\n                success = False\n                continue\n            automations = browser_automation.get(\"automations\", [])\n\n            debug_automation: bool = browser_automation.get(\"debug\", False)\n\n            # Create Selenium Browser Automation:\n            logger.info(\"Browser Automation base URL -&gt; %s\", base_url)\n            logger.info(\"Browser Automation User -&gt; %s\", user_name)\n            logger.debug(\"Browser Automation Password -&gt; %s\", password)\n            browser_automation_object = BrowserAutomation(\n                base_url=base_url,\n                user_name=user_name,\n                user_password=password,\n                automation_name=name,\n                take_screenshots=debug_automation,\n            )\n            # Implicit Wait is a global setting (for whole brwoser session)\n            # This makes sure a page is fully loaded and elements are present\n            # before accessing them. We set 15.0 seconds as default if not\n            # otherwise specified by \"wait_time\" in the payload.\n            # See https://www.selenium.dev/documentation/webdriver/waits/\n            wait_time = browser_automation.get(\"wait_time\", 15.0)\n            browser_automation_object.implicit_wait(wait_time)\n            if \"wait_time\" in browser_automation:\n                logger.info(\n                    \"Browser Automation Implicit Wait time -&gt; %s configured\", wait_time\n                )\n\n            for automation in automations:\n                if not \"type\" in automation:\n                    logger.error(\"Browser automation step is missing type. Skipping...\")\n                    success = False\n                    break\n                automation_type = automation.get(\"type\", \"\")\n\n                match automation_type:\n                    case \"login\":\n                        page = automation.get(\"page\", \"\")\n                        logger.info(\n                            \"Login to -&gt; %s as user -&gt; %s\", base_url + page, user_name\n                        )\n                        user_field = automation.get(\"user_field\", \"otds_username\")\n                        password_field = automation.get(\n                            \"password_field\", \"otds_password\"\n                        )\n                        login_button = automation.get(\"login_button\", \"loginbutton\")\n                        if not browser_automation_object.run_login(\n                            user_field=user_field,\n                            password_field=password_field,\n                            login_button=login_button,\n                        ):\n                            logger.error(\n                                \"Cannot log into -&gt; %s. Stopping automation.\",\n                                base_url + page,\n                            )\n                            success = False\n                            break\n                        else:\n                            logger.info(\n                                \"Successfuly logged into page -&gt; %s.\", base_url + page\n                            )\n                    case \"get_page\":\n                        page = automation.get(\"page\", \"\")\n                        if not page:\n                            logger.error(\n                                \"Automation type -&gt; %s requires page parameter\",\n                                automation_type,\n                            )\n                            success = False\n                            break\n                        logger.info(\"Get page -&gt; %s\", base_url + page)\n                        if not browser_automation_object.get_page(url=page):\n                            logger.error(\n                                \"Cannot get page -&gt; %s. Stopping automation.\",\n                                page,\n                            )\n                            success = False\n                            break\n                        else:\n                            # browser_automation_object.implicit_wait(15.0) # this is global but not command-specific! Don't need it here!\n                            logger.info(\n                                \"Successfuly loaded page -&gt; %s.\", base_url + page\n                            )\n                    case \"click_elem\":\n                        elem = automation.get(\"elem\", \"\")\n                        if not elem:\n                            logger.error(\n                                \"Automation type -&gt; %s requires elem parameter\",\n                                automation_type,\n                            )\n                            success = False\n                            break\n                        find = automation.get(\"find\", \"id\")\n                        if not browser_automation_object.find_elem_and_click(\n                            find_elem=elem, find_method=find\n                        ):\n                            logger.error(\n                                \"Cannot find clickable element -&gt; %s on current page. Stopping automation.\",\n                                elem,\n                            )\n                            success = False\n                            break\n                        else:\n                            # browser_automation_object.implicit_wait(15.0) # this is global but not command-specific! Don't need it here!\n                            logger.info(\"Successfuly clicked element -&gt; %s.\", elem)\n                    case \"set_elem\":\n                        elem = automation.get(\"elem\", \"\")\n                        if not elem:\n                            logger.error(\n                                \"Automation type -&gt; %s requires elem parameter\",\n                                automation_type,\n                            )\n                            success = False\n                            break\n                        find = automation.get(\"find\", \"id\")\n                        value = automation.get(\"value\", \"\")\n                        if not value:\n                            logger.error(\n                                \"Automation type -&gt; %s requires value parameter\",\n                                automation_type,\n                            )\n                            success = False\n                            break\n                        # we also support replacing placeholders that are\n                        # enclosed in double % characters like %%OTCS_RESOURCE_ID%%:\n                        value = self.replace_placeholders(value)\n                        if not browser_automation_object.find_elem_and_set(\n                            find_elem=elem, elem_value=value, find_method=find\n                        ):\n                            logger.error(\n                                \"Cannot find element -&gt; %s on current page to set value -&gt; %s. Stopping automation.\",\n                                elem,\n                                value,\n                            )\n                            success = False\n                            break\n                        else:\n                            logger.info(\n                                \"Successfuly set element -&gt; %s to set value -&gt; %s.\",\n                                elem,\n                                value,\n                            )\n                    case _:\n                        logger.error(\n                            \"Illegal automation step type -&gt; %s in browser automation!\",\n                            automation_type,\n                        )\n                        success = False\n                        break\n\n        if check_status:\n            self.write_status_file(success, section_name, browser_automations)\n\n        return success\n\n        # end method definition\n\n    def init_sap(\n        self, sap_external_system: dict, direct_application_server_login: bool = True\n    ) -&gt; SAP | None:\n        \"\"\"Initialize SAP object for RFC communication with SAP S/4HANA.\n\n        Args:\n            sap_external_system (dict): SAP external system created before\n            direct_application_server_login (bool): flag to control wether we comminicate directly with\n                                                    SAP application server or via a load balancer\n        Returns:\n            SAP: SAP object\n        \"\"\"\n\n        if not sap_external_system:\n            return None\n\n        username = sap_external_system[\"username\"]\n        password = sap_external_system[\"password\"]\n        # \"external_system_hostname\" is extracted from as_url in process_external_systems()\n        host = sap_external_system[\"external_system_hostname\"]\n        client = sap_external_system.get(\"client\", \"100\")\n        system_number = sap_external_system.get(\"external_system_number\", \"00\")\n        system_id = sap_external_system[\"external_system_name\"]\n        group = sap_external_system.get(\"group\", \"PUBLIC\")\n        destination = sap_external_system.get(\"destination\", \"\")\n\n        logger.info(\"Connection parameters SAP:\")\n        logger.info(\"SAP Hostname             = %s\", host)\n        logger.info(\"SAP Client               = %s\", client)\n        logger.info(\"SAP System Number        = %s\", system_number)\n        logger.info(\"SAP System ID            = %s\", system_id)\n        logger.info(\"SAP User Name            = %s\", username)\n        if not direct_application_server_login:\n            logger.info(\"SAP Group Name (for RFC) = %s\", group)\n        if destination:\n            logger.info(\"SAP Destination          = %s\", destination)\n\n        if direct_application_server_login:\n            logger.info(\"SAP Login                = Direct Application Server (ashost)\")\n            sap_object = SAP(\n                username=username,\n                password=password,\n                ashost=host,\n                client=client,\n                system_number=system_number,\n                system_id=system_id,\n                destination=destination,\n            )\n        else:\n            logger.info(\"SAP Login                = Logon with load balancing (mshost)\")\n            sap_object = SAP(\n                username=username,\n                password=password,\n                mshost=host,\n                group=group,\n                client=client,\n                system_number=system_number,\n                system_id=system_id,\n                destination=destination,\n            )\n\n        self._sap = sap_object\n\n        return sap_object\n\n        # end method definition\n\n    def process_sap_rfcs(self, sap_object: SAP, section_name: str = \"sapRFCs\") -&gt; bool:\n        \"\"\"Process SAP RFCs in payload and run them in SAP S/4HANA.\n\n        Args:\n            sap_object (SAP): SAP object\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n\n        if not sap_object:\n            logger.info(\"SAP object is undefined. Cannot call RFCs. Bailing out.\")\n            return False\n\n        # If this payload section has been processed successfully before we\n        # can return True and skip processing it once more:\n        if self.check_status_file(section_name):\n            return True\n\n        success: bool = True\n\n        for sap_rfc in self._sap_rfcs:\n            rfc_name = sap_rfc[\"name\"]\n\n            # Check if element has been disabled in payload (enabled = false).\n            # In this case we skip the element:\n            if \"enabled\" in sap_rfc and not sap_rfc[\"enabled\"]:\n                logger.info(\n                    \"Payload for SAP RFC -&gt; %s is disabled. Skipping...\", rfc_name\n                )\n                continue\n\n            rfc_description = (\n                sap_rfc[\"description\"] if sap_rfc.get(\"description\") else \"\"\n            )\n\n            # be careful to avoid key errors as SAP RFC parameters are optional:\n            rfc_params = sap_rfc[\"parameters\"] if sap_rfc.get(\"parameters\") else {}\n            if rfc_params:\n                logger.info(\n                    \"Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\n                    rfc_name,\n                    rfc_description,\n                    rfc_params,\n                )\n            else:\n                logger.info(\n                    \"Calling SAP RFC -&gt; %s (%s) without parameters...\",\n                    rfc_name,\n                    rfc_description,\n                )\n\n            # be careful to avoid key errors as SAP RFC parameters are optional:\n            rfc_call_options = (\n                sap_rfc[\"call_options\"] if sap_rfc.get(\"call_options\") else {}\n            )\n            if rfc_call_options:\n                logger.debug(\"Using call options -&gt; %s ...\", rfc_call_options)\n\n            result = sap_object.call(rfc_name, rfc_call_options, rfc_params)\n            if result is None:\n                logger.error(\"Failed to call SAP RFC -&gt; %s\", rfc_name)\n                success = False\n            elif result.get(\"RESULT\") != \"OK\":\n                logger.error(\n                    \"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\n                    rfc_name,\n                    str(result.get(\"FAILED\")),\n                    str(result),\n                )\n                success = False\n            else:\n                logger.info(\n                    \"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n                )\n                # Save result for status file content\n                sap_rfc[\"result\"] = result\n\n        self.write_status_file(success, section_name, self._sap_rfcs)\n\n        return success\n\n        # end method definition\n\n    def init_salesforce(self, salesforce_external_system: dict) -&gt; Salesforce | None:\n        \"\"\"Initialize Salesforce object for workspace creation. This is needed to query Salesforce API\n           to lookup IDs of Salesforce objects.\n\n        Args:\n            salesfoce_external_system (dict): Salesforce external system created before\n        Returns:\n            Salesforce: Salesforce object\n        \"\"\"\n\n        if not salesforce_external_system:\n            return None\n\n        username = salesforce_external_system[\"username\"]\n        password = salesforce_external_system[\"password\"]\n        base_url = salesforce_external_system[\"base_url\"]\n        authorization_url = salesforce_external_system.get(\"token_endpoint\", \"\")\n        client_id = salesforce_external_system[\"oauth_client_id\"]\n        client_secret = salesforce_external_system[\"oauth_client_secret\"]\n\n        logger.info(\"Connection parameters Salesforce:\")\n        logger.info(\"Salesforce base URL          = %s\", base_url)\n        logger.info(\"Salesforce authorization URL = %s\", base_url)\n        logger.info(\"Salesforce username          = %s\", username)\n        logger.debug(\"Salesforce password          = %s\", password)\n        logger.info(\"Salesforce client ID         = %s\", client_id)\n        logger.debug(\"Salesforce client secret     = %s\", client_secret)\n        salesforce_object = Salesforce(\n            base_url=base_url,\n            client_id=client_id,\n            client_secret=client_secret,\n            username=username,\n            password=password,\n            authorization_url=authorization_url,\n        )\n\n        self._salesforce = salesforce_object\n\n        return salesforce_object\n\n        # end method definition\n\n    def get_payload(self) -&gt; dict:\n        \"\"\"Get the Payload\"\"\"\n        return self._payload\n\n    def get_users(self) -&gt; list:\n        \"\"\"Get all useres\"\"\"\n        return self._users\n\n    def get_groups(self) -&gt; list:\n        \"\"\"Get all groups\"\"\"\n        return self._groups\n\n    def get_workspaces(self) -&gt; list:\n        \"\"\"Get all workspaces\"\"\"\n        return self._workspaces\n\n    def get_otcs_frontend(self) -&gt; object:\n        \"\"\"Get OTCS Frontend oject\"\"\"\n        return self._otcs_frontend\n\n    def get_otcs_backend(self) -&gt; object:\n        \"\"\"Get OTCS Backend object\"\"\"\n        return self._otcs_backend\n\n    def get_otds(self) -&gt; object:\n        \"\"\"Get OTDS object\"\"\"\n        return self._otds\n\n    def get_k8s(self) -&gt; object:\n        \"\"\"Get K8s object\"\"\"\n        return self._k8s\n\n    def getM365(self) -&gt; object:\n        \"\"\"Get M365 object\"\"\"\n        return self._m365\n\n    def generate_password(\n        self,\n        length: int,\n        use_special_chars: bool = False,\n        min_special: int = 1,\n        min_numerical: int = 1,\n        min_upper: int = 1,\n        min_lower: int = 1,\n        override_special: str = None,\n    ):\n        \"\"\"Function to generate random passwords with a given specification\n\n        Args:\n            length (int): Define password length\n            use_special_chars (bool, optional): Define if special characters should be used. Defaults to False.\n            min_special (int, optional): Define min amount of special characters. Defaults to 1.\n            min_numerical (int, optional): Define if numbers should be used. Defaults to 1.\n            min_upper (int, optional): Define mininum number of upper case letters. Defaults to 1.\n            min_lower (int, optional): Define minimum number of lower case letters. Defaults to 1.\n            override_special (string | None, optional): Define special characters to be used, if not set: !@#$%^&amp;*()_-+=&lt;&gt;?/{}[]. Defaults to None.\n\n        Raises:\n            ValueError: _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # Define character sets\n        lowercase_letters = string.ascii_lowercase\n        uppercase_letters = string.ascii_uppercase\n        numerical_digits = string.digits\n        special_characters = \"!@#$%^&amp;*()_-+=&lt;&gt;?/{}[]\"\n\n        if override_special:\n            special_characters = override_special\n        # Ensure minimum requirements are met\n\n        if min_special + min_numerical + min_upper + min_lower &gt; length:\n            raise ValueError(\"Minimum requirements exceed password length\")\n\n        # Initialize the password\n        password = []\n\n        # Add required characters\n        password.extend(random.sample(lowercase_letters, min_lower))\n        password.extend(random.sample(uppercase_letters, min_upper))\n        password.extend(random.sample(numerical_digits, min_numerical))\n\n        if use_special_chars:\n            password.extend(random.sample(special_characters, min_special))\n\n        # Fill the rest of the password with random characters\n        remaining_length = length - len(password)\n        all_chars = lowercase_letters + uppercase_letters + numerical_digits\n\n        if use_special_chars:\n            all_chars += special_characters\n\n        password.extend(random.choices(all_chars, k=remaining_length))\n\n        # Shuffle the password to ensure randomness\n        random.shuffle(password)\n\n        # Convert the password list to a string\n        final_password = \"\".join(password)\n\n        return final_password\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.__init__","title":"<code>__init__(payload_source, custom_settings_dir, k8s_object, otds_object, otac_object, otcs_backend_object, otcs_frontend_object, otcs_restart_callback, otiv_object, m365_object, browser_automation_object, placeholder_values, log_header_callback, stop_on_error=False, aviator_enabled=False)</code>","text":"<p>Initialize the Payload object</p> <p>Parameters:</p> Name Type Description Default <code>payload_source</code> <code>str</code> <p>path or URL to payload source file</p> required <code>k8s_object</code> <code>object</code> <p>Kubernetes object</p> required <code>otds_object</code> <code>OTDS</code> <p>OTDS object</p> required <code>otac_object</code> <code>OTAC</code> <p>OTAC object</p> required <code>otcs_backend_object</code> <code>OTCS</code> <p>OTCS backend object</p> required <code>otcs_frontend_object</code> <code>OTCS</code> <p>OTCS frontend object</p> required <code>otcs_restart_callback</code> <code>Callable</code> <p>function to call if OTCS service needs a restart</p> required <code>otiv_object</code> <code>object</code> <p>OTIV object</p> required <code>m365_object</code> <code>object</code> <p>M365 object to talk to Microsoft Graph API</p> required <code>browser_automation_object</code> <code>object</code> <p>BrowserAutomation object to automate things which don't have a REST API</p> required <code>placeholder_values</code> <code>dict</code> <p>dictionary of placeholder values                        to be replaced in admin settings</p> required <code>log_header_callback</code> <code>Callable</code> <p>prints a section break / header line into the log</p> required <code>stop_on_error</code> <code>bool</code> <p>controls if transport deployment should stop                   if one transport fails</p> <code>False</code> <code>aviator_enabled</code> <code>bool</code> <p>whether or not the Content Aviator is enabled</p> <code>False</code> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def __init__(\n    self,\n    payload_source: str,\n    custom_settings_dir: str,\n    k8s_object: K8s | None,\n    otds_object: OTDS,\n    otac_object: OTAC | None,\n    otcs_backend_object: OTCS,\n    otcs_frontend_object: OTCS,\n    otcs_restart_callback: Callable,\n    otiv_object: OTIV | None,\n    m365_object: M365 | None,\n    browser_automation_object: BrowserAutomation | None,\n    placeholder_values: dict,\n    log_header_callback: Callable,\n    stop_on_error: bool = False,\n    aviator_enabled: bool = False,\n):\n    \"\"\"Initialize the Payload object\n\n    Args:\n        payload_source (str): path or URL to payload source file\n        k8s_object (object): Kubernetes object\n        otds_object (OTDS): OTDS object\n        otac_object (OTAC): OTAC object\n        otcs_backend_object (OTCS): OTCS backend object\n        otcs_frontend_object (OTCS): OTCS frontend object\n        otcs_restart_callback (Callable): function to call if OTCS service needs a restart\n        otiv_object (object): OTIV object\n        m365_object (object): M365 object to talk to Microsoft Graph API\n        browser_automation_object (object): BrowserAutomation object to automate things which don't have a REST API\n        placeholder_values (dict): dictionary of placeholder values\n                                   to be replaced in admin settings\n        log_header_callback: prints a section break / header line into the log\n        stop_on_error (bool): controls if transport deployment should stop\n                              if one transport fails\n        aviator_enabled (bool): whether or not the Content Aviator is enabled\n    \"\"\"\n\n    self._stop_on_error = stop_on_error\n    self._payload_source = payload_source\n    self._k8s = k8s_object\n    self._otds = otds_object\n    self._otac = otac_object\n    self._otcs = otcs_backend_object\n    self._otcs_backend = otcs_backend_object\n    self._otcs_frontend = otcs_frontend_object\n    self._otiv = otiv_object\n    self._m365 = m365_object\n    self._sap = (\n        None  # this object only exists after external systems have been processed\n    )\n    self._salesforce = None\n    self._browser_automation = browser_automation_object\n    self._custom_settings_dir = custom_settings_dir\n    self._placeholder_values = placeholder_values\n    self._otcs_restart_callback = otcs_restart_callback\n    self._log_header_callback = log_header_callback\n    self._aviator_enabled = aviator_enabled\n    self._http_object = HTTP()\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.add_transport_extractions","title":"<code>add_transport_extractions(extractions)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>extractions</code> <code>list</code> <p>list of extractions from a single transport package</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of extractions that have actually extracted data</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def add_transport_extractions(self, extractions: list) -&gt; int:\n    \"\"\"_summary_\n\n    Args:\n        extractions (list): list of extractions from a single transport package\n\n    Returns:\n        int: number of extractions that have actually extracted data\n    \"\"\"\n\n    counter = 0\n    for extraction in extractions:\n        if extraction.get(\"enabled\", True) and \"data\" in extraction:\n            self._transport_extractions.append(extraction)\n            counter += 1\n    logger.info(\"Added -&gt; %s transport extractions\", str(counter))\n\n    return counter\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.check_external_system","title":"<code>check_external_system(external_system)</code>","text":"<p>Check if external system is reachable</p> <p>Parameters:</p> Name Type Description Default <code>external_system</code> <code>dict</code> <p>payload data structure of external system.                     We assume here that sanity check for                     valid data is already done before.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True = system is reachable, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def check_external_system(self, external_system: dict) -&gt; bool:\n    \"\"\"Check if external system is reachable\n\n    Args:\n        external_system (dict): payload data structure of external system.\n                                We assume here that sanity check for\n                                valid data is already done before.\n\n    Returns:\n        bool: True = system is reachable, False otherwise\n    \"\"\"\n\n    as_url = external_system[\"as_url\"]\n\n    # Extract the hostname:\n    external_system_hostname = urlparse(as_url).hostname\n    # Write this information back into the data structure:\n    external_system[\"external_system_hostname\"] = external_system_hostname\n    # Extract the port:\n    external_system_port = urlparse(as_url).port if urlparse(as_url).port else 80\n    # Write this information back into the data structure:\n    external_system[\"external_system_port\"] = external_system_port\n\n    if self._http_object.check_host_reachable(\n        external_system_hostname, external_system_port\n    ):\n        logger.info(\n            \"Mark external system -&gt; %s as reachable for later workspace creation and SAP RFC processing...\",\n            external_system[\"external_system_name\"],\n        )\n        external_system[\"reachable\"] = True\n        return True\n    else:\n        external_system[\"reachable\"] = False\n        return False\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.check_status_file","title":"<code>check_status_file(payload_section_name, payload_specific=True)</code>","text":"<p>Check if the payload section has been processed before. This is    done by checking the existance of a text file in the Admin Personal    workspace in Extended ECM with the name of the payload section.</p> <p>Parameters:</p> Name Type Description Default <code>payload_section_name</code> <code>str</code> <p>name of the payload section. This                         is used to construct the file name</p> required <code>payload_specific</code> <code>bool</code> <p>whether or not the success should be specific for                                each payload file or if success is \"global\" - like for the deletion                                of the existing M365 teams (which we don't want to execute per                                payload file)</p> <code>True</code> <p>Returns:     bool: True if the payload has been processed successfully before, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def check_status_file(\n    self, payload_section_name: str, payload_specific: bool = True\n) -&gt; bool:\n    \"\"\"Check if the payload section has been processed before. This is\n       done by checking the existance of a text file in the Admin Personal\n       workspace in Extended ECM with the name of the payload section.\n\n    Args:\n        payload_section_name (str): name of the payload section. This\n                                    is used to construct the file name\n        payload_specific (bool, optional): whether or not the success should be specific for\n                                           each payload file or if success is \"global\" - like for the deletion\n                                           of the existing M365 teams (which we don't want to execute per\n                                           payload file)\n    Returns:\n        bool: True if the payload has been processed successfully before, False otherwise\n    \"\"\"\n\n    logger.info(\n        \"Check if payload section -&gt; %s has been processed successfully before...\",\n        payload_section_name,\n    )\n\n    response = self._otcs.get_node_by_volume_and_path(\n        142\n    )  # write to Personal Workspace of Admin\n    target_folder_id = self._otcs.get_result_value(response, \"id\")\n    if not target_folder_id:\n        target_folder_id = 2004  # use Personal Workspace of Admin as fallback\n\n    file_name = self.get_status_file_name(\n        payload_section_name=payload_section_name, payload_specific=payload_specific\n    )\n\n    status_document = self._otcs.get_node_by_parent_and_name(\n        parent_id=int(target_folder_id), name=file_name, show_error=False\n    )\n    if status_document and status_document[\"results\"]:\n        name = self._otcs.get_result_value(status_document, \"name\")\n        if name == file_name:\n            logger.info(\n                \"Payload section -&gt; %s has been processed successfully before. Skipping...\",\n                payload_section_name,\n            )\n            return True\n    logger.info(\n        \"Payload section -&gt; %s has not been processed successfully before. Processing...\",\n        payload_section_name,\n    )\n    return False\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.cleanup_all_teams_m365","title":"<code>cleanup_all_teams_m365(section_name='teamsM365Cleanup')</code>","text":"<p>Delete Microsoft Teams that are left-overs from former deployments</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'teamsM365Cleanup'</code> <p>Returns:     bool: True if teams have been deleted, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def cleanup_all_teams_m365(self, section_name: str = \"teamsM365Cleanup\") -&gt; bool:\n    \"\"\"Delete Microsoft Teams that are left-overs from former deployments\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if teams have been deleted, False otherwise\n    \"\"\"\n\n    if not isinstance(self._m365, M365):\n        logger.error(\n            \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n            section_name,\n        )\n        return False\n\n    # We want this cleanup to only run once even if we have\n    # multiple payload files - so we pass payload_specific=False here:\n    if self.check_status_file(\n        payload_section_name=section_name, payload_specific=False\n    ):\n        logger.info(\n            \"Payload section -&gt; %s has been processed successfully before. Skip cleanup of M365 teams...\",\n            section_name,\n        )\n        return True\n\n    logger.info(\"Processing payload section -&gt; %s...\", section_name)\n\n    # We don't want to delete MS Teams that are matching the regular OTCS Group Names (like \"Sales\")\n    exception_list = self.get_all_group_names()\n\n    # These are the patterns that each MS Teams needs to match at least one of to be deleted\n    # Pattern 1: all MS teams with a name that has a number in brackets, line \"(1234)\"\n    # Pattern 2: all MS Teams with a name that starts with a number followed by a space,\n    #            followed by a \"-\" and followed by another space\n    # Pattern 3: all MS Teams with a name that starts with \"WS\" and a 1-4 digit number\n    #            (these are the workspaces for Purchase Contracts generated for Intelligent Filing)\n    # Pattern 4: all MS Teams with a name that ends with a 1-2 character + a number in brackets, like (US-1000)\n    #            this is a specialization of pattern 1\n    # Pattern 5: remove the teams that are created for the dummy copy&amp;paste template for the\n    #            Intelligent Filing workspaces\n    pattern_list = [\n        r\"\\(\\d+\\)\",\n        r\"\\d+\\s-\\s\",\n        r\"^WS\\d{1,4}$\",\n        r\"^.+?\\s\\(.{1,2}-\\d+\\)$\",\n        r\"Purchase\\sContract\\s\\(Template\\sfor\\sIntelligent\\sFiling\\)\",\n    ]\n\n    result = self._m365.delete_all_teams(exception_list, pattern_list)\n\n    # We want this cleanup to only run once even if we have\n    # multiple payload files - so we pass payload_specific=False here:\n    self.write_status_file(\n        success=True,\n        payload_section_name=section_name,\n        payload_section=exception_list + pattern_list,\n        payload_specific=False,\n    )\n\n    return result\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.cleanup_stale_teams_m365","title":"<code>cleanup_stale_teams_m365(workspace_types)</code>","text":"<p>Delete Microsoft Teams that are left-overs from former deployments.    This method is currently not used.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_types</code> <code>list</code> <p>list of all workspace types</p> required <p>Returns:     bool: True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def cleanup_stale_teams_m365(self, workspace_types: list) -&gt; bool:\n    \"\"\"Delete Microsoft Teams that are left-overs from former deployments.\n       This method is currently not used.\n\n    Args:\n        workspace_types (list): list of all workspace types\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n\n    if not isinstance(self._m365, M365):\n        logger.error(\n            \"Office 365 connection not setup properly. Skipping cleanup...\",\n        )\n        return False\n\n    if workspace_types == []:\n        logger.error(\"Empty workspace type list!\")\n        return False\n\n    for workspace_type in workspace_types:\n        if not \"name\" in workspace_type:\n            logger.error(\n                \"Workspace type -&gt; %s does not have a name. Skipping...\",\n                workspace_type,\n            )\n            continue\n        response = self._otcs.get_workspace_instances(workspace_type[\"name\"])\n        workspace_instances = response[\"results\"]\n        if not workspace_instances:\n            logger.info(\n                \"Workspace type -&gt; %s does not have any instances!\",\n                workspace_type[\"name\"],\n            )\n            continue\n        for workspace_instance in workspace_instances:\n            workspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\n            logger.info(\n                \"Check if stale Microsoft 365 Teams with name -&gt; %s exist...\",\n                workspace_name,\n            )\n            response = self._m365.delete_teams(workspace_name)\n\n    return True\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_group_id","title":"<code>determine_group_id(group)</code>","text":"<p>Determine the id of a group - either from payload or from OTCS.    If the group is found in OTCS write back the ID into the payload.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>dict</code> <p>group payload element</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>group ID</p> <p>Side Effects:     the group items are modified by adding an \"id\" dict element that     includes the technical ID of the group in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_group_id(self, group: dict) -&gt; int:\n    \"\"\"Determine the id of a group - either from payload or from OTCS.\n       If the group is found in OTCS write back the ID into the payload.\n\n    Args:\n        group (dict): group payload element\n\n    Returns:\n        int: group ID\n    Side Effects:\n        the group items are modified by adding an \"id\" dict element that\n        includes the technical ID of the group in Extended ECM\n    \"\"\"\n\n    # Is the ID already known in payload? (if determined before)\n    if \"id\" in group:\n        return group[\"id\"]\n\n    if not \"name\" in group:\n        logger.error(\"Group needs a name to lookup the ID.\")\n        return 0\n    group_name = group[\"name\"]\n\n    existing_groups = self._otcs.get_group(name=group_name)\n    # We use the lookup method here as get_group() could deliver more\n    # then 1 result element (in edge cases):\n    group_id = self._otcs.lookup_result_value(\n        response=existing_groups, key=\"name\", value=group_name, return_key=\"id\"\n    )\n\n    # Have we found an exact match?\n    if group_id:\n        # Write ID back into the payload:\n        group[\"id\"] = group_id\n        return group[\"id\"]\n    else:\n        logger.info(\"Did not find an existing group with name -&gt; %s\", group_name)\n        return 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_user_id","title":"<code>determine_user_id(user)</code>","text":"<p>Determine the id of a user - either from payload or from OTCS    If the user is found in OTCS write back the ID into the payload.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>dict</code> <p>user payload element</p> required <p>Returns:     int: user ID Side Effects:     the user items are modified by adding an \"id\" dict element that     includes the technical ID of the user in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_user_id(self, user: dict) -&gt; int:\n    \"\"\"Determine the id of a user - either from payload or from OTCS\n       If the user is found in OTCS write back the ID into the payload.\n\n    Args:\n        user (dict): user payload element\n    Returns:\n        int: user ID\n    Side Effects:\n        the user items are modified by adding an \"id\" dict element that\n        includes the technical ID of the user in Extended ECM\n    \"\"\"\n\n    # Is the ID already known in payload? (if determined before)\n    if \"id\" in user:\n        return user[\"id\"]\n\n    if not \"name\" in user:\n        logger.error(\"User needs a login name to lookup the ID.\")\n        return 0\n    user_name = user[\"name\"]\n\n    response = self._otcs.get_user(name=user_name)\n    # We use the lookup method here as get_user() could deliver more\n    # then 1 result element (in edge cases):\n    user_id = self._otcs.lookup_result_value(\n        response=response, key=\"name\", value=user_name, return_key=\"id\"\n    )\n\n    # Have we found an exact match?\n    if user_id:\n        # Write ID back into the payload\n        user[\"id\"] = user_id\n        return user[\"id\"]\n    else:\n        logger.info(\"Did not find an existing user with name -&gt; %s\", user_name)\n        return 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_user_id_m365","title":"<code>determine_user_id_m365(user)</code>","text":"<p>Determine the id of a M365 user - either from payload or from M365 via Graph API    If the user is found in M365 write back the M365 user ID into the payload.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>dict</code> <p>user payload element</p> required <p>Returns:     int: M365 user ID or 0 if the user is not found. Side Effects:     the user items are modified by adding an \"m365_id\" dict element that     includes the technical ID of the user in Microsoft 365</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_user_id_m365(self, user: dict) -&gt; int:\n    \"\"\"Determine the id of a M365 user - either from payload or from M365 via Graph API\n       If the user is found in M365 write back the M365 user ID into the payload.\n\n    Args:\n        user (dict): user payload element\n    Returns:\n        int: M365 user ID or 0 if the user is not found.\n    Side Effects:\n        the user items are modified by adding an \"m365_id\" dict element that\n        includes the technical ID of the user in Microsoft 365\n    \"\"\"\n\n    # is the payload already updated with the M365 user ID?\n    if \"m365_id\" in user:\n        return user[\"m365_id\"]\n\n    if not \"name\" in user:\n        logger.error(\"User needs a login name to lookup the M365 user ID.\")\n        return 0\n    user_name = user[\"name\"]\n\n    m365_user_name = user_name + \"@\" + self._m365.config()[\"domain\"]\n    existing_user = self._m365.get_user(m365_user_name)\n    if existing_user:\n        logger.info(\n            \"Found existing Microsoft 365 user -&gt; %s (%s) with ID -&gt; %s. Update m365_id in payload...\",\n            existing_user[\"displayName\"],\n            existing_user[\"userPrincipalName\"],\n            existing_user[\"id\"],\n        )\n        # write back the M365 user ID into the payload\n        user[\"m365_id\"] = existing_user[\"id\"]\n        return user[\"m365_id\"]\n    else:\n        logger.info(\"Did not find an existing M365 user with name -&gt; %s\", user_name)\n        return 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_workspace_id","title":"<code>determine_workspace_id(workspace)</code>","text":"<p>Determine the nodeID of a workspace - either from payload or from OTCS</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>dict</code> <p>workspace payload element</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>workspace Node ID</p> <p>Side Effects:     the workspace items are modified by adding an \"nodeId\" dict element that     includes the node ID of the workspace in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_workspace_id(self, workspace: dict) -&gt; int:\n    \"\"\"Determine the nodeID of a workspace - either from payload or from OTCS\n\n    Args:\n        workspace (dict): workspace payload element\n\n    Returns:\n        int: workspace Node ID\n    Side Effects:\n        the workspace items are modified by adding an \"nodeId\" dict element that\n        includes the node ID of the workspace in Extended ECM\n    \"\"\"\n\n    if \"nodeId\" in workspace:\n        return workspace[\"nodeId\"]\n\n    response = self._otcs.get_workspace_by_type_and_name(\n        type_name=workspace[\"type_name\"], name=workspace[\"name\"]\n    )\n    workspace_id = self._otcs.get_result_value(response, \"id\")\n    if workspace_id:\n        # Write nodeID back into the payload\n        workspace[\"nodeId\"] = workspace_id\n        return workspace_id\n    else:\n        logger.info(\n            \"Workspace of type -&gt; %s and name -&gt; %s does not yet exist.\",\n            workspace[\"type_name\"],\n            workspace[\"name\"],\n        )\n        return 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.generate_password","title":"<code>generate_password(length, use_special_chars=False, min_special=1, min_numerical=1, min_upper=1, min_lower=1, override_special=None)</code>","text":"<p>Function to generate random passwords with a given specification</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Define password length</p> required <code>use_special_chars</code> <code>bool</code> <p>Define if special characters should be used. Defaults to False.</p> <code>False</code> <code>min_special</code> <code>int</code> <p>Define min amount of special characters. Defaults to 1.</p> <code>1</code> <code>min_numerical</code> <code>int</code> <p>Define if numbers should be used. Defaults to 1.</p> <code>1</code> <code>min_upper</code> <code>int</code> <p>Define mininum number of upper case letters. Defaults to 1.</p> <code>1</code> <code>min_lower</code> <code>int</code> <p>Define minimum number of lower case letters. Defaults to 1.</p> <code>1</code> <code>override_special</code> <code>string | None</code> <p>Define special characters to be used, if not set: !@#$%^&amp;*()_-+=&lt;&gt;?/{}[]. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def generate_password(\n    self,\n    length: int,\n    use_special_chars: bool = False,\n    min_special: int = 1,\n    min_numerical: int = 1,\n    min_upper: int = 1,\n    min_lower: int = 1,\n    override_special: str = None,\n):\n    \"\"\"Function to generate random passwords with a given specification\n\n    Args:\n        length (int): Define password length\n        use_special_chars (bool, optional): Define if special characters should be used. Defaults to False.\n        min_special (int, optional): Define min amount of special characters. Defaults to 1.\n        min_numerical (int, optional): Define if numbers should be used. Defaults to 1.\n        min_upper (int, optional): Define mininum number of upper case letters. Defaults to 1.\n        min_lower (int, optional): Define minimum number of lower case letters. Defaults to 1.\n        override_special (string | None, optional): Define special characters to be used, if not set: !@#$%^&amp;*()_-+=&lt;&gt;?/{}[]. Defaults to None.\n\n    Raises:\n        ValueError: _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Define character sets\n    lowercase_letters = string.ascii_lowercase\n    uppercase_letters = string.ascii_uppercase\n    numerical_digits = string.digits\n    special_characters = \"!@#$%^&amp;*()_-+=&lt;&gt;?/{}[]\"\n\n    if override_special:\n        special_characters = override_special\n    # Ensure minimum requirements are met\n\n    if min_special + min_numerical + min_upper + min_lower &gt; length:\n        raise ValueError(\"Minimum requirements exceed password length\")\n\n    # Initialize the password\n    password = []\n\n    # Add required characters\n    password.extend(random.sample(lowercase_letters, min_lower))\n    password.extend(random.sample(uppercase_letters, min_upper))\n    password.extend(random.sample(numerical_digits, min_numerical))\n\n    if use_special_chars:\n        password.extend(random.sample(special_characters, min_special))\n\n    # Fill the rest of the password with random characters\n    remaining_length = length - len(password)\n    all_chars = lowercase_letters + uppercase_letters + numerical_digits\n\n    if use_special_chars:\n        all_chars += special_characters\n\n    password.extend(random.choices(all_chars, k=remaining_length))\n\n    # Shuffle the password to ensure randomness\n    random.shuffle(password)\n\n    # Convert the password list to a string\n    final_password = \"\".join(password)\n\n    return final_password\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.getM365","title":"<code>getM365()</code>","text":"<p>Get M365 object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def getM365(self) -&gt; object:\n    \"\"\"Get M365 object\"\"\"\n    return self._m365\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_all_group_names","title":"<code>get_all_group_names()</code>","text":"<p>Construct a list of all group name</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of all group names</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_all_group_names(self) -&gt; list:\n    \"\"\"Construct a list of all group name\n\n    Returns:\n        list: list of all group names\n    \"\"\"\n    return [group.get(\"name\") for group in self._groups]\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_business_object_properties","title":"<code>get_business_object_properties(bo_type_name)</code>","text":"<p>Get a dictionary with all property mapping of a business object type.    We contruct this dictionary from the two lists for the given    business object types (property mapping and property group mappings)    These two lists have been created before by process_business_object_types()</p> <p>This method is used for creation of business objects in Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>bo_type_name</code> <code>str</code> <p>Name of the business object type</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with keys that are either the attribute name or   a key that is contructed like this: st name + \"-\" + attribute name.   This allows for an easy lookup in mthods that have access to   the category data of business workspaces.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_business_object_properties(self, bo_type_name: str) -&gt; dict:\n    \"\"\"Get a dictionary with all property mapping of a business object type.\n       We contruct this dictionary from the two lists for the given\n       business object types (property mapping and property group mappings)\n       These two lists have been created before by process_business_object_types()\n\n       This method is used for creation of business objects in Salesforce.\n\n    Args:\n        bo_type_name (str): Name of the business object type\n\n    Returns:\n        dict: dictionary with keys that are either the attribute name or\n              a key that is contructed like this: st name + \"-\" + attribute name.\n              This allows for an easy lookup in mthods that have access to\n              the category data of business workspaces.\n    \"\"\"\n\n    # Find the matching business object type:\n    business_object_type = next(\n        (\n            item\n            for item in self._business_object_types\n            if item[\"name\"] == bo_type_name\n        ),\n        None,\n    )\n    if not business_object_type:\n        return None\n\n    business_properties = business_object_type.get(\"business_properties\")\n    business_property_groups = business_object_type.get(\"business_property_groups\")\n\n    lookup_dict = {}\n\n    for mapping in business_properties:\n        attribute_name = mapping.get(\"@attributeName\")\n        lookup_dict[attribute_name] = mapping\n\n    for mapping in business_property_groups:\n        set_name = mapping.get(\"@setName\")\n        attribute_name = mapping.get(\"@attributeName\")\n        lookup_dict[set_name + \"-\" + attribute_name] = mapping\n\n    return lookup_dict\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_groups","title":"<code>get_groups()</code>","text":"<p>Get all groups</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_groups(self) -&gt; list:\n    \"\"\"Get all groups\"\"\"\n    return self._groups\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_k8s","title":"<code>get_k8s()</code>","text":"<p>Get K8s object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_k8s(self) -&gt; object:\n    \"\"\"Get K8s object\"\"\"\n    return self._k8s\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_otcs_backend","title":"<code>get_otcs_backend()</code>","text":"<p>Get OTCS Backend object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_otcs_backend(self) -&gt; object:\n    \"\"\"Get OTCS Backend object\"\"\"\n    return self._otcs_backend\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_otcs_frontend","title":"<code>get_otcs_frontend()</code>","text":"<p>Get OTCS Frontend oject</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_otcs_frontend(self) -&gt; object:\n    \"\"\"Get OTCS Frontend oject\"\"\"\n    return self._otcs_frontend\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_otds","title":"<code>get_otds()</code>","text":"<p>Get OTDS object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_otds(self) -&gt; object:\n    \"\"\"Get OTDS object\"\"\"\n    return self._otds\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_payload","title":"<code>get_payload()</code>","text":"<p>Get the Payload</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_payload(self) -&gt; dict:\n    \"\"\"Get the Payload\"\"\"\n    return self._payload\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_payload_section","title":"<code>get_payload_section(payload_section_name)</code>","text":"<p>Get a defined section of the payload. The section is delivered as a list of settings. It deliveres an empty list if this payload section is disabled by the corresponding payload switch (this is read from the payloadSections dictionary of the payload)</p> <p>Parameters:</p> Name Type Description Default <code>payload_section_name</code> <code>str</code> <p>name of the dict element in the payload structure</p> required <p>Returns:     list: section of the payload as a Python list. Empty list if section does not exist     or section is disabled by the corresponding payload switch.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_payload_section(self, payload_section_name: str) -&gt; list:\n    \"\"\"Get a defined section of the payload. The section is delivered as a list of settings.\n    It deliveres an empty list if this payload section is disabled by the corresponding\n    payload switch (this is read from the payloadSections dictionary of the payload)\n\n    Args:\n        payload_section_name (str): name of the dict element in the payload structure\n    Returns:\n        list: section of the payload as a Python list. Empty list if section does not exist\n        or section is disabled by the corresponding payload switch.\n    \"\"\"\n\n    if not isinstance(self._payload, dict):\n        return []\n\n    # if the secton is not in the payload we return an empty list:\n    if not self._payload.get(payload_section_name):\n        return []\n\n    # Check if the payload section is either enabled\n    # or the struct for payloadSection enabling is not in the payload:\n    sections = self._payload.get(\"payloadSections\")\n    if sections:\n        section = next(\n            (item for item in sections if item[\"name\"] == payload_section_name),\n            None,\n        )\n        if not section or not section[\"enabled\"]:\n            return []\n\n    return self._payload[payload_section_name]\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_salesforce_business_object","title":"<code>get_salesforce_business_object(workspace, object_type, search_field, search_value)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>dict</code> <p>Workspace payload</p> required <code>object_type</code> <code>str</code> <p>Business Object Type</p> required <code>search_field</code> <code>str</code> <p>Search field to find business object in external system.</p> required <code>search_value</code> <code>str</code> <p>Search value to find business object in external system.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: technical ID of the business object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_salesforce_business_object(\n    self, workspace: dict, object_type: str, search_field: str, search_value: str\n) -&gt; str | None:\n    \"\"\"_summary_\n\n    Args:\n        workspace (dict): Workspace payload\n        object_type (str): Business Object Type\n        search_field (str): Search field to find business object in external system.\n        search_value (str): Search value to find business object in external system.\n\n    Returns:\n        str | None: technical ID of the business object\n    \"\"\"\n\n    if not self._salesforce:\n        logger.error(\n            \"Salesforce connection not initialized! Cannot connect to Salesforce API!\"\n        )\n        return None\n\n    logger.info(\n        \"Workspaces is connected to Salesforce and we need to lookup the BO ID...\"\n    )\n    salesforce_token = self._salesforce.authenticate()\n    if not salesforce_token:\n        logger.error(\"Failed to authenticate with Salesforce!\")\n        return None\n\n    response = self._salesforce.get_object(\n        object_type=object_type,\n        search_field=search_field,\n        search_value=search_value,\n        result_fields=[\"Id\"],\n    )\n    bo_id = self._salesforce.get_result_value(response, \"Id\")\n    if not bo_id:\n        logger.warning(\n            \"Business object of type -&gt; %s and %s = %s does not exist in Salesforce!\",\n            object_type,\n            search_field,\n            search_value,\n        )\n        logger.info(\"We try to create the Salesforce object...\")\n\n        # Geta helper dict to quickly lookup Salesforce properties\n        # for given set + attribute name:\n        property_lookup = self.get_business_object_properties(\n            bo_type_name=object_type\n        )\n        categories = workspace.get(\"categories\", [])\n        parameter_dict = {}\n        # We process all category entries in workspace payload\n        # and see if we have a matching mapping to a business property\n        # in the BO Type definition:\n        for category in categories:\n            # generate the lookup key:\n            key = \"\"\n            if \"set\" in category:\n                key += category[\"set\"] + \"-\"\n            key += category.get(\"attribute\")\n            # get the attribute value:\n            value = category.get(\"value\")\n            # lookup the mapping\n            mapping = property_lookup.get(key, None)\n            # Check if we have a mapping:\n            if mapping:\n                property_name = mapping.get(\"@propertyName\", None)\n                logger.info(\n                    \"Found business property -&gt; %s for attribute -&gt; %s\",\n                    property_name,\n                    category.get(\"attribute\"),\n                )\n                parameter_dict[property_name] = value\n            else:\n                logger.info(\n                    \"Attribute -&gt; %s (key -&gt; %s) does not have a mapped business property.\",\n                    category.get(\"attribute\"),\n                    key,\n                )\n\n        if not parameter_dict:\n            logger.warning(\"Cannot create Salesforce object - no parameters found\")\n            return None\n\n        logger.info(\n            \"Create Salesforce object of type -&gt; %s with parameters -&gt; %s\",\n            object_type,\n            str(parameter_dict),\n        )\n        #\n        # Now we try to create the Salesforce object\n        #\n        response = self._salesforce.add_object(\n            object_type=object_type, **parameter_dict\n        )\n        bo_id = self._salesforce.get_result_value(response, \"id\")\n        if bo_id:\n            logger.info(\n                \"Created Salesforce business object with ID -&gt; %s of type -&gt; %s \",\n                bo_id,\n                object_type,\n            )\n        else:\n            logger.error(\n                \"Failed to create Salesforce business object of type -&gt; %s\",\n                object_type,\n            )\n    else:\n        logger.info(\n            \"Retrieved ID -&gt; %s for Salesforce object type -&gt; %s (looking up -&gt; %s in field -&gt; %s)\",\n            bo_id,\n            object_type,\n            search_field,\n            search_value,\n        )\n\n    return bo_id\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_status_file","title":"<code>get_status_file(payload_section_name, payload_specific=True)</code>","text":"<p>Get the status file and read it into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>payload_section_name</code> <code>str</code> <p>name of the payload section. This                         is used to construct the file name</p> required <code>payload_specific</code> <code>bool</code> <p>whether or not the success should be specific for                      each payload file or if success is \"global\" - like for the deletion                      of the existing M365 teams (which we don't want to execute per                      payload file)</p> <code>True</code> <p>Returns:     dict: content of the status file as a dictionary or None in case of an error</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_status_file(\n    self, payload_section_name: str, payload_specific: bool = True\n) -&gt; list | None:\n    \"\"\"Get the status file and read it into a dictionary.\n\n    Args:\n        payload_section_name (str): name of the payload section. This\n                                    is used to construct the file name\n        payload_specific (bool): whether or not the success should be specific for\n                                 each payload file or if success is \"global\" - like for the deletion\n                                 of the existing M365 teams (which we don't want to execute per\n                                 payload file)\n    Returns:\n        dict: content of the status file as a dictionary or None in case of an error\n    \"\"\"\n\n    logger.info(\n        \"Get the status file of the payload section -&gt; %s...\",\n        payload_section_name,\n    )\n\n    response = self._otcs.get_node_by_volume_and_path(\n        142\n    )  # read from Personal Workspace of Admin\n    source_folder_id = self._otcs.get_result_value(response, \"id\")\n    if not source_folder_id:\n        source_folder_id = 2004  # use Personal Workspace of Admin as fallback\n\n    file_name = self.get_status_file_name(\n        payload_section_name=payload_section_name, payload_specific=payload_specific\n    )\n\n    status_document = self._otcs.get_node_by_parent_and_name(\n        parent_id=int(source_folder_id), name=file_name, show_error=True\n    )\n    status_file_id = self._otcs.get_result_value(status_document, \"id\")\n    if not status_file_id:\n        logger.error(\"Cannot find status file -&gt; %s\", file_name)\n        return None\n    content = self._otcs.get_document_content(status_file_id)\n\n    try:\n        json_data = json.loads(content.decode(\"utf-8\"))\n        if isinstance(json_data, list):\n            return json_data\n        else:\n            logger.error(\"File content is in JSON format but not a list.\")\n            return None\n    except json.JSONDecodeError as e:\n        logger.error(\"File content is not in valid JSON format; error -&gt; %s\", e)\n        return None\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_status_file_name","title":"<code>get_status_file_name(payload_section_name, payload_specific=True, prefix='success_')</code>","text":"<p>Construct the name of the status file.</p> <p>Parameters:</p> Name Type Description Default <code>payload_section_name</code> <code>str</code> <p>name of the payload section. This                         is used to construct the file name</p> required <code>payload_specific</code> <code>bool</code> <p>whether or not the success should be specific for                                each payload file or if success is \"global\" - like for the deletion                                of the existing M365 teams (which we don't want to execute per                                payload file)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>name of the payload section file</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_status_file_name(\n    self,\n    payload_section_name: str,\n    payload_specific: bool = True,\n    prefix: str = \"success_\",\n) -&gt; str:\n    \"\"\"Construct the name of the status file.\n\n    Args:\n        payload_section_name (str): name of the payload section. This\n                                    is used to construct the file name\n        payload_specific (bool, optional): whether or not the success should be specific for\n                                           each payload file or if success is \"global\" - like for the deletion\n                                           of the existing M365 teams (which we don't want to execute per\n                                           payload file)\n\n    Returns:\n        str: name of the payload section file\n    \"\"\"\n\n    # Some sections are actually not payload specific like teamsM365Cleanup\n    # we don't want external payload runs to re-apply this processing:\n    if payload_specific:\n        file_name = os.path.basename(self._payload_source)  # remove directories\n        # Split once at the first occurance of a dot\n        # as the _payload_source may have multiple suffixes\n        # such as .yml.gz.b64:\n        file_name = file_name.split(\".\", 1)[0]\n        file_name = prefix + file_name + \"_\" + payload_section_name + \".json\"\n    else:\n        file_name = prefix + payload_section_name + \".json\"\n\n    return file_name\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_users","title":"<code>get_users()</code>","text":"<p>Get all useres</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_users(self) -&gt; list:\n    \"\"\"Get all useres\"\"\"\n    return self._users\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_workspaces","title":"<code>get_workspaces()</code>","text":"<p>Get all workspaces</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_workspaces(self) -&gt; list:\n    \"\"\"Get all workspaces\"\"\"\n    return self._workspaces\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.init_payload","title":"<code>init_payload()</code>","text":"<p>Read the YAML or Terraform HCL payload file.</p> <p>Returns:     dict: payload as a Python dict. Elements are the different payload sections.           None in case the file couldn't be found or read.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def init_payload(self) -&gt; dict | None:\n    \"\"\"Read the YAML or Terraform HCL payload file.\n\n    Args:\n        None\n    Returns:\n        dict: payload as a Python dict. Elements are the different payload sections.\n              None in case the file couldn't be found or read.\n    \"\"\"\n\n    if not os.path.exists(self._payload_source):\n        logger.error(\"Cannot access payload file -&gt; %s\", self._payload_source)\n        return None\n\n    # Is it a YAML file?\n    if self._payload_source.endswith(\".yaml\"):\n        logger.info(\"Open payload from YAML file -&gt; %s\", self._payload_source)\n        try:\n            with open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\n                payload_data = stream.read()\n            self._payload = yaml.safe_load(payload_data)\n        except yaml.YAMLError as exception:\n            logger.error(\n                \"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\n                self._payload_source,\n                exception,\n            )\n            self._payload = {}\n    # Or is it a Terraform HCL file?\n    elif self._payload_source.endswith(\".tf\"):\n        logger.info(\n            \"Open payload from Terraform HCL file -&gt; %s\", self._payload_source\n        )\n        try:\n            with open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\n                self._payload = hcl2.api.load(stream)\n            # If payload is wrapped into \"external_payload\" we unwrap it:\n            if self._payload.get(\"external_payload\"):\n                self._payload = self._payload[\"external_payload\"]\n        except FileNotFoundError as exception:\n            logger.error(\n                \"Error while reading Terraform HCL payload file -&gt; %s; error -&gt; %s\",\n                self._payload_source,\n                exception,\n            )\n            self._payload = {}\n\n    elif self._payload_source.endswith(\".yml.gz.b64\"):\n        logger.info(\n            \"Open payload from base64-gz-YAML file -&gt; %s\", self._payload_source\n        )\n        try:\n            with open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\n                content = base64.b64decode(stream.read())\n                decoded_data = gzip.decompress(content)\n\n                self._payload = yaml.safe_load(decoded_data)\n\n        except yaml.YAMLError as exception:\n            logger.error(\n                \"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\n                self._payload_source,\n                exception,\n            )\n            self._payload = {}\n\n    # If not, it is an unsupported type:\n    else:\n        logger.error(\n            \"File -&gt; %s has unsupported file type\",\n            self._payload_source,\n        )\n        self._payload = {}\n\n    if self._payload is not None:\n        self._payload_sections = self._payload[\"payloadSections\"]\n\n        if not self._payload_sections:\n            logger.error(\n                \"Sections for payload -&gt; %s are undefined. Skipping...\",\n                self._payload_source,\n            )\n            return None\n\n    # Retrieve all the payload sections and store them in lists:\n    self._webhooks = self.get_payload_section(\"webHooks\")\n    self._webhooks_post = self.get_payload_section(\"webHooksPost\")\n    self._partitions = self.get_payload_section(\"partitions\")\n    self._oauth_clients = self.get_payload_section(\"oauthClients\")\n    self._auth_handlers = self.get_payload_section(\"authHandlers\")\n    self._trusted_sites = self.get_payload_section(\"trustedSites\")\n    self._system_attributes = self.get_payload_section(\"systemAttributes\")\n    self._groups = self.get_payload_section(\"groups\")\n    self._users = self.get_payload_section(\"users\")\n    self._admin_settings = self.get_payload_section(\"adminSettings\")\n    self._exec_pod_commands = self.get_payload_section(\"execPodCommands\")\n    self._external_systems = self.get_payload_section(\"externalSystems\")\n    self._transport_packages = self.get_payload_section(\"transportPackages\")\n    self._content_transport_packages = self.get_payload_section(\n        \"contentTransportPackages\"\n    )\n    self._transport_packages_post = self.get_payload_section(\n        \"transportPackagesPost\"\n    )\n    self._workspace_templates = self.get_payload_section(\"workspaceTemplates\")\n    self._workspaces = self.get_payload_section(\"workspaces\")\n    self._sap_rfcs = self.get_payload_section(\"sapRFCs\")\n    self._web_reports = self.get_payload_section(\"webReports\")\n    self._web_reports_post = self.get_payload_section(\"webReportsPost\")\n    self._cs_applications = self.get_payload_section(\"csApplications\")\n    self._admin_settings_post = self.get_payload_section(\"adminSettingsPost\")\n    self._additional_group_members = self.get_payload_section(\n        \"additionalGroupMemberships\"\n    )\n    self._additional_access_role_members = self.get_payload_section(\n        \"additionalAccessRoleMemberships\"\n    )\n    self._renamings = self.get_payload_section(\"renamings\")\n    self._items = self.get_payload_section(\"items\")\n    self._items_post = self.get_payload_section(\"itemsPost\")\n    self._permissions = self.get_payload_section(\"permissions\")\n    self._permissions_post = self.get_payload_section(\"permissionsPost\")\n    self._assignments = self.get_payload_section(\"assignments\")\n    self._security_clearances = self.get_payload_section(\"securityClearances\")\n    self._supplemental_markings = self.get_payload_section(\"supplementalMarkings\")\n    self._records_management_settings = self.get_payload_section(\n        \"recordsManagementSettings\"\n    )\n    self._holds = self.get_payload_section(\"holds\")\n    self._doc_generators = self.get_payload_section(\"documentGenerators\")\n    self._browser_automations = self.get_payload_section(\"browserAutomations\")\n    self._browser_automations_post = self.get_payload_section(\n        \"browserAutomationsPost\"\n    )\n\n    return self._payload\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.init_salesforce","title":"<code>init_salesforce(salesforce_external_system)</code>","text":"<p>Initialize Salesforce object for workspace creation. This is needed to query Salesforce API    to lookup IDs of Salesforce objects.</p> <p>Parameters:</p> Name Type Description Default <code>salesfoce_external_system</code> <code>dict</code> <p>Salesforce external system created before</p> required <p>Returns:     Salesforce: Salesforce object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def init_salesforce(self, salesforce_external_system: dict) -&gt; Salesforce | None:\n    \"\"\"Initialize Salesforce object for workspace creation. This is needed to query Salesforce API\n       to lookup IDs of Salesforce objects.\n\n    Args:\n        salesfoce_external_system (dict): Salesforce external system created before\n    Returns:\n        Salesforce: Salesforce object\n    \"\"\"\n\n    if not salesforce_external_system:\n        return None\n\n    username = salesforce_external_system[\"username\"]\n    password = salesforce_external_system[\"password\"]\n    base_url = salesforce_external_system[\"base_url\"]\n    authorization_url = salesforce_external_system.get(\"token_endpoint\", \"\")\n    client_id = salesforce_external_system[\"oauth_client_id\"]\n    client_secret = salesforce_external_system[\"oauth_client_secret\"]\n\n    logger.info(\"Connection parameters Salesforce:\")\n    logger.info(\"Salesforce base URL          = %s\", base_url)\n    logger.info(\"Salesforce authorization URL = %s\", base_url)\n    logger.info(\"Salesforce username          = %s\", username)\n    logger.debug(\"Salesforce password          = %s\", password)\n    logger.info(\"Salesforce client ID         = %s\", client_id)\n    logger.debug(\"Salesforce client secret     = %s\", client_secret)\n    salesforce_object = Salesforce(\n        base_url=base_url,\n        client_id=client_id,\n        client_secret=client_secret,\n        username=username,\n        password=password,\n        authorization_url=authorization_url,\n    )\n\n    self._salesforce = salesforce_object\n\n    return salesforce_object\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.init_sap","title":"<code>init_sap(sap_external_system, direct_application_server_login=True)</code>","text":"<p>Initialize SAP object for RFC communication with SAP S/4HANA.</p> <p>Parameters:</p> Name Type Description Default <code>sap_external_system</code> <code>dict</code> <p>SAP external system created before</p> required <code>direct_application_server_login</code> <code>bool</code> <p>flag to control wether we comminicate directly with                                     SAP application server or via a load balancer</p> <code>True</code> <p>Returns:     SAP: SAP object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def init_sap(\n    self, sap_external_system: dict, direct_application_server_login: bool = True\n) -&gt; SAP | None:\n    \"\"\"Initialize SAP object for RFC communication with SAP S/4HANA.\n\n    Args:\n        sap_external_system (dict): SAP external system created before\n        direct_application_server_login (bool): flag to control wether we comminicate directly with\n                                                SAP application server or via a load balancer\n    Returns:\n        SAP: SAP object\n    \"\"\"\n\n    if not sap_external_system:\n        return None\n\n    username = sap_external_system[\"username\"]\n    password = sap_external_system[\"password\"]\n    # \"external_system_hostname\" is extracted from as_url in process_external_systems()\n    host = sap_external_system[\"external_system_hostname\"]\n    client = sap_external_system.get(\"client\", \"100\")\n    system_number = sap_external_system.get(\"external_system_number\", \"00\")\n    system_id = sap_external_system[\"external_system_name\"]\n    group = sap_external_system.get(\"group\", \"PUBLIC\")\n    destination = sap_external_system.get(\"destination\", \"\")\n\n    logger.info(\"Connection parameters SAP:\")\n    logger.info(\"SAP Hostname             = %s\", host)\n    logger.info(\"SAP Client               = %s\", client)\n    logger.info(\"SAP System Number        = %s\", system_number)\n    logger.info(\"SAP System ID            = %s\", system_id)\n    logger.info(\"SAP User Name            = %s\", username)\n    if not direct_application_server_login:\n        logger.info(\"SAP Group Name (for RFC) = %s\", group)\n    if destination:\n        logger.info(\"SAP Destination          = %s\", destination)\n\n    if direct_application_server_login:\n        logger.info(\"SAP Login                = Direct Application Server (ashost)\")\n        sap_object = SAP(\n            username=username,\n            password=password,\n            ashost=host,\n            client=client,\n            system_number=system_number,\n            system_id=system_id,\n            destination=destination,\n        )\n    else:\n        logger.info(\"SAP Login                = Logon with load balancing (mshost)\")\n        sap_object = SAP(\n            username=username,\n            password=password,\n            mshost=host,\n            group=group,\n            client=client,\n            system_number=system_number,\n            system_id=system_id,\n            destination=destination,\n        )\n\n    self._sap = sap_object\n\n    return sap_object\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.prepare_workspace_business_objects","title":"<code>prepare_workspace_business_objects(workspace, business_objects)</code>","text":"<p>Prepare the business object data for the workspace creation.    This supports multiple external system connections. This methods    also checks if the external system is reachable and tries to create    missing business objects in the leading system if they are missing.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>dict</code> <p>Payload data for the Workspace</p> required <code>business_objects</code> <code>list</code> <p>Payload data for the business object connections.</p> required <p>Returns:</p> Type Description <code>list | None</code> <p>list | None: list of business object data connections (dicts)</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def prepare_workspace_business_objects(\n    self, workspace: dict, business_objects: list\n) -&gt; list | None:\n    \"\"\"Prepare the business object data for the workspace creation.\n       This supports multiple external system connections. This methods\n       also checks if the external system is reachable and tries to create\n       missing business objects in the leading system if they are missing.\n\n    Args:\n        workspace (dict): Payload data for the Workspace\n        business_objects (list): Payload data for the business object connections.\n\n    Returns:\n        list | None: list of business object data connections (dicts)\n    \"\"\"\n\n    business_object_list = []\n\n    for business_object_data in business_objects:\n        business_object = {}\n\n        name = workspace.get(\"name\")\n\n        # Read business object data from workspace payload.\n        # business_object_data is a dict with 3-5 elements:\n        if \"external_system\" in business_object_data:\n            ext_system_id = business_object_data[\"external_system\"]\n        else:\n            logger.error(\n                \"Missing External System in Business Object payload for workspace -&gt; %s.\",\n                name,\n            )\n            continue\n        if \"bo_type\" in business_object_data:\n            bo_type = business_object_data[\"bo_type\"]\n        else:\n            logger.error(\n                \"Missing Type in Business Object payload for workspace -&gt; %s.\",\n                name,\n            )\n            continue\n\n        if \"bo_id\" in business_object_data:\n            bo_id = business_object_data[\"bo_id\"]\n            bo_search_field = None\n            bo_search_value = None\n        elif (\n            not \"bo_search_field\" in business_object_data\n            or not \"bo_search_value\" in business_object_data\n        ):\n            logger.error(\n                \"Missing BO search fields (bo_search_field, bo_search_value) in Business Object payload for workspace -&gt; %s.\",\n                name,\n            )\n            continue\n        else:\n            bo_search_field = business_object_data[\"bo_search_field\"]\n            bo_search_value = business_object_data[\"bo_search_value\"]\n            bo_id = None\n\n        # Check if external system has been declared in payload:\n        external_system = next(\n            (\n                item\n                for item in self._external_systems\n                if (item[\"external_system_name\"] == ext_system_id)\n            ),\n            None,\n        )\n\n        if not external_system:\n            logger.warning(\n                \"External System -&gt; %s does not exist. Cannot connect workspace -&gt; %s to -&gt; %s. Create workspace without connection.\",\n                ext_system_id,\n                name,\n                ext_system_id,\n            )\n            continue\n        elif not external_system.get(\"reachable\"):\n            logger.warning(\n                \"External System -&gt; %s is not reachable. Cannot connect workspace -&gt; %s to -&gt; (%s, %s, %s, %s, %s). Create workspace without connection...\",\n                ext_system_id,\n                name,\n                ext_system_id,\n                bo_type,\n                bo_id,\n                bo_search_field,\n                bo_search_value,\n            )\n            continue\n        external_system_type = external_system.get(\"external_system_type\", \"\")\n\n        logger.info(\n            \"Workspace -&gt; %s will be connected with external system -&gt; %s (%s) with (type -&gt; %s, id -&gt; %s, search_field -&gt; %s, search_value -&gt; %s)\",\n            name,\n            external_system_type,\n            ext_system_id,\n            bo_type,\n            bo_id,\n            bo_search_field,\n            bo_search_value,\n        )\n\n        # For Salesforce we need to determine the actual business object ID (technical ID):\n        if external_system_type == \"Salesforce\" and not bo_id:\n            bo_id = self.get_salesforce_business_object(\n                workspace,\n                object_type=bo_type,\n                search_field=bo_search_field,\n                search_value=bo_search_value,\n            )\n            if not bo_id:\n                continue\n\n        business_object[\"ext_system_id\"] = ext_system_id\n        business_object[\"bo_type\"] = bo_type\n        business_object[\"bo_id\"] = bo_id\n\n        logger.info(\"Add external system -&gt; %s to list.\", bo_type)\n        business_object_list.append(business_object)\n\n    return business_object_list\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.prepare_workspace_create_form","title":"<code>prepare_workspace_create_form(categories, template_id, ext_system_id, bo_type, bo_id, parent_workspace_node_id)</code>","text":"<p>Prepare the category structure for the workspace creation.</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>list</code> <p>categories list from workspace payload</p> required <code>template_id</code> <code>int</code> <p>workspace template ID</p> required <code>ext_system_id</code> <code>int</code> <p>External system ID</p> required <code>bo_type</code> <code>int</code> <p>Business Object Type ID</p> required <code>bo_id</code> <code>int</code> <p>Business Object ID</p> required <code>parent_workspace_node_id</code> <code>int</code> <p>Parent Workspace ID</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: category structure for workspace creation or None          in case of an error.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def prepare_workspace_create_form(\n    self,\n    categories: list,\n    template_id: int,\n    ext_system_id: int,\n    bo_type: int,\n    bo_id: int,\n    parent_workspace_node_id: int,\n) -&gt; dict | None:\n    \"\"\"Prepare the category structure for the workspace creation.\n\n    Args:\n        categories (list): categories list from workspace payload\n        template_id (int): workspace template ID\n        ext_system_id (int): External system ID\n        bo_type (int): Business Object Type ID\n        bo_id (int): Business Object ID\n        parent_workspace_node_id (int): Parent Workspace ID\n\n    Returns:\n        dict | None: category structure for workspace creation or None\n                     in case of an error.\n    \"\"\"\n\n    category_create_data = {\"categories\": {}}\n\n    response = self._otcs.get_workspace_create_form(\n        template_id=template_id,\n        external_system_id=ext_system_id,\n        bo_type=bo_type,\n        bo_id=bo_id,\n        parent_id=parent_workspace_node_id,\n    )\n    if response is None:\n        logger.error(\n            \"Failed to retrieve create information for template -&gt; %s\",\n            template_id,\n        )\n        return None\n\n    logger.info(\n        \"Successfully retrieved create information for template -&gt; %s\",\n        template_id,\n    )\n\n    # Process category information\n    forms = response[\"forms\"]\n\n    categories_form = {}\n\n    # Typically the the create workspace form delivers 3 forms:\n    # 1. Form for System Attributes (has no role name)\n    # 2. Form for Category Data (role name = \"categories\")\n    # 3. Form for Classifications (role name = \"classifications\")\n    # First we extract these 3 forms:\n    for form in forms:\n        if \"role_name\" in form and form[\"role_name\"] == \"categories\":\n            categories_form = form\n            logger.debug(\"Found Categories form -&gt; %s\", form)\n            continue\n        if \"role_name\" in form and form[\"role_name\"] == \"classifications\":\n            logger.debug(\"Found Classification form -&gt; %s\", form)\n            continue\n        # the remaining option is that this form is the system attributes form:\n        logger.debug(\"Found System Attributes form -&gt; %s\", form)\n\n    # We are just interested in the single category data set (role_name = \"categories\"):\n    data = categories_form[\"data\"]\n    logger.debug(\"Categories data found -&gt; %s\", data)\n    schema = categories_form[\"schema\"][\"properties\"]\n    logger.debug(\"Categories schema found -&gt; %s\", schema)\n    # parallel loop over category data and schema\n    for cat_data, cat_schema in zip(data, schema):\n        logger.info(\"Category ID -&gt; %s\", cat_data)\n        data_attributes = data[cat_data]\n        logger.debug(\"Data Attributes -&gt; %s\", data_attributes)\n        schema_attributes = schema[cat_schema][\"properties\"]\n        logger.debug(\"Schema Attributes -&gt; %s\", schema_attributes)\n        cat_name = schema[cat_schema][\"title\"]\n        logger.info(\"Category name -&gt; %s\", cat_name)\n        # parallel loop over attribute data and schema\n        # Sets with one (fixed) row have type = object\n        # Multi-value Sets with (multiple) rows have type = array and \"properties\" in \"items\" schema\n        # Multi-value attributes have also type = array but NO \"properties\" in \"items\" schema\n        for attr_data, attr_schema in zip(data_attributes, schema_attributes):\n            logger.debug(\"Attribute ID -&gt; %s\", attr_data)\n            logger.debug(\"Attribute Data -&gt; %s\", data_attributes[attr_data])\n            logger.debug(\"Attribute Schema -&gt; %s\", schema_attributes[attr_schema])\n            attr_type = schema_attributes[attr_schema][\"type\"]\n            logger.debug(\"Attribute Type -&gt; %s\", attr_type)\n            if not \"title\" in schema_attributes[attr_schema]:\n                logger.debug(\"Attribute has no title. Skipping...\")\n                continue\n            # Check if it is an multi-line set:\n            if attr_type == \"array\" and (\n                \"properties\" in schema_attributes[attr_schema][\"items\"]\n            ):\n                set_name = schema_attributes[attr_schema][\"title\"]\n                logger.info(\"Multi-line Set -&gt; %s\", set_name)\n                set_data_attributes = data_attributes[\n                    attr_data\n                ]  # this is a list []\n                logger.debug(\"Set Data Attributes -&gt; %s\", set_data_attributes)\n                set_schema_attributes = schema_attributes[attr_schema][\"items\"][\n                    \"properties\"\n                ]\n                logger.debug(\"Set Schema Attributes -&gt; %s\", set_schema_attributes)\n                set_schema_max_rows = schema_attributes[attr_schema][\"items\"][\n                    \"maxItems\"\n                ]\n                logger.debug(\"Set Schema Max Rows -&gt; %s\", set_schema_max_rows)\n                set_data_max_rows = len(set_data_attributes)\n                logger.debug(\"Set Data Max Rows -&gt; %s\", set_data_max_rows)\n                row = 1\n                # it can happen that the payload contains more rows than the\n                # initial rows in the set data structure. In this case we use\n                # a copy of the data structure from row 0 as template...\n                first_row = dict(set_data_attributes[0])\n                # We don't know upfront how many rows of data we will find in payload\n                # but we at max process the maxItems specified in the schema:\n                while row &lt;= set_schema_max_rows:\n                    # Test if we have any payload for this row:\n                    attribute = next(\n                        (\n                            item\n                            for item in categories\n                            if (\n                                item[\"name\"] == cat_name\n                                and \"set\"\n                                in item  # not all items may have a \"set\" key\n                                and item[\"set\"] == set_name\n                                and \"row\"\n                                in item  # not all items may have a \"row\" key\n                                and item[\"row\"] == row\n                            )\n                        ),\n                        None,\n                    )\n                    # stop if there's no payload for the row:\n                    if attribute is None:\n                        logger.info(\n                            \"No payload found for set -&gt; %s, row -&gt; %s\",\n                            set_name,\n                            row,\n                        )\n                        # we assume that if there's no payload for row n there will be no payload for rows &gt; n\n                        # and break the while loop:\n                        break\n                    # do we need to create a new row in the data set?\n                    elif row &gt; set_data_max_rows:\n                        # use the row we stored above to create a new empty row:\n                        logger.info(\n                            \"Found payload for row -&gt; %s, we need a new data row for it\",\n                            row,\n                        )\n                        logger.info(\n                            \"Adding an additional row -&gt; %s to set data -&gt; %s\",\n                            row,\n                            set_name,\n                        )\n                        # add the empty dict to the list:\n                        set_data_attributes.append(dict(first_row))\n                        set_data_max_rows += 1\n                    else:\n                        logger.info(\n                            \"Found payload for row -&gt; %s %s we can store in existing data row\",\n                            row,\n                            set_name,\n                        )\n                    # traverse all attributes in a single row:\n                    for set_attr_schema in set_schema_attributes:\n                        logger.debug(\n                            \"Set Attribute ID -&gt; %s (row -&gt; %s)\",\n                            set_attr_schema,\n                            row,\n                        )\n                        logger.debug(\n                            \"Set Attribute Schema -&gt; %s (row -&gt; %s)\",\n                            set_schema_attributes[set_attr_schema],\n                            row,\n                        )\n                        set_attr_type = set_schema_attributes[set_attr_schema][\n                            \"type\"\n                        ]\n                        logger.debug(\n                            \"Set Attribute Type -&gt; %s (row -&gt; %s)\",\n                            set_attr_type,\n                            row,\n                        )\n                        set_attr_name = set_schema_attributes[set_attr_schema][\n                            \"title\"\n                        ]\n                        logger.debug(\n                            \"Set Attribute Name -&gt; %s (row -&gt; %s)\",\n                            set_attr_name,\n                            row,\n                        )\n                        # Lookup the attribute with the right category, set, attribute name, and row number in payload:\n                        attribute = next(\n                            (\n                                item\n                                for item in categories\n                                if (\n                                    item[\"name\"] == cat_name\n                                    and \"set\"\n                                    in item  # not all items may have a \"set\" key\n                                    and item[\"set\"] == set_name\n                                    and item[\"attribute\"] == set_attr_name\n                                    and \"row\"\n                                    in item  # not all items may have a \"row\" key\n                                    and item[\"row\"] == row\n                                )\n                            ),\n                            None,\n                        )\n                        if attribute is None:\n                            logger.warning(\n                                \"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s not found in payload.\",\n                                set_name,\n                                set_attr_name,\n                                row,\n                            )\n\n                            # need to use row - 1 as index starts with 0 but payload rows start with 1\n                            set_data_attributes[row - 1][set_attr_schema] = \"\"\n                        else:\n                            logger.info(\n                                \"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s found in payload, value -&gt; %s\",\n                                set_name,\n                                set_attr_name,\n                                row,\n                                attribute[\"value\"],\n                            )\n                            # Put the value from the payload into data structure\n                            # need to use row - 1 as index starts with 0 but payload rows start with 1\n                            set_data_attributes[row - 1][set_attr_schema] = (\n                                attribute[\"value\"]\n                            )\n                    row += 1  # continue the while loop with the next row\n            # Check if it is single-line set:\n            elif attr_type == \"object\":\n                set_name = schema_attributes[attr_schema][\"title\"]\n                logger.info(\"Single-line Set -&gt; %s\", set_name)\n                set_data_attributes = data_attributes[attr_data]\n                logger.debug(\"Set Data Attributes -&gt; %s\", set_data_attributes)\n\n                set_schema_attributes = schema_attributes[attr_schema][\"properties\"]\n                logger.debug(\"Set Schema Attributes -&gt; %s\", set_schema_attributes)\n                for set_attr_data, set_attr_schema in zip(\n                    set_data_attributes, set_schema_attributes\n                ):\n                    logger.debug(\"Set Attribute ID -&gt; %s\", set_attr_data)\n                    logger.debug(\n                        \"Set Attribute Data -&gt; %s\",\n                        set_data_attributes[set_attr_data],\n                    )\n                    logger.debug(\n                        \"Set Attribute Schema -&gt; %s\",\n                        set_schema_attributes[set_attr_schema],\n                    )\n                    set_attr_type = set_schema_attributes[set_attr_schema][\"type\"]\n                    logger.debug(\"Set Attribute Type -&gt; %s\", set_attr_type)\n                    set_attr_name = set_schema_attributes[set_attr_schema][\"title\"]\n                    logger.debug(\"Set Attribute Name -&gt; %s\", set_attr_name)\n                    # Lookup the attribute with the right category, set and attribute name in payload:\n                    attribute = next(\n                        (\n                            item\n                            for item in categories\n                            if (\n                                item[\"name\"] == cat_name\n                                and \"set\"\n                                in item  # not all items may have a \"set\" key\n                                and item[\"set\"] == set_name\n                                and item[\"attribute\"] == set_attr_name\n                            )\n                        ),\n                        None,\n                    )\n                    if attribute is None:\n                        logger.warning(\n                            \"Set -&gt; %s, Attribute -&gt; %s not found in payload.\",\n                            set_name,\n                            set_attr_name,\n                        )\n                        set_data_attributes[set_attr_data] = \"\"\n                    else:\n                        logger.info(\n                            \"Set -&gt; %s, Attribute -&gt; %s found in payload, value -&gt; %s\",\n                            set_name,\n                            set_attr_name,\n                            attribute[\"value\"],\n                        )\n                        # Put the value from the payload into data structure\n                        set_data_attributes[set_attr_data] = attribute[\"value\"]\n            # It is a plain attribute (not inside a set) or it is a multi-value attribute (not inside a set):\n            else:\n                attr_name = schema_attributes[attr_schema][\"title\"]\n                logger.debug(\"Attribute Name -&gt; %s\", attr_name)\n                # Lookup the attribute with the right category and attribute name in payload:\n                attribute = next(\n                    (\n                        item\n                        for item in categories\n                        if (\n                            item[\"name\"] == cat_name\n                            and item[\"attribute\"] == attr_name\n                        )\n                    ),\n                    None,\n                )\n                if attribute is None:\n                    logger.warning(\n                        \"Attribute -&gt; %s not found in payload.\", attr_name\n                    )\n                    data_attributes[attr_data] = \"\"\n                else:\n                    logger.info(\n                        \"Attribute -&gt; %s found in payload, value -&gt; %s\",\n                        attr_name,\n                        attribute[\"value\"],\n                    )\n                    # We need to handle a very special case here for Extended ECM for Government\n                    # which has an attribute type \"Organizational Unit\" (OU). This is referring to a group ID\n                    # which is not stable across deployments. So we need to lookup the Group ID and add it\n                    # to the data structure. This expects that the payload has the Group Name and not the Group ID\n                    if attr_type == str(11480):\n                        logger.info(\n                            \"Attribute -&gt; %s is is of type -&gt; Organizational Unit (%s). Looking up group ID for group name -&gt; %s\",\n                            attr_name,\n                            attr_type,\n                            attribute[\"value\"],\n                        )\n                        group = self._otcs.get_group(attribute[\"value\"])\n                        group_id = self._otcs.lookup_result_value(\n                            group, \"name\", attribute[\"value\"], \"id\"\n                        )\n\n                        if group_id:\n                            logger.info(\n                                \"Group for Organizational Unit -&gt; %s has ID -&gt; %s\",\n                                attribute[\"value\"],\n                                group_id,\n                            )\n                            # Put the group ID into data structure\n                            data_attributes[attr_data] = str(group_id)\n                        else:\n                            logger.error(\n                                \"Group for Organizational Unit -&gt; %s does not exist!\",\n                                attribute[\"value\"],\n                            )\n                            # Clear the value to avoid workspace create failure\n                            data_attributes[attr_data] = \"\"\n                    # handle special case where attribute type is a user picker.\n                    # we expect that the payload includes the login name for this\n                    # (as user IDs are not stable across systems) but then we need\n                    # to lookup the real user ID here:\n                    elif attr_type == \"otcs_user_picker\":\n                        logger.info(\n                            \"Attribute -&gt; %s is is of type -&gt; User Picker (%s). Looking up user ID for user login name -&gt; %s\",\n                            attr_name,\n                            attr_type,\n                            attribute[\"value\"],\n                        )\n                        user = self._otcs.get_user(attribute[\"value\"])\n                        user_id = self._otcs.lookup_result_value(\n                            response=user,\n                            key=\"name\",\n                            value=attribute[\"value\"],\n                            return_key=\"id\",\n                        )\n                        if user_id:\n                            # User has been found - determine ID:\n                            logger.info(\n                                \"User -&gt; %s has ID -&gt; %s\",\n                                attribute[\"value\"],\n                                user_id,\n                            )\n                            # Put the user ID into data structure\n                            data_attributes[attr_data] = str(user_id)\n                        else:\n                            logger.error(\n                                \"User with login name -&gt; %s does not exist!\",\n                                attribute[\"value\"],\n                            )\n                            # Clear the value to avoid workspace create failure\n                            data_attributes[attr_data] = \"\"\n                    else:\n                        # Put the value from the payload into data structure\n                        data_attributes[attr_data] = attribute[\"value\"]\n        category_create_data[\"categories\"][cat_data] = data_attributes\n\n    logger.debug(\"Category Create Data -&gt; %s\", category_create_data)\n\n    return category_create_data\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_additional_access_role_members","title":"<code>process_additional_access_role_members(section_name='additionalAccessRoleMemberships')</code>","text":"<p>Process additional access role memberships we want to have in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'additionalAccessRoleMemberships'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_additional_access_role_members(\n    self, section_name: str = \"additionalAccessRoleMemberships\"\n) -&gt; bool:\n    \"\"\"Process additional access role memberships we want to have in OTDS.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._additional_access_role_members:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for additional_access_role_member in self._additional_access_role_members:\n        if not \"access_role\" in additional_access_role_member:\n            logger.error(\"Missing access_role! Skipping...\")\n            continue\n        access_role = additional_access_role_member[\"access_role\"]\n\n        if (\n            \"enabled\" in additional_access_role_member\n            and not additional_access_role_member[\"enabled\"]\n        ):\n            logger.info(\n                \"Payload for Additional Member for AccessRole -&gt; %s is disabled. Skipping...\",\n                access_role,\n            )\n            continue\n\n        if (\n            (not \"user_name\" in additional_access_role_member)\n            and (not \"group_name\" in additional_access_role_member)\n            and (not \"partition_name\" in additional_access_role_member)\n        ):\n            logger.error(\n                \"Either group_name or user_name need to be specified! Skipping...\"\n            )\n            success = False\n            continue\n        if \"group_name\" in additional_access_role_member:\n            group_name = additional_access_role_member[\"group_name\"]\n            logger.info(\n                \"Adding group -&gt; %s to access role -&gt; %s in OTDS.\",\n                group_name,\n                access_role,\n            )\n            response = self._otds.add_group_to_access_role(access_role, group_name)\n            if not response:\n                logger.error(\n                    \"Failed to add group -&gt; %s to access role -&gt; %s in OTDS.\",\n                    group_name,\n                    access_role,\n                )\n                success = False\n        elif \"user_name\" in additional_access_role_member:\n            user_name = additional_access_role_member[\"user_name\"]\n            logger.info(\n                \"Adding user -&gt; %s to access role -&gt; %s in OTDS.\",\n                user_name,\n                access_role,\n            )\n            response = self._otds.add_user_to_access_role(access_role, user_name)\n            if not response:\n                logger.error(\n                    \"Failed to add user -&gt; %s to access role -&gt; %s in OTDS.\",\n                    user_name,\n                    access_role,\n                )\n                success = False\n        elif \"partition_name\" in additional_access_role_member:\n            partition_name = additional_access_role_member[\"partition_name\"]\n            logger.info(\n                \"Adding partition -&gt; %s to access role -&gt; %s in OTDS.\",\n                partition_name,\n                access_role,\n            )\n            response = self._otds.add_partition_to_access_role(\n                access_role, partition_name\n            )\n            if not response:\n                logger.error(\n                    \"Failed to add partition -&gt; %s to access role -&gt; %s in OTDS.\",\n                    partition_name,\n                    access_role,\n                )\n                success = False\n\n    self.write_status_file(\n        success, section_name, self._additional_access_role_members\n    )\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_additional_group_members","title":"<code>process_additional_group_members(section_name='additionalGroupMemberships')</code>","text":"<p>Process additional groups memberships we want to have in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'additionalGroupMemberships'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_additional_group_members(\n    self, section_name: str = \"additionalGroupMemberships\"\n) -&gt; bool:\n    \"\"\"Process additional groups memberships we want to have in OTDS.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._additional_group_members:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for additional_group_member in self._additional_group_members:\n        if not \"parent_group\" in additional_group_member:\n            logger.error(\"Missing parent_group! Skipping...\")\n            continue\n        parent_group = additional_group_member[\"parent_group\"]\n\n        if (\n            \"enabled\" in additional_group_member\n            and not additional_group_member[\"enabled\"]\n        ):\n            logger.info(\n                \"Payload for Additional Group Member with Parent Group -&gt; %s is disabled. Skipping...\",\n                parent_group,\n            )\n            continue\n\n        if (not \"user_name\" in additional_group_member) and (\n            not \"group_name\" in additional_group_member\n        ):\n            logger.error(\n                \"Either group_name or user_name need to be specified! Skipping...\"\n            )\n            success = False\n            continue\n        if \"group_name\" in additional_group_member:\n            group_name = additional_group_member[\"group_name\"]\n            logger.info(\n                \"Adding group -&gt; %s to parent group -&gt; %s in OTDS.\",\n                group_name,\n                parent_group,\n            )\n            response = self._otds.add_group_to_parent_group(\n                group_name, parent_group\n            )\n            if not response:\n                logger.error(\n                    \"Failed to add group -&gt; %s to parent group -&gt; %s in OTDS.\",\n                    group_name,\n                    parent_group,\n                )\n                success = False\n        elif \"user_name\" in additional_group_member:\n            user_name = additional_group_member[\"user_name\"]\n            logger.info(\n                \"Adding user -&gt; %s to group -&gt; %s in OTDS.\", user_name, parent_group\n            )\n            response = self._otds.add_user_to_group(user_name, parent_group)\n            if not response:\n                logger.error(\n                    \"Failed to add user -&gt; %s to group -&gt; %s in OTDS.\",\n                    user_name,\n                    parent_group,\n                )\n                success = False\n\n    self.write_status_file(success, section_name, self._additional_group_members)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_admin_settings","title":"<code>process_admin_settings(admin_settings, section_name='adminSettings')</code>","text":"<p>Process admin settings in payload and import them to Extended ECM.</p> <pre><code>The payload section is a list of dicts with these items:\n{\n    enabled: True or False to enable or disable the payload item\n    filename: The filename of the XML file with admin settings.\n              It needs to be the plain filename like \"admin.xml\".\n              The files reside inside the container in /settings root\n              directory. They are placed there by the Terraform automation\n              and are taken from the ./settings/payload directory.\n    description: Some description about the purpose of the settings.\n                 Just for information and optional.\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>admin_settings</code> <code>list</code> <p>list of admin settings. We need this parameter                    as we process two different lists.</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"adminSettingsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'adminSettings'</code> <p>Returns:     bool: True if a restart of the OTCS pods is required. False otherwise.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_admin_settings(\n    self, admin_settings: list, section_name: str = \"adminSettings\"\n) -&gt; bool:\n    \"\"\"Process admin settings in payload and import them to Extended ECM.\n\n        The payload section is a list of dicts with these items:\n        {\n            enabled: True or False to enable or disable the payload item\n            filename: The filename of the XML file with admin settings.\n                      It needs to be the plain filename like \"admin.xml\".\n                      The files reside inside the container in /settings root\n                      directory. They are placed there by the Terraform automation\n                      and are taken from the ./settings/payload directory.\n            description: Some description about the purpose of the settings.\n                         Just for information and optional.\n        }\n\n    Args:\n        admin_settings (list): list of admin settings. We need this parameter\n                               as we process two different lists.\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"adminSettingsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if a restart of the OTCS pods is required. False otherwise.\n    \"\"\"\n\n    if not admin_settings:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n    # If this payload section has been processed successfully before we\n    # can return False and skip processing it once more:\n    if self.check_status_file(section_name):\n        return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n    restart_required: bool = False\n    success: bool = True\n\n    for admin_setting in admin_settings:\n        # Sanity checks:\n        if not \"filename\" in admin_setting:\n            logger.error(\"Filename is missing. Skipping to next admin setting...\")\n            continue\n        filename = admin_setting[\"filename\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in admin_setting and not admin_setting[\"enabled\"]:\n            logger.info(\n                \"Payload for setting file -&gt; %s is disabled. Skipping...\", filename\n            )\n            continue\n\n        settings_file = self._custom_settings_dir + filename\n        if os.path.exists(settings_file):\n            description = admin_setting.get(\"description\")\n            if description:\n                logger.info(description)\n\n            # Read the config file:\n            with open(settings_file, \"r\", encoding=\"utf-8\") as file:\n                file_content = file.read()\n\n            logger.debug(\n                \"Replace Placeholder -&gt; %s in file -&gt; %s\",\n                self._placeholder_values,\n                file_content,\n            )\n\n            file_content = self.replace_placeholders(file_content)\n\n            # Write the updated config file:\n            tmpfile = \"/tmp/\" + os.path.basename(settings_file)\n            with open(tmpfile, \"w\", encoding=\"utf-8\") as file:\n                file.write(file_content)\n\n            response = self._otcs.apply_config(tmpfile)\n            if response and response[\"results\"][\"data\"][\"restart\"]:\n                logger.info(\"A restart of Extended ECM service is required.\")\n                restart_required = True\n        else:\n            logger.error(\"Admin settings file -&gt; %s not found.\", settings_file)\n            success = False\n\n    self.write_status_file(success, section_name, admin_settings)\n\n    return restart_required\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_assignments","title":"<code>process_assignments(section_name='assignments')</code>","text":"<p>Process assignments specified in payload and assign items (such as workspaces and items with nicknames) to users or groups.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'assignments'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_assignments(self, section_name: str = \"assignments\") -&gt; bool:\n    \"\"\"Process assignments specified in payload and assign items (such as workspaces and\n    items with nicknames) to users or groups.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._assignments:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for assignment in self._assignments:\n        # Sanity check: we need a subject - it's mandatory:\n        if not \"subject\" in assignment:\n            logger.error(\"Assignment needs a subject! Skipping assignment...\")\n            success = False\n            continue\n        subject = assignment[\"subject\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in assignment and not assignment[\"enabled\"]:\n            logger.info(\n                \"Payload for Assignment -&gt; %s is disabled. Skipping...\", subject\n            )\n            continue\n\n        # instruction is optional but we give a warning if they are missing:\n        if not \"instruction\" in assignment:\n            logger.warning(\"Assignment -&gt; %s should have an instruction!\", subject)\n            instruction = \"\"\n        else:\n            instruction = assignment[\"instruction\"]\n        # Sanity check: we either need users or groups (or both):\n        if not \"groups\" in assignment and not \"users\" in assignment:\n            logger.error(\n                \"Assignment -&gt; %s needs groups or users! Skipping assignment...\",\n                subject,\n            )\n            success = False\n            continue\n        # Check if a workspace is specified for the assignment and check it does exist:\n        if \"workspace\" in assignment and assignment[\"workspace\"]:\n            workspace = next(\n                (\n                    item\n                    for item in self._workspaces\n                    if item[\"id\"] == assignment[\"workspace\"]\n                ),\n                None,\n            )\n            if not workspace:\n                logger.error(\n                    \"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\n                    subject,\n                    assignment[\"workspace\"],\n                )\n                success = False\n                continue\n            node_id = self.determine_workspace_id(workspace)\n            if not node_id:\n                logger.error(\n                    \"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\n                    subject,\n                    assignment[\"workspace\"],\n                )\n                success = False\n                continue\n        # If we don't have a workspace then check if a nickname is specified for the assignment:\n        elif \"nickname\" in assignment:\n            response = self._otcs.get_node_from_nickname(assignment[\"nickname\"])\n            node_id = self._otcs.get_result_value(response, \"id\")\n            if not node_id:\n                # if response == None:\n                logger.error(\n                    \"Assignment item with nickname -&gt; %s not found\",\n                    assignment[\"nickname\"],\n                )\n                success = False\n                continue\n        else:\n            logger.error(\n                \"Assignment -&gt; %s needs a workspace or nickname! Skipping assignment...\",\n                subject,\n            )\n            success = False\n            continue\n\n        assignees = []\n\n        if \"groups\" in assignment:\n            group_assignees = assignment[\"groups\"]\n            for group_assignee in group_assignees:\n                # find the group in the group list\n                group = next(\n                    (\n                        item\n                        for item in self._groups\n                        if item[\"name\"] == group_assignee\n                    ),\n                    None,\n                )\n                if not group:\n                    logger.error(\n                        \"Assignment group -&gt; %s does not exist! Skipping group...\",\n                        group_assignee,\n                    )\n                    success = False\n                    continue\n                if not \"id\" in group:\n                    logger.error(\n                        \"Assignment group -&gt; %s does not have an ID. Skipping group...\",\n                        group_assignee,\n                    )\n                    success = False\n                    continue\n                group_id = group[\"id\"]\n                # add the group ID to the assignee list:\n                assignees.append(group_id)\n\n        if \"users\" in assignment:\n            user_assignees = assignment[\"users\"]\n            for user_assignee in user_assignees:\n                # find the user in the user list\n                user = next(\n                    (item for item in self._users if item[\"name\"] == user_assignee),\n                    None,\n                )\n                if not user:\n                    logger.error(\n                        \"Assignment user -&gt; %s does not exist! Skipping user...\",\n                        user_assignee,\n                    )\n                    success = False\n                    continue\n                if not \"id\" in user:\n                    logger.error(\n                        \"Assignment user -&gt; %s does not have an ID. Skipping user...\",\n                        user_assignee,\n                    )\n                    success = False\n                    continue\n                user_id = user[\"id\"]\n                # add the group ID to the assignee list:\n                assignees.append(user_id)\n\n        if not assignees:\n            logger.error(\n                \"Cannot add assignment -&gt; %s for node ID -&gt; %s because no assignee was found.\",\n                subject,\n                node_id,\n            )\n            success = False\n            continue\n\n        response = self._otcs.assign_item_to_user_group(\n            int(node_id), subject, instruction, assignees\n        )\n        if not response:\n            logger.error(\n                \"Failed to add assignment -&gt; %s for node ID -&gt; %s with assignees -&gt; %s.\",\n                subject,\n                node_id,\n                assignees,\n            )\n            success = False\n\n    self.write_status_file(success, section_name, self._assignments)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_auth_handlers","title":"<code>process_auth_handlers(section_name='authHandlers')</code>","text":"<p>Process OTDS authorization handlers in payload and create them in OTDS.    An authorization handler defined the connection to an Identity Provider (IdP).</p> <pre><code>The payload section is a list of dicts with these items:\n{\n    enabled: True or False to enable or disable the payload item\n    name: Name of the authorization handler. This is shown in the first\n          column of the Auth Handler list in OTDS.\n    description: Description of the handler. This is shown in the second\n                 column of the Auth Handler\n    type: type of the handler. Possible values are SALM, SAP, OAUTH\n    priority: a numeric value to order different handlers in OTDS by priority\n    active_by_default: Whether to activate this handler for any request to the\n                       OTDS login page. If True, any login request to the OTDS\n                       login page will be redirected to the IdP. If false, the\n                       user has to select the provider on the login page.\n    provider_name: The name of the identity provider. This should be a single word\n                   since it will be part of the metadata URL. This is what is\n                   shown as a button on the OTDS login page.\n    auth_principal_attributes: Authentication principal attributes (list)\n    nameid_format: Specifies which NameID format supported by the identity provider\n                   contains the desired user identifier. The value in this identifier\n                   must correspond to the value of the user attribute specified for the\n                   authentication principal attribute.\n    saml_url: Required for SAML Authentication Handler. The URL for the IdP's federation metadata.\n    otds_sp_endpoint: Used for SAML Authentication Handler. Specifies the service provider URL that will\n                      be used to identify OTDS to the identity provider.\n    certificate_file: Required for SAP Authentication Handler (SAPSSOEXT).\n                      Fully qualified file name (with path) to the certificate file (URI)\n    certificate_password: Required for SAP Authentication Handler (SAPSSOEXT).\n                          Password of the certificate file.\n    client_id: Client ID. Required for OAUTH authentication handler.\n    client_secret: Client Secret. Required for OAUTH authentication handler.\n    authorization_endpoint: Required for OAUTH authentication handler.\n                            The URL to redirect the browser to for authentication.\n                            It is used to retrieve the authorization code or an OIDC id_token.\n    token_endpoint: Used for OAUTH authentication handler. The URL from which to retrieve the access token.\n                    Not strictly required with OpenID Connect if using the implicit flow.\n    scope_string: Used for OAUTH authentication handler. Space delimited scope values to send.\n                  Include 'openid' to use OpenID Connect.\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'authHandlers'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_auth_handlers(self, section_name: str = \"authHandlers\") -&gt; bool:\n    \"\"\"Process OTDS authorization handlers in payload and create them in OTDS.\n       An authorization handler defined the connection to an Identity Provider (IdP).\n\n        The payload section is a list of dicts with these items:\n        {\n            enabled: True or False to enable or disable the payload item\n            name: Name of the authorization handler. This is shown in the first\n                  column of the Auth Handler list in OTDS.\n            description: Description of the handler. This is shown in the second\n                         column of the Auth Handler\n            type: type of the handler. Possible values are SALM, SAP, OAUTH\n            priority: a numeric value to order different handlers in OTDS by priority\n            active_by_default: Whether to activate this handler for any request to the\n                               OTDS login page. If True, any login request to the OTDS\n                               login page will be redirected to the IdP. If false, the\n                               user has to select the provider on the login page.\n            provider_name: The name of the identity provider. This should be a single word\n                           since it will be part of the metadata URL. This is what is\n                           shown as a button on the OTDS login page.\n            auth_principal_attributes: Authentication principal attributes (list)\n            nameid_format: Specifies which NameID format supported by the identity provider\n                           contains the desired user identifier. The value in this identifier\n                           must correspond to the value of the user attribute specified for the\n                           authentication principal attribute.\n            saml_url: Required for SAML Authentication Handler. The URL for the IdP's federation metadata.\n            otds_sp_endpoint: Used for SAML Authentication Handler. Specifies the service provider URL that will\n                              be used to identify OTDS to the identity provider.\n            certificate_file: Required for SAP Authentication Handler (SAPSSOEXT).\n                              Fully qualified file name (with path) to the certificate file (URI)\n            certificate_password: Required for SAP Authentication Handler (SAPSSOEXT).\n                                  Password of the certificate file.\n            client_id: Client ID. Required for OAUTH authentication handler.\n            client_secret: Client Secret. Required for OAUTH authentication handler.\n            authorization_endpoint: Required for OAUTH authentication handler.\n                                    The URL to redirect the browser to for authentication.\n                                    It is used to retrieve the authorization code or an OIDC id_token.\n            token_endpoint: Used for OAUTH authentication handler. The URL from which to retrieve the access token.\n                            Not strictly required with OpenID Connect if using the implicit flow.\n            scope_string: Used for OAUTH authentication handler. Space delimited scope values to send.\n                          Include 'openid' to use OpenID Connect.\n        }\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._auth_handlers:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for auth_handler in self._auth_handlers:\n        handler_name = auth_handler.get(\"name\")\n\n        if not handler_name:\n            logger.error(\"Auth handler does not have a name. Skipping...\")\n            success = False\n            continue\n\n        # Check if Auth Handler does already exist (e.g. after a restart of\n        # the customizer pod):\n        if self._otds.get_auth_handler(handler_name, show_error=False):\n            logger.info(\"Auth handler -&gt; %s does already exist. Skipping...\")\n            continue\n\n        handler_description = auth_handler.get(\"description\")\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in auth_handler and not auth_handler[\"enabled\"]:\n            logger.info(\n                \"Payload for OTDS Authorization Handler -&gt; %s is disabled. Skipping...\",\n                handler_name,\n            )\n            continue\n\n        handler_scope = auth_handler.get(\"scope\")\n        if not handler_scope:\n            # Make sure to pass None also if scope is empty string\n            handler_scope = None\n\n        handler_type = auth_handler.get(\"type\")\n        if not handler_type:\n            logger.error(\n                \"OTDS Authorization handler does not have a type. Skipping...\"\n            )\n            success = False\n            continue\n\n        priority = auth_handler.get(\"priority\")\n        active_by_default = auth_handler.get(\"active_by_default\")\n        if not active_by_default:\n            active_by_default = False\n\n        match handler_type:\n            case \"SAML\":\n                provider_name = auth_handler.get(\"provider_name\")\n                if not provider_name:\n                    logger.error(\n                        \"SAML Authorization handler needs a provider. Skipping...\"\n                    )\n                    success = False\n                    continue\n                saml_url = auth_handler.get(\"saml_url\")\n                if not saml_url:\n                    logger.error(\n                        \"SAML Authorization handler needs a SAML URL. Skipping...\"\n                    )\n                    success = False\n                    continue\n                otds_sp_endpoint = auth_handler.get(\"otds_sp_endpoint\")\n                if not otds_sp_endpoint:\n                    logger.error(\n                        \"SAML Authorization handler needs a OTDS SP Endpoint. Skipping...\"\n                    )\n                    success = False\n                    continue\n                auth_principal_attributes = auth_handler.get(\n                    \"auth_principal_attributes\"\n                )\n                nameid_format = auth_handler.get(\"nameid_format\")\n                response = self._otds.add_auth_handler_saml(\n                    name=handler_name,\n                    description=handler_description,\n                    scope=handler_scope,\n                    provider_name=provider_name,\n                    saml_url=saml_url,\n                    otds_sp_endpoint=otds_sp_endpoint,\n                    priority=priority,\n                    active_by_default=active_by_default,\n                    auth_principal_attributes=auth_principal_attributes,\n                    nameid_format=nameid_format,\n                )\n            case \"SAP\":\n                certificate_file = auth_handler.get(\"certificate_file\")\n                if not certificate_file:\n                    logger.error(\n                        \"SAP Authorization handler -&gt; %s (%s) requires a certificate file name. Skipping...\",\n                        handler_name,\n                        handler_type,\n                    )\n                    success = False\n                    continue\n                certificate_password = auth_handler.get(\"certificate_password\")\n                if not certificate_password:\n                    # This is not an error - we canhave this key with empty string!\n                    logger.info(\n                        \"SAP Authorization handler -&gt; %s (%s) does not have a certificate password - this can be OK.\",\n                        handler_name,\n                        handler_type,\n                    )\n                response = self._otds.add_auth_handler_sap(\n                    name=handler_name,\n                    description=handler_description,\n                    scope=handler_scope,\n                    certificate_file=certificate_file,\n                    certificate_password=certificate_password,\n                    priority=priority,\n                )\n            case \"OAUTH\":\n                provider_name = auth_handler.get(\"provider_name\")\n                if not provider_name:\n                    logger.error(\n                        \"OAUTH Authorization handler -&gt; %s (%s) requires a provider name. Skipping...\",\n                        handler_name,\n                        handler_type,\n                    )\n                    success = False\n                    continue\n                client_id = auth_handler.get(\"client_id\")\n                if not client_id:\n                    logger.error(\n                        \"OAUTH Authorization handler -&gt; %s (%s) requires a client ID. Skipping...\",\n                        handler_name,\n                        handler_type,\n                    )\n                    success = False\n                    continue\n                client_secret = auth_handler.get(\"client_secret\")\n                if not client_secret:\n                    logger.error(\n                        \"OAUTH Authorization handler -&gt; %s (%s) requires a client secret. Skipping...\",\n                        handler_name,\n                        handler_type,\n                    )\n                    success = False\n                    continue\n                authorization_endpoint = auth_handler.get(\"authorization_endpoint\")\n                if not authorization_endpoint:\n                    logger.error(\n                        \"OAUTH Authorization handler -&gt; %s (%s) requires a authorization endpoint. Skipping...\",\n                        handler_name,\n                        handler_type,\n                    )\n                    success = False\n                    continue\n                token_endpoint = auth_handler.get(\"token_endpoint\")\n                if not token_endpoint:\n                    logger.warning(\n                        \"OAUTH Authorization handler -&gt; %s (%s) does not have a token endpoint.\",\n                        handler_name,\n                        handler_type,\n                    )\n                scope_string = auth_handler.get(\"scope_string\")\n                response = self._otds.add_auth_handler_oauth(\n                    name=handler_name,\n                    description=handler_description,\n                    scope=handler_scope,\n                    provider_name=provider_name,\n                    client_id=client_id,\n                    client_secret=client_secret,\n                    priority=priority,\n                    active_by_default=active_by_default,\n                    authorization_endpoint=authorization_endpoint,\n                    token_endpoint=token_endpoint,\n                    scope_string=scope_string,\n                )\n            case _:\n                logger.error(\n                    \"Unsupported authorization handler type -&gt; %s\", handler_type\n                )\n                return False\n\n        if response:\n            logger.info(\n                \"Successfully added OTDS authorization handler -&gt; %s (%s)\",\n                handler_name,\n                handler_type,\n            )\n        else:\n            logger.error(\n                \"Failed to add OTDS authorization handler -&gt; %s (%s)\",\n                handler_name,\n                handler_type,\n            )\n            success = False\n\n    self.write_status_file(success, section_name, self._auth_handlers)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_browser_automations","title":"<code>process_browser_automations(browser_automations, section_name='browserAutomations', check_status=True)</code>","text":"<p>Process Selenium-based browser automations.</p> <p>Parameters:</p> Name Type Description Default <code>browser_automations</code> <code>list</code> <p>list of browser_automations (need this as parameter as we                         have multiple lists)</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'browserAutomations'</code> <code>check_status</code> <code>bool</code> <p>defines whether or not this needs to re-run                            for each customizer run (even if it has been successful before).                            If check_status is True (default) then it is only re-run                            if it has NOT been successfully before.</p> <code>True</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_browser_automations(\n    self,\n    browser_automations: list,\n    section_name: str = \"browserAutomations\",\n    check_status: bool = True,\n) -&gt; bool:\n    \"\"\"Process Selenium-based browser automations.\n\n    Args:\n        browser_automations (list): list of browser_automations (need this as parameter as we\n                                    have multiple lists)\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n        check_status (bool, optional): defines whether or not this needs to re-run\n                                       for each customizer run (even if it has been successful before).\n                                       If check_status is True (default) then it is only re-run\n                                       if it has NOT been successfully before.\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not browser_automations:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if check_status and self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for browser_automation in browser_automations:\n        description = browser_automation.get(\"description\", \"\")\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in browser_automation and not browser_automation[\"enabled\"]:\n            logger.info(\n                \"Payload for Browser Automation -&gt; %s is disabled. Skipping...\",\n                description,\n            )\n            continue\n\n        if not \"name\" in browser_automation:\n            logger.error(\"Browser automation is missing a unique name. Skipping...\")\n            success = False\n            continue\n        name = browser_automation.get(\"name\")\n\n        if description:\n            logger.info(\n                \"Processing Browser Automation -&gt; %s (%s)...\",\n                name,\n                description,\n            )\n        else:\n            logger.info(\"Processing Browser Automation -&gt; %s...\", name)\n\n        if not \"base_url\" in browser_automation:\n            logger.error(\"Browser automation is missing base_url. Skipping...\")\n            success = False\n            continue\n        base_url = browser_automation.get(\"base_url\")\n\n        if not \"user_name\" in browser_automation:\n            logger.info(\"Browser automation is not having user name.\")\n        user_name = browser_automation.get(\"user_name\", \"\")\n\n        if not \"password\" in browser_automation:\n            logger.info(\"Browser automation is not having password.\")\n        password = browser_automation.get(\"password\", \"\")\n\n        if not \"automations\" in browser_automation:\n            logger.error(\n                \"Browser automation is missing list of automations. Skipping...\"\n            )\n            success = False\n            continue\n        automations = browser_automation.get(\"automations\", [])\n\n        debug_automation: bool = browser_automation.get(\"debug\", False)\n\n        # Create Selenium Browser Automation:\n        logger.info(\"Browser Automation base URL -&gt; %s\", base_url)\n        logger.info(\"Browser Automation User -&gt; %s\", user_name)\n        logger.debug(\"Browser Automation Password -&gt; %s\", password)\n        browser_automation_object = BrowserAutomation(\n            base_url=base_url,\n            user_name=user_name,\n            user_password=password,\n            automation_name=name,\n            take_screenshots=debug_automation,\n        )\n        # Implicit Wait is a global setting (for whole brwoser session)\n        # This makes sure a page is fully loaded and elements are present\n        # before accessing them. We set 15.0 seconds as default if not\n        # otherwise specified by \"wait_time\" in the payload.\n        # See https://www.selenium.dev/documentation/webdriver/waits/\n        wait_time = browser_automation.get(\"wait_time\", 15.0)\n        browser_automation_object.implicit_wait(wait_time)\n        if \"wait_time\" in browser_automation:\n            logger.info(\n                \"Browser Automation Implicit Wait time -&gt; %s configured\", wait_time\n            )\n\n        for automation in automations:\n            if not \"type\" in automation:\n                logger.error(\"Browser automation step is missing type. Skipping...\")\n                success = False\n                break\n            automation_type = automation.get(\"type\", \"\")\n\n            match automation_type:\n                case \"login\":\n                    page = automation.get(\"page\", \"\")\n                    logger.info(\n                        \"Login to -&gt; %s as user -&gt; %s\", base_url + page, user_name\n                    )\n                    user_field = automation.get(\"user_field\", \"otds_username\")\n                    password_field = automation.get(\n                        \"password_field\", \"otds_password\"\n                    )\n                    login_button = automation.get(\"login_button\", \"loginbutton\")\n                    if not browser_automation_object.run_login(\n                        user_field=user_field,\n                        password_field=password_field,\n                        login_button=login_button,\n                    ):\n                        logger.error(\n                            \"Cannot log into -&gt; %s. Stopping automation.\",\n                            base_url + page,\n                        )\n                        success = False\n                        break\n                    else:\n                        logger.info(\n                            \"Successfuly logged into page -&gt; %s.\", base_url + page\n                        )\n                case \"get_page\":\n                    page = automation.get(\"page\", \"\")\n                    if not page:\n                        logger.error(\n                            \"Automation type -&gt; %s requires page parameter\",\n                            automation_type,\n                        )\n                        success = False\n                        break\n                    logger.info(\"Get page -&gt; %s\", base_url + page)\n                    if not browser_automation_object.get_page(url=page):\n                        logger.error(\n                            \"Cannot get page -&gt; %s. Stopping automation.\",\n                            page,\n                        )\n                        success = False\n                        break\n                    else:\n                        # browser_automation_object.implicit_wait(15.0) # this is global but not command-specific! Don't need it here!\n                        logger.info(\n                            \"Successfuly loaded page -&gt; %s.\", base_url + page\n                        )\n                case \"click_elem\":\n                    elem = automation.get(\"elem\", \"\")\n                    if not elem:\n                        logger.error(\n                            \"Automation type -&gt; %s requires elem parameter\",\n                            automation_type,\n                        )\n                        success = False\n                        break\n                    find = automation.get(\"find\", \"id\")\n                    if not browser_automation_object.find_elem_and_click(\n                        find_elem=elem, find_method=find\n                    ):\n                        logger.error(\n                            \"Cannot find clickable element -&gt; %s on current page. Stopping automation.\",\n                            elem,\n                        )\n                        success = False\n                        break\n                    else:\n                        # browser_automation_object.implicit_wait(15.0) # this is global but not command-specific! Don't need it here!\n                        logger.info(\"Successfuly clicked element -&gt; %s.\", elem)\n                case \"set_elem\":\n                    elem = automation.get(\"elem\", \"\")\n                    if not elem:\n                        logger.error(\n                            \"Automation type -&gt; %s requires elem parameter\",\n                            automation_type,\n                        )\n                        success = False\n                        break\n                    find = automation.get(\"find\", \"id\")\n                    value = automation.get(\"value\", \"\")\n                    if not value:\n                        logger.error(\n                            \"Automation type -&gt; %s requires value parameter\",\n                            automation_type,\n                        )\n                        success = False\n                        break\n                    # we also support replacing placeholders that are\n                    # enclosed in double % characters like %%OTCS_RESOURCE_ID%%:\n                    value = self.replace_placeholders(value)\n                    if not browser_automation_object.find_elem_and_set(\n                        find_elem=elem, elem_value=value, find_method=find\n                    ):\n                        logger.error(\n                            \"Cannot find element -&gt; %s on current page to set value -&gt; %s. Stopping automation.\",\n                            elem,\n                            value,\n                        )\n                        success = False\n                        break\n                    else:\n                        logger.info(\n                            \"Successfuly set element -&gt; %s to set value -&gt; %s.\",\n                            elem,\n                            value,\n                        )\n                case _:\n                    logger.error(\n                        \"Illegal automation step type -&gt; %s in browser automation!\",\n                        automation_type,\n                    )\n                    success = False\n                    break\n\n    if check_status:\n        self.write_status_file(success, section_name, browser_automations)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_business_object_types","title":"<code>process_business_object_types(section_name='businessObjectTypes')</code>","text":"<p>Create a data structure for all business object types in the Extended ECM system.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'businessObjectTypes'</code> <p>Returns:     list: list of business object types. Each list element is a dict with these values:         - id (str)         - name (str)         - type (str)         - ext_system_id (str)         - business_properties (list)         - business_property_groups (list)</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_business_object_types(\n    self, section_name: str = \"businessObjectTypes\"\n) -&gt; list:\n    \"\"\"Create a data structure for all business object types in the Extended ECM system.\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        list: list of business object types. Each list element is a dict with these values:\n            - id (str)\n            - name (str)\n            - type (str)\n            - ext_system_id (str)\n            - business_properties (list)\n            - business_property_groups (list)\n    \"\"\"\n\n    # If this payload section has been processed successfully before we\n    # still need to read the data structure from the status file and\n    # initialize self._workspace_types:\n    if self.check_status_file(section_name):\n        # read the list from the json file in admin Home\n        # this is important for restart of customizer pod\n        # as this data structure is used later on for workspace processing\n        logger.info(\n            \"Re-Initialize business object types list from status file -&gt; %s for later use...\",\n            self.get_status_file_name(payload_section_name=section_name),\n        )\n        self._business_object_types = self.get_status_file(section_name)\n        logger.info(\n            \"Found -&gt; %s business object types.\",\n            str(len(self._business_object_types)),\n        )\n        logger.debug(\n            \"Business object types -&gt; %s\", str(self._business_object_types)\n        )\n        return self._business_object_types\n\n    success: bool = True\n\n    # get all workspace types (these have been created by the transports and are not in the payload!)\n    # we need to do this each time as it needs to work across potential multiple payload files...\n    response = self._otcs.get_business_object_types()\n    if response is None:\n        logger.info(\"No business object types found!\")\n        self._business_object_types = []\n    else:\n        self._business_object_types = response[\"results\"]\n        logger.info(\n            \"Found -&gt; %s business object types.\",\n            str(len(self._business_object_types)),\n        )\n        logger.debug(\n            \"Business object types -&gt; %s\", str(self._business_object_types)\n        )\n\n    # now we enrich the workspace_type list elments (which are dicts)\n    # with additional dict elements for further processing:\n    for business_object_type in self._business_object_types:\n        # Get BO Type (e.g. KNA1):\n        bo_type = business_object_type[\"data\"][\"properties\"][\"bo_type\"]\n        logger.info(\"Business Object Type -&gt; %s\", bo_type)\n        business_object_type[\"type\"] = bo_type\n        # Get BO Type ID:\n        bo_type_id = business_object_type[\"data\"][\"properties\"][\"bo_type_id\"]\n        logger.info(\"Business Object Type ID -&gt; %s\", bo_type_id)\n        business_object_type[\"id\"] = bo_type_id\n        # Get BO Type Name:\n        bo_type_name = business_object_type[\"data\"][\"properties\"][\"bo_type_name\"]\n        logger.info(\"Business Object Type Name -&gt; %s\", bo_type_name)\n        business_object_type[\"name\"] = bo_type_name\n        # Get External System ID:\n        ext_system_id = business_object_type[\"data\"][\"properties\"][\"ext_system_id\"]\n        logger.info(\"External System ID -&gt; %s\", ext_system_id)\n        business_object_type[\"ext_system_id\"] = ext_system_id\n\n        # Get additional information per BO Type (this REST API is severly\n        # limited) - it does not return Property names from External System\n        # and is also missing Business Property Groups:\n        # if not \"/\" in bo_type:\n        #     response = self._otcs.get_business_object_type(\n        #         external_system_id=ext_system_id, type_name=bo_type\n        #     )\n        #     if response is None or not response[\"results\"]:\n        #         logger.warning(\n        #             \"Cannot retrieve additional information for business object type -&gt; %s. Skipping...\",\n        #             bo_type,\n        #         )\n        #         continue\n        #     business_properties = response[\"results\"][\"data\"][\n        #         \"business_object_type\"\n        #     ][\"data\"][\"businessProperties\"]\n        #     business_object_type[\"business_properties\"] = business_properties\n        # else:\n        #     logger.warning(\n        #         \"Business Object Type -&gt; %s does not have a proper name to call REST API.\",\n        #         bo_type,\n        #     )\n        #     business_object_type[\"business_properties\"] = []\n\n        business_object_type[\"business_properties\"] = []\n        business_object_type[\"business_property_groups\"] = []\n\n        # Now we complete the data with what we have extracted from the transport packages\n        # for Business Object Types. This is a workaround for the insufficient REST API\n        # implementation (see otcs.get_business_object_type)\n        if self._transport_extractions:\n            logger.info(\n                \"Enrich Business Object Types with data extractions from transport packages (found %s extractions)...\",\n                str(len(self._transport_extractions)),\n            )\n        else:\n            logger.info(\n                \"No transport extractions are recorded. This may be because of customizer restart.\"\n            )\n            extraction_status_file = \"transportPackagesExtractions\"\n            if self.check_status_file(extraction_status_file):\n                logger.info(\n                    \"Try to load extractions from success file -&gt; %s...\",\n                    extraction_status_file,\n                )\n                self._transport_extractions = self.get_status_file(\n                    extraction_status_file\n                )\n\n        for extraction in self._transport_extractions:\n            xpath = extraction.get(\"data\")\n            data_list = extraction.get(\"data\")\n            if not data_list:\n                logger.error(\n                    \"Extraction -&gt; %s is missing the data element. Skipping...\",\n                    xpath,\n                )\n                success = False\n                continue\n            if not isinstance(data_list, list):\n                logger.warning(\n                    \"Extracted data for -&gt; %s is not a list. Cannot process it. Skipping...\",\n                    xpath,\n                )\n                continue\n\n            # The following loop processes a dictionasry of this structure:\n\n            # llnode: {\n            #     '@created': '2017-11-23T16:43:35',\n            #     '@createdby': '1000',\n            #     '@createdbyname': 'Terrarium Admin',\n            #     '@description': '',\n            #     '@id': '16013',\n            #     '@modified': '2023-12-09T12:08:21',\n            #     '@name': 'SFDC Order',\n            #     '@objname': 'Business Object Type',\n            #     '@objtype': '889',\n            #     '@ownedby': '1000',\n            #     '@ownedbyname': 'Terrarium Admin',\n            #     '@parentguid': '95F96645-057D-4EAF-9083-BE9F24C0CB6C',\n            #     '@parentid': '2898',\n            #     '@parentname': 'Business Object Types',\n            #     ...\n            #     'Nickname': {'@domain': ''},\n            #     'name': {'@xml:lang': 'en', '#text': 'SFDC Order'},\n            #     'description': {'@xml:lang': 'en'},\n            #     'businessObjectTypeInfo': {\n            #         'basicInfo': {\n            #             '@businessObjectId': '9',\n            #             '@businessobjectType': 'Order',\n            #             '@deleted': 'false',\n            #             '@name': 'SFDC Order',\n            #             '@subtype': '889',\n            #             '@useBusWorkspace': 'true',\n            #             'displayUrl': {...}\n            #         },\n            #         'businessApplication': {\n            #             'businessObjectTypeReference': {...}},\n            #             'businessAttachmentInfo': {\n            #                 '@automaticAddingOfBusinessObject': 'false',\n            #                 '@canbeAddedAsBusinessObject': 'false',\n            #                 '@enableBADIBeforeAddingBO': 'false',\n            #                 '@enableBADIBeforeRemovingBO': 'false',\n            #                 '@enableMetadataMapping': 'false'\n            #             },\n            #             'managedObjectTypes': {\n            #                 'managedObjectType': [...]\n            #             },\n            #             'multilingualNames': {'language': [...]},\n            #             'callbacks': {'callback': [...]},\n            #             'workspaceTypeReference': {'@isDefaultDisplay': 'false', '@isDefaultSearch': 'false', 'businessObjectTypeReference': {...}},\n            #             'businessPropertyMappings': {\n            #                 'propertyMapping': [...]\n            #             },\n            #             'businessPropertyGroupMappings': {\n            #                 'propertyGroupMapping': [...]\n            #             },\n            #             'documentTypes': {\n            #                 'documentType': [...]\n            #             },\n            #             'CustomBOTypeInfo': None\n            #         }\n            # }\n\n            for data in data_list:\n                #\n                # Level 1: llnode\n                #\n                llnode = data.get(\"llnode\")\n                if not llnode:\n                    logger.error(\"Missing llnode structure in data. Skipping...\")\n                    success = False\n                    continue\n\n                #\n                # Level 2: businessobjectTypeInfo\n                #\n                business_object_type_info = llnode.get(\n                    \"businessobjectTypeInfo\", None\n                )\n                if not business_object_type_info:\n                    logger.error(\n                        \"Information is missing for Business Object Type -&gt; %s. Skipping...\",\n                        bo_type_name,\n                    )\n                    success = False\n                    continue\n\n                # Check if this extraction is for the current business object type:\n                basic_info = business_object_type_info.get(\"basicInfo\", None)\n                if not basic_info:\n                    logger.error(\n                        \"Cannot find Basic Info of Business Object Type -&gt; %s. Skipping...\",\n                        bo_type_name,\n                    )\n                    success = False\n                    continue\n                name = basic_info.get(\"@businessobjectType\", \"\")\n                if not name:\n                    logger.error(\n                        \"Cannot find name of Business Object Type -&gt; %s. Skipping...\",\n                        bo_type_name,\n                    )\n                    success = False\n                    continue\n                obj_type = llnode.get(\"@objtype\", None)\n                # we need to compare bo_type and NOT bo_type_name here!\n                # Otherwise we don't find the SAP and SuccessFactors data:\n                if name != bo_type or obj_type != \"889\":\n                    continue\n\n                #\n                # Level 3: businessPropertyMappings - plain, non-grouped properties\n                #\n                business_property_mappings = business_object_type_info.get(\n                    \"businessPropertyMappings\", None\n                )\n                if not business_property_mappings:\n                    logger.info(\n                        \"No Property Mapping for Business Object Type -&gt; %s. Skipping...\",\n                        bo_type_name,\n                    )\n                else:\n                    property_mappings = business_property_mappings.get(\n                        \"propertyMapping\", []\n                    )\n                    # This can happen if there's only 1 propertyMapping;\n                    if not isinstance(property_mappings, list):\n                        logger.info(\n                            \"Found a single property mapping in a dictionary (not in a list). Package it into a list...\",\n                        )\n                        property_mappings = [property_mappings]\n\n                    for property_mapping in property_mappings:\n                        property_name = property_mapping.get(\"@propertyName\")\n                        attribute_name = property_mapping.get(\"@attributeName\")\n                        category_id = property_mapping.get(\"@categoryId\")\n                        mapping_type = property_mapping.get(\"@type\")\n                        logger.info(\n                            \"%s Property Mapping for Business Object -&gt; %s: property -&gt; %s is mapped to attribute -&gt; %s (category -&gt; %s)\",\n                            mapping_type,\n                            bo_type_name,\n                            property_name,\n                            attribute_name,\n                            category_id,\n                        )\n                        business_object_type[\"business_properties\"].append(\n                            property_mapping\n                        )\n\n                #\n                # Level 3: businessPropertyGroupMappings - grouped properties\n                #\n                business_property_group_mappings = business_object_type_info.get(\n                    \"businessPropertyGroupMappings\", None\n                )\n                if not business_property_group_mappings:\n                    logger.info(\n                        \"No Property Group Mapping for Business Object Type -&gt; %s. Skipping...\",\n                        bo_type_name,\n                    )\n                    continue\n\n                property_group_mappings = business_property_group_mappings.get(\n                    \"propertyGroupMapping\", []\n                )\n                # This can happen if there's only 1 propertyMapping;\n                if isinstance(property_group_mappings, dict):\n                    logger.info(\n                        \"Found a single property group mapping in a dictionary (not in a list). Pack it into a list...\",\n                    )\n                    property_group_mappings = [property_group_mappings]\n\n                for property_group_mapping in property_group_mappings:\n                    group_name = property_group_mapping.get(\"@groupName\")\n                    set_name = property_group_mapping.get(\"@setName\")\n                    category_id = property_group_mapping.get(\"@categoryId\")\n                    mapping_type = property_group_mapping.get(\"@type\")\n                    logger.info(\n                        \"%s Property Group Mapping for Business Object -&gt; %s: group -&gt; %s is mapped to set -&gt; %s (category -&gt; %s)\",\n                        mapping_type,\n                        bo_type_name,\n                        group_name,\n                        set_name,\n                        category_id,\n                    )\n\n                    property_mappings = property_group_mapping.get(\n                        \"propertyMapping\", []\n                    )\n                    # This can happen if there's only 1 propertyMapping;\n                    if not isinstance(property_mappings, list):\n                        logger.info(\n                            \"Found a single property mapping in a dictionary (not in a list). Package it into a list...\",\n                        )\n                        property_mappings = [property_mappings]\n\n                    for property_mapping in property_mappings:\n                        # for nested mappings we only have 2 fields - the rest is on the group level - see above\n                        property_name = property_mapping.get(\"@propertyName\")\n                        attribute_name = property_mapping.get(\"@attributeName\")\n                        logger.info(\n                            \"%s Property Mapping inside group for Business Object -&gt; %s: group -&gt; %s, property -&gt; %s is mapped to set -&gt; %s, attribute -&gt; %s (category -&gt; %s)\",\n                            mapping_type,\n                            bo_type_name,\n                            group_name,\n                            property_name,\n                            set_name,\n                            attribute_name,\n                            category_id,\n                        )\n                        # we write the group / set information also in the property mapping\n                        # tp have a plain list with all information:\n                        property_mapping[\"@groupName\"] = group_name\n                        property_mapping[\"@setName\"] = set_name\n                        property_mapping[\"@type\"] = mapping_type\n                        business_object_type[\"business_property_groups\"].append(\n                            property_mapping\n                        )\n\n    self.write_status_file(success, section_name, self._business_object_types)\n\n    return self._business_object_types\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_cs_applications","title":"<code>process_cs_applications(otcs_object, section_name='csApplications')</code>","text":"<p>Process CS applications in payload and install them in Extended ECM. The CS Applications need to be installed in all frontend and backends.</p> <p>Parameters:</p> Name Type Description Default <code>otcs_object</code> <code>object</code> <p>this can either be the OTCS frontend or OTCS backend. If None                   then the otcs_backend is used.</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'csApplications'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_cs_applications(\n    self, otcs_object: OTCS, section_name: str = \"csApplications\"\n) -&gt; bool:\n    \"\"\"Process CS applications in payload and install them in Extended ECM.\n    The CS Applications need to be installed in all frontend and backends.\n\n    Args:\n        otcs_object (object): this can either be the OTCS frontend or OTCS backend. If None\n                              then the otcs_backend is used.\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._cs_applications:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # OTCS backend is the default:\n    if not otcs_object:\n        otcs_object = self._otcs_backend\n\n    for cs_application in self._cs_applications:\n        application_name = cs_application[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in cs_application and not cs_application[\"enabled\"]:\n            logger.info(\n                \"Payload for CS Application -&gt; %s is disabled. Skipping...\",\n                application_name,\n            )\n            continue\n\n        application_description = cs_application[\"description\"]\n\n        logger.info(\n            \"Install CS Application -&gt; %s (%s)...\",\n            application_name,\n            application_description,\n        )\n        response = otcs_object.install_cs_application(application_name)\n        if response is None:\n            logger.error(\n                \"Failed to install CS Application -&gt; %s!\", application_name\n            )\n            success = False\n\n    self.write_status_file(success, section_name, self._cs_applications)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_document_generators","title":"<code>process_document_generators(section_name='documentGenerators')</code>","text":"<p>Generate documents for a defined workspace type based on template</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'documentGenerators'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_document_generators(\n    self, section_name: str = \"documentGenerators\"\n) -&gt; bool:\n    \"\"\"Generate documents for a defined workspace type based on template\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._doc_generators:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # save admin credentials for later switch back to admin user:\n    admin_credentials = self._otcs.credentials()\n    authenticated_user = \"admin\"\n\n    for doc_generator in self._doc_generators:\n        if not \"workspace_type\" in doc_generator:\n            logger.error(\n                \"To generate documents for workspaces the workspace type needs to be specified in the payload! Skipping to next document generator...\"\n            )\n            success = False\n            continue\n        workspace_type = doc_generator[\"workspace_type\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in doc_generator and not doc_generator[\"enabled\"]:\n            logger.info(\n                \"Payload for document generator of workspace type -&gt; %s is disabled. Skipping...\",\n                workspace_type,\n            )\n            continue\n\n        if not \"template_path\" in doc_generator:\n            logger.error(\n                \"To generate documents for workspaces of type -&gt; %s the path to the document template needs to be specified in the payload! Skipping to next document generator...\",\n                workspace_type,\n            )\n            success = False\n            continue\n        template_path = doc_generator[\"template_path\"]\n        # 20541 is the ID of the Document Template Volume which\n        # (we hope) is stable:\n        template = self._otcs.get_node_by_volume_and_path(20541, template_path)\n        if not template:\n            logger.error(\n                \"Cannot find document template in path -&gt; %s. Skipping to next document generator...\",\n                template_path,\n            )\n            success = False\n            continue\n        template_id = self._otcs.get_result_value(template, \"id\")\n        template_name = self._otcs.get_result_value(template, \"name\")\n\n        if not \"classification_path\" in doc_generator:\n            logger.error(\n                \"To generate documents for workspaces of type -&gt; %s the path to the document classification needs to be specified in the payload! Skipping to next document generator...\",\n                workspace_type,\n            )\n            success = False\n            continue\n        classification_path = doc_generator[\"classification_path\"]\n        classification = self._otcs.get_node_by_volume_and_path(\n            198, classification_path\n        )\n        if not classification:\n            logger.error(\n                \"Cannot find document classification in path -&gt; %s. Skipping to next document generator...\",\n                classification_path,\n            )\n            success = False\n            continue\n        classification_id = self._otcs.get_result_value(classification, \"id\")\n\n        # \"category_name\" is optional. But if it is specified\n        # then also \"attributes\" needs to be specified:\n        if not \"category_name\" in doc_generator:\n            logger.info(\n                \"No metadata (category name) specified in the payload for this document generator.\",\n            )\n            category_name = \"\"\n            attributes = {}\n            category_data = {}\n        else:\n            category_name = doc_generator[\"category_name\"]\n            if not \"attributes\" in doc_generator:\n                logger.error(\n                    \"To generate documents for workspaces of type -&gt; %s with metadata, the attributes needs to be specified in the payload! Skipping to next document generator...\",\n                    workspace_type,\n                )\n                success = False\n                continue\n            attributes = doc_generator[\"attributes\"]\n\n            # The following method returns two values: the category ID and\n            # a dict of the attributes. If the category is not found\n            # on the document template it returns -1 for the category ID\n            # and an empty dict for the attribute definitions:\n            (\n                category_id,\n                attribute_definitions,\n            ) = self._otcs.get_node_category_definition(template_id, category_name)\n            if category_id == -1:\n                logger.error(\n                    \"The document template -&gt; %s does not have the specified category -&gt; %s. Skipping to next document generator...\",\n                    template_name,\n                    category_name,\n                )\n                success = False\n                continue\n\n            category_data = {str(category_id): {}}\n\n            # now we fill the prepared (but empty) category_data\n            # with the actual attribute values from the payload:\n            for attribute in attributes:\n                attribute_name = attribute[\"name\"]\n                attribute_value = attribute[\"value\"]\n                attribute_type = attribute_definitions[attribute_name][\"type\"]\n                attribute_id = attribute_definitions[attribute_name][\"id\"]\n\n                # Special treatment for type user: determine the ID for the login name.\n                # the ID is the actual value we have to put in the attribute:\n                if attribute_type == \"user\":\n                    user = self._otcs.get_user(attribute_value, show_error=True)\n                    user_id = self._otcs.get_result_value(response=user, key=\"id\")\n                    if not user_id:\n                        logger.error(\n                            \"Cannot find user with login name -&gt; %s. Skipping...\",\n                            attribute_value,\n                        )\n                        success = False\n                        continue\n                    attribute_value = user_id\n                category_data[str(category_id)][attribute_id] = attribute_value\n\n        if not \"workspace_folder_path\" in doc_generator:\n            logger.info(\n                \"No workspace folder path defined for workspaces of type -&gt; %s. Documents will be stored in workspace root.\",\n                workspace_type,\n            )\n            workspace_folder_path = []\n        else:\n            workspace_folder_path = doc_generator[\"workspace_folder_path\"]\n\n        if \"exec_as_user\" in doc_generator:\n            exec_as_user = doc_generator[\"exec_as_user\"]\n\n            # Find the user in the users payload:\n            exec_user = next(\n                (item for item in self._users if item[\"name\"] == exec_as_user),\n                None,\n            )\n            # Have we found the user in the payload?\n            if exec_user is not None:\n                logger.info(\n                    \"Executing document generator with user -&gt; %s\", exec_as_user\n                )\n                # we change the otcs credentials to the user:\n                self._otcs.set_credentials(exec_user[\"name\"], exec_user[\"password\"])\n\n                # we re-authenticate as the user:\n                logger.info(\"Authenticate user -&gt; %s...\", exec_as_user)\n                # True = force new login with new user\n                cookie = self._otcs.authenticate(revalidate=True)\n                if not cookie:\n                    logger.error(\"Couldn't authenticate user -&gt; %s\", exec_as_user)\n                    continue\n                admin_context = False\n                authenticated_user = exec_as_user\n            else:\n                logger.error(\n                    \"Cannot find user with login name -&gt; %s for executing. Executing as admin...\",\n                    exec_as_user,\n                )\n                admin_context = True\n                success = False\n        else:\n            admin_context = True\n            exec_as_user = \"admin\"\n\n        if admin_context and authenticated_user != \"admin\":\n            # Set back admin credentials:\n            self._otcs.set_credentials(\n                admin_credentials[\"username\"], admin_credentials[\"password\"]\n            )\n\n            # we re-authenticate as the admin user:\n            logger.info(\n                \"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n            )\n            # True = force new login with new user\n            cookie = self._otcs.authenticate(revalidate=True)\n            authenticated_user = \"admin\"\n\n        if category_data:\n            logger.info(\n                \"Generate documents for workspace type -&gt; %s based on template -&gt; %s with metadata -&gt; %s...\",\n                workspace_type,\n                template_name,\n                category_data,\n            )\n        else:\n            logger.info(\n                \"Generate documents for workspace type -&gt; %s based on template -&gt; %s without metadata...\",\n                workspace_type,\n                template_name,\n            )\n\n        # Find the workspace type with the name given in the _workspace_types\n        # datastructure that has been generated by process_workspace_types() method before:\n        workspace_type_id = next(\n            (\n                item[\"id\"]\n                for item in self._workspace_types\n                if item[\"name\"] == workspace_type\n            ),\n            None,\n        )\n        workspace_instances = self._otcs.get_workspace_instances(\n            type_name=workspace_type, type_id=workspace_type_id\n        )\n        if not workspace_instances or not workspace_instances[\"results\"]:\n            logger.warning(\n                \"No workspace instances found for workspace type -&gt; %s (%s)\",\n                workspace_type,\n                workspace_type_id,\n            )\n        for workspace_instance in workspace_instances[\"results\"]:\n            workspace_id = workspace_instance[\"data\"][\"properties\"][\"id\"]\n            workspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\n            if workspace_folder_path:\n                workspace_folder = self._otcs.get_node_by_workspace_and_path(\n                    workspace_id, workspace_folder_path\n                )\n                if workspace_folder:\n                    workspace_folder_id = self._otcs.get_result_value(\n                        workspace_folder, \"id\"\n                    )\n                else:\n                    # If the workspace template is not matching\n                    # the path we may have an error here. Then\n                    # we fall back to workspace root level.\n                    logger.warning(\n                        \"Folder path does not exist in workspace -&gt; %s. Using workspace root level instead...\",\n                        workspace_name,\n                    )\n                    workspace_folder_id = workspace_id\n            else:\n                workspace_folder_id = workspace_id\n\n            document_name = workspace_name + \" - \" + template_name\n            logger.info(\"Generate document -&gt; %s\", document_name)\n\n            response = self._otcs.check_node_name(\n                int(workspace_folder_id), document_name\n            )\n            if response[\"results\"]:\n                logger.warning(\n                    \"Node with name -&gt; %s does already exist in workspace folder with ID -&gt; %s\",\n                    document_name,\n                    workspace_folder_id,\n                )\n                continue\n            response = self._otcs.create_document_from_template(\n                int(template_id),\n                int(workspace_folder_id),\n                int(classification_id),\n                category_data,\n                document_name,\n                \"This document has been auto-generated by Terrarium\",\n            )\n            if not response:\n                logger.error(\n                    \"Failed to generate document -&gt; %s in workspace -&gt; %s (%s) as user -&gt; %s\",\n                    document_name,\n                    workspace_name,\n                    workspace_id,\n                    exec_as_user,\n                )\n                success = False\n            else:\n                logger.info(\n                    \"Successfully generated document -&gt; %s in workspace -&gt; %s\",\n                    document_name,\n                    workspace_name,\n                )\n\n    if authenticated_user != \"admin\":\n        # Set back admin credentials:\n        self._otcs.set_credentials(\n            admin_credentials[\"username\"], admin_credentials[\"password\"]\n        )\n\n        # we authenticate back as the admin user:\n        logger.info(\n            \"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n        )\n        # True = force new login with new user\n        cookie = self._otcs.authenticate(revalidate=True)\n\n    self.write_status_file(success, section_name, self._doc_generators)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_exec_pod_commands","title":"<code>process_exec_pod_commands(section_name='execPodCommands')</code>","text":"<p>Process commands that should be executed in the Kubernetes pods.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'execPodCommands'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_exec_pod_commands(self, section_name: str = \"execPodCommands\") -&gt; bool:\n    \"\"\"Process commands that should be executed in the Kubernetes pods.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not isinstance(self._k8s, K8s):\n        logger.error(\"K8s not setup properly -&gt; Skipping %s...\", section_name)\n        return False\n\n    if not self._exec_pod_commands:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for exec_pod_command in self._exec_pod_commands:\n        if not \"pod_name\" in exec_pod_command:\n            logger.error(\n                \"To execute a command in a pod the pod name needs to be specified in the payload! Skipping to next pod command...\"\n            )\n            success = False\n            continue\n        pod_name = exec_pod_command[\"pod_name\"]\n\n        if not \"command\" in exec_pod_command or not exec_pod_command.get(\"command\"):\n            logger.error(\n                \"Pod command is not specified for pod -&gt; %s! It needs to be a non-empty list! Skipping to next pod command...\",\n                pod_name,\n            )\n            success = False\n            continue\n        command = exec_pod_command[\"command\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in exec_pod_command and not exec_pod_command[\"enabled\"]:\n            logger.info(\n                \"Payload for Exec Pod Command in pod -&gt; %s is disabled. Skipping...\",\n                pod_name,\n            )\n            continue\n\n        if not \"description\" in exec_pod_command:\n            logger.info(\"Executing command -&gt; %s in pod -&gt; %s\", command, pod_name)\n\n        else:\n            description = exec_pod_command[\"description\"]\n            logger.info(\n                \"Executing command -&gt; %s in pod -&gt; %s (%s)\",\n                command,\n                pod_name,\n                description,\n            )\n\n        if (\n            not \"interactive\" in exec_pod_command\n            or exec_pod_command[\"interactive\"] is False\n        ):\n            result = self._k8s.exec_pod_command(pod_name, command)\n        else:\n            if not \"timeout\" in exec_pod_command:\n                result = self._k8s.exec_pod_command_interactive(pod_name, command)\n            else:\n                timeout = exec_pod_command[\"timeout\"]\n                result = self._k8s.exec_pod_command_interactive(\n                    pod_name, command, timeout\n                )\n\n        # we need to differentiate 3 cases here:\n        # 1. result = None is returned - this is an error (exception)\n        # 2. result is empty string - this is OK\n        # 3. result is a non-empty string - this is OK - print it to log\n        if result is None:\n            logger.error(\n                \"Execution of command -&gt; %s in pod -&gt; %s failed\",\n                command,\n                pod_name,\n            )\n            success = False\n        elif result != \"\":\n            logger.info(\n                \"Execution of command -&gt; %s in pod -&gt; %s returned result -&gt; %s\",\n                command,\n                pod_name,\n                result,\n            )\n        else:\n            # It is not an error if no result is returned. It depends on the nature of the command\n            # if a result is written to stdout or stderr.\n            logger.info(\n                \"Execution of command -&gt; %s in pod -&gt; %s did not return a result\",\n                command,\n                pod_name,\n            )\n\n    self.write_status_file(success, section_name, self._exec_pod_commands)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_external_systems","title":"<code>process_external_systems(section_name='externalSystems')</code>","text":"<p>Process external systems in payload and create them in Extended ECM.</p> <pre><code>The payload section is a list of dicts (each representing one external\nsystem) with these items:\n{\n    enabled: True or False to enable or disable the payload item\n    external_system_name: Name of the external systen.\n    external_system_type: Type of the external system.\n                          Possible values are\n                          * SAP\n                          * SuccessFactors\n                          * Salesforce\n                          * AppWorks Platform\n    base_url: Base URL of the external system\n    as_url: Application Server URL of the external system\n    username: (Technical) User Name for the connection\n    password: Passord of the (technical) user\n    oauth_client_id: OAuth client ID\n    oauth_client_secret: OAuth client secret\n    archive_logical_name: Logical name of Archive for SAP\n    archive_certificate_file: Path and filename to certificate file.\n                              This file is inside the customizer\n                              pof file system.\n}\nIf OAuth Client ID and Client Secret are provided then username\nand password are no longer used.\n\nIn the payload for SAP external systems there are additional\nitems \"client\", \"destination\" that are processed by init_sap()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'externalSystems'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise Side Effects:     - based on system_type different other settings in the dict are set     - reachability is tested and a flag is set in the payload dict</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_external_systems(self, section_name: str = \"externalSystems\") -&gt; bool:\n    \"\"\"Process external systems in payload and create them in Extended ECM.\n\n        The payload section is a list of dicts (each representing one external\n        system) with these items:\n        {\n            enabled: True or False to enable or disable the payload item\n            external_system_name: Name of the external systen.\n            external_system_type: Type of the external system.\n                                  Possible values are\n                                  * SAP\n                                  * SuccessFactors\n                                  * Salesforce\n                                  * AppWorks Platform\n            base_url: Base URL of the external system\n            as_url: Application Server URL of the external system\n            username: (Technical) User Name for the connection\n            password: Passord of the (technical) user\n            oauth_client_id: OAuth client ID\n            oauth_client_secret: OAuth client secret\n            archive_logical_name: Logical name of Archive for SAP\n            archive_certificate_file: Path and filename to certificate file.\n                                      This file is inside the customizer\n                                      pof file system.\n        }\n        If OAuth Client ID and Client Secret are provided then username\n        and password are no longer used.\n\n        In the payload for SAP external systems there are additional\n        items \"client\", \"destination\" that are processed by init_sap()\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        - based on system_type different other settings in the dict are set\n        - reachability is tested and a flag is set in the payload dict\n    \"\"\"\n\n    if not self._external_systems:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # WE DON'T WANT TO DO THIS AS WE NEED TO INITIALIZE\n    # DATASTRUCTURES LIKE self._sap and self._salesforce!!\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    # if self.check_status_file(section_name):\n    #   return True\n\n    success: bool = True\n\n    for external_system in self._external_systems:\n        #\n        # 1: Do sanity checks for the payload:\n        #\n        if not \"external_system_name\" in external_system:\n            logger.error(\n                \"External System connection needs a logical system name! Skipping to next external system...\"\n            )\n            success = False\n            continue\n        system_name = external_system[\"external_system_name\"]\n\n        if not \"external_system_type\" in external_system:\n            logger.error(\n                \"External System connection -&gt; %s needs a type (SAP, Salesfoce, SuccessFactors, AppWorks Platform)! Skipping to next external system...\",\n                system_name,\n            )\n            success = False\n            continue\n        system_type = external_system[\"external_system_type\"]\n\n        if \"enabled\" in external_system and not external_system[\"enabled\"]:\n            logger.info(\n                \"Payload for External System -&gt; %s (%s) is disabled. Skipping...\",\n                system_name,\n                system_type,\n            )\n            continue\n\n        # Possible Connection Types for external systems:\n        # \"Business Scenario Sample\" (Business Scenarios Sample Adapter)\n        # \"ot.sap.c4c.SpiAdapter\" (SAP C4C SPI Adapter)\n        # \"ot.sap.c4c.SpiAdapterV2\" (C4C SPI Adapter V2)\n        # \"HTTP\" (Default WebService Adapter)\n        # \"ot.sap.S4HANAAdapter\" (S/4HANA SPI Adapter)\n        # \"SF\" (SalesForce Adapter)\n        # \"SFInstance\" (SFWebService)\n\n        # Set the default settings for the different system types:\n        match system_type:\n            # Check if we have a SuccessFactors system:\n            case \"SuccessFactors\":\n                connection_type = \"SFInstance\"\n                auth_method = \"OAUTH\"\n                username = None\n                password = None\n            case \"SAP\":\n                connection_type = \"HTTP\"\n                auth_method = \"BASIC\"\n                oauth_client_id = None\n                oauth_client_secret = None\n            case \"Salesforce\":\n                connection_type = \"SF\"\n                auth_method = \"OAUTH\"\n                username = None\n                password = None\n            case \"AppWorks Platform\":\n                connection_type = \"HTTP\"\n                auth_method = \"BASIC\"\n                oauth_client_id = None\n                oauth_client_secret = None\n            case \"Business Scenario Sample\":\n                connection_type = \"Business Scenario Sample\"\n                auth_method = \"BASIC\"\n                oauth_client_id = None\n                oauth_client_secret = None\n            case _:\n                logger.error(\"Unsupported system_type defined -&gt; %s\", system_type)\n                return False\n\n        if not \"base_url\" in external_system:\n            base_url = \"\"  # baseUrl is optional\n        else:\n            base_url = external_system[\"base_url\"]\n\n        if not \"as_url\" in external_system:\n            logger.warning(\n                \"External System connection -&gt; %s needs an Application Server URL! Skipping to next external system...\",\n                system_name,\n            )\n            success = False\n            continue\n        as_url = external_system[\"as_url\"]\n\n        # Check if external system is reachable and\n        # update the payload dict with a \"reachable\" key/value pair:\n        self.check_external_system(external_system)\n\n        # Read either username/password (BASIC) or client ID / secret (OAuth)\n        match auth_method:\n            case \"BASIC\":\n                if not \"username\" in external_system:\n                    logger.warning(\n                        \"External System connection -&gt; %s needs a user name for BASIC authentication! Skipping to next external system...\",\n                        system_name,\n                    )\n                    continue\n                if not \"password\" in external_system:\n                    logger.warning(\n                        \"External System connection -&gt; %s needs a password for BASIC authentication! Skipping to next external system...\",\n                        system_name,\n                    )\n                    continue\n                username = external_system[\"username\"]\n                password = external_system[\"password\"]\n                oauth_client_id = \"\"\n                oauth_client_secret = \"\"\n\n            case \"OAUTH\":\n                if not \"oauth_client_id\" in external_system:\n                    logger.error(\n                        \"External System connection -&gt; %s is missing OAuth client ID! Skipping to next external system...\",\n                        system_name,\n                    )\n                    success = False\n                    continue\n                if not \"oauth_client_secret\" in external_system:\n                    logger.error(\n                        \"External System connection -&gt; %s is missing OAuth client secret! Skipping to next external system...\",\n                        system_name,\n                    )\n                    success = False\n                    continue\n                oauth_client_id = external_system[\"oauth_client_id\"]\n                oauth_client_secret = external_system[\"oauth_client_secret\"]\n                # For backward compatibility we also read username/password\n                # with OAuth settings:\n                username = (\n                    external_system[\"username\"]\n                    if external_system.get(\"username\")\n                    else None\n                )\n                password = (\n                    external_system[\"password\"]\n                    if external_system.get(\"password\")\n                    else None\n                )\n            case _:\n                logger.error(\n                    \"Unsupported authorization method specified (%s) , Skipping ... \",\n                    auth_method,\n                )\n                return False\n\n        # We do this existance test late in this function to make sure the payload\n        # datastructure is properly updated for debugging purposes.\n        logger.info(\n            \"Test if external system -&gt; %s does already exist...\", system_name\n        )\n        if self._otcs.get_external_system_connection(system_name):\n            logger.info(\n                \"External System connection -&gt; %s already exists!\",\n                system_name,\n            )\n            # This is for handling re-runs of customizer pod where the transports\n            # are skipped and thus self._sap or self._salesforce may not be initialized:\n            if system_type == \"SAP\" and not self._sap:\n                logger.info(\n                    \"Re-Initialize SAP connection for external system -&gt; %s.\",\n                    system_name,\n                )\n                # Initialize SAP object responsible for communication to SAP:\n                self._sap = self.init_sap(external_system)\n            if system_type == \"Salesforce\" and not self._salesforce:\n                logger.info(\n                    \"Re-Initialize Salesforce connection for external system -&gt; %s.\",\n                    system_name,\n                )\n                # Initialize Salesforce object responsible for communication to Salesforce:\n                self._salesforce = self.init_salesforce(external_system)\n            logger.info(\"Skip to next external system...\")\n            continue\n\n        #\n        # Create External System:\n        #\n        logger.info(\n            \"Create external system -&gt; %s; type -&gt; %s\", system_name, connection_type\n        )\n        response = self._otcs.add_external_system_connection(\n            connection_name=system_name,\n            connection_type=connection_type,\n            as_url=as_url,\n            base_url=base_url,\n            username=str(username),\n            password=str(password),\n            authentication_method=auth_method,\n            client_id=oauth_client_id,\n            client_secret=oauth_client_secret,\n        )\n        if response is None:\n            logger.error(\n                \"Failed to create external system -&gt; %s; type -&gt; %s\",\n                system_name,\n                connection_type,\n            )\n            success = False\n        else:\n            logger.info(\"Successfully created external system -&gt; %s\", system_name)\n\n        #\n        # In case of an SAP external system we also initialize the SAP object\n        # and do some SAP-specific Archiving config:\n        #\n        if system_type == \"SAP\":\n            # Initialize SAP object responsible for communication to SAP:\n            self._sap = self.init_sap(external_system)\n            if (\n                \"archive_logical_name\" in external_system\n                and \"archive_certificate_file\" in external_system\n                and self._otac\n            ):\n                logger.info(\n                    \"Put certificate file -&gt; %s for logical archive -&gt; %s into Archive Center\",\n                    external_system[\"archive_certificate_file\"],\n                    external_system[\"archive_logical_name\"],\n                )\n                response = self._otac.put_cert(\n                    external_system[\"external_system_name\"],\n                    external_system[\"archive_logical_name\"],\n                    external_system[\"archive_certificate_file\"],\n                )\n                logger.info(\n                    \"Enable certificate file -&gt; %s for logical archive -&gt; %s\",\n                    external_system[\"archive_certificate_file\"],\n                    external_system[\"archive_logical_name\"],\n                )\n                response = self._otac.enable_cert(\n                    external_system[\"external_system_name\"],\n                    external_system[\"archive_logical_name\"],\n                    True,\n                )\n\n        #\n        # In case of an Salesforce external system we also initialize the Salesforce object\n        #\n        if system_type == \"Salesforce\":\n            # Initialize Salesforce object responsible for communication to Salesforce:\n            self._salesforce = self.init_salesforce(external_system)\n\n    self.write_status_file(success, section_name, self._external_systems)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_group_placeholders","title":"<code>process_group_placeholders()</code>","text":"<p>For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%) with the actual ID of the Extended ECM group. For this we prepare a lookup dict. The dict self._placeholder_values already includes lookups for the OTCS and OTAWP OTDS resource IDs (see main.py)</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_group_placeholders(self):\n    \"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n    with the actual ID of the Extended ECM group. For this we prepare a lookup dict.\n    The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n    OTDS resource IDs (see main.py)\n    \"\"\"\n\n    for group in self._groups:\n        if not \"name\" in group:\n            logger.error(\n                \"Group needs a name for placeholder definition. Skipping...\"\n            )\n            continue\n        group_name = group[\"name\"]\n        # Check if group has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in group and not group[\"enabled\"]:\n            logger.info(\n                \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n            )\n            continue\n\n        # Now we determine the ID. Either it is in the payload section from\n        # the current customizer run or we try to look it up in the system.\n        # The latter case may happen if the customizer pod got restarted.\n        group_id = self.determine_group_id(group)\n        if not group_id:\n            logger.warning(\n                \"Group needs an ID for placeholder definition. Skipping...\"\n            )\n            continue\n\n        # Add Group with its ID to the dict self._placeholder_values:\n        self._placeholder_values[\n            \"OTCS_GROUP_ID_\"\n            + group_name.upper().replace(\" &amp; \", \"_\").replace(\" \", \"_\")\n        ] = str(group_id)\n\n    logger.debug(\n        \"Placeholder values after group processing = %s\", self._placeholder_values\n    )\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_groups","title":"<code>process_groups(section_name='groups')</code>","text":"<p>Process groups in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'groups'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise Side Effects:     the group items are modified by adding an \"id\" dict element that     includes the technical ID of the group in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_groups(self, section_name: str = \"groups\") -&gt; bool:\n    \"\"\"Process groups in payload and create them in Extended ECM.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        the group items are modified by adding an \"id\" dict element that\n        includes the technical ID of the group in Extended ECM\n    \"\"\"\n\n    if not self._groups:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # First run through groups: create all groups in payload\n    # and store the IDs of the created groups:\n    for group in self._groups:\n        if not \"name\" in group:\n            logger.error(\"Group needs a name. Skipping...\")\n            success = False\n            continue\n        group_name = group[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in group and not group[\"enabled\"]:\n            logger.info(\n                \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n            )\n            continue\n\n        # Check if the group does already exist (e.g. if job is restarted)\n        # as this is a pattern search it could return multiple groups:\n        group_id = self.determine_group_id(group)\n        if group_id:\n            logger.info(\n                \"Found existing group -&gt; %s (%s). Skipping to next group...\",\n                group_name,\n                group_id,\n            )\n            continue\n\n        logger.info(\"Did not find an existing group - creating a new group...\")\n\n        # Now we know it is a new group...\n        new_group = self._otcs.add_group(group_name)\n        if new_group:\n            new_group_id = self._otcs.get_result_value(new_group, \"id\")\n            logger.debug(\"New group -&gt; %s\", new_group)\n            group[\"id\"] = new_group_id\n        else:\n            logger.error(\"Failed to create group -&gt; %s\", group_name)\n            success = False\n            continue\n\n    logger.debug(\"Groups = %s\", self._groups)\n\n    # Second run through groups: create all group memberships\n    # (nested groups) based on the IDs created in first run:\n    for group in self._groups:\n        if not \"id\" in group:\n            logger.error(\"Group -&gt; %s does not have an ID.\", group[\"name\"])\n            success = False\n            continue\n        parent_group_names = group[\"parent_groups\"]\n        for parent_group_name in parent_group_names:\n            # First, try to find parent group in payload by parent group name:\n            parent_group = next(\n                (\n                    item\n                    for item in self._groups\n                    if item[\"name\"] == parent_group_name\n                ),\n                None,\n            )\n            if parent_group is None:\n                # If this didn't work, try to get the parent group from OTCS. This covers\n                # cases where the parent group is system generated or part\n                # of a former payload processing run:\n                parent_group = self._otcs.get_group(parent_group_name)\n                parent_group_id = self._otcs.get_result_value(parent_group, \"id\")\n                if not parent_group_id:\n                    logger.error(\n                        \"Parent Group -&gt; %s not found. Skipping...\",\n                        parent_group_name,\n                    )\n                    success = False\n                    continue\n            elif not \"id\" in parent_group:\n                logger.error(\n                    \"Parent Group -&gt; %s does not have an ID. Cannot establish group nesting. Skipping...\",\n                    parent_group[\"name\"],\n                )\n                success = False\n                continue\n            else:  # we can read the ID from the\n                parent_group_id = parent_group[\"id\"]\n\n            # retrieve all members of the parent group (1 = get only groups)\n            # to check if the current group is already a member in the parent group:\n            members = self._otcs.get_group_members(parent_group_id, 1)\n            if self._otcs.exist_result_item(members, \"id\", group[\"id\"]):\n                logger.info(\n                    \"Group -&gt; %s (%s) is already a member of parent group -&gt; %s (%s). Skipping to next parent group...\",\n                    group[\"name\"],\n                    group[\"id\"],\n                    parent_group_name,\n                    parent_group_id,\n                )\n            else:\n                logger.info(\n                    \"Add group -&gt; %s (%s) to parent group -&gt; %s (%s)\",\n                    group[\"name\"],\n                    group[\"id\"],\n                    parent_group_name,\n                    parent_group_id,\n                )\n                self._otcs.add_group_member(group[\"id\"], parent_group_id)\n\n    self.write_status_file(success, section_name, self._groups)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_groups_m365","title":"<code>process_groups_m365(section_name='groupsM365')</code>","text":"<p>Process groups in payload and create them in Microsoft 365.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'groupsM365'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_groups_m365(self, section_name: str = \"groupsM365\") -&gt; bool:\n    \"\"\"Process groups in payload and create them in Microsoft 365.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n    if not isinstance(self._m365, M365):\n        logger.error(\n            \"Office 365 connection not setup properly. Skipping payload section %s...\",\n            section_name,\n        )\n        return False\n\n    if not self._groups:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # First run through groups: create all groups in payload\n    # and store the IDs of the created groups:\n    for group in self._groups:\n        if not \"name\" in group:\n            logger.error(\"Group needs a name. Skipping...\")\n            success = False\n            continue\n        group_name = group[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in group and not group[\"enabled\"]:\n            logger.info(\n                \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n            )\n            continue\n        if not \"enable_o365\" in group or not group[\"enable_o365\"]:\n            logger.info(\n                \"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\n                group_name,\n            )\n            continue\n\n        # Check if the group does already exist (e.g. if job is restarted)\n        # as this is a pattern search it could return multiple groups:\n        existing_groups = self._m365.get_group(group_name)\n\n        if existing_groups and existing_groups[\"value\"]:\n            logger.debug(\n                \"Found existing Microsoft 365 groups -&gt; %s\",\n                existing_groups[\"value\"],\n            )\n            # Get list of all matching groups:\n            existing_groups_list = existing_groups[\"value\"]\n            # Find the group with the exact match of the name:\n            existing_group = next(\n                (\n                    item\n                    for item in existing_groups_list\n                    if item[\"displayName\"] == group_name\n                ),\n                None,\n            )\n            # Have we found an exact match?\n            if existing_group is not None:\n                logger.info(\n                    \"Found existing Microsoft 365 group -&gt; %s (%s) - skip creation of group...\",\n                    existing_group[\"displayName\"],\n                    existing_group[\"id\"],\n                )\n                # Write M365 group ID back into the payload (for the success file)\n                group[\"m365_id\"] = existing_group[\"id\"]\n                continue\n            logger.info(\n                \"Did not find an exact match for the group - creating a new Microsoft 365 group...\"\n            )\n        else:\n            logger.info(\n                \"Did not find any matching group - creating a new Microsoft 365 group...\"\n            )\n\n        # Now we know it is a new group...\n        new_group = self._m365.add_group(group_name)\n        if new_group is not None:\n            # Store the Microsoft 365 group ID in payload:\n            group[\"m365_id\"] = new_group[\"id\"]\n            logger.info(\n                \"New Microsoft 365 group -&gt; %s with ID -&gt; %s has been created\",\n                group_name,\n                group[\"m365_id\"],\n            )\n        else:\n            success = False\n\n    self.write_status_file(success, section_name, self._groups)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_holds","title":"<code>process_holds(section_name='holds')</code>","text":"<p>Process Records Management Holds for Extended ECM users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'holds'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_holds(self, section_name: str = \"holds\") -&gt; bool:\n    \"\"\"Process Records Management Holds for Extended ECM users.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._holds:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for hold in self._holds:\n        if not \"name\" in hold:\n            logger.error(\"Cannot create Hold without a name! Skipping...\")\n            continue\n        hold_name = hold[\"name\"]\n\n        if not \"type\" in hold:\n            logger.error(\n                \"Cannot create Hold -&gt; %s without a type! Skipping...\", hold_name\n            )\n            success = False\n            continue\n        hold_type = hold[\"type\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in hold and not hold[\"enabled\"]:\n            logger.info(\n                \"Payload for Hold -&gt; %s is disabled. Skipping...\", hold_name\n            )\n            continue\n\n        hold_group = hold.get(\"group\")\n        hold_comment = hold.get(\"comment\")\n        hold_alternate_id = hold.get(\"alternate_id\")\n        hold_date_applied = hold.get(\"date_applied\")\n        hold_date_suspend = hold.get(\"date_to_remove\")\n\n        # 550 is the RM Volume\n        response = self._otcs.get_node_by_volume_and_path(550, [\"Hold Maintenance\"])\n        if not response:\n            logger.error(\"Cannot find Records Management Volume!\")\n            continue\n        holds_maintenance_id = self._otcs.get_result_value(response, \"id\")\n        if not holds_maintenance_id:\n            logger.error(\n                \"Cannot find Holds Maintenance folder in Records Management Volume!\"\n            )\n            continue\n\n        if hold_group:\n            # Check if the Hold Group (folder) does already exist.\n            response = self._otcs.get_node_by_parent_and_name(\n                holds_maintenance_id, hold_group\n            )\n            parent_id = self._otcs.get_result_value(response, \"id\")\n            if not parent_id:\n                response = self._otcs.create_item(\n                    holds_maintenance_id, \"833\", hold_group\n                )\n                parent_id = self._otcs.get_result_value(response, \"id\")\n                if not parent_id:\n                    logger.error(\"Failed to create hold group -&gt; %s\", hold_group)\n                    continue\n        else:\n            parent_id = holds_maintenance_id\n\n        # Holds are special - they ahve folders that cannot be traversed\n        # in the normal way - we need to get the whole list of holds and use\n        # specialparameters for the exist_result_items() method as the REST\n        # API calls delivers a results-&gt;data-&gt;holds structure (not properties)\n        response = self._otcs.get_records_management_holds()\n        if self._otcs.exist_result_item(\n            response, \"HoldName\", hold_name, property_name=\"holds\"\n        ):\n            logger.info(\"Hold -&gt; %s does already exist. Skipping...\", hold_name)\n            continue\n\n        hold = self._otcs.create_records_management_hold(\n            hold_type,\n            hold_name,\n            hold_comment,\n            hold_alternate_id,\n            int(parent_id),\n            hold_date_applied,\n            hold_date_suspend,\n        )\n\n        if hold and hold[\"holdID\"]:\n            logger.info(\n                \"Successfully created hold -&gt; %s with ID -&gt; %s\",\n                hold_name,\n                hold[\"holdID\"],\n            )\n        else:\n            success = False\n\n    self.write_status_file(success, section_name, self._holds)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_items","title":"<code>process_items(items, section_name='items')</code>","text":"<p>Process items specified in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list</code> <p>list of items to create (need this as parameter as we           have multiple lists)</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"itemsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'items'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_items(self, items: list, section_name: str = \"items\") -&gt; bool:\n    \"\"\"Process items specified in payload and create them in Extended ECM.\n\n    Args:\n        items (list): list of items to create (need this as parameter as we\n                      have multiple lists)\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"itemsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not items:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for item in items:\n        if not \"name\" in item:\n            logger.error(\"Item needs a name. Skipping...\")\n            continue\n        item_name = item[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in item and not item[\"enabled\"]:\n            logger.info(\n                \"Payload for Item -&gt; %s is disabled. Skipping...\", item_name\n            )\n            continue\n\n        if not \"description\" in item:\n            item_description = \"\"\n        else:\n            item_description = item[\"description\"]\n\n        parent_nickname = item.get(\"parent_nickname\")\n        parent_path = item.get(\"parent_path\")\n\n        if parent_nickname:\n            parent_node = self._otcs.get_node_from_nickname(parent_nickname)\n            parent_id = self._otcs.get_result_value(parent_node, \"id\")\n            # if not parent_node:\n            if not parent_id:\n                logger.error(\n                    \"Item -&gt; %s has a parent nickname -&gt; %s that does not exist. Skipping...\",\n                    item_name,\n                    parent_nickname,\n                )\n                success = False\n                continue\n        else:  # use parent_path and Enterprise Volume\n            parent_node = self._otcs.get_node_by_volume_and_path(141, parent_path)\n            parent_id = self._otcs.get_result_value(parent_node, \"id\")\n            if not parent_id:\n                # if not parent_node:\n                logger.error(\n                    \"Item -&gt; %s has a parent path that does not exist. Skipping...\",\n                    item_name,\n                )\n                success = False\n                continue\n\n        original_nickname = item.get(\"original_nickname\")\n        original_path = item.get(\"original_path\")\n\n        if original_nickname:\n            original_node = self._otcs.get_node_from_nickname(original_nickname)\n            original_id = self._otcs.get_result_value(original_node, \"id\")\n            if not original_id:\n                # if not original_node:\n                logger.error(\n                    \"Item -&gt; %s has a original nickname -&gt; %s that does not exist. Skipping...\",\n                    item_name,\n                    original_nickname,\n                )\n                success = False\n                continue\n        elif original_path:\n            original_node = self._otcs.get_node_by_volume_and_path(\n                141, original_path\n            )\n            original_id = self._otcs.get_result_value(original_node, \"id\")\n            if not original_id:\n                # if not original_node:\n                logger.error(\n                    \"Item -&gt; %s has a original path that does not exist. Skipping...\",\n                    item_name,\n                )\n                success = False\n                continue\n        else:\n            original_id = 0\n\n        if not \"type\" in item:\n            logger.error(\"Item -&gt; %s needs a type. Skipping...\", item_name)\n            success = False\n            continue\n\n        item_type = item.get(\"type\")\n        item_url = item.get(\"url\")\n\n        # check that we have the required information\n        # for the given item type:\n        match item_type:\n            case 140:  # URL\n                if item_url == \"\":\n                    logger.error(\n                        \"Item -&gt; %s has type URL but the URL is not in the payload. Skipping...\",\n                        item_name,\n                    )\n                    success = False\n                    continue\n            case 1:  # Shortcut\n                if original_id == 0:\n                    logger.error(\n                        \"Item -&gt; %s has type Shortcut but the original item is not in the payload. Skipping...\",\n                        item_name,\n                    )\n                    success = False\n                    continue\n\n        # Check if an item with the same name does already exist.\n        # This can also be the case if the python container runs a 2nd time.\n        # For this reason we are also not issuing an error but just an info (False):\n        response = self._otcs.get_node_by_parent_and_name(\n            int(parent_id), item_name, show_error=False\n        )\n        if self._otcs.get_result_value(response, \"name\") == item_name:\n            logger.info(\n                \"Item with name -&gt; %s does already exist in parent folder with ID -&gt; %s\",\n                item_name,\n                parent_id,\n            )\n            continue\n        response = self._otcs.create_item(\n            int(parent_id),\n            str(item_type),\n            item_name,\n            item_description,\n            item_url,\n            int(original_id),\n        )\n        if not response:\n            logger.error(\"Failed to create item -&gt; %s.\", item_name)\n            success = False\n\n    self.write_status_file(success, section_name, items)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_oauth_clients","title":"<code>process_oauth_clients(section_name='oauthClients')</code>","text":"<p>Process OTDS OAuth clients in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'oauthClients'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_oauth_clients(self, section_name: str = \"oauthClients\") -&gt; bool:\n    \"\"\"Process OTDS OAuth clients in payload and create them in OTDS.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._oauth_clients:\n        logger.info(\"Payload section -&gt; % is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for oauth_client in self._oauth_clients:\n        client_name = oauth_client.get(\"name\")\n        if not client_name:\n            logger.error(\"OAuth client does not have a name. Skipping...\")\n            success = False\n            continue\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in oauth_client and not oauth_client[\"enabled\"]:\n            logger.info(\n                \"Payload for OAuthClient -&gt; %s is disabled. Skipping...\",\n                client_name,\n            )\n            continue\n\n        client_description = oauth_client.get(\"description\")\n        client_confidential = oauth_client.get(\"confidential\")\n        client_partition = oauth_client.get(\"partition\")\n        if client_partition == \"Global\":\n            client_partition = []\n        client_redirect_urls = oauth_client.get(\"redirect_urls\")\n        client_permission_scopes = oauth_client.get(\"permission_scopes\")\n        client_default_scopes = oauth_client.get(\"default_scopes\")\n        client_allow_impersonation = oauth_client.get(\"allow_impersonation\")\n        client_secret = oauth_client.get(\"secret\", \"\")\n\n        # Check if OAuth client does already exist\n        # (in an attempt to make the code idem-potent)\n        logger.info(\n            \"Check if OTDS OAuth Client -&gt; %s does already exist...\", client_name\n        )\n        response = self._otds.get_oauth_client(client_name, show_error=False)\n        if response:\n            logger.info(\n                \"OAuth Client -&gt; %s does already exist. Skipping...\", client_name\n            )\n            continue\n        else:\n            logger.info(\n                \"OAuth Client -&gt; %s does not exist. Creating...\", client_name\n            )\n\n        response = self._otds.add_oauth_client(\n            client_id=client_name,\n            description=client_description,\n            redirect_urls=client_redirect_urls,\n            allow_impersonation=client_allow_impersonation,\n            confidential=client_confidential,\n            auth_scopes=client_partition,\n            allowed_scopes=client_permission_scopes,\n            default_scopes=client_default_scopes,\n            secret=client_secret,\n        )\n        if response:\n            logger.info(\"Added OTDS OAuth client -&gt; %s\", client_name)\n        else:\n            logger.error(\"Failed to add OTDS OAuth client -&gt; %s\", client_name)\n            success = False\n            continue\n\n        # in case the secret has not been provided in the payload we retrieve\n        # the automatically created secret:\n        client_secret = response.get(\"secret\")\n        if not client_secret:\n            logger.error(\"OAuth client -&gt; %s does not have a secret!\", client_name)\n            continue\n\n        client_description += \" Client Secret: \" + str(client_secret)\n        response = self._otds.update_oauth_client(\n            client_name, {\"description\": client_description}\n        )\n        # Write the secret back into the payload\n        oauth_client[\"secret\"] = client_secret\n\n    self.write_status_file(success, section_name, self._oauth_clients)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_partition_licenses","title":"<code>process_partition_licenses(section_name='partitionLicenses')</code>","text":"<p>Process the licenses that should be assigned to OTDS partitions    (this includes existing partitions).</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'partitionLicenses'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_partition_licenses(\n    self, section_name: str = \"partitionLicenses\"\n) -&gt; bool:\n    \"\"\"Process the licenses that should be assigned to OTDS partitions\n       (this includes existing partitions).\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._partitions:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for partition in self._partitions:\n        partition_name = partition.get(\"name\")\n        if not partition_name:\n            logger.error(\"Partition does not have a name. Skipping...\")\n            success = False\n            continue\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in partition and not partition[\"enabled\"]:\n            logger.info(\n                \"Payload for Partition -&gt; %s is disabled. Skipping...\",\n                partition_name,\n            )\n            continue\n\n        response = self._otds.get_partition(partition_name, show_error=True)\n        if not response:\n            logger.error(\n                \"Partition -&gt; %s does not exist. Skipping...\", partition_name\n            )\n            success = False\n            continue\n\n        # Partions may have an optional list of licenses in\n        # the payload. Assign the partition to all these licenses:\n        partition_specific_licenses = partition.get(\"licenses\")\n        if partition_specific_licenses:\n            # We assume these licenses are Extended ECM licenses!\n            otcs_resource_name = self._otcs.config()[\"resource\"]\n            otcs_resource = self._otds.get_resource(otcs_resource_name)\n            if not otcs_resource:\n                logger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\n                success = False\n                continue\n            otcs_resource_id = otcs_resource[\"resourceID\"]\n            license_name = \"EXTENDED_ECM\"\n            for license_feature in partition_specific_licenses:\n                if self._otds.is_partition_licensed(\n                    partition_name=partition_name,\n                    resource_id=otcs_resource_id,\n                    license_feature=license_feature,\n                    license_name=license_name,\n                ):\n                    logger.info(\n                        \"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\n                        partition_name,\n                        license_name,\n                        license_feature,\n                    )\n                    continue\n                assigned_license = self._otds.assign_partition_to_license(\n                    partition_name,\n                    otcs_resource_id,\n                    license_feature,\n                    license_name,\n                )\n\n                if not assigned_license:\n                    logger.error(\n                        \"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\n                        partition_name,\n                        license_feature,\n                        license_name,\n                    )\n                    success = False\n                else:\n                    logger.info(\n                        \"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\n                        partition_name,\n                        license_feature,\n                        license_name,\n                    )\n\n    self.write_status_file(success, section_name, self._partitions)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_partitions","title":"<code>process_partitions(section_name='partitions')</code>","text":"<p>Process OTDS partitions in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections). This                           name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'partitions'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_partitions(self, section_name: str = \"partitions\") -&gt; bool:\n    \"\"\"Process OTDS partitions in payload and create them in OTDS.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections). This\n                                      name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._partitions:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for partition in self._partitions:\n        partition_name = partition.get(\"name\")\n        if not partition_name:\n            logger.error(\"Partition does not have a name. Skipping...\")\n            success = False\n            continue\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in partition and not partition[\"enabled\"]:\n            logger.info(\n                \"Payload for Partition -&gt; %s is disabled. Skipping...\",\n                partition_name,\n            )\n            continue\n\n        partition_description = partition.get(\"description\")\n\n        # Check if Partition does already exist\n        # (in an attempt to make the code idem-potent)\n        logger.info(\n            \"Check if OTDS partition -&gt; %s does already exist...\", partition_name\n        )\n        response = self._otds.get_partition(partition_name, show_error=False)\n        if response:\n            logger.info(\n                \"Partition -&gt; %s does already exist. Skipping...\", partition_name\n            )\n            continue\n\n        # Only continue if Partition does not exist already\n        logger.info(\"Partition -&gt; %s does not exist. Creating...\", partition_name)\n\n        response = self._otds.add_partition(partition_name, partition_description)\n        if response:\n            logger.info(\"Added OTDS partition -&gt; %s\", partition_name)\n        else:\n            logger.error(\"Failed to add OTDS partition -&gt; %s\", partition_name)\n            success = False\n            continue\n\n        access_role = partition.get(\"access_role\")\n        if access_role:\n            response = self._otds.add_partition_to_access_role(\n                access_role, partition_name\n            )\n            if response:\n                logger.info(\n                    \"Added OTDS partition -&gt; %s to access role -&gt; %s\",\n                    partition_name,\n                    access_role,\n                )\n            else:\n                logger.error(\n                    \"Failed to add OTDS partition -&gt; %s to access role -&gt; %s\",\n                    partition_name,\n                    access_role,\n                )\n                success = False\n                continue\n\n        # Partions may have an optional list of licenses in\n        # the payload. Assign the partition to all these licenses:\n        partition_specific_licenses = partition.get(\"licenses\")\n        if partition_specific_licenses:\n            # We assume these licenses are Extended ECM licenses!\n            otcs_resource_name = self._otcs.config()[\"resource\"]\n            otcs_resource = self._otds.get_resource(otcs_resource_name)\n            if not otcs_resource:\n                logger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\n                success = False\n                continue\n            otcs_resource_id = otcs_resource[\"resourceID\"]\n            license_name = \"EXTENDED_ECM\"\n            for license_feature in partition_specific_licenses:\n                assigned_license = self._otds.assign_partition_to_license(\n                    partition_name,\n                    otcs_resource_id,\n                    license_feature,\n                    license_name,\n                )\n\n                if not assigned_license:\n                    logger.error(\n                        \"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\n                        partition_name,\n                        license_feature,\n                        license_name,\n                    )\n                    success = False\n                else:\n                    logger.info(\n                        \"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\n                        partition_name,\n                        license_feature,\n                        license_name,\n                    )\n\n    self.write_status_file(success, section_name, self._partitions)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_payload","title":"<code>process_payload()</code>","text":"<p>Main method to process a payload file.</p> <p>Returns:     None</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_payload(self):\n    \"\"\"Main method to process a payload file.\n\n    Args:\n        None\n    Returns:\n        None\n    \"\"\"\n\n    if not self._payload_sections:\n        return None\n\n    for payload_section in self._payload_sections:\n        match payload_section[\"name\"]:\n            case \"webHooks\":\n                self._log_header_callback(\"Process Web Hooks\")\n                self.process_web_hooks(webhooks=self._webhooks)\n            case \"webHooksPost\":\n                self._log_header_callback(\"Process Web Hooks (post)\")\n                self.process_web_hooks(\n                    webhooks=self._webhooks_post, section_name=\"webHooksPost\"\n                )\n            case \"partitions\":\n                self._log_header_callback(\"Process OTDS Partitions\")\n                self.process_partitions()\n                self._log_header_callback(\"Assign OTCS Licenses to Partitions\")\n                self.process_partition_licenses()\n            case \"oauthClients\":\n                self._log_header_callback(\"Process OTDS OAuth Clients\")\n                self.process_oauth_clients()\n            case \"authHandlers\":\n                self._log_header_callback(\"Process OTDS Auth Handlers\")\n                self.process_auth_handlers()\n            case \"trustedSites\":\n                self._log_header_callback(\"Process OTDS Trusted Sites\")\n                self.process_trusted_sites()\n            case \"systemAttributes\":\n                self._log_header_callback(\"Process OTDS System Attributes\")\n                self.process_system_attributes()\n            case \"groups\":\n                self._log_header_callback(\"Process OTCS Groups\")\n                self.process_groups()\n                # Add all groups with ID the a lookup dict for placeholder replacements\n                # in adminSetting. This also updates the payload with group IDs from OTCS\n                # if the group already exists in Extended ECM. This is important especially\n                # if the customizer pod is restarted / run multiple times:\n                self.process_group_placeholders()\n                if self._m365 and isinstance(self._m365, M365):\n                    self._log_header_callback(\"Cleanup existing MS Teams\")\n                    self.cleanup_all_teams_m365()\n                    self._log_header_callback(\"Process M365 Groups\")\n                    self.process_groups_m365()\n            case \"users\":\n                self._log_header_callback(\"Process OTCS Users\")\n                self.process_users()\n                # Add all users with ID the a lookup dict for placeholder replacements\n                # in adminSetting. This also updates the payload with user IDs from OTCS\n                # if the user already exists in Extended ECM. This is important especially\n                # if the cutomizer pod is restarted / run multiple times:\n                self.process_user_placeholders()\n                self._log_header_callback(\"Assign OTCS Licenses to Users\")\n                self.process_user_licenses(\n                    resource_name=self._otcs.config()[\"resource\"],\n                    license_feature=self._otcs.config()[\"license\"],\n                    license_name=\"EXTENDED_ECM\",\n                    user_specific_payload_field=\"licenses\",\n                )\n                self._log_header_callback(\"Assign OTIV Licenses to Users\")\n\n                if (\n                    isinstance(self._otiv, OTIV)  # can be None in 24.1 or newer\n                    and self._otiv.config()\n                    and self._otiv.config()[\"resource\"]\n                    and self._otiv.config()[\"license\"]\n                ):\n                    self.process_user_licenses(\n                        resource_name=self._otiv.config()[\"resource\"],\n                        license_feature=self._otiv.config()[\"license\"],\n                        license_name=\"INTELLIGENT_VIEWING\",\n                        user_specific_payload_field=\"\",\n                        section_name=\"userLicensesViewing\",  # we need a specific name here for OTIV\n                    )\n                else:\n                    logger.info(\"Processing of OTIV licenses is disabled.\")\n                self._log_header_callback(\"Process User Settings\")\n                self.process_user_settings()\n                if self._m365 and isinstance(self._m365, M365):\n                    self._log_header_callback(\"Process M365 Users\")\n                    self.process_users_m365()\n                    # We need to do the MS Teams creation after the creation of\n                    # the M365 users as we require Group Owners to create teams\n                    self._log_header_callback(\"Process M365 Teams\")\n                    self.process_teams_m365()\n            case \"adminSettings\":\n                self._log_header_callback(\"Process Administration Settings\")\n                restart_required = self.process_admin_settings(\n                    admin_settings=self._admin_settings\n                )\n                if restart_required:\n                    logger.info(\n                        \"Admin Settings require a restart of OTCS services...\",\n                    )\n                    # Restart OTCS frontend and backend pods:\n                    self._otcs_restart_callback(self._otcs_backend)\n            case \"adminSettingsPost\":\n                self._log_header_callback(\"Process Administration Settings (post)\")\n                restart_required = self.process_admin_settings(\n                    self._admin_settings_post, \"adminSettingsPost\"\n                )\n                if restart_required:\n                    logger.info(\n                        \"Admin Settings (Post) require a restart of OTCS services...\",\n                    )\n                    # Restart OTCS frontend and backend pods:\n                    self._otcs_restart_callback(self._otcs_backend)\n            case \"execPodCommands\":\n                self._log_header_callback(\"Process Pod Commands\")\n                self.process_exec_pod_commands()\n            case \"csApplications\":\n                self._log_header_callback(\"Process CS Apps (backend)\")\n                self.process_cs_applications(\n                    self._otcs_backend, section_name=\"csApplicationsBackend\"\n                )\n                self._log_header_callback(\"Process CS Apps (frontend)\")\n                self.process_cs_applications(\n                    self._otcs_frontend, section_name=\"csApplicationsFrontend\"\n                )\n            case \"externalSystems\":\n                self._log_header_callback(\"Process External System Connections\")\n                self.process_external_systems()\n            case \"transportPackages\":\n                self._log_header_callback(\"Process Transport Packages\")\n                self.process_transport_packages(self._transport_packages)\n                # Right after the transport that create the business object types\n                # and the workspace types we extract them and put them into\n                # generated payload lists:\n                self._log_header_callback(\"Process Business Object Types\")\n                self.process_business_object_types()\n                self._log_header_callback(\"Process Workspace Types\")\n                self.process_workspace_types()\n                if self._m365 and isinstance(self._m365, M365):\n                    # Right after the transport that creates the top level folders\n                    # we can add the M365 Teams apps for Extended ECM as its own tab:\n                    self._log_header_callback(\"Process M365 Teams apps\")\n                    self.process_teams_m365_apps()\n            case \"contentTransportPackages\":\n                self._log_header_callback(\"Process Content Transport Packages\")\n                self.process_transport_packages(\n                    transport_packages=self._content_transport_packages,\n                    section_name=\"contentTransportPackages\",\n                )\n                # Process workspace permissions after content may have been added:\n                self._log_header_callback(\"Process Workspace Permissions\")\n                self.process_workspace_member_permissions()\n            case \"transportPackagesPost\":\n                self._log_header_callback(\"Process Transport Packages (post)\")\n                self.process_transport_packages(\n                    transport_packages=self._transport_packages_post,\n                    section_name=\"transportPackagesPost\",\n                )\n            case \"workspaceTemplates\":\n                # If a payload file (e.g. additional ones) does not have\n                # transportPackages then it can happen that the\n                # self._workspace_types is not yet initialized. As we need\n                # this structure for workspaceTemnplates we initialize it here:\n                if not self._business_object_types:\n                    self._log_header_callback(\"Process Business Object Types\")\n                    self.process_business_object_types()\n                if not self._workspace_types:\n                    self._log_header_callback(\"Process Workspace Types\")\n                    self.process_workspace_types()\n\n                self._log_header_callback(\n                    \"Process Workspace Templates (Template Role Assignments)\"\n                )\n                self.process_workspace_templates()\n            case \"workspaces\":\n                # If a payload file (e.g. additional ones) does not have\n                # transportPackages then it can happen that the self._business_object_types and\n                # self._workspace_types are not yet initialized. As we need\n                # these structures for workspaces we initialize it here:\n                if not self._business_object_types:\n                    self._log_header_callback(\"Process Business Object Types\")\n                    self.process_business_object_types()\n                if not self._workspace_types:\n                    self._log_header_callback(\"Process Workspace Types\")\n                    self.process_workspace_types()\n\n                self._log_header_callback(\"Process Workspaces\")\n                self.process_workspaces()\n                self._log_header_callback(\"Process Workspace Relationships\")\n                self.process_workspace_relationships()\n                self._log_header_callback(\"Process Workspace Memberships\")\n                self.process_workspace_members()\n\n                # This has to run after the processing of webReports that are\n                # used to enable Content Aviator in KINI database table:\n                if self._aviator_enabled:\n                    self._log_header_callback(\"Process Workspace Aviators\")\n                    self.process_workspace_aviators()\n            case \"sapRFCs\":\n                self._log_header_callback(\"Process SAP RFCs\")\n\n                sap_external_system = {}\n                if self._external_systems:\n                    sap_external_system = next(\n                        (\n                            item\n                            for item in self._external_systems\n                            if item.get(\"external_system_type\")\n                            and item[\"external_system_type\"] == \"SAP\"\n                        ),\n                        {},\n                    )\n                if not sap_external_system:\n                    logger.warning(\n                        \"SAP RFC in payload but SAP external system is configured. RFCs will not be processed.\"\n                    )\n                elif not sap_external_system.get(\"enabled\"):\n                    logger.warning(\n                        \"SAP RFC in payload but SAP external system is disabled. RFCs will not be processed.\"\n                    )\n                # if the external system is not marked reachable we check it once more as this could be fooled\n                # by customizer pod restarts\n                elif not sap_external_system.get(\n                    \"reachable\"\n                ) and not self.check_external_system(sap_external_system):\n                    logger.warning(\n                        \"SAP RFC in payload but SAP external system is not reachable. RFCs will not be processed.\"\n                    )\n                else:\n                    if self._sap:\n                        self.process_sap_rfcs(self._sap)\n                        self._log_header_callback(\"Process SAP Users\")\n                        self.process_users_sap(self._sap)\n                    else:\n                        logger.error(\n                            \"SAP object is not yet initialized. Something is wrong with payload section ordering.\"\n                        )\n            case \"webReports\":\n                self._log_header_callback(\"Process Web Reports\")\n                restart_required = self.process_web_reports(\n                    web_reports=self._web_reports\n                )\n                if restart_required:\n                    logger.info(\n                        \"Web Reports require a restart of OTCS services...\",\n                    )\n                    # Restart OTCS frontend and backend pods:\n                    self._otcs_restart_callback(self._otcs_backend)\n            case \"webReportsPost\":\n                self._log_header_callback(\"Process Web Reports (post)\")\n                restart_required = self.process_web_reports(\n                    web_reports=self._web_reports_post,\n                    section_name=\"webReportsPost\",\n                )\n                if restart_required:\n                    logger.info(\n                        \"WebReports (Post) require a restart of OTCS services...\",\n                    )\n                    # Restart OTCS frontend and backend pods:\n                    self._otcs_restart_callback(self._otcs_backend)\n            case \"additionalGroupMemberships\":\n                self._log_header_callback(\n                    \"Process additional group members for OTDS\"\n                )\n                self.process_additional_group_members()\n            case \"additionalAccessRoleMemberships\":\n                self._log_header_callback(\n                    \"Process additional access role members for OTDS\"\n                )\n                self.process_additional_access_role_members()\n            case \"renamings\":\n                self._log_header_callback(\"Process Node Renamings\")\n                self.process_renamings()\n            case \"items\":\n                self._log_header_callback(\"Process Items\")\n                self.process_items(items=self._items)\n            case \"itemsPost\":\n                self._log_header_callback(\"Process Items (post)\")\n                self.process_items(items=self._items_post, section_name=\"itemsPost\")\n            case \"permissions\":\n                self._log_header_callback(\"Process Permissions\")\n                self.process_permissions(permissions=self._permissions)\n            case \"permissionsPost\":\n                self._log_header_callback(\"Process Permissions (post)\")\n                self.process_permissions(\n                    permissions=self._permissions_post,\n                    section_name=\"permissionsPost\",\n                )\n            case \"assignments\":\n                self._log_header_callback(\"Process Assignments\")\n                self.process_assignments()\n            case \"securityClearances\":\n                self._log_header_callback(\"Process Security Clearances\")\n                self.process_security_clearances()\n            case \"supplementalMarkings\":\n                self._log_header_callback(\"Process Supplemental Markings\")\n                self.process_supplemental_markings()\n            case \"recordsManagementSettings\":\n                self._log_header_callback(\"Process Records Management Settings\")\n                self.process_records_management_settings()\n            case \"holds\":\n                self._log_header_callback(\"Process Records Management Holds\")\n                self.process_holds()\n            case \"documentGenerators\":\n                # If a payload file (e.g. additional ones) does not have\n                # transportPackages then it can happen that the\n                # self._workspace_types is not yet initialized. As we need\n                # this structure for documentGenerators we initialize it here:\n                if not self._workspace_types:\n                    self._log_header_callback(\"Process Workspace Types\")\n                    self.process_workspace_types()\n\n                self._log_header_callback(\"Process Document Generators\")\n                self.process_document_generators()\n            case \"browserAutomations\":\n                self._log_header_callback(\"Process Browser Automations\")\n                self.process_browser_automations(\n                    browser_automations=self._browser_automations\n                )\n            case \"browserAutomationsPost\":\n                self._log_header_callback(\"Process Browser Automations (post)\")\n                self.process_browser_automations(\n                    browser_automations=self._browser_automations_post,\n                    section_name=\"browserAutomationsPost\",\n                )\n            case _:\n                logger.error(\n                    \"Illegal payload section name -&gt; %s in payloadSections!\",\n                    payload_section[\"name\"],\n                )\n        payload_section_restart = payload_section.get(\"restart\", False)\n        if payload_section_restart:\n            logger.info(\n                \"Payload section -&gt; %s requests a restart of OTCS services...\",\n                payload_section[\"name\"],\n            )\n            # Restart OTCS frontend and backend pods:\n            self._otcs_restart_callback(self._otcs_backend)\n        else:\n            logger.info(\n                \"Payload section -&gt; %s does not require a restart of OTCS services\",\n                payload_section[\"name\"],\n            )\n\n    if self._users:\n        self._log_header_callback(\"Process User Profile Photos\")\n        self.process_user_photos()\n        if self._m365 and isinstance(self._m365, M365):\n            self._log_header_callback(\"Process M365 User Profile Photos\")\n            self.process_user_photos_m365()\n        self._log_header_callback(\"Process User Favorites and Profiles\")\n        self.process_user_favorites_and_profiles()\n        self._log_header_callback(\"Process User Security\")\n        self.process_user_security()\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_permissions","title":"<code>process_permissions(permissions, section_name='permissions')</code>","text":"<p>Process items specified in payload and upadate permissions.</p> <p>Parameters:</p> Name Type Description Default <code>permissions</code> <code>list</code> <p>list of items to apply permissions to.          Each list item in the payload is a dict with this structure:             {                 nodeid = \"...\"                 volume = \"...\"                 nickname = \"...\"                 public_access_permissions = [\"see\", \"see_content\", ...]                 owner_permissions = []                 owner_group_permissions = []                 groups = [                 {                     name = \"...\"                     permissions = []                 }                 ]                 users = [                 {                     name = \"...\"                     permissions = []                 }                 ]                 apply_to = 2             }</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"permissionsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'permissions'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_permissions(\n    self, permissions: list, section_name: str = \"permissions\"\n) -&gt; bool:\n    \"\"\"Process items specified in payload and upadate permissions.\n\n    Args:\n        permissions (list): list of items to apply permissions to.\n                     Each list item in the payload is a dict with this structure:\n                        {\n                            nodeid = \"...\"\n                            volume = \"...\"\n                            nickname = \"...\"\n                            public_access_permissions = [\"see\", \"see_content\", ...]\n                            owner_permissions = []\n                            owner_group_permissions = []\n                            groups = [\n                            {\n                                name = \"...\"\n                                permissions = []\n                            }\n                            ]\n                            users = [\n                            {\n                                name = \"...\"\n                                permissions = []\n                            }\n                            ]\n                            apply_to = 2\n                        }\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"permissionsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not permissions:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for permission in permissions:\n        if (\n            not \"path\" in permission\n            and not \"volume\" in permission\n            and not \"nickname\" in permission\n        ):\n            logger.error(\n                \"Item to change permission is not specified (needs path, volume, or nickname). Skipping...\"\n            )\n            success = False\n            continue\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in permission and not permission[\"enabled\"]:\n            logger.info(\"Payload for Permission is disabled. Skipping...\")\n            continue\n\n        node_id = 0\n\n        # Check if \"volume\" is in payload and not empty string\n        # we try to get the node ID from the volume type:\n        if \"volume\" in permission and permission[\"volume\"]:\n            volume_type = permission[\"volume\"]\n            logger.info(\n                \"Found volume type -&gt; %s in permission definition. Determine volume ID...\",\n                volume_type,\n            )\n            node = self._otcs.get_volume(volume_type)\n            node_id = self._otcs.get_result_value(node, \"id\")\n            if not node_id:\n                logger.error(\n                    \"Illegal volume -&gt; %s in permission specification. Skipping...\",\n                    volume_type,\n                )\n                success = False\n                continue\n        else:\n            # the following path block requires\n            # a value for the volume - if it is\n            # not specified we take the Enterprise Workspace (141):\n            volume_type = 141\n\n        # Check if \"path\" is in payload and not empty list\n        # (path can be combined with volume so we need to take volume into account):\n        if \"path\" in permission and permission[\"path\"]:\n            path = permission[\"path\"]\n            logger.info(\n                \"Found path -&gt; %s in permission definition. Determine node ID...\",\n                path,\n            )\n            node = self._otcs.get_node_by_volume_and_path(volume_type, path)\n            node_id = self._otcs.get_result_value(node, \"id\")\n            if not node_id:\n                logger.error(\"Path -&gt; %s does not exist. Skipping...\", path)\n                success = False\n                continue\n\n        # Check if \"nickname\" is in payload and not empty string:\n        if \"nickname\" in permission and permission[\"nickname\"]:\n            nickname = permission[\"nickname\"]\n            logger.info(\n                \"Found nickname -&gt; %s in permission definition. Determine node ID...\",\n                nickname,\n            )\n            node = self._otcs.get_node_from_nickname(nickname)\n            node_id = self._otcs.get_result_value(node, \"id\")\n            if not node_id:\n                logger.error(\"Nickname -&gt; {} does not exist. Skipping...\")\n                success = False\n                continue\n\n        # Now we should have a value for node_id:\n        if not node_id:\n            logger.error(\"No node ID found! Skipping permission...\")\n            success = False\n            continue\n\n        node_name = self._otcs.get_result_value(node, \"name\")\n        logger.info(\n            \"Found node -&gt; %s with ID -&gt; %s to apply permission to.\",\n            node_name,\n            node_id,\n        )\n        # write node information back into payload\n        # for better debugging\n        permission[\"node_name\"] = node_name\n        permission[\"node_id\"] = node_id\n\n        if \"apply_to\" in permission:\n            apply_to = permission[\"apply_to\"]\n        else:\n            apply_to = 2  # make item + sub-items the default\n\n        # 1. Process Owner Permissions (list canbe empty!)\n        if \"owner_permissions\" in permission:\n            owner_permissions = permission[\"owner_permissions\"]\n            logger.info(\n                \"Update owner permissions for item -&gt; %s (%s) to -&gt; %s\",\n                node_name,\n                str(node_id),\n                str(owner_permissions),\n            )\n            response = self._otcs.assign_permission(\n                int(node_id), \"owner\", 0, owner_permissions, apply_to\n            )\n            if not response:\n                logger.error(\n                    \"Failed to update owner permissions for item -&gt; %s (%s).\",\n                    node_name,\n                    str(node_id),\n                )\n                success = False\n\n        # 2. Process Owner Group Permissions\n        if \"owner_group_permissions\" in permission:\n            owner_group_permissions = permission[\"owner_group_permissions\"]\n            logger.info(\n                \"Update owner group permissions for item -&gt; %s (%s) to -&gt; %s\",\n                node_name,\n                str(node_id),\n                str(owner_group_permissions),\n            )\n            response = self._otcs.assign_permission(\n                int(node_id), \"group\", 0, owner_group_permissions, apply_to\n            )\n            if not response:\n                logger.error(\n                    \"Failed to update group permissions for item -&gt; %s (%s).\",\n                    node_name,\n                    str(node_id),\n                )\n                success = False\n\n        # 3. Process Public Permissions\n        if \"public_permissions\" in permission:\n            public_permissions = permission[\"public_permissions\"]\n            logger.info(\n                \"Update public permissions for item -&gt; %s (%s) to -&gt; %s\",\n                node_name,\n                str(node_id),\n                str(public_permissions),\n            )\n            response = self._otcs.assign_permission(\n                int(node_id), \"public\", 0, public_permissions, apply_to\n            )\n            if not response:\n                logger.error(\n                    \"Failed to update public permissions for item -&gt; %s (%s).\",\n                    str(node_id),\n                    node_name,\n                )\n                success = False\n                continue\n\n        # 4. Process Assigned User Permissions (if specified and not empty)\n        if \"users\" in permission and permission[\"users\"]:\n            users = permission[\"users\"]\n            for user in users:\n                if not \"name\" in user or not \"permissions\" in user:\n                    logger.error(\n                        \"Missing user name or permissions in user permission specificiation. Cannot set user permissions. Skipping...\"\n                    )\n                    success = False\n                    continue\n                user_name = user[\"name\"]\n                user_permissions = user[\"permissions\"]\n                response = self._otcs.get_user(user_name, True)\n                user_id = self._otcs.get_result_value(response=response, key=\"id\")\n                if not user_id:\n                    logger.error(\n                        \"Cannot find user with name -&gt; %s; cannot set user permissions. Skipping user...\",\n                        user_name,\n                    )\n                    success = False\n                    continue\n                user[\"id\"] = user_id  # write ID back into payload\n\n                logger.info(\n                    \"Update permission of user -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\n                    user_name,\n                    node_name,\n                    str(node_id),\n                    str(user_permissions),\n                )\n                response = self._otcs.assign_permission(\n                    int(node_id), \"custom\", user_id, user_permissions, apply_to\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to update assigned user permissions for item -&gt; %s.\",\n                        node_id,\n                    )\n                    success = False\n\n        # 5. Process Assigned Group Permissions (if specified and not empty)\n        if \"groups\" in permission and permission[\"groups\"]:\n            groups = permission[\"groups\"]\n            for group in groups:\n                if not \"name\" in group or not \"permissions\" in group:\n                    logger.error(\n                        \"Missing group name or permissions in group permission specificiation. Cannot set group permissions. Skipping...\"\n                    )\n                    continue\n                group_name = group[\"name\"]\n                group_permissions = group[\"permissions\"]\n                logger.info(\n                    \"Update permissions of group -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\n                    group_name,\n                    node_name,\n                    str(node_id),\n                    str(group_permissions),\n                )\n                otcs_group = self._otcs.get_group(group_name, True)\n                group_id = self._otcs.get_result_value(otcs_group, \"id\")\n                if not group_id:\n                    logger.error(\n                        \"Cannot find group with name -&gt; %s; cannot set group permissions. Skipping group...\",\n                        group_name,\n                    )\n                    success = False\n                    continue\n                group[\"id\"] = group_id  # write ID back into payload\n                response = self._otcs.assign_permission(\n                    int(node_id), \"custom\", group_id, group_permissions, apply_to\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to update assigned group permissions for item -&gt; %s (%s).\",\n                        node_name,\n                        str(node_id),\n                    )\n                    success = False\n\n    self.write_status_file(success, section_name, permissions)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_records_management_settings","title":"<code>process_records_management_settings(section_name='recordsManagementSettings')</code>","text":"<p>Process Records Management Settings for Extended ECM. The setting files need to be placed in the OTCS file system file via a transport into the Support Asset Volume.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'recordsManagementSettings'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_records_management_settings(\n    self, section_name: str = \"recordsManagementSettings\"\n) -&gt; bool:\n    \"\"\"Process Records Management Settings for Extended ECM.\n    The setting files need to be placed in the OTCS file system file via\n    a transport into the Support Asset Volume.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._records_management_settings:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    if (\n        \"records_management_system_settings\" in self._records_management_settings\n        and self._records_management_settings[\"records_management_system_settings\"]\n        != \"\"\n    ):\n        filename = (\n            self._custom_settings_dir\n            + self._records_management_settings[\n                \"records_management_system_settings\"\n            ]\n        )\n        response = self._otcs.import_records_management_settings(filename)\n        if not response:\n            success = False\n\n    if (\n        \"records_management_codes\" in self._records_management_settings\n        and self._records_management_settings[\"records_management_codes\"] != \"\"\n    ):\n        filename = (\n            self._custom_settings_dir\n            + self._records_management_settings[\"records_management_codes\"]\n        )\n        response = self._otcs.import_records_management_codes(filename)\n        if not response:\n            success = False\n\n    if (\n        \"records_management_rsis\" in self._records_management_settings\n        and self._records_management_settings[\"records_management_rsis\"] != \"\"\n    ):\n        filename = (\n            self._custom_settings_dir\n            + self._records_management_settings[\"records_management_rsis\"]\n        )\n        response = self._otcs.import_records_management_rsis(filename)\n        if not response:\n            success = False\n\n    if (\n        \"physical_objects_system_settings\" in self._records_management_settings\n        and self._records_management_settings[\"physical_objects_system_settings\"]\n        != \"\"\n    ):\n        filename = (\n            self._custom_settings_dir\n            + self._records_management_settings[\"physical_objects_system_settings\"]\n        )\n        response = self._otcs.import_physical_objects_settings(filename)\n        if not response:\n            success = False\n\n    if (\n        \"physical_objects_codes\" in self._records_management_settings\n        and self._records_management_settings[\"physical_objects_codes\"] != \"\"\n    ):\n        filename = (\n            self._custom_settings_dir\n            + self._records_management_settings[\"physical_objects_codes\"]\n        )\n        response = self._otcs.import_physical_objects_codes(filename)\n        if not response:\n            success = False\n\n    if (\n        \"physical_objects_locators\" in self._records_management_settings\n        and self._records_management_settings[\"physical_objects_locators\"] != \"\"\n    ):\n        filename = (\n            self._custom_settings_dir\n            + self._records_management_settings[\"physical_objects_locators\"]\n        )\n        response = self._otcs.import_physical_objects_locators(filename)\n        if not response:\n            success = False\n\n    if (\n        \"security_clearance_codes\" in self._records_management_settings\n        and self._records_management_settings[\"security_clearance_codes\"] != \"\"\n    ):\n        filename = (\n            self._custom_settings_dir\n            + self._records_management_settings[\"security_clearance_codes\"]\n        )\n        response = self._otcs.import_security_clearance_codes(filename)\n        if not response:\n            success = False\n\n    self.write_status_file(success, section_name, self._records_management_settings)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_renamings","title":"<code>process_renamings(section_name='renamings')</code>","text":"<p>Process renamings specified in payload and rename existing Extended ECM items.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'renamings'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_renamings(self, section_name: str = \"renamings\") -&gt; bool:\n    \"\"\"Process renamings specified in payload and rename existing Extended ECM items.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._renamings:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for renaming in self._renamings:\n        if not \"nodeid\" in renaming:\n            if not \"volume\" in renaming:\n                logger.error(\n                    \"Renamings require either a node ID or a volume! Skipping to next renaming...\"\n                )\n                continue\n            # Determine object ID of volume:\n            volume = self._otcs.get_volume(renaming[\"volume\"])\n            node_id = self._otcs.get_result_value(volume, \"id\")\n        else:\n            node_id = renaming[\"nodeid\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in renaming and not renaming[\"enabled\"]:\n            logger.info(\"Payload for Renaming is disabled. Skipping...\")\n            continue\n\n        response = self._otcs.rename_node(\n            int(node_id), renaming[\"name\"], renaming[\"description\"]\n        )\n        if not response:\n            logger.error(\n                \"Failed to rename node ID -&gt; %s to new name -&gt; %s.\",\n                node_id,\n                renaming[\"name\"],\n            )\n            success = False\n\n    self.write_status_file(success, section_name, self._renamings)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_sap_rfcs","title":"<code>process_sap_rfcs(sap_object, section_name='sapRFCs')</code>","text":"<p>Process SAP RFCs in payload and run them in SAP S/4HANA.</p> <p>Parameters:</p> Name Type Description Default <code>sap_object</code> <code>SAP</code> <p>SAP object</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'sapRFCs'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_sap_rfcs(self, sap_object: SAP, section_name: str = \"sapRFCs\") -&gt; bool:\n    \"\"\"Process SAP RFCs in payload and run them in SAP S/4HANA.\n\n    Args:\n        sap_object (SAP): SAP object\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not sap_object:\n        logger.info(\"SAP object is undefined. Cannot call RFCs. Bailing out.\")\n        return False\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for sap_rfc in self._sap_rfcs:\n        rfc_name = sap_rfc[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in sap_rfc and not sap_rfc[\"enabled\"]:\n            logger.info(\n                \"Payload for SAP RFC -&gt; %s is disabled. Skipping...\", rfc_name\n            )\n            continue\n\n        rfc_description = (\n            sap_rfc[\"description\"] if sap_rfc.get(\"description\") else \"\"\n        )\n\n        # be careful to avoid key errors as SAP RFC parameters are optional:\n        rfc_params = sap_rfc[\"parameters\"] if sap_rfc.get(\"parameters\") else {}\n        if rfc_params:\n            logger.info(\n                \"Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\n                rfc_name,\n                rfc_description,\n                rfc_params,\n            )\n        else:\n            logger.info(\n                \"Calling SAP RFC -&gt; %s (%s) without parameters...\",\n                rfc_name,\n                rfc_description,\n            )\n\n        # be careful to avoid key errors as SAP RFC parameters are optional:\n        rfc_call_options = (\n            sap_rfc[\"call_options\"] if sap_rfc.get(\"call_options\") else {}\n        )\n        if rfc_call_options:\n            logger.debug(\"Using call options -&gt; %s ...\", rfc_call_options)\n\n        result = sap_object.call(rfc_name, rfc_call_options, rfc_params)\n        if result is None:\n            logger.error(\"Failed to call SAP RFC -&gt; %s\", rfc_name)\n            success = False\n        elif result.get(\"RESULT\") != \"OK\":\n            logger.error(\n                \"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\n                rfc_name,\n                str(result.get(\"FAILED\")),\n                str(result),\n            )\n            success = False\n        else:\n            logger.info(\n                \"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n            )\n            # Save result for status file content\n            sap_rfc[\"result\"] = result\n\n    self.write_status_file(success, section_name, self._sap_rfcs)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_security_clearances","title":"<code>process_security_clearances(section_name='securityClearances')</code>","text":"<p>Process Security Clearances for Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'securityClearances'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_security_clearances(\n    self, section_name: str = \"securityClearances\"\n) -&gt; bool:\n    \"\"\"Process Security Clearances for Extended ECM.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._security_clearances:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for security_clearance in self._security_clearances:\n        clearance_level = security_clearance.get(\"level\")\n        clearance_name = security_clearance.get(\"name\")\n\n        if \"enabled\" in security_clearance and not security_clearance[\"enabled\"]:\n            logger.info(\n                \"Payload for Security Clearance -&gt; %s is disabled. Skipping...\",\n                clearance_name,\n            )\n            continue\n\n        clearance_description = security_clearance.get(\"description\")\n        if not clearance_description:\n            clearance_description = \"\"\n        if clearance_level and clearance_name:\n            logger.info(\n                \"Creating Security Clearance -&gt; %s : %s\",\n                clearance_level,\n                clearance_name,\n            )\n            self._otcs.run_web_report(\n                \"web_report_security_clearance\", security_clearance\n            )\n        else:\n            logger.error(\n                \"Cannot create Security Clearance - either level or name is missing!\"\n            )\n            success = False\n\n    self.write_status_file(success, section_name, self._security_clearances)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_supplemental_markings","title":"<code>process_supplemental_markings(section_name='supplementalMarkings')</code>","text":"<p>Process Supplemental Markings for Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'supplementalMarkings'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_supplemental_markings(\n    self, section_name: str = \"supplementalMarkings\"\n) -&gt; bool:\n    \"\"\"Process Supplemental Markings for Extended ECM.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._supplemental_markings:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for supplemental_marking in self._supplemental_markings:\n        code = supplemental_marking.get(\"code\")\n\n        if (\n            \"enabled\" in supplemental_marking\n            and not supplemental_marking[\"enabled\"]\n        ):\n            logger.info(\n                \"Payload for Supplemental Marking -&gt; %s is disabled. Skipping...\",\n                code,\n            )\n            continue\n\n        description = supplemental_marking.get(\"description\")\n        if not description:\n            description = \"\"\n        if code:\n            logger.info(\n                \"Creating Supplemental Marking -&gt; %s : %s\", code, description\n            )\n            self._otcs.run_web_report(\n                \"web_report_supplemental_marking\", supplemental_marking\n            )\n        else:\n            logger.error(\n                \"Cannot create Supplemental Marking - either code or description is missing!\"\n            )\n            success = False\n\n    self.write_status_file(success, section_name, self._supplemental_markings)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_system_attributes","title":"<code>process_system_attributes(section_name='systemAttributes')</code>","text":"<p>Process OTDS system attributes in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'systemAttributes'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_system_attributes(self, section_name: str = \"systemAttributes\") -&gt; bool:\n    \"\"\"Process OTDS system attributes in payload and create them in OTDS.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._system_attributes:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for system_attribute in self._system_attributes:\n        # Check if there's a matching formal parameter defined on the Web Report node:\n        if not system_attribute.get(\"name\"):\n            logger.error(\"OTDS System Attribute needs a name. Skipping...\")\n            success = False\n            continue\n        attribute_name = system_attribute[\"name\"]\n\n        if \"enabled\" in system_attribute and not system_attribute[\"enabled\"]:\n            logger.info(\n                \"Payload for OTDS System Attribute -&gt; %s is disabled. Skipping...\",\n                attribute_name,\n            )\n            continue\n\n        if not system_attribute.get(\"value\"):\n            logger.error(\"OTDS System Attribute needs a value. Skipping...\")\n            continue\n\n        attribute_value = system_attribute[\"value\"]\n        attribute_description = system_attribute.get(\"description\")\n        response = self._otds.add_system_attribute(\n            attribute_name, attribute_value, attribute_description\n        )\n        if response:\n            logger.info(\n                \"Added OTDS system attribute -&gt; %s with value -&gt; %s\",\n                attribute_name,\n                attribute_value,\n            )\n        else:\n            logger.error(\n                \"Failed to add OTDS system attribute -&gt; %s with value -&gt; %s\",\n                attribute_name,\n                attribute_value,\n            )\n            success = False\n\n    self.write_status_file(success, section_name, self._system_attributes)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_teams_m365","title":"<code>process_teams_m365(section_name='teamsM365')</code>","text":"<p>Process groups in payload and create matching Teams in Microsoft 365.    We need to do this after the creation of the M365 users as wie require    Group Owners to create teams.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'teamsM365'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_teams_m365(self, section_name: str = \"teamsM365\") -&gt; bool:\n    \"\"\"Process groups in payload and create matching Teams in Microsoft 365.\n       We need to do this after the creation of the M365 users as wie require\n       Group Owners to create teams.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not isinstance(self._m365, M365):\n        logger.error(\n            \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n            section_name,\n        )\n        return False\n\n    if not self._groups:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for group in self._groups:\n        if not \"name\" in group:\n            logger.error(\"Team needs a name. Skipping...\")\n            success = False\n            continue\n        group_name = group[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in group and not group[\"enabled\"]:\n            logger.info(\n                \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n            )\n            continue\n        if not \"enable_o365\" in group or not group[\"enable_o365\"]:\n            logger.info(\n                \"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\n                group_name,\n            )\n            continue\n\n        # Check if the M365 group does not exist (this should actually never happen at this point)\n        if not \"m365_id\" in group:\n            # The \"m365_id\" value is set by the method process_groups_m365()\n            logger.error(\n                \"No M365 Group exist for group -&gt; %s (M365 Group creation may have failed). Skipping...\",\n                group_name,\n            )\n            success = False\n            continue\n\n        if self._m365.has_team(group_name):\n            logger.info(\n                \"M365 group -&gt; %s already has an MS Team connected. Skipping...\",\n                group_name,\n            )\n            continue\n\n        logger.info(\n            \"Create M365 Team -&gt; %s for existing M365 Group -&gt; %s...\",\n            group_name,\n            group_name,\n        )\n        # Now \"upgrading\" this group to a MS Team:\n        new_team = self._m365.add_team(group_name)\n        if not new_team:\n            success = False\n            continue\n\n    self.write_status_file(success, section_name, self._groups)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_teams_m365_apps","title":"<code>process_teams_m365_apps(section_name='teamsM365Apps', tab_name='Extended ECM')</code>","text":"<p>Process groups in payload and configure Extended ECM Teams Apps    as a tab called \"Extended ECM\".    We need to do this after the transport as we need top level folders    we can point the Extended ECM teams app to.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'teamsM365Apps'</code> <code>tab_name</code> <code>str</code> <p>Name of the Extended ECM tab. Default is \"Extended ECM\".</p> <code>'Extended ECM'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_teams_m365_apps(\n    self, section_name: str = \"teamsM365Apps\", tab_name: str = \"Extended ECM\"\n) -&gt; bool:\n    \"\"\"Process groups in payload and configure Extended ECM Teams Apps\n       as a tab called \"Extended ECM\".\n       We need to do this after the transport as we need top level folders\n       we can point the Extended ECM teams app to.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n        tab_name (str, optional): Name of the Extended ECM tab. Default is \"Extended ECM\".\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not isinstance(self._m365, M365):\n        logger.error(\n            \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n            section_name,\n        )\n        return False\n\n    if not self._groups:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # Determine the ID of the Extended ECM App:\n    app_name = self._m365.config()[\"teamsAppName\"]\n    response = self._m365.get_teams_apps(f\"contains(displayName, '{app_name}')\")\n    # Get the App catalog ID:\n    app_catalog_id = self._m365.get_result_value(response, \"id\", 0)\n    if not app_catalog_id:\n        logger.error(\"M365 App -&gt; %s not found in catalog!\", app_name)\n        return False\n\n    for group in self._groups:\n        if not \"name\" in group:\n            logger.error(\"Team needs a name. Skipping...\")\n            success = False\n            continue\n        group_name = group[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in group and not group[\"enabled\"]:\n            logger.info(\n                \"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n            )\n            continue\n        if not \"enable_o365\" in group or not group[\"enable_o365\"]:\n            logger.info(\n                \"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\n                group_name,\n            )\n            continue\n\n        #\n        # Now we create a tab in the \"General\" channel for the Extended ECM Teams App\n        #\n\n        # 1. Check if the tab is already assigned to the General channel.\n        # This determines if we need to create or update the tab / app:\n        app_name = self._m365.config()[\"teamsAppName\"]\n        response = self._m365.get_team_channel_tabs(\n            team_name=group_name, channel_name=\"General\"\n        )\n        # Check if tab is already there:\n        if self._m365.exist_result_item(response, \"displayName\", tab_name):\n            logger.info(\n                \"M365 Teams app -&gt; %s is already configured for M365 Team -&gt; %s. Updating it with new URLs and IDs...\",\n                app_name,\n                tab_name,\n            )\n            update = True  # update existing tab\n        else:\n            logger.info(\n                \"Add tab -&gt; %s to channel -&gt; General of M365 Team -&gt; %s for app -&gt; %s\",\n                tab_name,\n                group_name,\n                app_name,\n            )\n            update = False  # create new tab\n\n        # 2. Determine the M365 Team ID. If the team is not found then skip:\n        response = self._m365.get_team(group_name)\n        team_id = self._m365.get_result_value(response, \"id\", 0)\n        if not team_id:\n            logger.error(\"M365 Team -&gt; %s not found!\", group_name)\n            success = False\n            continue\n\n        # 3. Install the App for the particular M365 Team (if it is not yet installed):\n        response = self._m365.get_teams_apps_of_team(\n            team_id,\n            f\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n        )\n        if self._m365.exist_result_item(\n            response, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n        ):\n            logger.info(\n                \"App -&gt; %s is already installed for M365 Team -&gt; %s (%s). Trying to upgrade app...\",\n                app_name,\n                group_name,\n                team_id,\n            )\n            response = self._m365.upgrade_teams_app_of_team(team_id, app_name)\n            if not response:\n                logger.error(\n                    \"Failed to upgrade the existing app -&gt; %s for the M365 Team -&gt; %s\",\n                    app_name,\n                    group_name,\n                )\n                success = False\n                continue\n        else:\n            logger.info(\n                \"Install M365 Teams app -&gt; %s for M365 team -&gt; %s\",\n                app_name,\n                group_name,\n            )\n            response = self._m365.assign_teams_app_to_team(\n                team_id=team_id, app_id=app_catalog_id\n            )\n            if not response:\n                logger.error(\n                    \"Failed to install App -&gt; %s (%s) for M365 Team -&gt; %s\",\n                    app_name,\n                    app_catalog_id,\n                    group_name,\n                )\n                success = False\n                continue\n\n        # 4. Create a Tab in the \"General\" channel of the M365 Team:\n        if group_name == \"Innovate\":\n            # Use the Enterprise Workspace for the\n            # top-level group \"Innovate\":\n            node_id = 2000\n        else:\n            # We assume the departmental group names are identical to\n            # top-level folders in the Enterprise volume\n            node = self._otcs.get_node_by_parent_and_name(2000, group_name)\n            node_id = self._otcs.get_result_value(node, \"id\")\n            if not node_id:\n                logger.warning(\n                    \"Cannot find a top-level container for group -&gt; %s. Cannot configure M365 Teams app. Skipping...\",\n                    group_name,\n                )\n                continue\n\n        app_url = (\n            self._otcs_frontend.cs_support_public_url()\n        )  # it is important to use the frontend pod URL here\n        app_url += \"/xecmoffice/teamsapp.html?nodeId=\"\n        app_url += (\n            str(node_id) + \"&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=\"\n        )\n        app_url += self._otcs_frontend.cs_public_url()\n        app_url += \"&amp;appId=\" + app_catalog_id\n\n        if update:\n            # App / Tab exist but needs to be updated with new\n            # IDs for the new deployment of Extended ECM\n            # as the M365 Teams survive between Terrarium deployments:\n\n            logger.info(\n                \"Updating tab -&gt; %s of M365 Team channel -&gt; General for app -&gt; %s (%s) with new URLs and node IDs\",\n                tab_name,\n                app_name,\n                app_catalog_id,\n            )\n\n            response = self._m365.update_teams_app_of_channel(\n                team_name=group_name,\n                channel_name=\"General\",\n                tab_name=tab_name,\n                app_url=app_url,\n                cs_node_id=node_id,\n            )\n        else:\n            # Tab does not exist in \"General\" channel so we\n            # add / configure it freshly:\n\n            logger.info(\n                \"Adding tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\n                tab_name,\n                app_name,\n                app_catalog_id,\n            )\n\n            response = self._m365.add_teams_app_to_channel(\n                team_name=group_name,\n                channel_name=\"General\",\n                app_id=app_catalog_id,\n                tab_name=tab_name,\n                app_url=app_url,\n                cs_node_id=node_id,\n            )\n            if not response:\n                logger.error(\n                    \"Failed to add tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\n                    tab_name,\n                    app_name,\n                    app_catalog_id,\n                )\n\n    self.write_status_file(success, section_name, self._groups)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_transport_packages","title":"<code>process_transport_packages(transport_packages, section_name='transportPackages')</code>","text":"<p>Process transport packages in payload and import them to Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>transport_packages</code> <code>list</code> <p>list of transport packages. As we                        have three different lists (transport,                        content_transport, transport_post) so                        we need a parameter</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"transportPackagesPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'transportPackages'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_transport_packages(\n    self, transport_packages: list, section_name: str = \"transportPackages\"\n) -&gt; bool:\n    \"\"\"Process transport packages in payload and import them to Extended ECM.\n\n    Args:\n        transport_packages (list): list of transport packages. As we\n                                   have three different lists (transport,\n                                   content_transport, transport_post) so\n                                   we need a parameter\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"transportPackagesPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not transport_packages:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for transport_package in transport_packages:\n        if not \"name\" in transport_package:\n            logger.error(\n                \"Transport Package needs a name! Skipping to next transport...\"\n            )\n            success = False\n            continue\n        name = transport_package[\"name\"]\n\n        if \"enabled\" in transport_package and not transport_package[\"enabled\"]:\n            logger.info(\n                \"Payload for Transport Package -&gt; %s is disabled. Skipping...\", name\n            )\n            continue\n\n        if not \"url\" in transport_package:\n            logger.error(\n                \"Transport Package -&gt; %s needs a URL! Skipping to next transport...\",\n                name,\n            )\n            success = False\n            continue\n        if not \"description\" in transport_package:\n            logger.warning(\"Transport Package -&gt; %s is missing a description\", name)\n        url = transport_package[\"url\"]\n        description = transport_package[\"description\"]\n\n        # For some transports there can be string replacements\n        # configured:\n        if \"replacements\" in transport_package:\n            replacements = transport_package[\"replacements\"]\n        else:\n            replacements = None\n\n        # For some transports there can be data extractions\n        # configured:\n        if \"extractions\" in transport_package:\n            extractions = transport_package[\"extractions\"]\n        else:\n            extractions = None\n\n        logger.info(\"Deploy transport -&gt; %s; URL -&gt; %s\", description, url)\n        if replacements:\n            logger.info(\"Use replacements -&gt; %s\", str(replacements))\n        if extractions:\n            logger.info(\"Use extractions -&gt; %s\", str(extractions))\n\n        response = self._otcs.deploy_transport(\n            url, name, description, replacements, extractions\n        )\n        if response is None:\n            logger.error(\"Failed to deploy transport -&gt; %s; URL -&gt; %s\", name, url)\n            success = False\n            if self._stop_on_error:\n                break\n        else:\n            logger.info(\"Successfully deployed transport -&gt; %s\", name)\n            # Save the extractions for later processing, e.g. in process_business_object_types()\n            if extractions:\n                self.add_transport_extractions(extractions)\n\n    self.write_status_file(success, section_name, transport_packages)\n    self.write_status_file(\n        success, section_name + \"Extractions\", self._transport_extractions\n    )\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_trusted_sites","title":"<code>process_trusted_sites(section_name='trustedSites')</code>","text":"<p>Process OTDS trusted sites in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'trustedSites'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_trusted_sites(self, section_name: str = \"trustedSites\") -&gt; bool:\n    \"\"\"Process OTDS trusted sites in payload and create them in OTDS.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._trusted_sites:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for trusted_site in self._trusted_sites:\n        # old payload may still have trusted sites as list of string\n        # we changed also the trusted sites to dict with 23.3\n        # We want to be backwards compatible so we handle both cases:\n        if isinstance(trusted_site, dict):\n            url = trusted_site.get(\"url\")\n        elif isinstance(trusted_site, str):\n            url = trusted_site\n        if not url:\n            logger.error(\"OTDS Trusted site does not have a URL. Skipping...\")\n            success = False\n            continue\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if (\n            isinstance(trusted_site, dict)\n            and \"enabled\" in trusted_site\n            and not trusted_site[\"enabled\"]\n        ):\n            logger.info(\n                \"Payload for OTDS Trusted Site -&gt; %s is disabled. Skipping...\",\n                url,\n            )\n            continue\n\n        response = self._otds.add_trusted_site(url)\n        if response:\n            logger.info(\"Added OTDS trusted site -&gt; %s\", trusted_site)\n        else:\n            logger.error(\"Failed to add trusted site -&gt; %s\", trusted_site)\n            success = False\n\n    self.write_status_file(success, section_name, self._trusted_sites)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_favorites_and_profiles","title":"<code>process_user_favorites_and_profiles(section_name='userFavoritesAndProfiles')</code>","text":"<p>Process user favorites in payload and create them in Extended ECM.    This method also simulates browsing the favorites to populate the    widgets on the landing pages and sets personal preferences.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userFavoritesAndProfiles'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_favorites_and_profiles(\n    self, section_name: str = \"userFavoritesAndProfiles\"\n) -&gt; bool:\n    \"\"\"Process user favorites in payload and create them in Extended ECM.\n       This method also simulates browsing the favorites to populate the\n       widgets on the landing pages and sets personal preferences.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # We can only set favorites if we impersonate / authenticate as the user.\n    # The following code (for loop) will change the authenticated user - we need to\n    # switch it back to admin user later so we safe the admin credentials for this:\n\n    if self._users:\n        # save admin credentials for later switch back to admin user:\n        admin_credentials = self._otcs.credentials()\n    else:\n        admin_credentials = {}\n\n    for user in self._users:\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        user_password = user[\"password\"]\n\n        # we change the otcs credentials to the user:\n        self._otcs.set_credentials(user_name, user_password)\n\n        # we re-authenticate as the user:\n        logger.info(\"Authenticate user -&gt; %s...\", user_name)\n        # True = force new login with new user\n        cookie = self._otcs.authenticate(revalidate=True)\n        if not cookie:\n            logger.error(\"Couldn't authenticate user -&gt; %s\", user_name)\n            success = False\n            continue\n\n        # we update the user profile to activate responsive (dynamic) containers:\n        response = self._otcs.update_user_profile(\n            field=\"responsiveContainerMode\",\n            value=True,\n            config_section=\"SmartUI\",\n        )\n        if response is None:\n            logger.warning(\n                \"Profile for user -&gt; %s couldn't be updated with responsive container mode'!\",\n                user_name,\n            )\n        else:\n            logger.info(\n                \"Profile for user -&gt; %s has been updated to enable responsive container mode.\",\n                user_name,\n            )\n        response = self._otcs.update_user_profile(\n            field=\"responsiveContainerMessageMode\",\n            value=True,\n            config_section=\"SmartUI\",\n        )\n        if response is None:\n            logger.warning(\n                \"Profile for user -&gt; %s couldn't be updated with responsive container message mode'!\",\n                user_name,\n            )\n        else:\n            logger.info(\n                \"Profile for user -&gt; %s has been updated to enable messages for responsive container mode.\",\n                user_name,\n            )\n\n        # we work through the list of favorites defined for the user:\n        favorites = user[\"favorites\"]\n        for favorite in favorites:\n            # check if favorite is a logical workspace name\n            favorite_item = next(\n                (item for item in self._workspaces if item[\"id\"] == favorite), None\n            )\n            is_workspace = False\n            if favorite_item:\n                logger.info(\n                    \"Found favorite item (workspace) in payload -&gt; %s\",\n                    favorite_item[\"name\"],\n                )\n                favorite_id = self.determine_workspace_id(favorite_item)\n                if not favorite_id:\n                    logger.warning(\n                        \"Workspace of type -&gt; %s and name -&gt; %s does not exist. Cannot create favorite. Skipping...\",\n                        favorite_item[\"type_name\"],\n                        favorite_item[\"name\"],\n                    )\n                    continue\n\n                is_workspace = True\n            else:\n                # alternatively try to find the item as a nickname:\n                favorite_item = self._otcs.get_node_from_nickname(favorite)\n                favorite_id = self._otcs.get_result_value(favorite_item, \"id\")\n                #                    if favorite_item is None:\n                if favorite_id is None:\n                    logger.warning(\n                        \"Favorite -&gt; %s neither found as workspace ID nor as nickname. Skipping to next favorite...\",\n                        favorite,\n                    )\n                    continue\n\n            response = self._otcs.add_favorite(favorite_id)\n            if response is None:\n                logger.warning(\n                    \"Favorite ID -&gt; %s couldn't be added for user -&gt; %s!\",\n                    favorite_id,\n                    user_name,\n                )\n            else:\n                logger.info(\n                    \"Added favorite for user -&gt; %s, node ID -&gt; %s.\",\n                    user_name,\n                    favorite_id,\n                )\n                logger.info(\n                    \"Simulate user -&gt; %s browsing node ID -&gt; %s.\",\n                    user_name,\n                    favorite_id,\n                )\n                # simulate a browse by the user to populate recently accessed items\n                if is_workspace:\n                    response = self._otcs.get_workspace(favorite_id)\n                else:\n                    response = self._otcs.get_node(favorite_id)\n\n        # we work through the list of proxies defined for the user\n        # (we need to consider that not all users have the proxies element):\n        proxies = user[\"proxies\"] if user.get(\"proxies\") else []\n\n        for proxy in proxies:\n            proxy_user = next(\n                (item for item in self._users if item[\"name\"] == proxy),\n                None,\n            )\n            if not proxy_user or not \"id\" in proxy_user:\n                logger.error(\n                    \"The proxy -&gt; %s for user -&gt; %s does not exist! Skipping proxy...\",\n                    proxy,\n                    user_name,\n                )\n                success = False\n                continue\n            proxy_user_id = proxy_user[\"id\"]\n\n            # Check if the proxy is already set:\n            if not self._otcs.is_proxy(proxy):\n                logger.info(\n                    \"Set user -&gt; %s (%s) as proxy for user -&gt; %s.\",\n                    proxy,\n                    proxy_user_id,\n                    user_name,\n                )\n                # set the user proxy - currently we don't support time based proxies in payload.\n                # The called method is ready to support this.\n                response = self._otcs.add_user_proxy(proxy_user_id)\n            else:\n                logger.info(\n                    \"User -&gt; %s (%s) is already proxy for user -&gt; %s. Skipping...\",\n                    proxy,\n                    proxy_user_id,\n                    user_name,\n                )\n    if self._users:\n        # Set back admin credentials:\n        self._otcs.set_credentials(\n            admin_credentials[\"username\"], admin_credentials[\"password\"]\n        )\n\n        # we re-authenticate as the admin user:\n        logger.info(\n            \"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n        )\n        # True = force new login with new user\n        cookie = self._otcs.authenticate(revalidate=True)\n\n    # Also for the admin user we want to update the user profile to activate responsive (dynamic) containers:\n    response = self._otcs.update_user_profile(\n        field=\"responsiveContainerMode\",\n        value=True,\n        config_section=\"SmartUI\",\n    )\n    if response is None:\n        logger.warning(\n            \"Profile for admin user couldn't be updated with responsive container mode'!\",\n        )\n    else:\n        logger.info(\n            \"Profile for admin user has been updated to enable responsive container mode.\",\n        )\n    response = self._otcs.update_user_profile(\n        field=\"responsiveContainerMessageMode\",\n        value=True,\n        config_section=\"SmartUI\",\n    )\n    if response is None:\n        logger.warning(\n            \"Profile for admin user couldn't be updated with responsive container message mode'!\",\n        )\n    else:\n        logger.info(\n            \"Profile for admin user has been updated to enable messages for responsive container mode.\",\n        )\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_licenses","title":"<code>process_user_licenses(resource_name, license_feature, license_name, user_specific_payload_field='licenses', section_name='userLicenses')</code>","text":"<p>Assign a specific OTDS license feature to all Extended ECM users.    This method is used for OTIV and Extended ECM licenses.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>name of the OTDS resource</p> required <code>license_feature</code> <code>str</code> <p>license feature to assign to the user (product specific)</p> required <code>license_name</code> <code>str</code> <p>Name of the license Key (e.g. \"EXTENDED_ECM\" or \"INTELLIGENT_VIEWING\")</p> required <code>user_specific_payload_field</code> <code>str</code> <p>name of the user specific field in payload                                          (if empty it will be ignored)</p> <code>'licenses'</code> <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userLicenses'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_licenses(\n    self,\n    resource_name: str,\n    license_feature: str,\n    license_name: str,\n    user_specific_payload_field: str = \"licenses\",\n    section_name: str = \"userLicenses\",\n) -&gt; bool:\n    \"\"\"Assign a specific OTDS license feature to all Extended ECM users.\n       This method is used for OTIV and Extended ECM licenses.\n\n    Args:\n        resource_name (str): name of the OTDS resource\n        license_feature (str): license feature to assign to the user (product specific)\n        license_name (str): Name of the license Key (e.g. \"EXTENDED_ECM\" or \"INTELLIGENT_VIEWING\")\n        user_specific_payload_field (str, optional): name of the user specific field in payload\n                                                     (if empty it will be ignored)\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    otds_resource = self._otds.get_resource(resource_name)\n    if not otds_resource:\n        logger.error(\n            \"OTDS Resource -&gt; {} not found. Cannot assign licenses to users.\"\n        )\n        return False\n\n    user_partition = self._otcs.config()[\"partition\"]\n    if not user_partition:\n        logger.error(\"OTCS user partition not found in OTDS!\")\n        return False\n\n    for user in self._users:\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        if user_specific_payload_field and user_specific_payload_field in user:\n            logger.info(\n                \"Found specific license feature -&gt; %s for User -&gt; %s. Overwriting default license feature -&gt; %s\",\n                user[user_specific_payload_field],\n                user_name,\n                license_feature,\n            )\n            user_license_feature = user[user_specific_payload_field]\n        else:  # use the default feature from the actual parameter\n            user_license_feature = [license_feature]\n\n        for license_feature in user_license_feature:\n            if self._otds.is_user_licensed(\n                user_name=user_name,\n                resource_id=otds_resource[\"resourceID\"],\n                license_feature=license_feature,\n                license_name=license_name,\n            ):\n                logger.info(\n                    \"User -&gt; %s is already licensed for -&gt; %s (%s)\",\n                    user_name,\n                    license_name,\n                    license_feature,\n                )\n                continue\n            assigned_license = self._otds.assign_user_to_license(\n                user_partition,\n                user_name,  # we want the plain login name here\n                otds_resource[\"resourceID\"],\n                license_feature,\n                license_name,\n            )\n\n            if not assigned_license:\n                logger.error(\n                    \"Failed to assign license feature -&gt; %s to user -&gt; %s!\",\n                    license_feature,\n                    user_name,\n                )\n                success = False\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_photos","title":"<code>process_user_photos(section_name='userPhotos')</code>","text":"<p>Process user photos in payload and assign them to Extended ECM users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userPhotos'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_photos(self, section_name: str = \"userPhotos\") -&gt; bool:\n    \"\"\"Process user photos in payload and assign them to Extended ECM users.\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # we assume the nickname of the photo item equals the login name of the user\n    # we also assume that the photos have been uploaded / transported into the target system\n    for user in self._users:\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        if not \"id\" in user:\n            logger.error(\n                \"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\n                user_name,\n            )\n            success = False\n            continue\n\n        user_id = user[\"id\"]\n\n        response = self._otcs.get_node_from_nickname(user_name)\n        if response is None:\n            logger.warning(\n                \"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\n                user_name,\n            )\n            continue\n        photo_id = self._otcs.get_result_value(response, \"id\")\n        response = self._otcs.update_user_photo(user_id, photo_id)\n        if not response:\n            logger.error(\"Failed to add photo for user -&gt; %s\", user_name)\n            success = False\n        else:\n            logger.info(\"Successfully added photo for user -&gt; %s\", user_name)\n\n    # Check if Admin has a photo as well (nickname needs to be \"admin\"):\n    response = self._otcs.get_node_from_nickname(\"admin\")\n    if response is None:\n        logger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\n    else:\n        photo_id = self._otcs.get_result_value(response, \"id\")\n        response = self._otcs.update_user_photo(1000, photo_id)\n        if response is None:\n            logger.warning(\"Failed to add photo for admin\")\n        else:\n            logger.info(\"Successfully added photo for admin\")\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_photos_m365","title":"<code>process_user_photos_m365(section_name='userPhotosM365')</code>","text":"<p>Process user photos in payload and assign them to Microsoft 365 users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userPhotosM365'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_photos_m365(self, section_name: str = \"userPhotosM365\") -&gt; bool:\n    \"\"\"Process user photos in payload and assign them to Microsoft 365 users.\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not isinstance(self._m365, M365):\n        logger.error(\n            \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n            section_name,\n        )\n        return False\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # we assume the nickname of the photo item equals the login name of the user\n    # we also assume that the photos have been uploaded / transported into the target system\n    for user in self._users:\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        if not \"id\" in user:\n            logger.error(\n                \"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\n                user_name,\n            )\n            success = False\n            continue\n\n        if not \"enable_o365\" in user or not user[\"enable_o365\"]:\n            logger.info(\n                \"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\n                user_name,\n            )\n            continue\n\n        # If the customizer pod is restarted it may be that\n        # the M365 user exists even if the M365 user ID is\n        # not yet written back into the payload. So we use the\n        # determine_user_id_m365() method that handles both cases\n        # and updates the payload if the user exists in M365 already.\n        user_m365_id = self.determine_user_id_m365(user)\n        if not user_m365_id:\n            logger.error(\"M365 user -&gt; %s does not exist. Skipping...\", user_name)\n            success = False\n            continue\n\n        if self._m365.get_user_photo(user_m365_id, show_error=False):\n            logger.info(\n                \"User -&gt; %s (%s) has already a photo in Microsoft 365. Skipping...\",\n                user_name,\n                user_m365_id,\n            )\n            continue\n        else:\n            logger.info(\n                \"User -&gt; %s (%s) has not yet a photo in Microsoft 365. Uploading...\",\n                user_name,\n                user_m365_id,\n            )\n\n        response = self._otcs.get_node_from_nickname(user_name)\n        if response is None:\n            logger.warning(\n                \"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\n                user_name,\n            )\n            continue\n        photo_id = self._otcs.get_result_value(response, \"id\")\n        photo_name = self._otcs.get_result_value(response, \"name\")\n        photo_path = \"/tmp/\" + str(photo_name)\n        response = self._otcs.download_document(photo_id, photo_path)\n        if response is None:\n            logger.warning(\n                \"Failed to download photo for user -&gt; %s from Extended ECM\",\n                user_name,\n            )\n            success = False\n            continue\n        else:\n            logger.info(\n                \"Successfully downloaded photo for user -&gt; %s from Extended ECM to file -&gt; %s\",\n                user_name,\n                photo_path,\n            )\n\n        # Upload photo to M365:\n        response = self._m365.update_user_photo(user_m365_id, photo_path)\n        if response is None:\n            logger.error(\n                \"Failed to upload photo for user -&gt; %s to Microsoft 365\", user_name\n            )\n            success = False\n        else:\n            logger.info(\n                \"Successfully uploaded photo for user -&gt; %s to Microsoft 365\",\n                user_name,\n            )\n\n    # Check if Admin has a photo as well (nickname needs to be \"admin\")\n    # Then we want this to be applied in M365 as well:\n    response = self._otcs.get_node_from_nickname(\"admin\")\n    if response is None:\n        logger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\n    else:\n        photo_id = self._otcs.get_result_value(response, \"id\")\n        photo_name = self._otcs.get_result_value(response, \"name\")\n        photo_path = \"/tmp/\" + str(photo_name)\n        response = self._otcs.download_document(photo_id, photo_path)\n        if response is None:\n            logger.warning(\n                \"Failed to download photo for admin user from Extended ECM\",\n            )\n            success = False\n        else:\n            logger.info(\n                \"Successfully downloaded photo for admin from Extended ECM to file -&gt; %s\",\n                photo_path,\n            )\n            m365_admin_email = \"admin@\" + self._m365.config()[\"domain\"]\n            response = self._m365.update_user_photo(m365_admin_email, photo_path)\n            if response is None:\n                logger.warning(\"Failed to add photo for %s\", m365_admin_email)\n            else:\n                logger.info(\"Successfully added photo for %s\", m365_admin_email)\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_placeholders","title":"<code>process_user_placeholders()</code>","text":"<p>For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%) with the actual ID of the Extended ECM user. For this we prepare a lookup dict. The dict self._placeholder_values already includes lookups for the OTCS and OTAWP OTDS resource IDs (see customizer.py)</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_placeholders(self):\n    \"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n    with the actual ID of the Extended ECM user. For this we prepare a lookup dict.\n    The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n    OTDS resource IDs (see customizer.py)\n    \"\"\"\n\n    for user in self._users:\n        if not \"name\" in user:\n            logger.error(\n                \"User needs a name for placeholder definition. Skipping...\"\n            )\n            continue\n        user_name = user[\"name\"]\n        # Check if user has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        # Now we determine the ID. Either it is in the payload section from\n        # the current customizer run or we try to look it up in the system.\n        # The latter case may happen if the customizer pod got restarted.\n        user_id = self.determine_user_id(user)\n        if not user_id:\n            logger.warning(\n                \"User needs an ID for placeholder definition. Skipping...\"\n            )\n            continue\n\n        # Add user with its ID to the dict self._placeholder_values:\n        self._placeholder_values[\"OTCS_USER_ID_%s\", user_name.upper()] = str(\n            user_id\n        )\n\n    logger.debug(\n        \"Placeholder values after user processing = %s\", self._placeholder_values\n    )\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_security","title":"<code>process_user_security(section_name='userSecurity')</code>","text":"<p>Process Security Clearance and Supplemental Markings for Extended ECM users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userSecurity'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_security(self, section_name: str = \"userSecurity\"):\n    \"\"\"Process Security Clearance and Supplemental Markings for Extended ECM users.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for user in self._users:\n        user_id = user.get(\"id\")\n        user_name = user.get(\"name\")\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        # Read security clearance from user payload (it is optional!)\n        user_security_clearance = user.get(\"security_clearance\")\n        if user_id and user_security_clearance:\n            self._otcs.assign_user_security_clearance(\n                user_id, user_security_clearance\n            )\n\n        # Read supplemental markings from user payload (it is optional!)\n        user_supplemental_markings = user.get(\"supplemental_markings\")\n        if user_id and user_supplemental_markings:\n            self._otcs.assign_user_supplemental_markings(\n                user_id, user_supplemental_markings\n            )\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_settings","title":"<code>process_user_settings(section_name='userSettings')</code>","text":"<p>Process user settings in payload and apply themin OTDS.    This includes password settings and user display settings.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userSettings'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_settings(self, section_name: str = \"userSettings\") -&gt; bool:\n    \"\"\"Process user settings in payload and apply themin OTDS.\n       This includes password settings and user display settings.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for user in self._users:\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        user_partition = self._otcs.config()[\"partition\"]\n        if not user_partition:\n            logger.error(\"User partition not found!\")\n            success = False\n            continue\n\n        # Set the OTDS display name. Extended ECM does not use this but\n        # it makes AppWorks display users correctly (and it doesn't hurt)\n        # We only set this if firstname _and_ last name are in the payload:\n        if \"firstname\" in user and \"lastname\" in user:\n            user_display_name = user[\"firstname\"] + \" \" + user[\"lastname\"]\n            response = self._otds.update_user(\n                user_partition, user_name, \"displayName\", user_display_name\n            )\n            if response:\n                logger.info(\n                    \"Display name for user -&gt; %s has been updated to -&gt; %s\",\n                    user_name,\n                    user_display_name,\n                )\n            else:\n                logger.error(\n                    \"Display name for user -&gt; %s could not be updated to -&gt; %s\",\n                    user_name,\n                    user_display_name,\n                )\n                success = False\n\n        # Don't enforce the user to reset password at first login (settings in OTDS):\n        logger.info(\"Don't enforce password change for user -&gt; %s...\", user_name)\n        response = self._otds.update_user(\n            user_partition, user_name, \"UserMustChangePasswordAtNextSignIn\", \"False\"\n        )\n        if not response:\n            success = False\n\n        response = self._otds.update_user(\n            user_partition, user_name, \"UserCannotChangePassword\", \"True\"\n        )\n        if not response:\n            success = False\n\n        # Set user password to never expire\n        response = self._otds.update_user(\n            user_partition, user_name, \"PasswordNeverExpires\", \"True\"\n        )\n        if not response:\n            success = False\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_users","title":"<code>process_users(section_name='users')</code>","text":"<p>Process users in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'users'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise Side Effects:     the user items are modified by adding an \"id\" dict element that     includes the technical ID of the user in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_users(self, section_name: str = \"users\") -&gt; bool:\n    \"\"\"Process users in payload and create them in Extended ECM.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        the user items are modified by adding an \"id\" dict element that\n        includes the technical ID of the user in Extended ECM\n    \"\"\"\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    #        if self.check_status_file(section_name):\n    #            return True\n\n    success: bool = True\n\n    # Add all users in payload and establish membership in\n    # specified groups:\n    for user in self._users:\n        # Sanity checks:\n        if not \"name\" in user:\n            logger.error(\"User is missing a login. Skipping to next user...\")\n            success = False\n            continue\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        # Sanity checks:\n        if (\n            not \"password\" in user\n            or user[\"password\"] is None\n            or user[\"password\"] == \"\"\n        ):\n            logger.info(\n                \"User -&gt; %s no password defined in payload, generating random password...\",\n                user_name,\n            )\n            user[\"password\"] = self.generate_password(\n                length=10, use_special_chars=True\n            )\n\n            description_attribue = {\n                \"name\": \"description\",\n                \"value\": \"initial password: \" + user[\"password\"],\n            }\n\n            try:\n                user[\"extra_attributes\"].append(description_attribue)\n            except KeyError:\n                user[\"extra_attributes\"] = [description_attribue]\n\n        # Sanity checks:\n        if not \"base_group\" in user:\n            logger.warning(\n                \"User -&gt; %s is missing a base group - setting to default group\",\n                user_name,\n            )\n            user[\"base_group\"] = \"DefaultGroup\"\n\n        # Check if the user does already exist (e.g. if job is restarted)\n        # determine_user_id() also writes back the user ID into the payload\n        # if it has gathered it from OTCS.\n        user_id = self.determine_user_id(user)\n        if user_id:\n            logger.info(\n                \"Found existing user -&gt; %s (%s). Skipping to next user...\",\n                user_name,\n                user_id,\n            )\n            continue\n        logger.info(\"Did not find an existing user - creating a new user...\")\n\n        # Find the base group of the user. Assume 'Default Group' (= 1001) if not found:\n        base_group = next(\n            (\n                item[\"id\"]\n                for item in self._groups\n                if item[\"name\"] == user[\"base_group\"] and item.get(\"id\")\n            ),\n            1001,\n        )\n\n        # Now we know it is a new user...\n        new_user = self._otcs.add_user(\n            name=user_name,\n            password=user[\"password\"],\n            first_name=user.get(\"firstname\", \"\"),  # be careful - can be empty\n            last_name=user.get(\"lastname\", \"\"),  # be careful - can be empty\n            email=user.get(\"email\", \"\"),  # be careful - can be empty\n            title=user.get(\"title\", \"\"),  # be careful - can be empty\n            base_group=base_group,\n            privileges=user.get(\"privileges\", [\"Login\", \"Public Access\"]),\n        )\n\n        # Process group memberships of new user:\n        if new_user is not None:\n            new_user_id = self._otcs.get_result_value(new_user, \"id\")\n            logger.info(\n                \"New user -&gt; %s with ID -&gt; %s has been created\",\n                user_name,\n                new_user_id,\n            )\n            # Write back user ID into payload\n            user[\"id\"] = new_user_id\n\n            user_groups = user[\"groups\"]  # list of groups the user is in\n            for user_group in user_groups:\n                # Try to find the group dictionary item in the payload\n                # for user group name:\n                group = next(\n                    (item for item in self._groups if item[\"name\"] == user_group),\n                    None,\n                )\n                if group:\n                    group_id = group.get(\"id\")  # Careful ID may not exist\n                    group_name = group[\"name\"]\n                else:\n                    # if group is not in payload try to find group in OTCS\n                    # in case it is a pre-existing group:\n                    group = self._otcs.get_group(user_group)\n                    group_id = self._otcs.get_result_value(group, \"id\")\n                    if group_id is None:\n                        logger.error(\n                            \"Group -&gt; %s not found. Skipping...\", user_group\n                        )\n                        success = False\n                        continue\n                    group_name = self._otcs.get_result_value(group, \"name\")\n\n                if group_id is None:\n                    logger.error(\n                        \"Group -&gt; %s does not have an ID. Cannot add user -&gt; %s to this group. Skipping...\",\n                        group_name,\n                        user[\"name\"],\n                    )\n                    success = False\n                    continue\n\n                logger.info(\n                    \"Add user -&gt; %s (%s) to group -&gt; %s (%s)\",\n                    user[\"name\"],\n                    user[\"id\"],\n                    group_name,\n                    group_id,\n                )\n                response = self._otcs.add_group_member(user[\"id\"], group_id)\n                if not response:\n                    success = False\n            # for some unclear reason the user is not added to its base group in OTDS\n            # so we do this explicitly:\n            response = self._otds.add_user_to_group(\n                user[\"name\"], user[\"base_group\"]\n            )\n            if not response:\n                success = False\n\n            # Extra OTDS attributes for the user can be provided in \"extra_attributes\"\n            # as part of the user payload.\n            if \"extra_attributes\" in user:\n                extra_attributes = user[\"extra_attributes\"]\n                for extra_attribute in extra_attributes:\n                    attribute_name = extra_attribute.get(\"name\")\n                    attribute_value = extra_attribute.get(\"value\")\n                    if not attribute_name or not attribute_value:\n                        logger.error(\n                            \"User attribute is missing a name or value. Skipping...\"\n                        )\n                        success = False\n                        continue\n                    logger.info(\n                        \"Set user attribute -&gt; %s to -&gt; %s\",\n                        attribute_name,\n                        attribute_value,\n                    )\n                    user_partition = self._otcs.config()[\"partition\"]\n                    if not user_partition:\n                        logger.error(\"User partition not found!\")\n                        success = False\n                        continue\n                    self._otds.update_user(\n                        user_partition,\n                        user[\"name\"],\n                        attribute_name,\n                        attribute_value,\n                    )\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_users_m365","title":"<code>process_users_m365(section_name='usersM365')</code>","text":"<p>Process users in payload and create them in Microsoft 365 via MS Graph API.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'usersM365'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_users_m365(self, section_name: str = \"usersM365\") -&gt; bool:\n    \"\"\"Process users in payload and create them in Microsoft 365 via MS Graph API.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not isinstance(self._m365, M365):\n        logger.error(\n            \"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\n            section_name,\n        )\n        return False\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    # Add all users in payload and establish membership in\n    # specified groups:\n    for user in self._users:\n        # Sanity checks:\n        if not \"name\" in user:\n            logger.error(\"User is missing a login. Skipping to next user...\")\n            success = False\n            continue\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n        if not \"enable_o365\" in user or not user[\"enable_o365\"]:\n            logger.info(\n                \"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\n                user_name,\n            )\n            continue\n\n        # Sanity checks:\n        if not \"password\" in user:\n            logger.error(\n                \"User -&gt; %s is missing a password. Skipping to next user...\",\n                user_name,\n            )\n            success = False\n            continue\n        user_password = user[\"password\"]\n        # be careful with the following fields - they could be empty\n        user_department = user.get(\"base_group\", \"\")\n        user_first_name = user.get(\"firstname\", \"\")\n        user_last_name = user.get(\"lastname\", \"\")\n        user_location = user.get(\"location\", \"US\")\n        user_email = user.get(\"email\", user_name)\n\n        # Check if the user does already exist in M365 (e.g. if job is restarted)\n        m365_user_id = self.determine_user_id_m365(user)\n        if not m365_user_id:\n            logger.info(\n                \"Did not find existing Micosoft 365 user - creating user %s...\",\n                user_email,\n            )\n\n            # Now we know it is a new user...\n            new_user = self._m365.add_user(\n                email=user_email,\n                password=user_password,\n                first_name=user_first_name,\n                last_name=user_last_name,\n                location=user_location,\n                department=user_department,\n            )\n            if new_user is not None:\n                # Store the Microsoft 365 user ID in payload:\n                user[\"m365_id\"] = new_user[\"id\"]\n                logger.info(\n                    \"New Microsoft 365 user -&gt; %s with ID -&gt; %s has been created\",\n                    user_name,\n                    user[\"m365_id\"],\n                )\n            else:\n                logger.error(\n                    \"Failed to create new Microsoft 365 user -&gt; %s. Skipping...\",\n                    user_name,\n                )\n                success = False\n                continue\n\n        # Now we assign a license to the new M365 user.\n        # First we see if there's a M365 SKU list in user\n        # payload - if not we wrap the default SKU configured\n        # for the m365 object into a single item list:\n        existing_user_licenses = self._m365.get_user_licenses(user[\"m365_id\"])\n        sku_list = user.get(\"m365_skus\", [self._m365.config()[\"skuId\"]])\n        for sku_id in sku_list:\n            # Check if the M365 user already has this license:\n            if not self._m365.exist_result_item(\n                existing_user_licenses, \"skuId\", sku_id\n            ):\n                response = self._m365.assign_license_to_user(\n                    user[\"m365_id\"], sku_id\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to assign license -&gt; %s to Microsoft 365 user -&gt; %s\",\n                        sku_id,\n                        user_name,\n                    )\n                    success = False\n                else:\n                    if (\n                        not \"m365_skus\" in user\n                    ):  # this is only True if the default license from the m365 object is taken\n                        user[\"m365_skus\"] = [sku_id]\n                    logger.info(\n                        \"License -&gt; %s has been assigned to Microsoft 365 user -&gt; %s\",\n                        sku_id,\n                        user_name,\n                    )\n            else:\n                logger.info(\n                    \"Microsoft 365 user -&gt; %s already has the license -&gt; %s\",\n                    user_name,\n                    sku_id,\n                )\n\n        # Now we assign the Extended ECM Teams App to the new M365 user.\n        # First we check if the app is already assigned to the user.\n        # If not we install / assign the app. If the user already has\n        # the Extended ECM app we try to uprade it:\n        app_name = self._m365.config()[\"teamsAppName\"]\n        response = self._m365.get_teams_apps_of_user(\n            user[\"m365_id\"],\n            f\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n        )\n        if self._m365.exist_result_item(\n            response, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n        ):\n            logger.info(\n                \"App -&gt; %s is already installed for M365 user -&gt; %s (%s). Trying to upgrade app...\",\n                app_name,\n                user_name,\n                user[\"m365_id\"],\n            )\n            response = self._m365.upgrade_teams_app_of_user(\n                user[\"m365_id\"], app_name\n            )\n        else:\n            logger.info(\n                \"Install M365 Teams app -&gt; %s for M365 user -&gt; %s\",\n                app_name,\n                user_name,\n            )\n            response = self._m365.assign_teams_app_to_user(\n                user[\"m365_id\"], app_name\n            )\n            if not response:\n                logger.error(\n                    \"Failed to install the App -&gt; %s for M365 user -&gt; %s\",\n                    app_name,\n                    user_name,\n                )\n                success = False\n                continue\n\n        # Process Microsoft 365 group memberships of new user:\n        if \"m365_id\" in user:\n            user_id = user[\"m365_id\"]\n            # don't forget the base group (department) !\n            group_names = user[\"groups\"]\n            if user_department:\n                group_names.append(user_department)\n            logger.info(\n                \"User -&gt; %s has these groups in payload -&gt; %s (including base group -&gt; %s). Checking if they are Microsoft 365 Groups...\",\n                user_name,\n                group_names,\n                user_department,\n            )\n            # Go through all group names:\n            for group_name in group_names:\n                # Find the group payload item to the parent group name:\n                group = next(\n                    (item for item in self._groups if item[\"name\"] == group_name),\n                    None,\n                )\n                if not group:\n                    # if group is not in payload then this membership\n                    # is not relevant for Microsoft 365. This could be system generated\n                    # groups like \"PageEdit\" or \"Business Administrators\".\n                    # In this case we do \"continue\" as we can't process parent groups\n                    # either:\n                    logger.info(\n                        \"No payload found for Group -&gt; %s. Skipping...\", group_name\n                    )\n                    continue\n                elif not \"enable_o365\" in group or not group[\"enable_o365\"]:\n                    # If Microsoft 365 is not enabled for this group in\n                    # the payload we don't create a M365 but we do NOT continue\n                    # as there may still be parent groups that are M365 enabled\n                    # we want to put the user in (see below):\n                    logger.info(\n                        \"Payload Group -&gt; %s is not enabled for M365.\", group_name\n                    )\n                else:\n                    response = self._m365.get_group(group_name)\n                    if (\n                        response is None\n                        or not \"value\" in response\n                        or not response[\"value\"]\n                    ):\n                        logger.error(\n                            \"Microsoft 365 Group -&gt; %s not found. Skipping...\",\n                            group_name,\n                        )\n                        success = False\n                    else:\n                        group_id = response[\"value\"][0][\"id\"]\n\n                        # Check if user is already a member. We don't want\n                        # to throw an error if the user is not found as a member\n                        # so we pass show_error=False:\n                        if self._m365.is_member(\n                            group_id, user_id, show_error=False\n                        ):\n                            logger.info(\n                                \"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\n                                user[\"name\"],\n                                user_id,\n                                group_name,\n                                group_id,\n                            )\n                        else:\n                            logger.info(\n                                \"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\n                                user[\"name\"],\n                                user_id,\n                                group_name,\n                                group_id,\n                            )\n                            response = self._m365.add_group_member(\n                                group_id, user_id\n                            )\n                            if not response:\n                                logger.error(\n                                    \"Failed to add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\n                                    user[\"name\"],\n                                    user_id,\n                                    group_name,\n                                    group_id,\n                                )\n                                success = False\n\n                            # As each group should have at least one owner in M365\n                            # we set all users also as owners for now. Later we\n                            # may want to configure this via payload:\n                            logger.info(\n                                \"Make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\n                                user[\"name\"],\n                                user_id,\n                                group_name,\n                                group_id,\n                            )\n                            response = self._m365.add_group_owner(group_id, user_id)\n                            if not response:\n                                logger.error(\n                                    \"Failed to make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\n                                    user[\"name\"],\n                                    user_id,\n                                    group_name,\n                                    group_id,\n                                )\n                                success = False\n\n                # As M365 groups are flat (not nested) we also add the\n                # user as member to the parent groups of the current group\n                # if the parent group is enabled for M365:\n                parent_group_names = group.get(\"parent_groups\")\n                logger.info(\n                    \"Group -&gt; %s has the following parent groups -&gt; %s\",\n                    group_name,\n                    parent_group_names,\n                )\n                for parent_group_name in parent_group_names:\n                    # Find the group dictionary item to the parent group name:\n                    parent_group = next(\n                        (\n                            item\n                            for item in self._groups\n                            if item[\"name\"] == parent_group_name\n                        ),\n                        None,\n                    )\n                    if (\n                        parent_group is None\n                        or not \"enable_o365\" in parent_group\n                        or not parent_group[\"enable_o365\"]\n                    ):\n                        # if parent group is not in payload then this membership\n                        # is not relevant for Microsoft 365.\n                        # If Office 365 is not enabled for this parent group in\n                        # the payload we can also skip:\n                        logger.info(\n                            \"Parent Group -&gt; %s is not enabled for M365. Skipping...\",\n                            group_name,\n                        )\n                        continue\n\n                    response = self._m365.get_group(parent_group_name)\n                    if (\n                        response is None\n                        or not \"value\" in response\n                        or not response[\"value\"]\n                    ):\n                        logger.error(\n                            \"Microsoft 365 Group -&gt; %s not found. Skipping...\",\n                            group_name,\n                        )\n                        success = False\n                        continue\n                    parent_group_id = response[\"value\"][0][\"id\"]\n\n                    # Check if user is already a member. We don't want\n                    # to throw an error if the user is not found as a member:\n                    if self._m365.is_member(\n                        parent_group_id, user_id, show_error=False\n                    ):\n                        logger.info(\n                            \"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\n                            user[\"name\"],\n                            user_id,\n                            parent_group_name,\n                            parent_group_id,\n                        )\n                        continue\n\n                    logger.info(\n                        \"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\n                        user[\"name\"],\n                        user_id,\n                        parent_group_name,\n                        parent_group_id,\n                    )\n                    self._m365.add_group_member(parent_group_id, user_id)\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_users_sap","title":"<code>process_users_sap(sap_object, section_name='usersSAP')</code>","text":"<p>Process users in payload and sync them with SAP (passwords for now).</p> <p>Parameters:</p> Name Type Description Default <code>sap_object</code> <code>SAP</code> <p>SAP object</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'usersSAP'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise Side Effects:     the user items are modified by adding an \"id\" dict element that     includes the technical ID of the user in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_users_sap(\n    self, sap_object: SAP, section_name: str = \"usersSAP\"\n) -&gt; bool:\n    \"\"\"Process users in payload and sync them with SAP (passwords for now).\n\n    Args:\n        sap_object (SAP): SAP object\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        the user items are modified by adding an \"id\" dict element that\n        includes the technical ID of the user in Extended ECM\n    \"\"\"\n\n    if not self._users:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    rfc_name = \"ZFM_TERRA_RFC_CHNG_USR_PW\"\n    rfc_description = \"RFC to update the SAP user password\"\n    rfc_call_options = ()\n\n    # Add all users in payload and establish membership in\n    # specified groups:\n    for user in self._users:\n        # Sanity checks:\n        if not \"name\" in user:\n            logger.error(\"User is missing a login. Skipping to next user...\")\n            success = False\n            continue\n        user_name = user[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in user and not user[\"enabled\"]:\n            logger.info(\n                \"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n            )\n            continue\n\n        # Check if the user is enabled for SAP:\n        if not \"enable_sap\" in user or not user[\"enable_sap\"]:\n            logger.info(\"User -&gt; %s is not enabled for SAP. Skipping...\", user_name)\n            continue\n\n        # Sanity checks:\n        if not \"password\" in user:\n            logger.error(\n                \"User -&gt; %s is missing a password. Cannot sync with SAP. Skipping to next user...\",\n                user_name,\n            )\n            success = False\n            continue\n        user_password = user[\"password\"]\n\n        rfc_params = {\n            \"USERNAME\": user_name,\n            \"PASSWORD\": user_password,\n        }\n\n        logger.info(\n            \"Updating password of user -&gt; %s in SAP. Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\n            user_name,\n            rfc_name,\n            rfc_description,\n            rfc_params,\n        )\n\n        result = sap_object.call(rfc_name, rfc_call_options, rfc_params)\n        if result is None:\n            logger.error(\n                \"Failed to call SAP RFC -&gt; %s to update password of user -&gt; %s\",\n                rfc_name,\n                user_name,\n            )\n            success = False\n        elif result.get(\"RESULT\") != \"OK\":\n            logger.error(\n                \"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\n                rfc_name,\n                str(result.get(\"FAILED\")),\n                str(result),\n            )\n            success = False\n            # Save result for status file content\n            user[\"sap_sync_result\"] = result\n        else:\n            logger.info(\n                \"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n            )\n            # Save result for status file content\n            user[\"sap_sync_result\"] = result\n\n    self.write_status_file(success, section_name, self._users)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_web_hooks","title":"<code>process_web_hooks(webhooks, section_name='webHooks')</code>","text":"<p>Process Web Hooks in payload and do HTTP requests.</p> <p>Parameters:</p> Name Type Description Default <code>webhooks</code> <code>list</code> <p>list of web hook payload settings</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'webHooks'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_web_hooks(self, webhooks: list, section_name: str = \"webHooks\") -&gt; bool:\n    \"\"\"Process Web Hooks in payload and do HTTP requests.\n\n    Args:\n        webhooks (list): list of web hook payload settings\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not webhooks:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n\n    # WE LET THIS RUN EACH TIME!\n    #        if self.check_status_file(section_name):\n    #            return True\n\n    success: bool = True\n\n    for webhook in webhooks:\n        url = webhook.get(\"url\")\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        enabled = webhook.get(\"enabled\", True)\n\n        if not enabled and not url:\n            logger.info(\"Payload for Web Hook is disabled. Skipping...\")\n            continue\n        elif not url:\n            logger.info(\"Web Hook does not have a url. Skipping...\")\n            success = False\n            continue\n        elif not enabled:\n            logger.info(\"Payload for Web Hook -&gt; %s is disabled. Skipping...\", url)\n            continue\n\n        description = webhook.get(\"description\")\n\n        method = webhook.get(\"method\", \"POST\")\n\n        payload = webhook.get(\"payload\", {})\n\n        headers = webhook.get(\"headers\", {})\n\n        if description:\n            logger.info(\"Calling Web Hook -&gt; %s: %s (%s)\", method, url, description)\n        else:\n            logger.info(\"Calling Web Hook -&gt; %s: %s\", method, url)\n\n        response = self._http_object.http_request(\n            url=url,\n            method=method,\n            payload=payload,\n            headers=headers,\n            retries=webhook.get(\"retries\", 0),\n            wait_time=webhook.get(\"wait_time\", 0),\n        )\n        if not response or not response.ok:\n            success = False\n\n    self.write_status_file(success, section_name, webhooks)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_web_reports","title":"<code>process_web_reports(web_reports, section_name='webReports')</code>","text":"<p>Process web reports in payload and run them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>web_reports</code> <code>list</code> <p>list of web reports. As we have two different list (pre and post)                 we need to pass the actual list as parameter.</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webReportsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'webReports'</code> <p>Returns:     bool: True if a restart of the OTCS pods is required. False otherwise.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_web_reports(\n    self, web_reports: list, section_name: str = \"webReports\"\n) -&gt; bool:\n    \"\"\"Process web reports in payload and run them in Extended ECM.\n\n    Args:\n        web_reports (list): list of web reports. As we have two different list (pre and post)\n                            we need to pass the actual list as parameter.\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webReportsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if a restart of the OTCS pods is required. False otherwise.\n    \"\"\"\n\n    if not web_reports:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n    # If this payload section has been processed successfully before we\n    # can return False and skip processing it once more:\n    if self.check_status_file(section_name):\n        return False  # important to return False here as otherwise we are triggering a restart of services!!\n\n    restart_required: bool = False\n    success: bool = True\n\n    for web_report in web_reports:\n        nick_name = web_report[\"nickname\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in web_report and not web_report[\"enabled\"]:\n            logger.info(\n                \"Payload for Web Report -&gt; %s is disabled. Skipping...\", nick_name\n            )\n            continue\n\n        description = web_report[\"description\"]\n        restart = web_report.get(\"restart\", False)\n\n        if not self._otcs.get_node_from_nickname(nick_name):\n            logger.error(\n                \"Web Report with nickname -&gt; %s does not exist! Skipping...\",\n                nick_name,\n            )\n            success = False\n            continue\n\n        # be careful to avoid key errors as Web Report parameters are optional:\n        actual_params = (\n            web_report[\"parameters\"] if web_report.get(\"parameters\") else {}\n        )\n        formal_params = self._otcs.get_web_report_parameters(nick_name)\n        if actual_params:\n            logger.info(\n                \"Running Web Report -&gt; %s (%s) with parameters -&gt; %s ...\",\n                nick_name,\n                description,\n                actual_params,\n            )\n            # Do some sanity checks to see if the formal and actual parameters are matching...\n            # Check 1: are there formal parameters at all?\n            if not formal_params:\n                logger.error(\n                    \"Web Report -&gt; %s is called with actual parameters but it does not expect parameters! Skipping...\",\n                    nick_name,\n                )\n                success = False\n                continue\n            lets_continue = False\n            # Check 2: Iterate through the actual parameters given in the payload\n            # and see if there's a matching formal parameter expected by the Web Report:\n            for key, value in actual_params.items():\n                # Check if there's a matching formal parameter defined on the Web Report node:\n                formal_param = next(\n                    (item for item in formal_params if item[\"parm_name\"] == key),\n                    None,\n                )\n                if formal_param is None:\n                    logger.error(\n                        \"Web Report -&gt; %s is called with parameter -&gt; %s that is not expected! Value: %s) Skipping...\",\n                        nick_name,\n                        key,\n                        value,\n                    )\n                    success = False\n                    lets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n            # Check 3: Iterate through the formal parameters and validate there's a matching\n            # actual parameter defined in the payload for each mandatory formal parameter\n            # that does not have a default value:\n            for formal_param in formal_params:\n                if (\n                    (formal_param[\"mandatory\"] is True)\n                    and (formal_param[\"default_value\"] is None)\n                    and not actual_params.get(formal_param[\"parm_name\"])\n                ):\n                    logger.error(\n                        \"Web Report -&gt; %s is called without mandatory parameter -&gt; %s! Skipping...\",\n                        nick_name,\n                        formal_param[\"parm_name\"],\n                    )\n                    success = False\n                    lets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n            # Did any of the checks fail?\n            if lets_continue:\n                continue\n            # Actual parameters are validated, we can run the Web Report:\n            response = self._otcs.run_web_report(nick_name, actual_params)\n        else:\n            logger.info(\n                \"Running Web Report -&gt; %s (%s) without parameters...\",\n                nick_name,\n                description,\n            )\n            # Check if there's a formal parameter that is mandatory but\n            # does not have a default value:\n            if formal_params:\n                required_param = next(\n                    (\n                        item\n                        for item in formal_params\n                        if (item[\"mandatory\"] is True)\n                        and (not item[\"default_value\"])\n                    ),\n                    None,\n                )\n                if required_param:\n                    logger.error(\n                        \"Web Report -&gt; %s is called without parameters but has a mandatory parameter -&gt; %s without a default value! Skipping...\",\n                        nick_name,\n                        required_param[\"parm_name\"],\n                    )\n                    success = False\n                    continue\n                else:  # we are good to proceed!\n                    logger.debug(\n                        \"Web Report -&gt; %s does not have a mandatory parameter without a default value!\",\n                        nick_name,\n                    )\n            response = self._otcs.run_web_report(nick_name)\n        if response is None:\n            logger.error(\"Failed to run web report -&gt; %s\", nick_name)\n            success = False\n\n        if restart:\n            restart_required = True\n\n    self.write_status_file(success, section_name, web_reports)\n\n    return restart_required\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_aviators","title":"<code>process_workspace_aviators(section_name='workspaceAviators')</code>","text":"<p>Process workspaces Content Aviator settings in payload and enable Aviator for selected workspaces.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceAviators'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_aviators(\n    self, section_name: str = \"workspaceAviators\"\n) -&gt; bool:\n    \"\"\"Process workspaces Content Aviator settings in payload and enable Aviator for selected workspaces.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._workspaces:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for workspace in self._workspaces:\n        # Read name from payload (just for logging):\n        if not \"name\" in workspace:\n            continue\n        workspace_name = workspace[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in workspace and not workspace[\"enabled\"]:\n            logger.info(\n                \"Payload for Workspace -&gt; %s is disabled. Skipping...\",\n                workspace_name,\n            )\n            continue\n\n        # Read Aviator setting from payload:\n        if not \"enable_aviator\" in workspace or not workspace[\"enable_aviator\"]:\n            logger.info(\n                \"Aviator is not enabled for Workspace -&gt; %s. Skipping to next workspace...\",\n                workspace_name,\n            )\n            continue\n\n        # We cannot just lookup with workspace.get(\"nodeId\") as the customizer\n        # may have been restarted inbetween - so we use our proper determine_workspace_id\n        # here...\n        workspace_id = self.determine_workspace_id(workspace)\n        if not workspace_id:\n            logger.error(\n                \"Cannot find node ID for workspace -&gt; %s. Workspace creation may have failed. Skipping to next workspace...\",\n                workspace_name,\n            )\n            success = False\n            continue\n\n        # Make code idem-potent and check if Aviator is already enabled\n        # for this workspace:\n        if self._otcs.check_workspace_aviator(workspace_id=workspace_id):\n            logger.info(\n                \"Skip workspace -&gt; %s (%s) as Aviator is already enabled...\",\n                workspace_name,\n                workspace_id,\n            )\n            continue\n\n        # Now enable the Content Aviator for the workspace:\n        response = self._otcs.update_workspace_aviator(workspace_id, True)\n        if not response:\n            logger.error(\n                \"Failed to enable Content Aviator for workspace -&gt; %s (%s)\",\n                workspace_name,\n                workspace_id,\n            )\n            success = False\n            continue\n\n    self.write_status_file(success, section_name, self._workspaces)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_member_permissions","title":"<code>process_workspace_member_permissions(section_name='workspaceMemberPermissions')</code>","text":"<p>Process workspaces members in payload and set their permissions.    We need this separate from process_workspace_members() with also    sets permissions (if in payload) as we add documents to workspaces with    content transports and these documents don't inherit role permissions    (this is a transport limitation)</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceMemberPermissions'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_member_permissions(\n    self, section_name: str = \"workspaceMemberPermissions\"\n) -&gt; bool:\n    \"\"\"Process workspaces members in payload and set their permissions.\n       We need this separate from process_workspace_members() with also\n       sets permissions (if in payload) as we add documents to workspaces with\n       content transports and these documents don't inherit role permissions\n       (this is a transport limitation)\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._workspaces:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for workspace in self._workspaces:\n        # Read name from payload (just for logging):\n        if not \"name\" in workspace:\n            continue\n        workspace_name = workspace[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in workspace and not workspace[\"enabled\"]:\n            logger.info(\n                \"Payload for Workspace -&gt; %s is disabled. Skipping...\",\n                workspace_name,\n            )\n            continue\n\n        # Read members from payload:\n        if not \"members\" in workspace:\n            logger.info(\n                \"Workspace -&gt; %s has no members in payload. No need to update permissions. Skipping to next workspace...\",\n                workspace_name,\n            )\n            continue\n        members = workspace[\"members\"]\n\n        workspace_id = workspace[\"id\"]\n        workspace_node_id = int(self.determine_workspace_id(workspace))\n        if not workspace_node_id:\n            logger.warning(\n                \"Workspace without node ID cannot cannot get permission changes (workspaces creation may have failed). Skipping to next workspace...\"\n            )\n            continue\n\n        workspace_roles = self._otcs.get_workspace_roles(workspace_node_id)\n        if workspace_roles is None:\n            logger.info(\n                \"Workspace with ID -&gt; %s and node Id -&gt; %s has no roles to update permissions. Skipping to next workspace...\",\n                workspace_id,\n                workspace_node_id,\n            )\n            continue\n\n        for member in members:\n            # read user list and role name from payload:\n            member_users = (\n                member[\"users\"] if member.get(\"users\") else []\n            )  # be careful to avoid key errors as users are optional\n            member_groups = (\n                member[\"groups\"] if member.get(\"groups\") else []\n            )  # be careful to avoid key errors as groups are optional\n            member_role_name = member[\"role\"]\n\n            if member_role_name == \"\":  # role name is required\n                logger.error(\n                    \"Members of workspace -&gt; %s is missing the role name.\",\n                    workspace_name,\n                )\n                success = False\n                continue\n            if (\n                member_users == [] and member_groups == []\n            ):  # we either need users or groups (or both)\n                logger.warning(\n                    \"Role -&gt; %s of workspace -&gt; %s does not have any members (no users nor groups).\",\n                    member_role_name,\n                    workspace_name,\n                )\n                continue\n\n            role_id = self._otcs.lookup_result_value(\n                workspace_roles, \"name\", member_role_name, \"id\"\n            )\n            if role_id is None:\n                logger.error(\n                    \"Workspace -&gt; %s does not have a role with name -&gt; %s\",\n                    workspace_name,\n                    member_role_name,\n                )\n                success = False\n                continue\n            logger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n\n            member_permissions = member.get(\"permissions\", [])\n            if member_permissions == []:\n                logger.info(\n                    \"No permission change for workspace -&gt; %s and role -&gt; %s.\",\n                    workspace_name,\n                    member_role_name,\n                )\n                continue\n\n            logger.info(\n                \"Update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s\",\n                workspace_name,\n                str(workspace_node_id),\n                member_role_name,\n                str(member_permissions),\n            )\n            response = self._otcs.assign_permission(\n                node_id=workspace_node_id,\n                assignee_type=\"custom\",\n                assignee=role_id,\n                permissions=member_permissions,\n                apply_to=2,\n            )\n            if not response:\n                logger.error(\n                    \"Failed to update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s.\",\n                    workspace_name,\n                    str(workspace_node_id),\n                    member_role_name,\n                    str(member_permissions),\n                )\n                success = False\n\n    self.write_status_file(success, section_name, self._workspaces)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_members","title":"<code>process_workspace_members(section_name='workspaceMembers')</code>","text":"<p>Process workspaces members in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceMembers'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_members(self, section_name: str = \"workspaceMembers\") -&gt; bool:\n    \"\"\"Process workspaces members in payload and create them in Extended ECM.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._workspaces:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for workspace in self._workspaces:\n        # Read name from payload (just for logging):\n        if not \"name\" in workspace:\n            continue\n        workspace_name = workspace[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in workspace and not workspace[\"enabled\"]:\n            logger.info(\n                \"Payload for Workspace -&gt; %s is disabled. Skipping...\",\n                workspace_name,\n            )\n            continue\n\n        # Read members from payload:\n        if not \"members\" in workspace:\n            logger.info(\n                \"Workspace -&gt; %s has no members in payload. Skipping to next workspace...\",\n                workspace_name,\n            )\n            continue\n        members = workspace[\"members\"]\n\n        workspace_id = workspace[\"id\"]\n        logger.info(\n            \"Workspace -&gt; %s has memberships in payload - establishing...\",\n            workspace_name,\n        )\n\n        workspace_node_id = int(self.determine_workspace_id(workspace))\n        if not workspace_node_id:\n            logger.warning(\n                \"Workspace without node ID cannot have members (workspaces creation may have failed). Skipping to next workspace...\"\n            )\n            continue\n\n        # now determine the actual node IDs of the workspaces (have been created by process_workspaces()):\n        workspace_node = self._otcs.get_node(workspace_node_id)\n        workspace_owner_id = self._otcs.get_result_value(\n            workspace_node, \"owner_user_id\"\n        )\n        workspace_owner_name = self._otcs.get_result_value(workspace_node, \"owner\")\n\n        workspace_roles = self._otcs.get_workspace_roles(workspace_node_id)\n        if workspace_roles is None:\n            logger.info(\n                \"Workspace with ID -&gt; %s and node Id -&gt; %s has no roles. Skipping to next workspace...\",\n                workspace_id,\n                workspace_node_id,\n            )\n            continue\n\n        # We don't want the workspace creator to be in the leader role\n        # of automatically created workspaces - this can happen because the\n        # creator gets added to the leader role automatically:\n        leader_role_id = self._otcs.lookup_result_value(\n            workspace_roles, \"leader\", True, \"id\"\n        )\n\n        if leader_role_id:\n            leader_role_name = self._otcs.lookup_result_value(\n                workspace_roles, \"leader\", True, \"name\"\n            )\n            response = self._otcs.remove_member_from_workspace(\n                workspace_node_id, leader_role_id, workspace_owner_id, False\n            )\n            if response:\n                logger.info(\n                    \"Removed creator user -&gt; %s (%s) from leader role -&gt; {%s (%s) of workspace -&gt; %s\",\n                    workspace_owner_name,\n                    workspace_owner_id,\n                    leader_role_name,\n                    leader_role_id,\n                    workspace_name,\n                )\n\n        logger.info(\n            \"Adding members to workspace with ID -&gt; %s and node ID -&gt; %s defined in payload...\",\n            workspace_id,\n            workspace_node_id,\n        )\n\n        for member in members:\n            # read user list and role name from payload:\n            member_users = (\n                member[\"users\"] if member.get(\"users\") else []\n            )  # be careful to avoid key errors as users are optional\n            member_groups = (\n                member[\"groups\"] if member.get(\"groups\") else []\n            )  # be careful to avoid key errors as groups are optional\n            member_role_name = member[\"role\"]\n\n            if member_role_name == \"\":  # role name is required\n                logger.error(\n                    \"Members of workspace -&gt; %s is missing the role name.\",\n                    workspace_name,\n                )\n                success = False\n                continue\n            if (\n                member_users == [] and member_groups == []\n            ):  # we either need users or groups (or both)\n                logger.warning(\n                    \"Role -&gt; %s of workspace -&gt; %s does not have any members (no users nor groups).\",\n                    member_role_name,\n                    workspace_name,\n                )\n                continue\n\n            role_id = self._otcs.lookup_result_value(\n                workspace_roles, \"name\", member_role_name, \"id\"\n            )\n            if role_id is None:\n                #    if member_role is None:\n                logger.error(\n                    \"Workspace -&gt; %s does not have a role with name -&gt; %s\",\n                    workspace_name,\n                    member_role_name,\n                )\n                success = False\n                continue\n            logger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n\n            # Process users as workspaces members:\n            for member_user in member_users:\n                # find member user in current payload:\n                member_user_id = next(\n                    (item for item in self._users if item[\"name\"] == member_user),\n                    {},\n                )\n                if member_user_id:\n                    user_id = member_user_id[\"id\"]\n                else:\n                    # If this didn't work, try to get the member user from OTCS. This covers\n                    # cases where the user is system generated or part\n                    # of a former payload processing (thus not in the current payload):\n                    logger.info(\n                        \"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\n                        member_user,\n                    )\n                    response = self._otcs.get_user(member_user)\n                    user_id = self._otcs.lookup_result_value(\n                        response, key=\"name\", value=member_user, return_key=\"id\"\n                    )\n                    if not user_id:\n                        logger.error(\n                            \"Cannot find member user with login -&gt; %s. Skipping...\",\n                            member_user,\n                        )\n                        continue\n\n                # Add member if it does not yet exists - suppress warning\n                # message if user is already in role:\n                response = self._otcs.add_member_to_workspace(\n                    workspace_node_id, int(role_id), user_id, False\n                )\n                if response is None:\n                    logger.error(\n                        \"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                        member_user,\n                        user_id,\n                        member_role_name,\n                        workspace_name,\n                    )\n                    success = False\n                else:\n                    logger.info(\n                        \"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                        member_user,  # member_user_id[\"name\"],\n                        user_id,\n                        member_role_name,\n                        workspace_name,\n                    )\n\n            # Process groups as workspaces members:\n            for member_group in member_groups:\n                member_group_id = next(\n                    (item for item in self._groups if item[\"name\"] == member_group),\n                    None,\n                )\n                if member_group_id is None:\n                    logger.error(\"Cannot find group with name -&gt; %s\", member_group)\n                    success = False\n                    continue\n                group_id = member_group_id[\"id\"]\n\n                response = self._otcs.add_member_to_workspace(\n                    workspace_node_id, int(role_id), group_id\n                )\n                if response is None:\n                    logger.error(\n                        \"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                        member_group_id[\"name\"],\n                        group_id,\n                        member_role_name,\n                        workspace_name,\n                    )\n                    success = False\n                else:\n                    logger.info(\n                        \"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\n                        member_group_id[\"name\"],\n                        group_id,\n                        member_role_name,\n                        workspace_name,\n                    )\n\n            # Optionally the payload may have a permission list for the role\n            # to change the default permission from the workspace template\n            # to something more specific:\n            member_permissions = member.get(\"permissions\", [])\n            if member_permissions == []:\n                logger.info(\n                    \"No permission change for workspace -&gt; %s and role -&gt; %s.\",\n                    workspace_name,\n                    member_role_name,\n                )\n                continue\n\n            logger.info(\n                \"Update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s\",\n                workspace_name,\n                str(workspace_node_id),\n                member_role_name,\n                str(member_permissions),\n            )\n            response = self._otcs.assign_permission(\n                node_id=workspace_node_id,\n                assignee_type=\"custom\",\n                assignee=role_id,\n                permissions=member_permissions,\n                apply_to=2,\n            )\n            if not response:\n                logger.error(\n                    \"Failed to update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s.\",\n                    workspace_name,\n                    str(workspace_node_id),\n                    member_role_name,\n                    str(member_permissions),\n                )\n                success = False\n\n    self.write_status_file(success, section_name, self._workspaces)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_relationships","title":"<code>process_workspace_relationships(section_name='workspaceRelationships')</code>","text":"<p>Process workspaces relationships in payload and create them in Extended ECM.</p> <p>Relationships can only be created if all workspaces have been created before. Once a workspace got created, the node ID of that workspaces has been added to the payload[\"workspaces\"] data structure (see process_workspaces()) Relationships are created between the node IDs of two business workspaces (and not the logical IDs in the inital payload specification)</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceRelationships'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_relationships(\n    self, section_name: str = \"workspaceRelationships\"\n) -&gt; bool:\n    \"\"\"Process workspaces relationships in payload and create them in Extended ECM.\n\n    Relationships can only be created if all workspaces have been created before.\n    Once a workspace got created, the node ID of that workspaces has been added\n    to the payload[\"workspaces\"] data structure (see process_workspaces())\n    Relationships are created between the node IDs of two business workspaces\n    (and not the logical IDs in the inital payload specification)\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    if not self._workspaces:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for workspace in self._workspaces:\n        # Read name from payload:\n        if not \"name\" in workspace:\n            continue\n        name = workspace[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in workspace and not workspace[\"enabled\"]:\n            logger.info(\n                \"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n            )\n            continue\n\n        # Read relationships from payload:\n        if not \"relationships\" in workspace:\n            logger.info(\n                \"Workspace -&gt; %s has no relationships. Skipping to next workspace...\",\n                name,\n            )\n            continue\n\n        # Check that workspaces actually have a logical ID -\n        # otherwise we cannot establish the relationship:\n        if not \"id\" in workspace:\n            logger.warning(\n                \"Workspace without ID cannot have a relationship. Skipping to next workspace...\"\n            )\n            continue\n\n        workspace_id = workspace[\"id\"]\n        logger.info(\"Workspace -&gt; %s has relationships - creating...\", name)\n\n        workspace_node_id = self.determine_workspace_id(workspace)\n        if not workspace_node_id:\n            logger.warning(\n                \"Workspace without node ID cannot have a relationship (workspace creation may have failed). Skipping to next workspace...\"\n            )\n            continue\n        # now determine the actual node IDs of the workspaces (have been created above):\n        logger.info(\n            \"Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\n            workspace_id,\n            workspace_node_id,\n        )\n\n        for related_workspace_id in workspace[\"relationships\"]:\n            # Find the workspace type with the name given in the payload:\n            related_workspace = next(\n                (\n                    item\n                    for item in self._workspaces\n                    if item[\"id\"] == related_workspace_id\n                ),\n                None,\n            )\n            if related_workspace is None:\n                logger.error(\n                    \"Related Workspace with logical ID -&gt; %s not found.\",\n                    related_workspace_id,\n                )\n                success = False\n                continue\n\n            if \"enabled\" in related_workspace and not related_workspace[\"enabled\"]:\n                logger.info(\n                    \"Payload for Related Workspace -&gt; %s is disabled. Skipping...\",\n                    related_workspace[\"name\"],\n                )\n                continue\n\n            related_workspace_node_id = self.determine_workspace_id(\n                related_workspace\n            )\n            if not related_workspace_node_id:\n                logger.warning(\n                    \"Related Workspace without node ID (workspaces creation may have failed). Skipping to next workspace...\"\n                )\n                continue\n\n            logger.info(\n                \"Related Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\n                related_workspace_id,\n                related_workspace_node_id,\n            )\n\n            logger.info(\n                \"Create Workspace Relationship between workspace node ID -&gt; %s and workspace node ID -&gt; %s\",\n                workspace_node_id,\n                related_workspace_node_id,\n            )\n\n            # Check if relationship does already exists:\n            response = self._otcs.get_workspace_relationships(workspace_node_id)\n\n            existing_workspace_relationship = self._otcs.exist_result_item(\n                response, \"id\", related_workspace_node_id\n            )\n            if existing_workspace_relationship:\n                logger.info(\n                    \"Workspace relationship between workspace ID -&gt; %s and related workspace ID -&gt; %s does already exist. Skipping...\",\n                    workspace_node_id,\n                    related_workspace_node_id,\n                )\n                continue\n\n            response = self._otcs.create_workspace_relationship(\n                workspace_node_id, related_workspace_node_id\n            )\n            if not response:\n                logger.error(\"Failed to create workspace relationship.\")\n                success = False\n            else:\n                logger.info(\"Successfully created workspace relationship.\")\n\n    self.write_status_file(success, section_name, self._workspaces)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_templates","title":"<code>process_workspace_templates(section_name='workspaceTemplates')</code>","text":"<p>Process Workspace Template playload. This allows to define role members on    template basis. This avoids having to \"pollute\" workspace template templates    with user or group information and instead controls this via payload.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceTemplates'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_templates(\n    self, section_name: str = \"workspaceTemplates\"\n) -&gt; bool:\n    \"\"\"Process Workspace Template playload. This allows to define role members on\n       template basis. This avoids having to \"pollute\" workspace template templates\n       with user or group information and instead controls this via payload.\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for workspace_template in self._workspace_templates:\n        # Read Workspace Type Name from payload:\n        if not \"type_name\" in workspace_template:\n            logger.error(\n                \"Workspace template needs a type name! Skipping to next workspace template...\",\n            )\n            success = False\n            continue\n        type_name = workspace_template[\"type_name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in workspace_template and not workspace_template[\"enabled\"]:\n            logger.info(\n                \"Payload for Workspace Template -&gt; %s is disabled. Skipping to next workspace template...\",\n                type_name,\n            )\n            continue\n\n        # Read Workspace Template Name from payload:\n        if not \"template_name\" in workspace_template:\n            logger.error(\n                \"Workspace Template for Workspace Type -&gt; %s needs a template name! Skipping to next workspace template...\",\n                type_name,\n            )\n            success = False\n            continue\n        template_name = workspace_template[\"template_name\"]\n\n        # Read members from payload:\n        if not \"members\" in workspace_template:\n            logger.info(\n                \"Workspace template with type -&gt; %s and name -&gt; %s has no members in payload. Skipping to next workspace...\",\n                type_name,\n                template_name,\n            )\n            continue\n        members = workspace_template[\"members\"]\n\n        # Find the workspace type with the name given in the _workspace_types\n        # datastructure that has been generated by process_workspace_types() method before:\n        workspace_type = next(\n            (item for item in self._workspace_types if item[\"name\"] == type_name),\n            None,\n        )\n        if workspace_type is None:\n            logger.error(\n                \"Workspace Type -&gt; %s not found. Skipping to next workspace template...\",\n                type_name,\n            )\n            success = False\n            continue\n        if workspace_type[\"templates\"] == []:\n            logger.error(\n                \"Workspace Type -&gt; %s does not have templates. Skipping to next workspace template...\",\n                type_name,\n            )\n            success = False\n            continue\n\n        workspace_template = next(\n            (\n                item\n                for item in workspace_type[\"templates\"]\n                if item[\"name\"] == template_name\n            ),\n            None,\n        )\n        if workspace_template:  # does this template exist?\n            logger.info(\n                \"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\n                template_name,\n            )\n        else:\n            logger.error(\n                \"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\n                template_name,\n            )\n            logger.error(\n                \"Workspace Type -&gt; %s has only these templates -&gt; %s\",\n                type_name,\n                workspace_type[\"templates\"],\n            )\n            success = False\n            continue\n\n        template_id = workspace_template[\"id\"]\n\n        workspace_roles = self._otcs.get_workspace_roles(template_id)\n        if workspace_roles is None:\n            logger.info(\n                \"Workspace Template %s with node Id -&gt; %s has no roles. Skipping to next workspace...\",\n                template_name,\n                template_id,\n            )\n            continue\n\n        for member in members:\n            # read user list and role name from payload:\n            member_users = (\n                member[\"users\"] if member.get(\"users\") else []\n            )  # be careful to avoid key errors as users are optional\n            member_groups = (\n                member[\"groups\"] if member.get(\"groups\") else []\n            )  # be careful to avoid key errors as groups are optional\n            member_role_name = member[\"role\"]\n\n            if member_role_name == \"\":  # role name is required\n                logger.error(\n                    \"Members of workspace template -&gt; %s is missing the role name.\",\n                    template_name,\n                )\n                success = False\n                continue\n            if (\n                member_users == [] and member_groups == []\n            ):  # we either need users or groups (or both)\n                logger.warning(\n                    \"Role -&gt; %s of workspace template -&gt; %s does not have any members (no users nor groups).\",\n                    member_role_name,\n                    template_name,\n                )\n                continue\n\n            role_id = self._otcs.lookup_result_value(\n                workspace_roles, \"name\", member_role_name, \"id\"\n            )\n            if role_id is None:\n                #    if member_role is None:\n                logger.error(\n                    \"Workspace template -&gt; %s does not have a role with name -&gt; %s\",\n                    template_name,\n                    member_role_name,\n                )\n                success = False\n                continue\n            logger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n\n            # Process users as workspace template members:\n            for member_user in member_users:\n                # find member user in current payload:\n                member_user_id = next(\n                    (item for item in self._users if item[\"name\"] == member_user),\n                    {},\n                )\n                if member_user_id:\n                    user_id = member_user_id[\"id\"]\n                else:\n                    # If this didn't work, try to get the member user from OTCS. This covers\n                    # cases where the user is system generated or part\n                    # of a former payload processing (thus not in the current payload):\n                    logger.info(\n                        \"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\n                        member_user,\n                    )\n                    response = self._otcs.get_user(member_user)\n                    user_id = self._otcs.lookup_result_value(\n                        response, key=\"name\", value=member_user, return_key=\"id\"\n                    )\n                    if not user_id:\n                        logger.error(\n                            \"Cannot find member user with login -&gt; %s. Skipping...\",\n                            member_user,\n                        )\n                        success = False\n                        continue\n\n                # Add member if it does not yet exists - suppress warning\n                # message if user is already in role:\n                response = self._otcs.add_member_to_workspace(\n                    template_id, int(role_id), user_id, False\n                )\n                if response is None:\n                    logger.error(\n                        \"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                        member_user,\n                        user_id,\n                        member_role_name,\n                        template_name,\n                    )\n                    success = False\n                else:\n                    logger.info(\n                        \"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                        member_user,\n                        user_id,\n                        member_role_name,\n                        template_name,\n                    )\n\n            # Process groups as workspace template members:\n            for member_group in member_groups:\n                member_group_id = next(\n                    (item for item in self._groups if item[\"name\"] == member_group),\n                    None,\n                )\n                if member_group_id is None:\n                    logger.error(\"Cannot find group with name -&gt; %s\", member_group)\n                    success = False\n                    continue\n                group_id = member_group_id[\"id\"]\n\n                response = self._otcs.add_member_to_workspace(\n                    template_id, int(role_id), group_id\n                )\n                if response is None:\n                    logger.error(\n                        \"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                        member_group_id[\"name\"],\n                        group_id,\n                        member_role_name,\n                        template_name,\n                    )\n                    success = False\n                else:\n                    logger.info(\n                        \"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\n                        member_group_id[\"name\"],\n                        group_id,\n                        member_role_name,\n                        template_name,\n                    )\n\n    self.write_status_file(success, section_name, self._workspace_types)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_types","title":"<code>process_workspace_types(section_name='workspaceTypes')</code>","text":"<p>Create a data structure for all workspace types in the Extended ECM system.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceTypes'</code> <p>Returns:     list: list of workspace types. Each list element is a dict with these values:         - id (str)         - name (str)         - templates (list)             + name (str)             + id</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_types(self, section_name: str = \"workspaceTypes\") -&gt; list:\n    \"\"\"Create a data structure for all workspace types in the Extended ECM system.\n\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        list: list of workspace types. Each list element is a dict with these values:\n            - id (str)\n            - name (str)\n            - templates (list)\n                + name (str)\n                + id\n    \"\"\"\n\n    # If this payload section has been processed successfully before we\n    # still need to read the data structure from the status file and\n    # initialize self._workspace_types:\n    if self.check_status_file(section_name):\n        # read the list from the json file in admin Home\n        # this is important for restart of customizer pod\n        # as this data structure is used later on for workspace processing\n        logger.info(\n            \"Re-Initialize workspace types list from status file -&gt; %s for later use...\",\n            self.get_status_file_name(payload_section_name=section_name),\n        )\n        self._workspace_types = self.get_status_file(section_name)\n        logger.info(\"Found -&gt; %s workspace types.\", str(len(self._workspace_types)))\n        logger.debug(\"Workspace types -&gt; %s\", str(self._workspace_types))\n        return self._workspace_types\n\n    # get all workspace types (these have been created by the transports and are not in the payload!)\n    # we need to do this each time as it needs to work across potential multiple payload files...\n    response = self._otcs.get_workspace_types()\n    if response is None:\n        logger.error(\"No workspace types found!\")\n        self._workspace_types = []\n    else:\n        self._workspace_types = response[\"results\"]\n        logger.info(\"Found -&gt; %s workspace types.\", str(len(self._workspace_types)))\n        logger.debug(\"Workspace types -&gt; %s\", str(self._workspace_types))\n\n    # now we enrich the workspace_type list elments (which are dicts)\n    # with additional dict elements for further processing:\n    for workspace_type in self._workspace_types:\n        workspace_type_id = workspace_type[\"data\"][\"properties\"][\"wksp_type_id\"]\n        logger.info(\"Workspace Type ID -&gt; %s\", workspace_type_id)\n        workspace_type[\"id\"] = workspace_type_id\n        workspace_type_name = workspace_type[\"data\"][\"properties\"][\"wksp_type_name\"]\n        logger.info(\"Workspace Type Name -&gt; %s\", workspace_type_name)\n        workspace_type[\"name\"] = workspace_type_name\n        workspace_templates = workspace_type[\"data\"][\"properties\"][\"templates\"]\n        # Create empty lists of dicts with template names and node IDs:\n        workspace_type[\"templates\"] = []\n        if workspace_templates:\n            # Determine available templates per workspace type (there can be multiple!)\n            for workspace_template in workspace_templates:\n                workspace_template_id = workspace_template[\"id\"]\n                workspace_template_name = workspace_template[\"name\"]\n                logger.info(\n                    \"Found workspace template with name -&gt; %s and ID -&gt; %s\",\n                    workspace_template_name,\n                    workspace_template_id,\n                )\n                template = {\n                    \"name\": workspace_template_name,\n                    \"id\": workspace_template_id,\n                }\n                workspace_type[\"templates\"].append(template)\n\n                # Workaround for problem with workspace role inheritance\n                # which may be related to Transport or REST API: to work-around this we\n                # push down the workspace roles to the workspace folders explicitly:\n                response = self._otcs.get_workspace_roles(workspace_template_id)\n\n                for roles in response[\"results\"]:\n                    role_name = roles[\"data\"][\"properties\"][\"name\"]\n                    role_id = roles[\"data\"][\"properties\"][\"id\"]\n                    permissions = roles[\"data\"][\"properties\"][\"perms\"]\n                    # as get_workspace_roles() delivers permissions as a value (bit encoded)\n                    # we need to convert it to a permissions string list:\n                    permission_string_list = (\n                        self._otcs.convert_permission_value_to_permission_string(\n                            permissions\n                        )\n                    )\n\n                    logger.info(\n                        \"Inherit permissions of workspace template -&gt; %s and role -&gt; %s to workspace folders...\",\n                        workspace_template_name,\n                        role_name,\n                    )\n\n                    # Inherit permissions to folders of workspace template:\n                    response = self._otcs.assign_workspace_permissions(\n                        workspace_template_id,\n                        role_id,\n                        permission_string_list,\n                        1,  # Only sub items - workspace node itself is OK\n                    )\n\n        else:\n            logger.warning(\n                \"Workspace Types Name -&gt; %s has no templates!\", workspace_type_name\n            )\n            continue\n\n    self.write_status_file(True, section_name, self._workspace_types)\n\n    return self._workspace_types\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspaces","title":"<code>process_workspaces(section_name='workspaces')</code>","text":"<p>Process workspaces in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"workspacesPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaces'</code> <p>Returns:     bool: True if payload has been processed without errors, False otherwise</p> Side Effects <p>Set workspace[\"nodeId] to the node ID of the created workspace</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspaces(self, section_name: str = \"workspaces\") -&gt; bool:\n    \"\"\"Process workspaces in payload and create them in Extended ECM.\n\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"workspacesPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n\n    Side Effects:\n        Set workspace[\"nodeId] to the node ID of the created workspace\n    \"\"\"\n\n    if not self._workspaces:\n        logger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\n        return True\n\n    # If this payload section has been processed successfully before we\n    # can return True and skip processing it once more:\n    if self.check_status_file(section_name):\n        return True\n\n    success: bool = True\n\n    for workspace in self._workspaces:\n        # Read name from payload:\n        if not \"name\" in workspace:\n            logger.error(\"Workspace needs a name! Skipping to next workspace...\")\n            success = False\n            continue\n        name = workspace[\"name\"]\n\n        # Check if element has been disabled in payload (enabled = false).\n        # In this case we skip the element:\n        if \"enabled\" in workspace and not workspace[\"enabled\"]:\n            logger.info(\n                \"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n            )\n            continue\n\n        # Read Type Name from payload:\n        if not \"type_name\" in workspace:\n            logger.error(\n                \"Workspace -&gt; %s needs a type name! Skipping to next workspace...\",\n                name,\n            )\n            success = False\n            continue\n        type_name = workspace[\"type_name\"]\n\n        # We need to do this early to find out if we have a cross-application workspace\n        # and need to continue even if the workspace does exist...\n        if \"business_objects\" in workspace and workspace[\"business_objects\"]:\n            business_objects = workspace[\"business_objects\"]\n\n            business_object_list = self.prepare_workspace_business_objects(\n                workspace=workspace, business_objects=business_objects\n            )\n            # Check if any of the external systems are avaiable:\n            if business_object_list:\n                logger.info(\n                    \"Workspace -&gt; %s will be connected to -&gt; %s business object(s).\",\n                    name,\n                    str(len(business_object_list)),\n                )\n        else:\n            logger.info(\n                \"Workspace -&gt; %s is not connected to any business object.\", name\n            )\n            business_object_list = []\n\n        # Intialize cross-application workspace to \"off\":\n        ibo_workspace_id = None\n\n        # check if the workspace has been created before (effort to make the customizing code idem-potent)\n        logger.info(\n            \"Check if workspace -&gt; %s of type -&gt; %s does already exist...\",\n            name,\n            type_name,\n        )\n        # Check if workspace does already exist\n        # In case the workspace exists, determine_workspace_id()\n        # also stores the node ID into workspace[\"nodeId\"]\n        workspace_id = self.determine_workspace_id(workspace)\n        if workspace_id:\n            logger.info(\n                \"Workspace -&gt; %s of type -&gt; %s does already exist and has ID -&gt; %s!\",\n                name,\n                type_name,\n                workspace_id,\n            )\n            # Check if we have an existing workspace that is cross-application.\n            # In this case we cannot just continue.\n            if len(business_object_list) &gt; 1:\n                ibo_workspace_id = workspace_id\n                logger.info(\n                    \"This is a cross-application workspace so we cannot skip the creation...\"\n                )\n                # We assume the workspace is already conntected to the first BO in the list\n                # This is a simplifiying assumption and should be enahcned in the future.\n                business_object_list.pop(0)\n            else:\n                logger.info(\n                    \"This workspace is NOT a cross-application workspace so we can skip the creation...\"\n                )\n                continue\n\n        logger.info(\n            \"Creating new Workspace -&gt; %s; Workspace Type -&gt; %s...\", name, type_name\n        )\n\n        # Read optional description from payload:\n        if not \"description\" in workspace:\n            description = \"\"\n        else:\n            description = workspace[\"description\"]\n\n        # Parent ID is optional and only required if workspace type does not specify a create location.\n        # This is typically the case if it is a nested workspace or workspaces of the same type can be created\n        # in different locations in the Enterprise Workspace:\n        parent_id = workspace[\"parent_id\"] if workspace.get(\"parent_id\") else None\n\n        if parent_id is not None:\n            parent_workspace = next(\n                (item for item in self._workspaces if item[\"id\"] == parent_id), None\n            )\n            if parent_workspace is None:\n                logger.error(\n                    \"Parent Workspace with logical ID -&gt; %s not found.\", parent_id\n                )\n                success = False\n                continue\n\n            parent_workspace_node_id = self.determine_workspace_id(parent_workspace)\n            if not parent_workspace_node_id:\n                logger.warning(\n                    \"Parent Workspace without node ID (parent workspace creation may have failed). Skipping to next workspace...\"\n                )\n                success = False\n                continue\n\n            logger.info(\n                \"Parent Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\n                parent_id,\n                parent_workspace_node_id,\n            )\n        else:\n            # if no parent_id is specified the workspace location is determined by the workspace type definition\n            # and we pass None as parent ID to the get_workspace_create_form and create_workspace methods below:\n            parent_workspace_node_id = None\n\n        # Find the workspace type with the name given in the payload:\n        workspace_type = next(\n            (item for item in self._workspace_types if item[\"name\"] == type_name),\n            None,\n        )\n        if workspace_type is None:\n            logger.error(\n                \"Workspace Type -&gt; %s not found. Skipping to next workspace...\",\n                type_name,\n            )\n            success = False\n            continue\n        if workspace_type[\"templates\"] == []:\n            logger.error(\n                \"Workspace Type -&gt; %s does not have templates. Skipping to next workspace...\",\n                type_name,\n            )\n            success = False\n            continue\n\n        # check if the template to be used is specified in the payload:\n        if \"template_name\" in workspace:\n            template_name = workspace[\"template_name\"]\n            workspace_template = next(\n                (\n                    item\n                    for item in workspace_type[\"templates\"]\n                    if item[\"name\"] == template_name\n                ),\n                None,\n            )\n            if workspace_template:  # does this template exist?\n                logger.info(\n                    \"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\n                    template_name,\n                )\n            else:\n                logger.error(\n                    \"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\n                    template_name,\n                )\n                logger.error(\n                    \"Workspace Type -&gt; %s has only these templates -&gt; %s\",\n                    type_name,\n                    workspace_type[\"templates\"],\n                )\n                success = False\n                continue\n        # template to be used is NOT specified in the payload - then we just take the first one:\n        else:\n            workspace_template = workspace_type[\"templates\"][0]\n            logger.info(\n                \"Workspace Template has not been specified in payload - we just take the first one (%s)\",\n                workspace_template,\n            )\n\n        template_id = workspace_template[\"id\"]\n        template_name = workspace_template[\"name\"]\n        workspace_type_id = workspace_type[\"id\"]\n\n        logger.info(\n            \"Create Workspace -&gt; %s (type -&gt; %s) from workspace template -&gt; %s (ID -&gt; %s)\",\n            name,\n            type_name,\n            template_name,\n            template_id,\n        )\n\n        # Handle the case where the workspace is not connected\n        # to any external system / business object:\n        if not business_object_list:\n            business_object_list.append(\n                {\n                    \"ext_system_id\": None,\n                    \"bo_type\": None,\n                    \"bo_id\": None,\n                }\n            )\n\n        for business_object in business_object_list:\n            # Read categories from payload:\n            if not \"categories\" in workspace:\n                logger.info(\n                    \"Workspace payload has no category data! Will leave category attributes empty...\"\n                )\n                category_create_data = {}\n            else:\n                categories = workspace[\"categories\"]\n                category_create_data = self.prepare_workspace_create_form(\n                    categories=categories,\n                    template_id=template_id,\n                    ext_system_id=business_object[\"ext_system_id\"],\n                    bo_type=business_object[\"bo_type\"],\n                    bo_id=business_object[\"bo_id\"],\n                    parent_workspace_node_id=parent_workspace_node_id,\n                )\n\n            if ibo_workspace_id:\n                logger.info(\n                    \"Connect existing workspace to an additional business object (IBO)\"\n                )\n            # Create the workspace with all provided information:\n            response = self._otcs.create_workspace(\n                workspace_template_id=template_id,\n                workspace_name=name,\n                workspace_description=description,\n                workspace_type=workspace_type_id,\n                category_data=category_create_data,\n                external_system_id=business_object[\"ext_system_id\"],\n                bo_type=business_object[\"bo_type\"],\n                bo_id=business_object[\"bo_id\"],\n                parent_id=parent_workspace_node_id,\n                ibo_workspace_id=ibo_workspace_id,\n                show_error=(\n                    not self._sap\n                ),  # if SAP is active it may produce workspaces concurrently (race condition). Then we don't want to issue errors.\n            )\n            if response is None:\n                # Check if workspace has been concurrently created by some other\n                # process (e.g. via SAP or Salesforce). This would be a race condition\n                # that seems to really occur.\n                workspace_id = self.determine_workspace_id(workspace)\n                if workspace_id:\n                    logger.info(\n                        \"Workspace -&gt; %s of type -&gt; %s has been created by an external process and has ID -&gt; %s!\",\n                        name,\n                        type_name,\n                        workspace_id,\n                    )\n                else:\n                    logger.error(\n                        \"Failed to create workspace -&gt; %s of type -&gt; %s!\",\n                        name,\n                        type_name,\n                    )\n                    success = False\n                    continue\n            else:\n                # Now we add the node ID of the new workspace to the payload data structure\n                # This will be reused when creating the workspace relationships!\n                if not ibo_workspace_id:\n                    workspace[\"nodeId\"] = self._otcs.get_result_value(\n                        response, \"id\"\n                    )\n                    ibo_workspace_id = workspace[\"nodeId\"]\n\n                    # We also get the name the workspace was finally created with.\n                    # This can be different form the name in the payload as additional\n                    # naming conventions from the Workspace Type definitions may apply.\n                    # This is important to make the python container idem-potent.\n                    response = self._otcs.get_workspace(workspace[\"nodeId\"])\n                    workspace[\"name\"] = self._otcs.get_result_value(\n                        response, \"name\"\n                    )\n\n                    logger.info(\n                        \"Successfully created workspace with final name -&gt; %s and node ID -&gt; %s\",\n                        workspace[\"name\"],\n                        workspace[\"nodeId\"],\n                    )\n\n        # Check if there's an workspace nickname configured:\n        if \"nickname\" in workspace:\n            nickname = workspace[\"nickname\"]\n            logger.info(\n                \"Assign nickname %s to workspace -&gt; %s (%s)...\",\n                nickname,\n                name,\n                workspace[\"nodeId\"],\n            )\n            response = self._otcs.set_node_nickname(\n                node_id=workspace[\"nodeId\"], nickname=nickname, show_error=True\n            )\n            if not response:\n                logger.error(\n                    \"Failed to assign nickname -&gt; %s to workspace -&gt; %s\",\n                    nickname,\n                    name,\n                )\n\n        # Check if there's an workspace icon/image configured:\n        if \"image_nickname\" in workspace:\n            image_nickname = workspace[\"image_nickname\"]\n\n            response = self._otcs.get_node_from_nickname(image_nickname)\n            node_id = self._otcs.get_result_value(response, \"id\")\n            if node_id:\n                mime_type = self._otcs.get_result_value(response, \"mime_type\")\n                if not mime_type:\n                    logger.warning(\n                        \"Missing mime type information - assuming image/png\"\n                    )\n                    mime_type = \"image/png\"\n                file_path = \"/tmp/\" + image_nickname\n                self._otcs.download_document(node_id=node_id, file_path=file_path)\n                response = self._otcs.update_workspace_icon(\n                    workspace_id=workspace[\"nodeId\"],\n                    file_path=file_path,\n                    file_mimetype=mime_type,\n                )\n                if not response:\n                    logger.error(\n                        \"Failed to assign icon -&gt; %s to workspace -&gt; %s from file -&gt; %s \",\n                        image_nickname,\n                        name,\n                        file_path,\n                    )\n            else:\n                logger.error(\n                    \"Cannot find workspace image with nickname -&gt; %s for workspace -&gt; %s\",\n                    image_nickname,\n                    name,\n                )\n\n        # Check if an RM classification is specified for the workspace:\n        # RM Classification is specified as list of path elements (top-down)\n        if (\n            \"rm_classification_path\" in workspace\n            and workspace[\"rm_classification_path\"] != []\n        ):\n            rm_class_node = self._otcs.get_node_by_volume_and_path(\n                198, workspace[\"rm_classification_path\"]\n            )\n            rm_class_node_id = self._otcs.get_result_value(rm_class_node, \"id\")\n            if rm_class_node_id:\n                response = self._otcs.assign_rm_classification(\n                    workspace[\"nodeId\"], rm_class_node_id, False\n                )\n                if response is None:\n                    logger.error(\n                        \"Failed to assign RM classification -&gt; %s (%s) to workspace -&gt; %s\",\n                        workspace[\"rm_classification_path\"][-1],\n                        rm_class_node_id,\n                        name,\n                    )\n                else:\n                    logger.info(\n                        \"Assigned RM Classification -&gt; %s to workspace -&gt; %s\",\n                        workspace[\"rm_classification_path\"][-1],\n                        name,\n                    )\n        # Check if one or multiple classifications are specified for the workspace\n        # Classifications are specified as list of path elements (top-down)\n        if (\n            \"classification_pathes\" in workspace\n            and workspace[\"classification_pathes\"] != []\n        ):\n            for classification_path in workspace[\"classification_pathes\"]:\n                class_node = self._otcs.get_node_by_volume_and_path(\n                    198, classification_path\n                )\n                class_node_id = self._otcs.get_result_value(class_node, \"id\")\n                if class_node_id:\n                    response = self._otcs.assign_classification(\n                        workspace[\"nodeId\"], [class_node_id], False\n                    )\n                    if response is None:\n                        logger.error(\n                            \"Failed to assign classification -&gt; %s to workspace -&gt; %s\",\n                            class_node_id,\n                            name,\n                        )\n                    else:\n                        logger.info(\n                            \"Assigned Classification -&gt; %s to workspace -&gt; %s\",\n                            classification_path[-1],\n                            name,\n                        )\n\n    self.write_status_file(success, section_name, self._workspaces)\n\n    return success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.replace_placeholders","title":"<code>replace_placeholders(content)</code>","text":"<p>Function to replace placeholders in file content.    The content of the file is provided via a parameter.    The replacements are defined in a object variable    _placeholder_values (type = dictionary)    The placeholder values are supposed to be surrounded by    double % signs like %%OTAWP_RESOURCE_ID%%</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>file content to replace placeholders in</p> required <p>Returns:     str: updated content with all defined replacements</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def replace_placeholders(self, content: str) -&gt; str:\n    \"\"\"Function to replace placeholders in file content.\n       The content of the file is provided via a parameter.\n       The replacements are defined in a object variable\n       _placeholder_values (type = dictionary)\n       The placeholder values are supposed to be surrounded by\n       double % signs like %%OTAWP_RESOURCE_ID%%\n\n    Args:\n        content (str): file content to replace placeholders in\n    Returns:\n        str: updated content with all defined replacements\n    \"\"\"\n    # https://stackoverflow.com/questions/63502218/replacing-placeholders-in-a-text-file-with-python\n\n    # if no placeholders are defined we can return the\n    # initial value:\n    if not self._placeholder_values:\n        return content\n\n    try:\n        # We do a dynamic replacement here. The replacement is calculated\n        # by the lambda function that is basically a lookup of the replacement\n        # key found in the settings file with the value defined in the list\n        # of replacement values in self._placeholder_values\n        return re.sub(\n            r\"%%(\\w+?)%%\",\n            lambda match: self._placeholder_values[match.group(1)],\n            content,\n        )\n    except KeyError as key_error:\n        logger.error(\n            \"Found placeholder in settings file without a defined value; error -&gt; %s\",\n            str(key_error),\n        )\n        return content\n    except re.error as re_error:\n        logger.error(\"Regex substitution error -&gt; %s\", str(re_error))\n        return content\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.write_status_file","title":"<code>write_status_file(success, payload_section_name, payload_section, payload_specific=True)</code>","text":"<p>Write a status file into the Admin Personal Workspace in Extended ECM    to indicate that the payload section has been deployed successfully.    This speeds up the customizing process in case the customizer pod    is restarted.</p> <p>Parameters:</p> Name Type Description Default <code>success</code> <code>bool</code> <p>True if the section was processed successful, False otherwise.</p> required <code>payload_section_name</code> <code>str</code> <p>name of the payload section</p> required <code>payload_section</code> <code>list</code> <p>payload section content - this is written as JSon into the file</p> required <code>payload_specific</code> <code>bool</code> <p>whether or not the success should be specific for                      each payload file or if success is \"global\" - like for the deletion                      of the existing M365 teams (which we don't want to execute per                      payload file)</p> <code>True</code> <p>Returns:     bool: True if the status file as been upladed to Extended ECM successfully, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def write_status_file(\n    self,\n    success: bool,\n    payload_section_name: str,\n    payload_section: list,\n    payload_specific: bool = True,\n) -&gt; bool:\n    \"\"\"Write a status file into the Admin Personal Workspace in Extended ECM\n       to indicate that the payload section has been deployed successfully.\n       This speeds up the customizing process in case the customizer pod\n       is restarted.\n\n    Args:\n        success (bool): True if the section was processed successful, False otherwise.\n        payload_section_name (str): name of the payload section\n        payload_section (list): payload section content - this is written as JSon into the file\n        payload_specific (bool): whether or not the success should be specific for\n                                 each payload file or if success is \"global\" - like for the deletion\n                                 of the existing M365 teams (which we don't want to execute per\n                                 payload file)\n    Returns:\n        bool: True if the status file as been upladed to Extended ECM successfully, False otherwise\n    \"\"\"\n\n    if success:\n        logger.info(\n            \"Payload section -&gt; %s has been completed successfully!\",\n            payload_section_name,\n        )\n        prefix = \"success_\"\n    else:\n        logger.error(\n            \"Payload section -&gt; %s had failures!\",\n            payload_section_name,\n        )\n        prefix = \"failure_\"\n\n    response = self._otcs.get_node_by_volume_and_path(\n        142\n    )  # write to Personal Workspace of Admin (with Volume Type ID = 142)\n    target_folder_id = self._otcs.get_result_value(response, \"id\")\n    if not target_folder_id:\n        target_folder_id = 2004  # use Personal Workspace of Admin as fallback\n\n    file_name = self.get_status_file_name(\n        payload_section_name=payload_section_name,\n        payload_specific=payload_specific,\n        prefix=prefix,\n    )\n\n    full_path = \"/tmp/\" + file_name\n\n    with open(full_path, mode=\"w\", encoding=\"utf-8\") as localfile:\n        localfile.write(json.dumps(payload_section, indent=2))\n\n    # Check if the status file has been uploaded before.\n    # This can happen if we re-run the python container.\n    # In this case we add a version to the existing document:\n    response = self._otcs.get_node_by_parent_and_name(\n        parent_id=int(target_folder_id), name=file_name, show_error=False\n    )\n    target_document_id = self._otcs.get_result_value(response, \"id\")\n    if target_document_id:\n        response = self._otcs.add_document_version(\n            node_id=int(target_document_id),\n            file_url=full_path,\n            file_name=file_name,\n            mime_type=\"text/plain\",\n            description=\"Updated status file after re-run of customization\",\n        )\n    else:\n        response = self._otcs.upload_file_to_parent(\n            file_url=full_path,\n            file_name=file_name,\n            mime_type=\"text/plain\",\n            parent_id=int(target_folder_id),\n        )\n\n    if response:\n        logger.info(\n            \"Status file -&gt; %s has been written to Personal Workspace of admin user\",\n            file_name,\n        )\n        return True\n\n    logger.error(\n        \"Failed to write status file -&gt; %s to Personal Workspace of admin user\",\n        file_name,\n    )\n\n    return False\n</code></pre>"},{"location":"pyxecm/salesforce/","title":"Salesforce","text":"<p>Salesforce Module to interact with the Salesforce API</p> <p>Class: Salesforce Methods:</p> <p>init : class initializer config : Returns config data set credentials: Returns the token data request_header: Returns the request header for Salesforce API calls parse_request_response: Parse the REST API responses and convert                         them to Python dict in a safe way exist_result_item: Check if an dict item is in the response                    of the Salesforce API call get_result_value: Check if a defined value (based on a key) is in the Salesforce API response</p> <p>authenticate : Authenticates at Salesforce API</p> <p>get_user: Get a Salesforce user based on its ID. add_user: Add a new Salesforce user.</p> Get a Salesforce object based on a defined <p>field value and return selected result fields.</p> <p>add_object: Add object to Salesforce. This is a generic wrapper method             for the actual add methods. add_account: Add a new Account object to Salesforce. add_product: Add a new Product object to Salesforce. add_opportunity: Add a new Opportunity object to Salesfoce. add_case: Add a new Case object to Salesforce. The case number           is automatically created and can not be provided. add_asset: Add a new Asset object to Salesforce. add_contract: Add a new Contract object to Salesforce.</p>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce","title":"<code>Salesforce</code>","text":"<p>             Bases: <code>object</code></p> <p>Used to retrieve and automate stettings in Salesforce.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>class Salesforce(object):\n    \"\"\"Used to retrieve and automate stettings in Salesforce.\"\"\"\n\n    _config: dict\n    _access_token = None\n    _instance_url = None\n\n    def __init__(\n        self,\n        base_url: str,\n        client_id: str,\n        client_secret: str,\n        username: str,\n        password: str,\n        authorization_url: str = \"\",\n        security_token: str = \"\",\n    ):\n        \"\"\"Initialize the Salesforce object\n\n        Args:\n            base_url (str): base URL of the Salesforce tenant\n            authorization_url (str): authorization URL of the Salesforce tenant, typically ending with \"/services/oauth2/token\"\n            client_id (str): Salesforce Client ID\n            client_secret (str): Salesforce Client Secret\n            username (str): user name in Saleforce\n            password (str): password of the user\n            authorization_url (str, optional): URL for Salesforce login. If not given it will be constructed with default values\n                                               using base_url\n            security_token (str, optional): security token for Salesforce login\n        \"\"\"\n\n        salesforce_config = {}\n\n        # Set the authentication endpoints and credentials\n        salesforce_config[\"baseUrl\"] = base_url\n        salesforce_config[\"clientId\"] = client_id\n        salesforce_config[\"clientSecret\"] = client_secret\n        salesforce_config[\"username\"] = username\n        salesforce_config[\"password\"] = password\n        salesforce_config[\"securityToken\"] = security_token\n        if authorization_url:\n            salesforce_config[\"authenticationUrl\"] = authorization_url\n        else:\n            salesforce_config[\"authenticationUrl\"] = (\n                salesforce_config[\"baseUrl\"] + \"/services/oauth2/token\"\n            )\n\n        # Set the data for the token request\n        salesforce_config[\"authenticationData\"] = {\n            \"grant_type\": \"password\",\n            \"client_id\": client_id,\n            \"client_secret\": client_secret,\n            \"username\": username,\n            \"password\": password,\n        }\n\n        self._config = salesforce_config\n\n    def config(self) -&gt; dict:\n        \"\"\"Returns the configuration dictionary\n\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\n        return self._config\n\n    # end method definition\n\n    def credentials(self) -&gt; dict:\n        \"\"\"Return the login credentials\n\n        Returns:\n            dict: dictionary with login credentials for Salesforce\n        \"\"\"\n        return self.config()[\"authenticationData\"]\n\n    # end method definition\n\n    def request_header(self, content_type: str = \"application/json\") -&gt; dict:\n        \"\"\"Returns the request header used for Application calls.\n           Consists of Bearer access token and Content Type\n\n        Args:\n            content_type (str, optional): content type for the request\n        Return:\n            dict: request header values\n        \"\"\"\n\n        request_header = {\n            \"Authorization\": \"Bearer {}\".format(self._access_token),\n            \"Content-Type\": content_type,\n        }\n        return request_header\n\n    # end method definition\n\n    def parse_request_response(\n        self,\n        response_object: requests.Response,\n        additional_error_message: str = \"\",\n        show_error: bool = True,\n    ) -&gt; dict | None:\n        \"\"\"Converts the request response (JSon) to a Python dict in a safe way\n           that also handles exceptions. It first tries to load the response.text\n           via json.loads() that produces a dict output. Only if response.text is\n           not set or is empty it just converts the response_object to a dict using\n           the vars() built-in method.\n\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str, optional): use a more specific error message\n                                                      in case of an error\n            show_error (bool): True: write an error to the log file\n                               False: write a warning to the log file\n        Returns:\n            dict: response information or None in case of an error\n        \"\"\"\n\n        if not response_object:\n            return None\n\n        try:\n            if response_object.text:\n                dict_object = json.loads(response_object.text)\n            else:\n                dict_object = vars(response_object)\n        except json.JSONDecodeError as exception:\n            if additional_error_message:\n                message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                    additional_error_message, exception\n                )\n            else:\n                message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                    exception\n                )\n            if show_error:\n                logger.error(message)\n            else:\n                logger.warning(message)\n            return None\n        else:\n            return dict_object\n\n    # end method definition\n\n    def exist_result_item(self, response: dict, key: str, value: str) -&gt; bool:\n        \"\"\"Check existence of key / value pair in the response properties of an Salesforce API call.\n\n        Args:\n            response (dict): REST response from an Salesforce API call\n            key (str): property name (key)\n            value (str): value to find in the item with the matching key\n        Returns:\n            bool: True if the value was found, False otherwise\n        \"\"\"\n\n        if not response:\n            return False\n\n        if \"records\" in response:\n            records = response[\"records\"]\n            if not records or not isinstance(records, list):\n                return False\n\n            for record in records:\n                if value == record[key]:\n                    return True\n        else:\n            if not key in response:\n                return False\n            if value == response[key]:\n                return True\n\n        return False\n\n    # end method definition\n\n    def get_result_value(\n        self,\n        response: dict,\n        key: str,\n        index: int = 0,\n    ) -&gt; str | None:\n        \"\"\"Get value of a result property with a given key of an Salesforce API call.\n\n        Args:\n            response (dict): REST response from an Salesforce REST Call\n            key (str): property name (key)\n            index (int, optional): Index to use (1st element has index 0).\n                                   Defaults to 0.\n        Returns:\n            str: value for the key, None otherwise\n        \"\"\"\n\n        if not response:\n            return None\n\n        # do we have a complex response - e.g. from an SOQL query?\n        # these have list of \"records\":\n        if \"records\" in response:\n            values = response[\"records\"]\n            if not values or not isinstance(values, list) or len(values) - 1 &lt; index:\n                return None\n            value = values[index][key]\n        else:  # simple response - try to find key in response directly:\n            if not key in response:\n                return None\n            value = response[key]\n\n        return value\n\n    # end method definition\n\n    def authenticate(self, revalidate: bool = False) -&gt; str | None:\n        \"\"\"Authenticate at Salesforce with client ID and client secret.\n\n        Args:\n            revalidate (bool, optional): determinse if a re-athentication is enforced\n                                         (e.g. if session has timed out with 401 error)\n        Returns:\n            str: Access token. Also stores access token in self._access_token. None in case of error\n        \"\"\"\n\n        # Already authenticated and session still valid?\n        if self._access_token and not revalidate:\n            logger.info(\n                \"Session still valid - return existing access token -&gt; %s\",\n                str(self._access_token),\n            )\n            return self._access_token\n\n        request_url = self.config()[\"authenticationUrl\"]\n        request_header = request_login_headers\n\n        logger.info(\"Requesting Salesforce Access Token from -&gt; %s\", request_url)\n\n        authenticate_post_body = self.credentials()\n\n        response = None\n        self._access_token = None\n        self._instance_url = None\n\n        try:\n            response = requests.post(\n                request_url,\n                data=authenticate_post_body,\n                headers=request_header,\n                timeout=REQUEST_TIMEOUT,\n            )\n        except requests.exceptions.ConnectionError as exception:\n            logger.warning(\n                \"Unable to connect to -&gt; %s : %s\",\n                self.config()[\"authenticationUrl\"],\n                exception,\n            )\n            return None\n\n        if response.ok:\n            authenticate_dict = self.parse_request_response(response)\n            if not authenticate_dict:\n                return None\n            else:\n                # Store authentication access_token:\n                self._access_token = authenticate_dict[\"access_token\"]\n                logger.debug(\"Access Token -&gt; %s\", self._access_token)\n                self._instance_url = authenticate_dict[\"instance_url\"]\n                logger.debug(\"Instance URL -&gt; %s\", self._instance_url)\n        else:\n            logger.error(\n                \"Failed to request an Salesforce Access Token; error -&gt; %s\",\n                response.text,\n            )\n            return None\n\n        return self._access_token\n\n    # end method definition\n\n    def get_object_id_by_name(\n        self, object_type: str, name: str, name_field: str = \"Name\"\n    ) -&gt; Optional[str]:\n        \"\"\"Get the ID of a given Salesforce object with a given type and name.\n\n        Args:\n            object_type (str): Sales object type, like \"Account\", \"Case\", ...\n            name (str): Name of the Salesforce object.\n            name_field (str, optional): Field where the name is stored. Defaults to \"Name\".\n\n        Returns:\n            Optional[str]: Object ID or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/query/\"\n\n        query = f\"SELECT Id FROM {object_type} WHERE {name_field} = '{name}'\"\n\n        retries = 0\n        while True:\n            response = requests.get(\n                request_url,\n                headers=request_header,\n                params={\"q\": query},\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                response = self.parse_request_response(response)\n                object_id = self.get_result_value(response, \"Id\")\n                return object_id\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get Salesforce object ID for object type -&gt; %s and object name -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    object_type,\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_profile_id(self, profile_name: str) -&gt; Optional[str]:\n        \"\"\"Get a user profile ID by profile name.\n\n        Args:\n            profile_name (str): Name of the User Profile.\n\n        Returns:\n            Optional[str]: Technical ID of the user profile.\n        \"\"\"\n\n        return self.get_object_id_by_name(object_type=\"Profile\", name=profile_name)\n\n    # end method definition\n\n    def get_user_id(self, username: str) -&gt; Optional[str]:\n        \"\"\"Get a user ID by user name.\n\n        Args:\n            username (str): Name of the User.\n\n        Returns:\n            Optional[str]: Technical ID of the user\n        \"\"\"\n\n        return self.get_object_id_by_name(\n            object_type=\"User\", name=username, name_field=\"Username\"\n        )\n\n    # end method definition\n\n    def get_object(\n        self,\n        object_type: str,\n        search_field: str,\n        search_value: str,\n        result_fields: list | None,\n        limit: int = 200,\n    ) -&gt; dict | None:\n        \"\"\"Get a Salesforce object based on a defined field value and return selected result fields.\n\n        Args:\n            object_type (str): Salesforce Business Object type. Such as \"Account\" or \"Case\".\n            search_field (str): object field to search in\n            search_value (str): value to search for\n            result_fields (list | None): list of fields to return. If None, then all standard fields\n                                         of the object will be returned.\n            limit (int, optional): maximum number of fields to return. Salesforce enforces 200 as upper limit.\n\n        Returns:\n            dict | None: Dictionary with the Salesforce object data.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n        if search_field and not search_value:\n            logger.error(\n                \"No search value has been provided for search field -&gt; %s!\",\n                search_field,\n            )\n            return None\n        if not result_fields:\n            logger.info(\n                \"No result fields defined. Using 'FIELDS(STANDARD)' to deliver all standard fields of the object.\"\n            )\n            result_fields = [\"FIELDS(STANDARD)\"]\n\n        query = \"SELECT {} FROM {}\".format(\", \".join(result_fields), object_type)\n        if search_field and search_value:\n            query += \" WHERE {}='{}'\".format(search_field, search_value)\n        query += \" LIMIT {}\".format(str(limit))\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/query/?q={query}\"\n\n        logger.info(\n            \"Sending query -&gt; %s to Salesforce; calling -&gt; %s\", query, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(request_url, headers=request_header, timeout=30)\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to retrieve Salesforce object -&gt; %s with %s = %s; status -&gt; %s; error -&gt; %s\",\n                    object_type,\n                    search_field,\n                    search_value,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_object(self, object_type: str, **kwargs: Any) -&gt; dict | None:\n        \"\"\"Add object to Salesforce. This is a generic wrapper method\n           for the actual add methods.\n\n        Args:\n            object_type (str): Type of the Salesforce business object, like \"Account\" or \"Case\".\n\n        Returns:\n            dict | None: Dictionary with the Salesforce Case data or None if the request fails.\n        \"\"\"\n\n        match object_type:\n            case \"Account\":\n                return self.add_account(\n                    account_name=kwargs.pop(\"AccountName\", None),\n                    account_number=kwargs.pop(\"AccountNumber\", None),\n                    account_type=kwargs.pop(\"Type\", None),\n                    description=kwargs.pop(\"Description\", None),\n                    industry=kwargs.pop(\"Industry\", None),\n                    website=kwargs.pop(\"Website\", None),\n                    phone=kwargs.pop(\"Phone\", None),\n                    **kwargs,\n                )\n            case \"Product\":\n                return self.add_product(\n                    product_name=kwargs.pop(\"Name\", None),\n                    product_code=kwargs.pop(\"ProductCode\", None),\n                    description=kwargs.pop(\"Description\", None),\n                    price=kwargs.pop(\"Price\", None),\n                    **kwargs,\n                )\n            case \"Opportunity\":\n                return self.add_opportunity(\n                    name=kwargs.pop(\"Name\", None),\n                    stage=kwargs.pop(\"StageName\", None),\n                    close_date=kwargs.pop(\"CloseDate\", None),\n                    amount=kwargs.pop(\"Amount\", None),\n                    account_id=kwargs.pop(\"AccountId\", None),\n                    description=kwargs.pop(\"Description\", None),\n                    **kwargs,\n                )\n            case \"Case\":\n                return self.add_case(\n                    subject=kwargs.pop(\"Subject\", None),\n                    description=kwargs.pop(\"Description\", None),\n                    status=kwargs.pop(\"Status\", None),\n                    priority=kwargs.pop(\"Priority\", None),\n                    origin=kwargs.pop(\"Origin\", None),\n                    account_id=kwargs.pop(\"AccountId\", None),\n                    owner_id=kwargs.pop(\"OwnerId\", None),\n                    asset_id=kwargs.pop(\"AssetId\", None),\n                    product_id=kwargs.pop(\"ProductId\", None),\n                    **kwargs,\n                )\n            case \"Contract\":\n                return self.add_contract(\n                    account_id=kwargs.pop(\"AccountId\", None),\n                    start_date=kwargs.pop(\"ContractStartDate\", None),\n                    contract_term=kwargs.pop(\"ContractTerm\", None),\n                    status=kwargs.pop(\"Status\", None),\n                    description=kwargs.pop(\"Description\", None),\n                    contract_type=kwargs.pop(\"ContractType\", None),\n                    **kwargs,\n                )\n            case \"Asset\":\n                return self.add_asset(\n                    asset_name=kwargs.pop(\"Name\", None),\n                    product_id=kwargs.pop(\"Product\", None),\n                    serial_number=kwargs.pop(\"SerialNumber\", None),\n                    status=kwargs.pop(\"Status\", None),\n                    purchase_date=kwargs.pop(\"PurchaseDate\", None),\n                    install_date=kwargs.pop(\"InstallDate\", None),\n                    description=kwargs.pop(\"AssetDescription\", None),\n                    **kwargs,\n                )\n            case _:\n                logger.error(\n                    \"Unsupported Salesforce business object -&gt; %s!\",\n                    object_type,\n                )\n\n    # end method definition\n\n    def get_user(self, user_id: str) -&gt; dict | None:\n        \"\"\"Get a Salesforce user based on its ID.\n\n        Args:\n            user_id (str): ID of the Salesforce user\n\n        Returns:\n            dict | None: Dictionary with the Salesforce user data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = (\n            f\"{self._instance_url}/services/data/v52.0/sobjects/User/{user_id}\"\n        )\n\n        logger.info(\n            \"Get Salesforce user with ID -&gt; %s; calling -&gt; %s\", user_id, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.get(\n                request_url, headers=request_header, timeout=REQUEST_TIMEOUT\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get Salesforce user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    user_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def get_all_user_profiles(self) -&gt; dict | None:\n        \"\"\"Get all user profiles\n\n        Returns:\n            dict | None: Dictionary with salesforce user profiles.\n\n            Example response:\n            {\n                'totalSize': 15,\n                'done': True,\n                'records': [\n                    {\n                        ...\n                        'attributes': {\n                            'type': 'Profile',\n                            'url': '/services/data/v52.0/sobjects/Profile/00eDn000001msL8IAI'},\n                            'Id': '00eDn000001msL8IAI',\n                            'Name': 'Standard User',\n                            'CreatedById':\n                            '005Dn000001rRodIAE',\n                            'CreatedDate': '2022-11-30T15:30:54.000+0000',\n                            'Description': None,\n                            'LastModifiedById': '005Dn000001rUacIAE',\n                            'LastModifiedDate': '2024-02-08T17:46:17.000+0000',\n                            'PermissionsCustomizeApplication': False,\n                            'PermissionsEditTask': True,\n                            'PermissionsImportLeads': False\n                        }\n                    }, ...\n                ]\n            }\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/query/\"\n\n        query = \"SELECT Id, Name, CreatedById, CreatedDate, Description, LastModifiedById, LastModifiedDate, PermissionsCustomizeApplication, PermissionsEditTask, PermissionsImportLeads FROM Profile\"\n\n        retries = 0\n        while True:\n            response = requests.get(\n                request_url,\n                headers=request_header,\n                params={\"q\": query},\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to get Salesforce user profiles; status -&gt; %s; error -&gt; %s\",\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_user(\n        self,\n        username: str,\n        email: str,\n        password: str,\n        firstname: str,\n        lastname: str,\n        profile_id: Optional[str] = None,\n        alias: Optional[str] = None,\n    ) -&gt; dict | None:\n        \"\"\"Add a new Salesforce user.\n\n        Args:\n            username (str): Login name of the new user\n            email (str): Email of the new user\n            password (str): Password of the new user\n            firstname (str): First name of the new user.\n            lastname (str): Last name of the new user.\n            profile_id (str, optional): Profile ID of the new user. Defaults to None.\n                                        Use method get_all_user_profiles() to determine\n                                        the desired Profile for the user.\n            alias (str, optional): Alias of the new user. Defaults to None.\n\n        Returns:\n            dict | None: Dictionary with the Salesforce User data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/User/\"\n\n        payload = {\n            \"Username\": username,\n            \"Email\": email,\n            \"Password\": password,\n            \"FirstName\": firstname,\n            \"LastName\": lastname,\n            \"ProfileId\": profile_id,\n            \"Alias\": alias,\n        }\n\n        logger.info(\n            \"Adding Salesforce user -&gt; %s; calling -&gt; %s\", username, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(payload),\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Salesforce user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    username,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_account(\n        self,\n        account_name: str,\n        account_number: str,\n        account_type: str = \"Customer\",\n        description: Optional[str] = None,\n        industry: Optional[str] = None,\n        website: Optional[str] = None,\n        phone: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; dict | None:\n        \"\"\"Add a new Account object to Salesforce.\n\n        Args:\n            account_name (str): Name of the new Salesforce account.\n            account_number (str): Number of the new Salesforce account (this is a logical number, not the technical ID)\n            account_type (str): Type of the Salesforce account. Typical values are \"Customer\" or \"Prospect\".\n            description(str, optional): Description of the new Salesforce account.\n            industry (str, optional): Industry of the new Salesforce account. Defaults to None.\n            website (str, optional): Website of the new Salesforce account. Defaults to None.\n            phone (str, optional): Phone number of the new Salesforce account. Defaults to None.\n            kwargs (Any): Additional values (e.g. custom fields)\n\n        Returns:\n            dict | None: Dictionary with the Salesforce Account data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Account/\"\n\n        payload = {\n            \"Name\": account_name,\n            \"AccountNumber\": account_number,\n            \"Type\": account_type,\n            \"Industry\": industry,\n            \"Description\": description,\n            \"Website\": website,\n            \"Phone\": phone,\n        }\n        payload.update(kwargs)  # Add additional fields from kwargs\n\n        logger.info(\n            \"Adding Salesforce account -&gt; %s; calling -&gt; %s\", account_name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(payload),\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Salesforce account -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    account_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_product(\n        self,\n        product_name: str,\n        product_code: str,\n        description: str,\n        price: float,\n        **kwargs: Any,\n    ) -&gt; dict | None:\n        \"\"\"Add a new Product object to Salesforce.\n\n        Args:\n            product_name (str): Name of the Salesforce Product.\n            product_code (str): Code of the Salesforce Product.\n            description (str): Description of the Salesforce Product.\n            price (float): Price of the Salesforce Product.\n\n        Returns:\n            dict | None: Dictionary with the Salesforce Product data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Product2/\"\n\n        payload = {\n            \"Name\": product_name,\n            \"ProductCode\": product_code,\n            \"Description\": description,\n            \"Price__c\": price,\n        }\n        payload.update(kwargs)  # Add additional fields from kwargs\n\n        logger.info(\n            \"Add Salesforce product -&gt; %s; calling -&gt; %s\", product_name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(payload),\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Salesforce product -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    product_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_opportunity(\n        self,\n        name: str,\n        stage: str,\n        close_date: str,\n        amount: Union[int, float],\n        account_id: str,\n        description: str = None,\n        **kwargs: Any,\n    ) -&gt; dict | None:\n        \"\"\"Add a new Opportunity object to Salesfoce.\n\n        Args:\n            name (str): Name of the Opportunity.\n            stage (str): Stage of the Opportunity. Typical Value:\n                         \"Prospecting\", \"Qualification\", \"Value Proposition\", \"Negotiation/Review\",\n                         \"Closed Won\", \"Closed Lost\"\n            close_date (str): Close date of the Opportunity. Should be in format YYYY-MM-DD.\n            amount (Union[int, float]): Amount (expected revenue) of the opportunity.\n                                        Can either be an integer or a float value.\n            account_id (str): Technical ID of the related Salesforce Account.\n\n        Returns:\n            dict | None: Dictionary with the Salesforce Opportunity data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Opportunity/\"\n\n        payload = {\n            \"Name\": name,\n            \"StageName\": stage,\n            \"CloseDate\": close_date,\n            \"Amount\": amount,\n            \"AccountId\": account_id,\n        }\n        if description:\n            payload[\"Description\"] = description\n        payload.update(kwargs)  # Add additional fields from kwargs\n\n        logger.info(\n            \"Add Salesforce opportunity -&gt; %s; calling -&gt; %s\", name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(payload),\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Salesforce opportunity -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    def add_case(\n        self,\n        subject: str,\n        description: str,\n        status: str,\n        priority: str,\n        origin: str,\n        account_id: str,\n        owner_id: str,\n        asset_id: Optional[str] = None,\n        product_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; dict | None:\n        \"\"\"Add a new Case object to Salesforce. The case number is automatically created and can not be\n           provided.\n\n        Args:\n            subject (str): Subject (title) of the case. It's like the name.\n            description (str): Description of the case\n            status (str): Status of the case. Typecal values: \"New\", \"On Hold\", \"Escalated\"\n            priority (str): Priority of the case. Typical values: \"High\", \"Medium\", \"Low\".\n            origin (str): origin (source) of the case. Typical values: \"Email\", \"Phone\", \"Web\"\n            account_id (str): technical ID of the related Account\n            asset_id (str): technical ID of the related Asset\n            product_id (str): technical ID of the related Product\n            kwargs (Any): additional values (e.g. custom fields)\n\n        Returns:\n            dict | None: Dictionary with the Salesforce Case data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Case/\"\n\n        payload = {\n            \"Subject\": subject,\n            \"Description\": description,\n            \"Status\": status,\n            \"Priority\": priority,\n            \"Origin\": origin,\n            \"AccountId\": account_id,\n            \"OwnerId\": owner_id,\n        }\n\n        if asset_id:\n            payload[\"AssetId\"] = asset_id\n        if product_id:\n            payload[\"ProductId\"] = product_id\n        payload.update(kwargs)  # Add additional fields from kwargs\n\n        logger.info(\"Add Salesforce case -&gt; %s; calling -&gt; %s\", subject, request_url)\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(payload),\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Salesforce case -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    subject,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_asset(\n        self,\n        asset_name: str,\n        product_id: str,\n        serial_number: str,\n        status: str,\n        purchase_date: str,\n        install_date: str,\n        description: str | None = None,\n        **kwargs: Any,\n    ) -&gt; dict | None:\n        \"\"\"Add a new Asset object to Salesforce.\n\n        Args:\n            asset_name (str): Name of the Asset.\n            product_id (str): Related Product ID.\n            serial_number (str): Serial Number of the Asset.\n            status (str): Status of the Asset. Typical values are \"Purchased\", \"Shipped\", \"Installed\", \"Registered\", \"Obsolete\"\n            purchase_date (str): Purchase date of the Asset.\n            install_date (str): Install date of the Asset.\n            description (str): Description of the Asset.\n            kwargs (Any): Additional values (e.g. custom fields)\n\n        Returns:\n            dict | None: Dictionary with the Salesforce Asset data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Asset/\"\n\n        payload = {\n            \"Name\": asset_name,\n            \"ProductId\": product_id,\n            \"SerialNumber\": serial_number,\n            \"Status\": status,\n            \"PurchaseDate\": purchase_date,\n            \"InstallDate\": install_date,\n        }\n        if description:\n            payload[\"Description\"] = description\n        payload.update(kwargs)  # Add additional fields from kwargs\n\n        logger.info(\n            \"Add Salesforce asset -&gt; %s; calling -&gt; %s\", asset_name, request_url\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(payload),\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Salesforce user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    asset_name,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n\n    # end method definition\n\n    def add_contract(\n        self,\n        account_id: str,\n        start_date: str,\n        contract_term: int,\n        status: str = \"Draft\",\n        description: Optional[str] = None,\n        contract_type: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; dict | None:\n        \"\"\"Add a new Contract object to Salesforce.\n\n        Args:\n            account_id (str): Technical ID of the related Salesforce Account object.\n            start_date (str): Start date of the Contract. Use YYYY-MM-DD notation.\n            contract_term (int): Term of the Contract in number of months, e.g. 48 for 4 years term.\n                                 The end date of the contract will be calculated from start date + term.\n            contract_type (str): Type of the Contract. Typical values are \"Subscription\",\n                                 \"Maintenance\", \"Support\", \"Lease\", or \"Service\".\n            status (str): Status of the Contract. Typical values are \"Draft\", \"Activated\", or \"In Approval Process\"\n\n        Returns:\n            dict | None: Dictionary with the Salesforce user data or None if the request fails.\n        \"\"\"\n\n        if not self._access_token or not self._instance_url:\n            logger.error(\"Authentication required.\")\n            return None\n\n        request_header = self.request_header()\n        request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Contract/\"\n\n        payload = {\n            \"AccountId\": account_id,\n            \"StartDate\": start_date,\n            \"ContractTerm\": contract_term,\n            \"Status\": status,\n        }\n        if description:\n            payload[\"Description\"] = description\n        if contract_type:\n            payload[\"ContractType\"] = contract_type\n        payload.update(kwargs)  # Add additional fields from kwargs\n\n        logger.info(\n            \"Adding Salesforce contract for account ID -&gt; %s; calling -&gt; %s\",\n            account_id,\n            request_url,\n        )\n\n        retries = 0\n        while True:\n            response = requests.post(\n                request_url,\n                headers=request_header,\n                data=json.dumps(payload),\n                timeout=REQUEST_TIMEOUT,\n            )\n            if response.ok:\n                return self.parse_request_response(response)\n            elif response.status_code == 401 and retries == 0:\n                logger.warning(\"Session has expired - try to re-authenticate...\")\n                self.authenticate(revalidate=True)\n                request_header = self.request_header()\n                retries += 1\n            else:\n                logger.error(\n                    \"Failed to add Salesforce contract for account ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                    account_id,\n                    response.status_code,\n                    response.text,\n                )\n                return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.__init__","title":"<code>__init__(base_url, client_id, client_secret, username, password, authorization_url='', security_token='')</code>","text":"<p>Initialize the Salesforce object</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>base URL of the Salesforce tenant</p> required <code>authorization_url</code> <code>str</code> <p>authorization URL of the Salesforce tenant, typically ending with \"/services/oauth2/token\"</p> <code>''</code> <code>client_id</code> <code>str</code> <p>Salesforce Client ID</p> required <code>client_secret</code> <code>str</code> <p>Salesforce Client Secret</p> required <code>username</code> <code>str</code> <p>user name in Saleforce</p> required <code>password</code> <code>str</code> <p>password of the user</p> required <code>authorization_url</code> <code>str</code> <p>URL for Salesforce login. If not given it will be constructed with default values                                using base_url</p> <code>''</code> <code>security_token</code> <code>str</code> <p>security token for Salesforce login</p> <code>''</code> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def __init__(\n    self,\n    base_url: str,\n    client_id: str,\n    client_secret: str,\n    username: str,\n    password: str,\n    authorization_url: str = \"\",\n    security_token: str = \"\",\n):\n    \"\"\"Initialize the Salesforce object\n\n    Args:\n        base_url (str): base URL of the Salesforce tenant\n        authorization_url (str): authorization URL of the Salesforce tenant, typically ending with \"/services/oauth2/token\"\n        client_id (str): Salesforce Client ID\n        client_secret (str): Salesforce Client Secret\n        username (str): user name in Saleforce\n        password (str): password of the user\n        authorization_url (str, optional): URL for Salesforce login. If not given it will be constructed with default values\n                                           using base_url\n        security_token (str, optional): security token for Salesforce login\n    \"\"\"\n\n    salesforce_config = {}\n\n    # Set the authentication endpoints and credentials\n    salesforce_config[\"baseUrl\"] = base_url\n    salesforce_config[\"clientId\"] = client_id\n    salesforce_config[\"clientSecret\"] = client_secret\n    salesforce_config[\"username\"] = username\n    salesforce_config[\"password\"] = password\n    salesforce_config[\"securityToken\"] = security_token\n    if authorization_url:\n        salesforce_config[\"authenticationUrl\"] = authorization_url\n    else:\n        salesforce_config[\"authenticationUrl\"] = (\n            salesforce_config[\"baseUrl\"] + \"/services/oauth2/token\"\n        )\n\n    # Set the data for the token request\n    salesforce_config[\"authenticationData\"] = {\n        \"grant_type\": \"password\",\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"username\": username,\n        \"password\": password,\n    }\n\n    self._config = salesforce_config\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_account","title":"<code>add_account(account_name, account_number, account_type='Customer', description=None, industry=None, website=None, phone=None, **kwargs)</code>","text":"<p>Add a new Account object to Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>account_name</code> <code>str</code> <p>Name of the new Salesforce account.</p> required <code>account_number</code> <code>str</code> <p>Number of the new Salesforce account (this is a logical number, not the technical ID)</p> required <code>account_type</code> <code>str</code> <p>Type of the Salesforce account. Typical values are \"Customer\" or \"Prospect\".</p> <code>'Customer'</code> <code>description(str,</code> <code>optional</code> <p>Description of the new Salesforce account.</p> required <code>industry</code> <code>str</code> <p>Industry of the new Salesforce account. Defaults to None.</p> <code>None</code> <code>website</code> <code>str</code> <p>Website of the new Salesforce account. Defaults to None.</p> <code>None</code> <code>phone</code> <code>str</code> <p>Phone number of the new Salesforce account. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional values (e.g. custom fields)</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce Account data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_account(\n    self,\n    account_name: str,\n    account_number: str,\n    account_type: str = \"Customer\",\n    description: Optional[str] = None,\n    industry: Optional[str] = None,\n    website: Optional[str] = None,\n    phone: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict | None:\n    \"\"\"Add a new Account object to Salesforce.\n\n    Args:\n        account_name (str): Name of the new Salesforce account.\n        account_number (str): Number of the new Salesforce account (this is a logical number, not the technical ID)\n        account_type (str): Type of the Salesforce account. Typical values are \"Customer\" or \"Prospect\".\n        description(str, optional): Description of the new Salesforce account.\n        industry (str, optional): Industry of the new Salesforce account. Defaults to None.\n        website (str, optional): Website of the new Salesforce account. Defaults to None.\n        phone (str, optional): Phone number of the new Salesforce account. Defaults to None.\n        kwargs (Any): Additional values (e.g. custom fields)\n\n    Returns:\n        dict | None: Dictionary with the Salesforce Account data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Account/\"\n\n    payload = {\n        \"Name\": account_name,\n        \"AccountNumber\": account_number,\n        \"Type\": account_type,\n        \"Industry\": industry,\n        \"Description\": description,\n        \"Website\": website,\n        \"Phone\": phone,\n    }\n    payload.update(kwargs)  # Add additional fields from kwargs\n\n    logger.info(\n        \"Adding Salesforce account -&gt; %s; calling -&gt; %s\", account_name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(payload),\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Salesforce account -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                account_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_asset","title":"<code>add_asset(asset_name, product_id, serial_number, status, purchase_date, install_date, description=None, **kwargs)</code>","text":"<p>Add a new Asset object to Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>asset_name</code> <code>str</code> <p>Name of the Asset.</p> required <code>product_id</code> <code>str</code> <p>Related Product ID.</p> required <code>serial_number</code> <code>str</code> <p>Serial Number of the Asset.</p> required <code>status</code> <code>str</code> <p>Status of the Asset. Typical values are \"Purchased\", \"Shipped\", \"Installed\", \"Registered\", \"Obsolete\"</p> required <code>purchase_date</code> <code>str</code> <p>Purchase date of the Asset.</p> required <code>install_date</code> <code>str</code> <p>Install date of the Asset.</p> required <code>description</code> <code>str</code> <p>Description of the Asset.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional values (e.g. custom fields)</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce Asset data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_asset(\n    self,\n    asset_name: str,\n    product_id: str,\n    serial_number: str,\n    status: str,\n    purchase_date: str,\n    install_date: str,\n    description: str | None = None,\n    **kwargs: Any,\n) -&gt; dict | None:\n    \"\"\"Add a new Asset object to Salesforce.\n\n    Args:\n        asset_name (str): Name of the Asset.\n        product_id (str): Related Product ID.\n        serial_number (str): Serial Number of the Asset.\n        status (str): Status of the Asset. Typical values are \"Purchased\", \"Shipped\", \"Installed\", \"Registered\", \"Obsolete\"\n        purchase_date (str): Purchase date of the Asset.\n        install_date (str): Install date of the Asset.\n        description (str): Description of the Asset.\n        kwargs (Any): Additional values (e.g. custom fields)\n\n    Returns:\n        dict | None: Dictionary with the Salesforce Asset data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Asset/\"\n\n    payload = {\n        \"Name\": asset_name,\n        \"ProductId\": product_id,\n        \"SerialNumber\": serial_number,\n        \"Status\": status,\n        \"PurchaseDate\": purchase_date,\n        \"InstallDate\": install_date,\n    }\n    if description:\n        payload[\"Description\"] = description\n    payload.update(kwargs)  # Add additional fields from kwargs\n\n    logger.info(\n        \"Add Salesforce asset -&gt; %s; calling -&gt; %s\", asset_name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(payload),\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Salesforce user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                asset_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_case","title":"<code>add_case(subject, description, status, priority, origin, account_id, owner_id, asset_id=None, product_id=None, **kwargs)</code>","text":"<p>Add a new Case object to Salesforce. The case number is automatically created and can not be    provided.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>Subject (title) of the case. It's like the name.</p> required <code>description</code> <code>str</code> <p>Description of the case</p> required <code>status</code> <code>str</code> <p>Status of the case. Typecal values: \"New\", \"On Hold\", \"Escalated\"</p> required <code>priority</code> <code>str</code> <p>Priority of the case. Typical values: \"High\", \"Medium\", \"Low\".</p> required <code>origin</code> <code>str</code> <p>origin (source) of the case. Typical values: \"Email\", \"Phone\", \"Web\"</p> required <code>account_id</code> <code>str</code> <p>technical ID of the related Account</p> required <code>asset_id</code> <code>str</code> <p>technical ID of the related Asset</p> <code>None</code> <code>product_id</code> <code>str</code> <p>technical ID of the related Product</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional values (e.g. custom fields)</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce Case data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_case(\n    self,\n    subject: str,\n    description: str,\n    status: str,\n    priority: str,\n    origin: str,\n    account_id: str,\n    owner_id: str,\n    asset_id: Optional[str] = None,\n    product_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict | None:\n    \"\"\"Add a new Case object to Salesforce. The case number is automatically created and can not be\n       provided.\n\n    Args:\n        subject (str): Subject (title) of the case. It's like the name.\n        description (str): Description of the case\n        status (str): Status of the case. Typecal values: \"New\", \"On Hold\", \"Escalated\"\n        priority (str): Priority of the case. Typical values: \"High\", \"Medium\", \"Low\".\n        origin (str): origin (source) of the case. Typical values: \"Email\", \"Phone\", \"Web\"\n        account_id (str): technical ID of the related Account\n        asset_id (str): technical ID of the related Asset\n        product_id (str): technical ID of the related Product\n        kwargs (Any): additional values (e.g. custom fields)\n\n    Returns:\n        dict | None: Dictionary with the Salesforce Case data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Case/\"\n\n    payload = {\n        \"Subject\": subject,\n        \"Description\": description,\n        \"Status\": status,\n        \"Priority\": priority,\n        \"Origin\": origin,\n        \"AccountId\": account_id,\n        \"OwnerId\": owner_id,\n    }\n\n    if asset_id:\n        payload[\"AssetId\"] = asset_id\n    if product_id:\n        payload[\"ProductId\"] = product_id\n    payload.update(kwargs)  # Add additional fields from kwargs\n\n    logger.info(\"Add Salesforce case -&gt; %s; calling -&gt; %s\", subject, request_url)\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(payload),\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Salesforce case -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                subject,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_contract","title":"<code>add_contract(account_id, start_date, contract_term, status='Draft', description=None, contract_type=None, **kwargs)</code>","text":"<p>Add a new Contract object to Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>str</code> <p>Technical ID of the related Salesforce Account object.</p> required <code>start_date</code> <code>str</code> <p>Start date of the Contract. Use YYYY-MM-DD notation.</p> required <code>contract_term</code> <code>int</code> <p>Term of the Contract in number of months, e.g. 48 for 4 years term.                  The end date of the contract will be calculated from start date + term.</p> required <code>contract_type</code> <code>str</code> <p>Type of the Contract. Typical values are \"Subscription\",                  \"Maintenance\", \"Support\", \"Lease\", or \"Service\".</p> <code>None</code> <code>status</code> <code>str</code> <p>Status of the Contract. Typical values are \"Draft\", \"Activated\", or \"In Approval Process\"</p> <code>'Draft'</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce user data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_contract(\n    self,\n    account_id: str,\n    start_date: str,\n    contract_term: int,\n    status: str = \"Draft\",\n    description: Optional[str] = None,\n    contract_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict | None:\n    \"\"\"Add a new Contract object to Salesforce.\n\n    Args:\n        account_id (str): Technical ID of the related Salesforce Account object.\n        start_date (str): Start date of the Contract. Use YYYY-MM-DD notation.\n        contract_term (int): Term of the Contract in number of months, e.g. 48 for 4 years term.\n                             The end date of the contract will be calculated from start date + term.\n        contract_type (str): Type of the Contract. Typical values are \"Subscription\",\n                             \"Maintenance\", \"Support\", \"Lease\", or \"Service\".\n        status (str): Status of the Contract. Typical values are \"Draft\", \"Activated\", or \"In Approval Process\"\n\n    Returns:\n        dict | None: Dictionary with the Salesforce user data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Contract/\"\n\n    payload = {\n        \"AccountId\": account_id,\n        \"StartDate\": start_date,\n        \"ContractTerm\": contract_term,\n        \"Status\": status,\n    }\n    if description:\n        payload[\"Description\"] = description\n    if contract_type:\n        payload[\"ContractType\"] = contract_type\n    payload.update(kwargs)  # Add additional fields from kwargs\n\n    logger.info(\n        \"Adding Salesforce contract for account ID -&gt; %s; calling -&gt; %s\",\n        account_id,\n        request_url,\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(payload),\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Salesforce contract for account ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                account_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_object","title":"<code>add_object(object_type, **kwargs)</code>","text":"<p>Add object to Salesforce. This is a generic wrapper method    for the actual add methods.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>Type of the Salesforce business object, like \"Account\" or \"Case\".</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce Case data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_object(self, object_type: str, **kwargs: Any) -&gt; dict | None:\n    \"\"\"Add object to Salesforce. This is a generic wrapper method\n       for the actual add methods.\n\n    Args:\n        object_type (str): Type of the Salesforce business object, like \"Account\" or \"Case\".\n\n    Returns:\n        dict | None: Dictionary with the Salesforce Case data or None if the request fails.\n    \"\"\"\n\n    match object_type:\n        case \"Account\":\n            return self.add_account(\n                account_name=kwargs.pop(\"AccountName\", None),\n                account_number=kwargs.pop(\"AccountNumber\", None),\n                account_type=kwargs.pop(\"Type\", None),\n                description=kwargs.pop(\"Description\", None),\n                industry=kwargs.pop(\"Industry\", None),\n                website=kwargs.pop(\"Website\", None),\n                phone=kwargs.pop(\"Phone\", None),\n                **kwargs,\n            )\n        case \"Product\":\n            return self.add_product(\n                product_name=kwargs.pop(\"Name\", None),\n                product_code=kwargs.pop(\"ProductCode\", None),\n                description=kwargs.pop(\"Description\", None),\n                price=kwargs.pop(\"Price\", None),\n                **kwargs,\n            )\n        case \"Opportunity\":\n            return self.add_opportunity(\n                name=kwargs.pop(\"Name\", None),\n                stage=kwargs.pop(\"StageName\", None),\n                close_date=kwargs.pop(\"CloseDate\", None),\n                amount=kwargs.pop(\"Amount\", None),\n                account_id=kwargs.pop(\"AccountId\", None),\n                description=kwargs.pop(\"Description\", None),\n                **kwargs,\n            )\n        case \"Case\":\n            return self.add_case(\n                subject=kwargs.pop(\"Subject\", None),\n                description=kwargs.pop(\"Description\", None),\n                status=kwargs.pop(\"Status\", None),\n                priority=kwargs.pop(\"Priority\", None),\n                origin=kwargs.pop(\"Origin\", None),\n                account_id=kwargs.pop(\"AccountId\", None),\n                owner_id=kwargs.pop(\"OwnerId\", None),\n                asset_id=kwargs.pop(\"AssetId\", None),\n                product_id=kwargs.pop(\"ProductId\", None),\n                **kwargs,\n            )\n        case \"Contract\":\n            return self.add_contract(\n                account_id=kwargs.pop(\"AccountId\", None),\n                start_date=kwargs.pop(\"ContractStartDate\", None),\n                contract_term=kwargs.pop(\"ContractTerm\", None),\n                status=kwargs.pop(\"Status\", None),\n                description=kwargs.pop(\"Description\", None),\n                contract_type=kwargs.pop(\"ContractType\", None),\n                **kwargs,\n            )\n        case \"Asset\":\n            return self.add_asset(\n                asset_name=kwargs.pop(\"Name\", None),\n                product_id=kwargs.pop(\"Product\", None),\n                serial_number=kwargs.pop(\"SerialNumber\", None),\n                status=kwargs.pop(\"Status\", None),\n                purchase_date=kwargs.pop(\"PurchaseDate\", None),\n                install_date=kwargs.pop(\"InstallDate\", None),\n                description=kwargs.pop(\"AssetDescription\", None),\n                **kwargs,\n            )\n        case _:\n            logger.error(\n                \"Unsupported Salesforce business object -&gt; %s!\",\n                object_type,\n            )\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_opportunity","title":"<code>add_opportunity(name, stage, close_date, amount, account_id, description=None, **kwargs)</code>","text":"<p>Add a new Opportunity object to Salesfoce.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Opportunity.</p> required <code>stage</code> <code>str</code> <p>Stage of the Opportunity. Typical Value:          \"Prospecting\", \"Qualification\", \"Value Proposition\", \"Negotiation/Review\",          \"Closed Won\", \"Closed Lost\"</p> required <code>close_date</code> <code>str</code> <p>Close date of the Opportunity. Should be in format YYYY-MM-DD.</p> required <code>amount</code> <code>Union[int, float]</code> <p>Amount (expected revenue) of the opportunity.                         Can either be an integer or a float value.</p> required <code>account_id</code> <code>str</code> <p>Technical ID of the related Salesforce Account.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce Opportunity data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_opportunity(\n    self,\n    name: str,\n    stage: str,\n    close_date: str,\n    amount: Union[int, float],\n    account_id: str,\n    description: str = None,\n    **kwargs: Any,\n) -&gt; dict | None:\n    \"\"\"Add a new Opportunity object to Salesfoce.\n\n    Args:\n        name (str): Name of the Opportunity.\n        stage (str): Stage of the Opportunity. Typical Value:\n                     \"Prospecting\", \"Qualification\", \"Value Proposition\", \"Negotiation/Review\",\n                     \"Closed Won\", \"Closed Lost\"\n        close_date (str): Close date of the Opportunity. Should be in format YYYY-MM-DD.\n        amount (Union[int, float]): Amount (expected revenue) of the opportunity.\n                                    Can either be an integer or a float value.\n        account_id (str): Technical ID of the related Salesforce Account.\n\n    Returns:\n        dict | None: Dictionary with the Salesforce Opportunity data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Opportunity/\"\n\n    payload = {\n        \"Name\": name,\n        \"StageName\": stage,\n        \"CloseDate\": close_date,\n        \"Amount\": amount,\n        \"AccountId\": account_id,\n    }\n    if description:\n        payload[\"Description\"] = description\n    payload.update(kwargs)  # Add additional fields from kwargs\n\n    logger.info(\n        \"Add Salesforce opportunity -&gt; %s; calling -&gt; %s\", name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(payload),\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Salesforce opportunity -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_product","title":"<code>add_product(product_name, product_code, description, price, **kwargs)</code>","text":"<p>Add a new Product object to Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Name of the Salesforce Product.</p> required <code>product_code</code> <code>str</code> <p>Code of the Salesforce Product.</p> required <code>description</code> <code>str</code> <p>Description of the Salesforce Product.</p> required <code>price</code> <code>float</code> <p>Price of the Salesforce Product.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce Product data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_product(\n    self,\n    product_name: str,\n    product_code: str,\n    description: str,\n    price: float,\n    **kwargs: Any,\n) -&gt; dict | None:\n    \"\"\"Add a new Product object to Salesforce.\n\n    Args:\n        product_name (str): Name of the Salesforce Product.\n        product_code (str): Code of the Salesforce Product.\n        description (str): Description of the Salesforce Product.\n        price (float): Price of the Salesforce Product.\n\n    Returns:\n        dict | None: Dictionary with the Salesforce Product data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/Product2/\"\n\n    payload = {\n        \"Name\": product_name,\n        \"ProductCode\": product_code,\n        \"Description\": description,\n        \"Price__c\": price,\n    }\n    payload.update(kwargs)  # Add additional fields from kwargs\n\n    logger.info(\n        \"Add Salesforce product -&gt; %s; calling -&gt; %s\", product_name, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(payload),\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Salesforce product -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                product_name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.add_user","title":"<code>add_user(username, email, password, firstname, lastname, profile_id=None, alias=None)</code>","text":"<p>Add a new Salesforce user.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Login name of the new user</p> required <code>email</code> <code>str</code> <p>Email of the new user</p> required <code>password</code> <code>str</code> <p>Password of the new user</p> required <code>firstname</code> <code>str</code> <p>First name of the new user.</p> required <code>lastname</code> <code>str</code> <p>Last name of the new user.</p> required <code>profile_id</code> <code>str</code> <p>Profile ID of the new user. Defaults to None.                         Use method get_all_user_profiles() to determine                         the desired Profile for the user.</p> <code>None</code> <code>alias</code> <code>str</code> <p>Alias of the new user. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce User data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def add_user(\n    self,\n    username: str,\n    email: str,\n    password: str,\n    firstname: str,\n    lastname: str,\n    profile_id: Optional[str] = None,\n    alias: Optional[str] = None,\n) -&gt; dict | None:\n    \"\"\"Add a new Salesforce user.\n\n    Args:\n        username (str): Login name of the new user\n        email (str): Email of the new user\n        password (str): Password of the new user\n        firstname (str): First name of the new user.\n        lastname (str): Last name of the new user.\n        profile_id (str, optional): Profile ID of the new user. Defaults to None.\n                                    Use method get_all_user_profiles() to determine\n                                    the desired Profile for the user.\n        alias (str, optional): Alias of the new user. Defaults to None.\n\n    Returns:\n        dict | None: Dictionary with the Salesforce User data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/sobjects/User/\"\n\n    payload = {\n        \"Username\": username,\n        \"Email\": email,\n        \"Password\": password,\n        \"FirstName\": firstname,\n        \"LastName\": lastname,\n        \"ProfileId\": profile_id,\n        \"Alias\": alias,\n    }\n\n    logger.info(\n        \"Adding Salesforce user -&gt; %s; calling -&gt; %s\", username, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.post(\n            request_url,\n            headers=request_header,\n            data=json.dumps(payload),\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to add Salesforce user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                username,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticate at Salesforce with client ID and client secret.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determinse if a re-athentication is enforced                          (e.g. if session has timed out with 401 error)</p> <code>False</code> <p>Returns:     str: Access token. Also stores access token in self._access_token. None in case of error</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; str | None:\n    \"\"\"Authenticate at Salesforce with client ID and client secret.\n\n    Args:\n        revalidate (bool, optional): determinse if a re-athentication is enforced\n                                     (e.g. if session has timed out with 401 error)\n    Returns:\n        str: Access token. Also stores access token in self._access_token. None in case of error\n    \"\"\"\n\n    # Already authenticated and session still valid?\n    if self._access_token and not revalidate:\n        logger.info(\n            \"Session still valid - return existing access token -&gt; %s\",\n            str(self._access_token),\n        )\n        return self._access_token\n\n    request_url = self.config()[\"authenticationUrl\"]\n    request_header = request_login_headers\n\n    logger.info(\"Requesting Salesforce Access Token from -&gt; %s\", request_url)\n\n    authenticate_post_body = self.credentials()\n\n    response = None\n    self._access_token = None\n    self._instance_url = None\n\n    try:\n        response = requests.post(\n            request_url,\n            data=authenticate_post_body,\n            headers=request_header,\n            timeout=REQUEST_TIMEOUT,\n        )\n    except requests.exceptions.ConnectionError as exception:\n        logger.warning(\n            \"Unable to connect to -&gt; %s : %s\",\n            self.config()[\"authenticationUrl\"],\n            exception,\n        )\n        return None\n\n    if response.ok:\n        authenticate_dict = self.parse_request_response(response)\n        if not authenticate_dict:\n            return None\n        else:\n            # Store authentication access_token:\n            self._access_token = authenticate_dict[\"access_token\"]\n            logger.debug(\"Access Token -&gt; %s\", self._access_token)\n            self._instance_url = authenticate_dict[\"instance_url\"]\n            logger.debug(\"Instance URL -&gt; %s\", self._instance_url)\n    else:\n        logger.error(\n            \"Failed to request an Salesforce Access Token; error -&gt; %s\",\n            response.text,\n        )\n        return None\n\n    return self._access_token\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Returns the configuration dictionary\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    return self._config\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.credentials","title":"<code>credentials()</code>","text":"<p>Return the login credentials</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with login credentials for Salesforce</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def credentials(self) -&gt; dict:\n    \"\"\"Return the login credentials\n\n    Returns:\n        dict: dictionary with login credentials for Salesforce\n    \"\"\"\n    return self.config()[\"authenticationData\"]\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.exist_result_item","title":"<code>exist_result_item(response, key, value)</code>","text":"<p>Check existence of key / value pair in the response properties of an Salesforce API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an Salesforce API call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>value</code> <code>str</code> <p>value to find in the item with the matching key</p> required <p>Returns:     bool: True if the value was found, False otherwise</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def exist_result_item(self, response: dict, key: str, value: str) -&gt; bool:\n    \"\"\"Check existence of key / value pair in the response properties of an Salesforce API call.\n\n    Args:\n        response (dict): REST response from an Salesforce API call\n        key (str): property name (key)\n        value (str): value to find in the item with the matching key\n    Returns:\n        bool: True if the value was found, False otherwise\n    \"\"\"\n\n    if not response:\n        return False\n\n    if \"records\" in response:\n        records = response[\"records\"]\n        if not records or not isinstance(records, list):\n            return False\n\n        for record in records:\n            if value == record[key]:\n                return True\n    else:\n        if not key in response:\n            return False\n        if value == response[key]:\n            return True\n\n    return False\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.get_all_user_profiles","title":"<code>get_all_user_profiles()</code>","text":"<p>Get all user profiles</p> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with salesforce user profiles.</p> <code>dict | None</code> <p>Example response:</p> <code>dict | None</code> <p>{ 'totalSize': 15, 'done': True, 'records': [     {         ...         'attributes': {             'type': 'Profile',             'url': '/services/data/v52.0/sobjects/Profile/00eDn000001msL8IAI'},             'Id': '00eDn000001msL8IAI',             'Name': 'Standard User',             'CreatedById':             '005Dn000001rRodIAE',             'CreatedDate': '2022-11-30T15:30:54.000+0000',             'Description': None,             'LastModifiedById': '005Dn000001rUacIAE',             'LastModifiedDate': '2024-02-08T17:46:17.000+0000',             'PermissionsCustomizeApplication': False,             'PermissionsEditTask': True,             'PermissionsImportLeads': False         }     }, ... ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def get_all_user_profiles(self) -&gt; dict | None:\n    \"\"\"Get all user profiles\n\n    Returns:\n        dict | None: Dictionary with salesforce user profiles.\n\n        Example response:\n        {\n            'totalSize': 15,\n            'done': True,\n            'records': [\n                {\n                    ...\n                    'attributes': {\n                        'type': 'Profile',\n                        'url': '/services/data/v52.0/sobjects/Profile/00eDn000001msL8IAI'},\n                        'Id': '00eDn000001msL8IAI',\n                        'Name': 'Standard User',\n                        'CreatedById':\n                        '005Dn000001rRodIAE',\n                        'CreatedDate': '2022-11-30T15:30:54.000+0000',\n                        'Description': None,\n                        'LastModifiedById': '005Dn000001rUacIAE',\n                        'LastModifiedDate': '2024-02-08T17:46:17.000+0000',\n                        'PermissionsCustomizeApplication': False,\n                        'PermissionsEditTask': True,\n                        'PermissionsImportLeads': False\n                    }\n                }, ...\n            ]\n        }\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/query/\"\n\n    query = \"SELECT Id, Name, CreatedById, CreatedDate, Description, LastModifiedById, LastModifiedDate, PermissionsCustomizeApplication, PermissionsEditTask, PermissionsImportLeads FROM Profile\"\n\n    retries = 0\n    while True:\n        response = requests.get(\n            request_url,\n            headers=request_header,\n            params={\"q\": query},\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get Salesforce user profiles; status -&gt; %s; error -&gt; %s\",\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.get_object","title":"<code>get_object(object_type, search_field, search_value, result_fields, limit=200)</code>","text":"<p>Get a Salesforce object based on a defined field value and return selected result fields.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>Salesforce Business Object type. Such as \"Account\" or \"Case\".</p> required <code>search_field</code> <code>str</code> <p>object field to search in</p> required <code>search_value</code> <code>str</code> <p>value to search for</p> required <code>result_fields</code> <code>list | None</code> <p>list of fields to return. If None, then all standard fields                          of the object will be returned.</p> required <code>limit</code> <code>int</code> <p>maximum number of fields to return. Salesforce enforces 200 as upper limit.</p> <code>200</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce object data.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def get_object(\n    self,\n    object_type: str,\n    search_field: str,\n    search_value: str,\n    result_fields: list | None,\n    limit: int = 200,\n) -&gt; dict | None:\n    \"\"\"Get a Salesforce object based on a defined field value and return selected result fields.\n\n    Args:\n        object_type (str): Salesforce Business Object type. Such as \"Account\" or \"Case\".\n        search_field (str): object field to search in\n        search_value (str): value to search for\n        result_fields (list | None): list of fields to return. If None, then all standard fields\n                                     of the object will be returned.\n        limit (int, optional): maximum number of fields to return. Salesforce enforces 200 as upper limit.\n\n    Returns:\n        dict | None: Dictionary with the Salesforce object data.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n    if search_field and not search_value:\n        logger.error(\n            \"No search value has been provided for search field -&gt; %s!\",\n            search_field,\n        )\n        return None\n    if not result_fields:\n        logger.info(\n            \"No result fields defined. Using 'FIELDS(STANDARD)' to deliver all standard fields of the object.\"\n        )\n        result_fields = [\"FIELDS(STANDARD)\"]\n\n    query = \"SELECT {} FROM {}\".format(\", \".join(result_fields), object_type)\n    if search_field and search_value:\n        query += \" WHERE {}='{}'\".format(search_field, search_value)\n    query += \" LIMIT {}\".format(str(limit))\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/query/?q={query}\"\n\n    logger.info(\n        \"Sending query -&gt; %s to Salesforce; calling -&gt; %s\", query, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(request_url, headers=request_header, timeout=30)\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to retrieve Salesforce object -&gt; %s with %s = %s; status -&gt; %s; error -&gt; %s\",\n                object_type,\n                search_field,\n                search_value,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.get_object_id_by_name","title":"<code>get_object_id_by_name(object_type, name, name_field='Name')</code>","text":"<p>Get the ID of a given Salesforce object with a given type and name.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>Sales object type, like \"Account\", \"Case\", ...</p> required <code>name</code> <code>str</code> <p>Name of the Salesforce object.</p> required <code>name_field</code> <code>str</code> <p>Field where the name is stored. Defaults to \"Name\".</p> <code>'Name'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Object ID or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def get_object_id_by_name(\n    self, object_type: str, name: str, name_field: str = \"Name\"\n) -&gt; Optional[str]:\n    \"\"\"Get the ID of a given Salesforce object with a given type and name.\n\n    Args:\n        object_type (str): Sales object type, like \"Account\", \"Case\", ...\n        name (str): Name of the Salesforce object.\n        name_field (str, optional): Field where the name is stored. Defaults to \"Name\".\n\n    Returns:\n        Optional[str]: Object ID or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = f\"{self._instance_url}/services/data/v52.0/query/\"\n\n    query = f\"SELECT Id FROM {object_type} WHERE {name_field} = '{name}'\"\n\n    retries = 0\n    while True:\n        response = requests.get(\n            request_url,\n            headers=request_header,\n            params={\"q\": query},\n            timeout=REQUEST_TIMEOUT,\n        )\n        if response.ok:\n            response = self.parse_request_response(response)\n            object_id = self.get_result_value(response, \"Id\")\n            return object_id\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get Salesforce object ID for object type -&gt; %s and object name -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                object_type,\n                name,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.get_profile_id","title":"<code>get_profile_id(profile_name)</code>","text":"<p>Get a user profile ID by profile name.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>Name of the User Profile.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Technical ID of the user profile.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def get_profile_id(self, profile_name: str) -&gt; Optional[str]:\n    \"\"\"Get a user profile ID by profile name.\n\n    Args:\n        profile_name (str): Name of the User Profile.\n\n    Returns:\n        Optional[str]: Technical ID of the user profile.\n    \"\"\"\n\n    return self.get_object_id_by_name(object_type=\"Profile\", name=profile_name)\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.get_result_value","title":"<code>get_result_value(response, key, index=0)</code>","text":"<p>Get value of a result property with a given key of an Salesforce API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an Salesforce REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>index</code> <code>int</code> <p>Index to use (1st element has index 0).                    Defaults to 0.</p> <code>0</code> <p>Returns:     str: value for the key, None otherwise</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def get_result_value(\n    self,\n    response: dict,\n    key: str,\n    index: int = 0,\n) -&gt; str | None:\n    \"\"\"Get value of a result property with a given key of an Salesforce API call.\n\n    Args:\n        response (dict): REST response from an Salesforce REST Call\n        key (str): property name (key)\n        index (int, optional): Index to use (1st element has index 0).\n                               Defaults to 0.\n    Returns:\n        str: value for the key, None otherwise\n    \"\"\"\n\n    if not response:\n        return None\n\n    # do we have a complex response - e.g. from an SOQL query?\n    # these have list of \"records\":\n    if \"records\" in response:\n        values = response[\"records\"]\n        if not values or not isinstance(values, list) or len(values) - 1 &lt; index:\n            return None\n        value = values[index][key]\n    else:  # simple response - try to find key in response directly:\n        if not key in response:\n            return None\n        value = response[key]\n\n    return value\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.get_user","title":"<code>get_user(user_id)</code>","text":"<p>Get a Salesforce user based on its ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>ID of the Salesforce user</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary with the Salesforce user data or None if the request fails.</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def get_user(self, user_id: str) -&gt; dict | None:\n    \"\"\"Get a Salesforce user based on its ID.\n\n    Args:\n        user_id (str): ID of the Salesforce user\n\n    Returns:\n        dict | None: Dictionary with the Salesforce user data or None if the request fails.\n    \"\"\"\n\n    if not self._access_token or not self._instance_url:\n        logger.error(\"Authentication required.\")\n        return None\n\n    request_header = self.request_header()\n    request_url = (\n        f\"{self._instance_url}/services/data/v52.0/sobjects/User/{user_id}\"\n    )\n\n    logger.info(\n        \"Get Salesforce user with ID -&gt; %s; calling -&gt; %s\", user_id, request_url\n    )\n\n    retries = 0\n    while True:\n        response = requests.get(\n            request_url, headers=request_header, timeout=REQUEST_TIMEOUT\n        )\n        if response.ok:\n            return self.parse_request_response(response)\n        elif response.status_code == 401 and retries == 0:\n            logger.warning(\"Session has expired - try to re-authenticate...\")\n            self.authenticate(revalidate=True)\n            request_header = self.request_header()\n            retries += 1\n        else:\n            logger.error(\n                \"Failed to get Salesforce user -&gt; %s; status -&gt; %s; error -&gt; %s\",\n                user_id,\n                response.status_code,\n                response.text,\n            )\n            return None\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.get_user_id","title":"<code>get_user_id(username)</code>","text":"<p>Get a user ID by user name.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Name of the User.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Technical ID of the user</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def get_user_id(self, username: str) -&gt; Optional[str]:\n    \"\"\"Get a user ID by user name.\n\n    Args:\n        username (str): Name of the User.\n\n    Returns:\n        Optional[str]: Technical ID of the user\n    \"\"\"\n\n    return self.get_object_id_by_name(\n        object_type=\"User\", name=username, name_field=\"Username\"\n    )\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the request response (JSon) to a Python dict in a safe way    that also handles exceptions. It first tries to load the response.text    via json.loads() that produces a dict output. Only if response.text is    not set or is empty it just converts the response_object to a dict using    the vars() built-in method.</p> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>use a more specific error message                                       in case of an error</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>True: write an error to the log file                False: write a warning to the log file</p> <code>True</code> <p>Returns:     dict: response information or None in case of an error</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def parse_request_response(\n    self,\n    response_object: requests.Response,\n    additional_error_message: str = \"\",\n    show_error: bool = True,\n) -&gt; dict | None:\n    \"\"\"Converts the request response (JSon) to a Python dict in a safe way\n       that also handles exceptions. It first tries to load the response.text\n       via json.loads() that produces a dict output. Only if response.text is\n       not set or is empty it just converts the response_object to a dict using\n       the vars() built-in method.\n\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str, optional): use a more specific error message\n                                                  in case of an error\n        show_error (bool): True: write an error to the log file\n                           False: write a warning to the log file\n    Returns:\n        dict: response information or None in case of an error\n    \"\"\"\n\n    if not response_object:\n        return None\n\n    try:\n        if response_object.text:\n            dict_object = json.loads(response_object.text)\n        else:\n            dict_object = vars(response_object)\n    except json.JSONDecodeError as exception:\n        if additional_error_message:\n            message = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\n                additional_error_message, exception\n            )\n        else:\n            message = \"Cannot decode response as JSon; error -&gt; {}\".format(\n                exception\n            )\n        if show_error:\n            logger.error(message)\n        else:\n            logger.warning(message)\n        return None\n    else:\n        return dict_object\n</code></pre>"},{"location":"pyxecm/salesforce/#pyxecm.customizer.salesforce.Salesforce.request_header","title":"<code>request_header(content_type='application/json')</code>","text":"<p>Returns the request header used for Application calls.    Consists of Bearer access token and Content Type</p> <p>Parameters:</p> Name Type Description Default <code>content_type</code> <code>str</code> <p>content type for the request</p> <code>'application/json'</code> <p>Return:     dict: request header values</p> Source code in <code>pyxecm/customizer/salesforce.py</code> <pre><code>def request_header(self, content_type: str = \"application/json\") -&gt; dict:\n    \"\"\"Returns the request header used for Application calls.\n       Consists of Bearer access token and Content Type\n\n    Args:\n        content_type (str, optional): content type for the request\n    Return:\n        dict: request header values\n    \"\"\"\n\n    request_header = {\n        \"Authorization\": \"Bearer {}\".format(self._access_token),\n        \"Content-Type\": content_type,\n    }\n    return request_header\n</code></pre>"},{"location":"pyxecm/sap/","title":"SAP","text":"<p>SAP RFC Module to implement Remote Function calls to SAP S/4HANA For documentation of PyRFC see here: https://github.com/SAP/PyRFC and here: https://sap.github.io/PyRFC/pyrfc.html </p> <p>RFC typically uses port 3300 to communication with the SAP server. Make sure this port is not blocked by your firewall.</p> <p>Connection Parameter: * ashost (hostname or IP address of the application server - this should NOT be a full URL!) * sysnr (the backend's system number, e.g. 00) * client (the client or \"Mandant\" to which to logon, e.g. 100) * user (e.g. \"nwheeler\") * passwd (password of the user) * lang (logon language as two-character ISO-Code, e.g. EN) * trace (on of 0(off), 1(brief), 2(verbose), 3(detailed), 4(full)) * use_tls (activates SSL/TLS encryption. Set to 0 or 1. By default TLS is turned on (1)) * tls_client_pse (Specifies the PSE file containing the necessary certificates for TLS communication.                   A PSE file is a SAP proprietary certificate store, similar to a p12 file,                   containing the private key and the certificate chain to be used in the TLS                   handshake with the server, beginning with the server's public certificate and                   ending with the root CA certifcate. It should also contain the client certificate                   used for login at the server, if your client program does not use basic                   user &amp; password authentication)</p> <p>Class: SAP Methods:</p> <p>init : class initializer call: Calls and RFC based on its name and passes parameters.</p>"},{"location":"pyxecm/sap/#pyxecm.customizer.sap.SAP","title":"<code>SAP</code>","text":"<p>             Bases: <code>object</code></p> <p>Used to implement Remote Function Calls (RFC) to SAP S/4HANA</p> Source code in <code>pyxecm/customizer/sap.py</code> <pre><code>class SAP(object):\n    \"\"\"Used to implement Remote Function Calls (RFC) to SAP S/4HANA\"\"\"\n\n    _connection_parameters = {}\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        system_id: str,\n        ashost: str = \"\",\n        mshost: str = \"\",\n        msport: str = \"3601\",\n        group: str = \"PUBLIC\",\n        destination: str = \"\",\n        client: str = \"100\",\n        system_number: str = \"00\",\n        lang: str = \"EN\",\n        trace: str = \"3\",\n    ):\n        \"\"\"Initialize the SAP object.\"\"\"\n\n        logger.info(\"Initializing SAP object...\")\n        logger.info(\"Using PyRFC version -&gt; %s\", pyrfc.__version__)\n\n        # Set up connection parameters\n        self._connection_parameters = {\n            \"user\": username,\n            \"passwd\": password,\n            \"client\": client,\n            \"trace\": trace,\n            \"lang\": lang,\n        }\n\n        # see https://sap.github.io/PyRFC/pyrfc.html#connection\n        if ashost:\n            logger.info(\"Logon with application server logon: requiring ashost, sysnr\")\n            self._connection_parameters[\"ashost\"] = ashost\n            self._connection_parameters[\"sysnr\"] = system_number\n            self._connection_parameters[\"sysid\"] = system_id\n        elif mshost:\n            logger.info(\n                \"Logon with load balancing: requiring mshost, msserv, sysid, group\"\n            )\n            self._connection_parameters[\"mshost\"] = mshost\n            self._connection_parameters[\"sysid\"] = system_id\n            self._connection_parameters[\"msserv\"] = msport\n            self._connection_parameters[\"group\"] = group\n\n        if destination:\n            self._connection_parameters[\"dest\"] = destination\n\n        # end method definition\n\n    def call(self, rfc_name: str, options: dict, rfc_parameters: dict) -&gt; dict | None:\n        \"\"\"Do an RFC Call. See http://sap.github.io/PyRFC/pyrfc.html#pyrfc.Connection.call\n\n        Args:\n            rfc_name (str): this is the name of the RFC (typical in capital letters), e.g. SM02_ADD_MESSAGE\n            options (dictionary, optional): the call options for the RFC call. Defaults to {}.\n            * not_requested: Allows to deactivate certain parameters in the function module interface.\n              This is particularly useful for BAPIs which have many large tables, the Python client is not interested in.\n              Deactivate those, to reduce network traffic and memory consumption in your application considerably.\n              This functionality can be used for input and output parameters. If the parameter is an input,\n              no data for that parameter will be sent to the backend. If it\u2019s an output, the backend will be\n              informed not to return data for that parameter.\n            * timeout: Cancel RFC connection if ongoing RFC call not completed within timeout seconds.\n              Timeout can be also set as client connection configuration option, in which case is valid for all RFC calls.\n            rfc_parameters (dict, optional): the actual RFC parameters thatare specific for\n                                                   the type of the call. Defaults to {}.\n        Returns:\n            dict: Result of the RFC call or None if the call fails or timeouts.\n        \"\"\"\n\n        # Create the connection object and call the RFC function\n        params = self._connection_parameters\n        logger.debug(\"Connection Parameters -&gt; %s\", params)\n\n        try:\n            with pyrfc.Connection(**params) as conn:\n                result = conn.call(rfc_name, options=options, **rfc_parameters)\n                return result\n        except pyrfc.RFCError as exception:\n            logger.error(\"Failed to call RFC -&gt; %s; error -&gt; %s\", rfc_name, exception)\n            return None\n</code></pre>"},{"location":"pyxecm/sap/#pyxecm.customizer.sap.SAP.__init__","title":"<code>__init__(username, password, system_id, ashost='', mshost='', msport='3601', group='PUBLIC', destination='', client='100', system_number='00', lang='EN', trace='3')</code>","text":"<p>Initialize the SAP object.</p> Source code in <code>pyxecm/customizer/sap.py</code> <pre><code>def __init__(\n    self,\n    username: str,\n    password: str,\n    system_id: str,\n    ashost: str = \"\",\n    mshost: str = \"\",\n    msport: str = \"3601\",\n    group: str = \"PUBLIC\",\n    destination: str = \"\",\n    client: str = \"100\",\n    system_number: str = \"00\",\n    lang: str = \"EN\",\n    trace: str = \"3\",\n):\n    \"\"\"Initialize the SAP object.\"\"\"\n\n    logger.info(\"Initializing SAP object...\")\n    logger.info(\"Using PyRFC version -&gt; %s\", pyrfc.__version__)\n\n    # Set up connection parameters\n    self._connection_parameters = {\n        \"user\": username,\n        \"passwd\": password,\n        \"client\": client,\n        \"trace\": trace,\n        \"lang\": lang,\n    }\n\n    # see https://sap.github.io/PyRFC/pyrfc.html#connection\n    if ashost:\n        logger.info(\"Logon with application server logon: requiring ashost, sysnr\")\n        self._connection_parameters[\"ashost\"] = ashost\n        self._connection_parameters[\"sysnr\"] = system_number\n        self._connection_parameters[\"sysid\"] = system_id\n    elif mshost:\n        logger.info(\n            \"Logon with load balancing: requiring mshost, msserv, sysid, group\"\n        )\n        self._connection_parameters[\"mshost\"] = mshost\n        self._connection_parameters[\"sysid\"] = system_id\n        self._connection_parameters[\"msserv\"] = msport\n        self._connection_parameters[\"group\"] = group\n\n    if destination:\n        self._connection_parameters[\"dest\"] = destination\n</code></pre>"},{"location":"pyxecm/sap/#pyxecm.customizer.sap.SAP.call","title":"<code>call(rfc_name, options, rfc_parameters)</code>","text":"<p>Do an RFC Call. See http://sap.github.io/PyRFC/pyrfc.html#pyrfc.Connection.call</p> <p>Parameters:</p> Name Type Description Default <code>rfc_name</code> <code>str</code> <p>this is the name of the RFC (typical in capital letters), e.g. SM02_ADD_MESSAGE</p> required <code>options</code> <code>dictionary</code> <p>the call options for the RFC call. Defaults to {}.</p> required <code>*</code> <code>not_requested</code> <p>Allows to deactivate certain parameters in the function module interface. This is particularly useful for BAPIs which have many large tables, the Python client is not interested in. Deactivate those, to reduce network traffic and memory consumption in your application considerably. This functionality can be used for input and output parameters. If the parameter is an input, no data for that parameter will be sent to the backend. If it\u2019s an output, the backend will be informed not to return data for that parameter.</p> required <code>*</code> <code>timeout</code> <p>Cancel RFC connection if ongoing RFC call not completed within timeout seconds. Timeout can be also set as client connection configuration option, in which case is valid for all RFC calls.</p> required <code>rfc_parameters</code> <code>dict</code> <p>the actual RFC parameters thatare specific for                                    the type of the call. Defaults to {}.</p> required <p>Returns:     dict: Result of the RFC call or None if the call fails or timeouts.</p> Source code in <code>pyxecm/customizer/sap.py</code> <pre><code>def call(self, rfc_name: str, options: dict, rfc_parameters: dict) -&gt; dict | None:\n    \"\"\"Do an RFC Call. See http://sap.github.io/PyRFC/pyrfc.html#pyrfc.Connection.call\n\n    Args:\n        rfc_name (str): this is the name of the RFC (typical in capital letters), e.g. SM02_ADD_MESSAGE\n        options (dictionary, optional): the call options for the RFC call. Defaults to {}.\n        * not_requested: Allows to deactivate certain parameters in the function module interface.\n          This is particularly useful for BAPIs which have many large tables, the Python client is not interested in.\n          Deactivate those, to reduce network traffic and memory consumption in your application considerably.\n          This functionality can be used for input and output parameters. If the parameter is an input,\n          no data for that parameter will be sent to the backend. If it\u2019s an output, the backend will be\n          informed not to return data for that parameter.\n        * timeout: Cancel RFC connection if ongoing RFC call not completed within timeout seconds.\n          Timeout can be also set as client connection configuration option, in which case is valid for all RFC calls.\n        rfc_parameters (dict, optional): the actual RFC parameters thatare specific for\n                                               the type of the call. Defaults to {}.\n    Returns:\n        dict: Result of the RFC call or None if the call fails or timeouts.\n    \"\"\"\n\n    # Create the connection object and call the RFC function\n    params = self._connection_parameters\n    logger.debug(\"Connection Parameters -&gt; %s\", params)\n\n    try:\n        with pyrfc.Connection(**params) as conn:\n            result = conn.call(rfc_name, options=options, **rfc_parameters)\n            return result\n    except pyrfc.RFCError as exception:\n        logger.error(\"Failed to call RFC -&gt; %s; error -&gt; %s\", rfc_name, exception)\n        return None\n</code></pre>"},{"location":"pyxecm/translate/","title":"Translate","text":"<p>Experimental module to automate translations</p> <p>Class: Translator Methods:</p> <p>init : class initializer config: Return the configuration parameters translate: Translate a string from one language to another using the Google Translate V2 API translateV3: Translate a string from one language to another using the Google Translate V3 API</p>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator","title":"<code>Translator</code>","text":"<p>Class for translation of of strings based on the Google Translate API. The class supports V2 and V3 translation APIs</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>class Translator:\n    \"\"\"Class for translation of of strings based on the Google Translate API.\n    The class supports V2 and V3 translation APIs\n    \"\"\"\n\n    _config = None\n    _headers = None\n\n    def __init__(self, api_key: str, project_key: str = \"\", domain: str = \"\"):\n        translateConfig = {}\n\n        translateConfig[\"apiKey\"] = api_key\n        translateConfig[\n            \"translateUrlV2\"\n        ] = \"https://translation.googleapis.com/language/translate/v2\"\n        translateConfig[\n            \"translateUrlV3\"\n        ] = \"https://translation.googleapis.com/v3/projects/{}:translateText\".format(\n            project_key\n        )\n        translateConfig[\"project\"] = project_key\n        translateConfig[\"parent\"] = \"projects/{}/locations/global\".format(project_key)\n        translateConfig[\"model\"] = f'nmt{\":{}\".format(domain) if domain else \"\"}'\n\n        self._headers = {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n        }\n\n        self._config = translateConfig\n\n    def config(self) -&gt; dict:\n        \"\"\"Return the configuration parameters\n\n        Returns:\n            dict: configuration parameters\n        \"\"\"\n\n        return self._config\n\n    def translate(self, source_language: str, target_language: str, text: str) -&gt; str:\n        \"\"\"Translate a string from one language to another using the Google Translate V2 API\n\n        Args:\n            source_language (str): source language\n            target_language (str): destination language\n            text (str): string to translate\n\n        Returns:\n            str: translated string\n        \"\"\"\n\n        params = {\n            \"key\": self.config()[\"apiKey\"],\n            \"q\": text,\n            \"source\": source_language,\n            \"target\": target_language,\n        }\n\n        request_url = self.config()[\"translateUrlV2\"]\n\n        response = requests.post(url=request_url, params=params, timeout=None)\n\n        if response.status_code != 200:\n            logger.error(\"Failed to translate text -&gt; %s\", response.content)\n            return None\n\n        translated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\n\n        return translated_text\n\n    # end method definition\n\n    def translateV3(self, source_language: str, target_language: str, text: str) -&gt; str:\n        \"\"\"Translate a string from one language to another using the Google Translate V3 API\n\n        Args:\n            source_language (str): source language\n            target_language (str): destination language\n            text (str): string to translate\n\n        Returns:\n            str: translated string\n        \"\"\"\n\n        data = {\n            \"source_language_code\": source_language,\n            \"target_language_code\": target_language,\n            \"contents\": [text],\n        }\n\n        request_header = self._headers\n        request_url = self.config()[\"translateUrlV3\"]\n\n        response = requests.post(\n            url=request_url, headers=request_header, json=data, timeout=None\n        )\n\n        if response.status_code != 200:\n            logger.error(\"Failed to translate text -&gt; %s\", response.content)\n            return None\n\n        translated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\n\n        return translated_text\n</code></pre>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator.config","title":"<code>config()</code>","text":"<p>Return the configuration parameters</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>configuration parameters</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>def config(self) -&gt; dict:\n    \"\"\"Return the configuration parameters\n\n    Returns:\n        dict: configuration parameters\n    \"\"\"\n\n    return self._config\n</code></pre>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator.translate","title":"<code>translate(source_language, target_language, text)</code>","text":"<p>Translate a string from one language to another using the Google Translate V2 API</p> <p>Parameters:</p> Name Type Description Default <code>source_language</code> <code>str</code> <p>source language</p> required <code>target_language</code> <code>str</code> <p>destination language</p> required <code>text</code> <code>str</code> <p>string to translate</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>translated string</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>def translate(self, source_language: str, target_language: str, text: str) -&gt; str:\n    \"\"\"Translate a string from one language to another using the Google Translate V2 API\n\n    Args:\n        source_language (str): source language\n        target_language (str): destination language\n        text (str): string to translate\n\n    Returns:\n        str: translated string\n    \"\"\"\n\n    params = {\n        \"key\": self.config()[\"apiKey\"],\n        \"q\": text,\n        \"source\": source_language,\n        \"target\": target_language,\n    }\n\n    request_url = self.config()[\"translateUrlV2\"]\n\n    response = requests.post(url=request_url, params=params, timeout=None)\n\n    if response.status_code != 200:\n        logger.error(\"Failed to translate text -&gt; %s\", response.content)\n        return None\n\n    translated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\n\n    return translated_text\n</code></pre>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator.translateV3","title":"<code>translateV3(source_language, target_language, text)</code>","text":"<p>Translate a string from one language to another using the Google Translate V3 API</p> <p>Parameters:</p> Name Type Description Default <code>source_language</code> <code>str</code> <p>source language</p> required <code>target_language</code> <code>str</code> <p>destination language</p> required <code>text</code> <code>str</code> <p>string to translate</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>translated string</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>def translateV3(self, source_language: str, target_language: str, text: str) -&gt; str:\n    \"\"\"Translate a string from one language to another using the Google Translate V3 API\n\n    Args:\n        source_language (str): source language\n        target_language (str): destination language\n        text (str): string to translate\n\n    Returns:\n        str: translated string\n    \"\"\"\n\n    data = {\n        \"source_language_code\": source_language,\n        \"target_language_code\": target_language,\n        \"contents\": [text],\n    }\n\n    request_header = self._headers\n    request_url = self.config()[\"translateUrlV3\"]\n\n    response = requests.post(\n        url=request_url, headers=request_header, json=data, timeout=None\n    )\n\n    if response.status_code != 200:\n        logger.error(\"Failed to translate text -&gt; %s\", response.content)\n        return None\n\n    translated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\n\n    return translated_text\n</code></pre>"},{"location":"pyxecm/web/","title":"Web","text":"<p>Module to implement functions to execute Web Requests</p> <p>Class: HTTP Methods:</p> <p>init : class initializer check_host_reachable: checks if a server / host is reachable http_request: make a HTTP request to a defined URL / endpoint (e.g. a Web Hook)</p>"},{"location":"pyxecm/web/#pyxecm.helper.web.HTTP","title":"<code>HTTP</code>","text":"<p>             Bases: <code>object</code></p> <p>Used to issue HTTP request and test if hosts are reachable.</p> Source code in <code>pyxecm/helper/web.py</code> <pre><code>class HTTP(object):\n    \"\"\"Used to issue HTTP request and test if hosts are reachable.\"\"\"\n\n    _config = None\n\n    def __init__(self):\n        \"\"\"Initialize the HTTP object\n\n        Args:\n        \"\"\"\n\n    def check_host_reachable(self, hostname: str, port: int = 80) -&gt; bool:\n        \"\"\"Check if a server / web address is reachable\n\n        Args:\n            hostname (str): endpoint hostname\n            port (int): endpoint port\n        Results:\n            bool: True is reachable, False otherwise\n        \"\"\"\n\n        logger.info(\n            \"Test if host -&gt; %s is reachable on port -&gt; %s ...\", hostname, str(port)\n        )\n        try:\n            socket.getaddrinfo(hostname, port)\n        except socket.gaierror as exception:\n            logger.warning(\n                \"Address-related error - cannot reach host -&gt; %s; error -&gt; %s\",\n                hostname,\n                exception.strerror,\n            )\n            return False\n        except socket.error as exception:\n            logger.warning(\n                \"Connection error - cannot reach host -&gt; %s; error -&gt; %s\",\n                hostname,\n                exception.strerror,\n            )\n            return False\n        else:\n            logger.info(\"Host is reachable at -&gt; %s:%s\", hostname, str(port))\n            return True\n\n    # end method definition\n\n    def http_request(\n        self,\n        url: str,\n        method: str = \"POST\",\n        payload: dict | None = None,\n        headers: dict | None = None,\n        timeout: int = 60,\n        retries: int = 0,\n        wait_time: int = 0,\n    ):\n        \"\"\"Issues an http request to a given URL.\n\n        Args:\n            url (str): URL of the request\n            method (str, optional): Method of the request (POST, PUT, GET, ...). Defaults to \"POST\".\n            payload (dict, optional): Request payload. Defaults to None.\n            headers (dict, optional): Request header. Defaults to None. If None then a default\n                                      value defined in \"requestHeaders\" is used.\n            timeout (int, optional): timeout in seconds\n            retries (int, optional): number of retries. If -1 then unlimited retries.\n            wait_time (int, optional): number of seconds to wait after each try\n        Returns:\n            Response of call\n        \"\"\"\n\n        if not headers:\n            headers = requestHeaders\n\n        logger.info(\n            \"Make HTTP Request to URL -&gt; %s using -&gt; %s method with payload -&gt; %s (max number of retries = %s)\",\n            url,\n            method,\n            str(payload),\n            str(retries),\n        )\n\n        try_counter = 1\n\n        while True:\n            response = requests.request(\n                method=method, url=url, data=payload, headers=headers, timeout=timeout\n            )\n\n            if not response.ok and retries == 0:\n                logger.error(\n                    \"HTTP request -&gt; %s to url -&gt; %s failed; status -&gt; %s; error -&gt; %s\",\n                    method,\n                    url,\n                    response.status_code,\n                    response.text,\n                )\n                return response\n\n            elif response.ok:\n                logger.info(\n                    \"HTTP request -&gt; %s to url -&gt; %s succeeded with status -&gt; %s!\",\n                    method,\n                    url,\n                    response.status_code,\n                )\n                if wait_time &gt; 0:\n                    logger.info(\"Sleeping %s seconds...\", wait_time)\n                    time.sleep(wait_time)\n                return response\n\n            else:\n                logger.warning(\n                    \"HTTP request -&gt; %s to url -&gt; %s failed (try %s); status -&gt; %s; error -&gt; %s\",\n                    method,\n                    url,\n                    try_counter,\n                    response.status_code,\n                    response.text,\n                )\n                if wait_time &gt; 0:\n                    logger.warning(\n                        \"Sleeping %s seconds and then trying once more...\",\n                        str(wait_time),\n                    )\n                    time.sleep(wait_time)\n                else:\n                    logger.warning(\"Trying once more...\")\n                retries -= 1\n                try_counter += 1\n</code></pre>"},{"location":"pyxecm/web/#pyxecm.helper.web.HTTP.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the HTTP object</p> <p>Args:</p> Source code in <code>pyxecm/helper/web.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the HTTP object\n\n    Args:\n    \"\"\"\n</code></pre>"},{"location":"pyxecm/web/#pyxecm.helper.web.HTTP.check_host_reachable","title":"<code>check_host_reachable(hostname, port=80)</code>","text":"<p>Check if a server / web address is reachable</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>endpoint hostname</p> required <code>port</code> <code>int</code> <p>endpoint port</p> <code>80</code> <p>Results:     bool: True is reachable, False otherwise</p> Source code in <code>pyxecm/helper/web.py</code> <pre><code>def check_host_reachable(self, hostname: str, port: int = 80) -&gt; bool:\n    \"\"\"Check if a server / web address is reachable\n\n    Args:\n        hostname (str): endpoint hostname\n        port (int): endpoint port\n    Results:\n        bool: True is reachable, False otherwise\n    \"\"\"\n\n    logger.info(\n        \"Test if host -&gt; %s is reachable on port -&gt; %s ...\", hostname, str(port)\n    )\n    try:\n        socket.getaddrinfo(hostname, port)\n    except socket.gaierror as exception:\n        logger.warning(\n            \"Address-related error - cannot reach host -&gt; %s; error -&gt; %s\",\n            hostname,\n            exception.strerror,\n        )\n        return False\n    except socket.error as exception:\n        logger.warning(\n            \"Connection error - cannot reach host -&gt; %s; error -&gt; %s\",\n            hostname,\n            exception.strerror,\n        )\n        return False\n    else:\n        logger.info(\"Host is reachable at -&gt; %s:%s\", hostname, str(port))\n        return True\n</code></pre>"},{"location":"pyxecm/web/#pyxecm.helper.web.HTTP.http_request","title":"<code>http_request(url, method='POST', payload=None, headers=None, timeout=60, retries=0, wait_time=0)</code>","text":"<p>Issues an http request to a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the request</p> required <code>method</code> <code>str</code> <p>Method of the request (POST, PUT, GET, ...). Defaults to \"POST\".</p> <code>'POST'</code> <code>payload</code> <code>dict</code> <p>Request payload. Defaults to None.</p> <code>None</code> <code>headers</code> <code>dict</code> <p>Request header. Defaults to None. If None then a default                       value defined in \"requestHeaders\" is used.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>timeout in seconds</p> <code>60</code> <code>retries</code> <code>int</code> <p>number of retries. If -1 then unlimited retries.</p> <code>0</code> <code>wait_time</code> <code>int</code> <p>number of seconds to wait after each try</p> <code>0</code> <p>Returns:     Response of call</p> Source code in <code>pyxecm/helper/web.py</code> <pre><code>def http_request(\n    self,\n    url: str,\n    method: str = \"POST\",\n    payload: dict | None = None,\n    headers: dict | None = None,\n    timeout: int = 60,\n    retries: int = 0,\n    wait_time: int = 0,\n):\n    \"\"\"Issues an http request to a given URL.\n\n    Args:\n        url (str): URL of the request\n        method (str, optional): Method of the request (POST, PUT, GET, ...). Defaults to \"POST\".\n        payload (dict, optional): Request payload. Defaults to None.\n        headers (dict, optional): Request header. Defaults to None. If None then a default\n                                  value defined in \"requestHeaders\" is used.\n        timeout (int, optional): timeout in seconds\n        retries (int, optional): number of retries. If -1 then unlimited retries.\n        wait_time (int, optional): number of seconds to wait after each try\n    Returns:\n        Response of call\n    \"\"\"\n\n    if not headers:\n        headers = requestHeaders\n\n    logger.info(\n        \"Make HTTP Request to URL -&gt; %s using -&gt; %s method with payload -&gt; %s (max number of retries = %s)\",\n        url,\n        method,\n        str(payload),\n        str(retries),\n    )\n\n    try_counter = 1\n\n    while True:\n        response = requests.request(\n            method=method, url=url, data=payload, headers=headers, timeout=timeout\n        )\n\n        if not response.ok and retries == 0:\n            logger.error(\n                \"HTTP request -&gt; %s to url -&gt; %s failed; status -&gt; %s; error -&gt; %s\",\n                method,\n                url,\n                response.status_code,\n                response.text,\n            )\n            return response\n\n        elif response.ok:\n            logger.info(\n                \"HTTP request -&gt; %s to url -&gt; %s succeeded with status -&gt; %s!\",\n                method,\n                url,\n                response.status_code,\n            )\n            if wait_time &gt; 0:\n                logger.info(\"Sleeping %s seconds...\", wait_time)\n                time.sleep(wait_time)\n            return response\n\n        else:\n            logger.warning(\n                \"HTTP request -&gt; %s to url -&gt; %s failed (try %s); status -&gt; %s; error -&gt; %s\",\n                method,\n                url,\n                try_counter,\n                response.status_code,\n                response.text,\n            )\n            if wait_time &gt; 0:\n                logger.warning(\n                    \"Sleeping %s seconds and then trying once more...\",\n                    str(wait_time),\n                )\n                time.sleep(wait_time)\n            else:\n                logger.warning(\"Trying once more...\")\n            retries -= 1\n            try_counter += 1\n</code></pre>"},{"location":"pyxecm/xml/","title":"XML","text":"<p>XML helper module</p> <p>Class: XML Methods:</p> <p>get_xml_element: Retrieve an XML Element from a string using an XPath expression modify_xml_element: Update the text (= content) of an XML element search_setting: Search a JSON-like setting inside an XML text telement replace_setting: Update a setting value replace_in_xml_files: Replace all occurrences of the search pattern with the replace string in all                       XML files in the directory and its subdirectories.</p>"},{"location":"pyxecm/xml/#pyxecm.helper.xml.XML","title":"<code>XML</code>","text":"<p>XML Class to parse and update Extended ECM transport packages</p> Source code in <code>pyxecm/helper/xml.py</code> <pre><code>class XML:\n    \"\"\"XML Class to parse and update Extended ECM transport packages\"\"\"\n\n    @classmethod\n    def get_xml_element(cls, xml_content: str, xpath: str):\n        \"\"\"Retrieves an XML Element from a string using an XPath expression\n\n        Args:\n            xml_content (str): XML file as a string\n            xpath (str): XPath to find the element\n\n        Returns:\n            str: text of element\n        \"\"\"\n\n        # Parse XML content into an etree\n        tree = etree.fromstring(xml_content)\n\n        # Find the XML element specified by XPath\n        element = tree.find(xpath)\n\n        return element\n\n    @classmethod\n    def modify_xml_element(cls, xml_content: str, xpath: str, new_value: str):\n        \"\"\"Update the text (= content) of an XML element\n\n        Args:\n            xml_content (str): the content of an XML file\n            xpath (str): XML Path to identify the XML element\n            new_value (str): new text (content)\n        \"\"\"\n        element = cls.get_xml_element(xml_content=xml_content, xpath=xpath)\n\n        if element is not None:\n            # Modify the XML element with the new value\n            element.text = new_value\n        else:\n            logger.warning(\"XML Element -&gt; %s not found.\", xpath)\n\n    @classmethod\n    def search_setting(\n        cls,\n        element_text: str,\n        setting_key: str,\n        is_simple: bool = True,\n        is_escaped: bool = False,\n    ) -&gt; str | None:\n        \"\"\"Search a setting in an XML element and return its value\n\n        The simple case covers settings like this:\n        &amp;quot;syncCandidates&amp;quot;:true,\n        \"syncCandidates\":true,\n        In this case the setting value is a scalar like true, false, a number or none\n        the regular expression pattern searches for a setting name in \"...\" (quotes) followed\n        by a colon (:). The value is taken from what follows the colon until the next comma (,)\n\n        The more complex case is a string value that may itself have commas,\n        so we cannot look for comma as a delimiter like in the simple case\n        but we take the value for a string delimited by double quotes (\"...\")\n\n        Args:\n            element_text (str): the text to examine - typically content of an XML element\n            setting_key (str): name of the setting key (before the colon)\n            is_simple (bool, optional): True if the value is scalar (not having assocs with commas). Defaults to True.\n            is_escaped (bool, optional): True if the quotes or escaped with &amp;quot;. Defaults to False.\n\n        Returns:\n            str: the value of the setting or None if the setting is not found.\n        \"\"\"\n\n        if is_simple:\n            if is_escaped:\n                pattern = r\"&amp;quot;{0}&amp;quot;:[^,]*\".format(setting_key)\n            else:\n                pattern = r'\"{0}\":[^,]*'.format(setting_key)\n        else:\n            if is_escaped:\n                pattern = r\"&amp;quot;{0}&amp;quot;:&amp;quot;.*&amp;quot;\".format(setting_key)\n            else:\n                pattern = r'\"{0}\":\"([^\"]*)\"'.format(setting_key)\n\n        match = re.search(pattern, element_text)\n        if match:\n            setting_line = match.group(0)\n            setting_value = setting_line.split(\":\")[1]\n            return setting_value\n        else:\n            return None\n\n    @classmethod\n    def replace_setting(\n        cls,\n        element_text: str,\n        setting_key: str,\n        new_value: str,\n        is_simple: bool = True,\n        is_escaped: bool = False,\n    ) -&gt; str:\n        \"\"\"Replace the value of a defined setting with a new value.\n\n        The simple case covers settings like this:\n        &amp;quot;syncCandidates&amp;quot;:true,\n        \"syncCandidates\":true,\n        In this case the setting value is a scalar like true, false, a number or none\n        the regular expression pattern searches for a setting name in \"...\" (quotes) followed\n        by a colon (:). The value is taken from what follows the colon until the next comma (,)\n\n        The more complex case is a string value that may itself have commas,\n        so we cannot look for comma as a delimiter like in the simple case\n        but we take the value for a string delimited by double quotes (\"...\")\n\n        Args:\n            element_text (str): original text of the XML element (that is to be updated)\n            setting_key (str): name of the setting\n            new_value (str): new value of the setting\n            is_simple (bool, optional): True = value is a scalar like true, false, a number or none. Defaults to True.\n            is_escaped (bool, optional): True if the value is surrrounded with &amp;quot;. Defaults to False.\n\n        Returns:\n            str: updated element text\n        \"\"\"\n\n        if is_simple:\n            if is_escaped:\n                pattern = r\"&amp;quot;{0}&amp;quot;:[^,]*\".format(setting_key)\n            else:\n                pattern = r'\"{0}\":[^,]*'.format(setting_key)\n        else:\n            if is_escaped:\n                pattern = r\"&amp;quot;{0}&amp;quot;:&amp;quot;.*&amp;quot;\".format(setting_key)\n            else:\n                pattern = r'\"{0}\":\"([^\"]*)\"'.format(setting_key)\n\n        new_text = re.sub(pattern, new_value, element_text)\n\n        return new_text\n\n    @classmethod\n    def replace_in_xml_files(\n        cls,\n        directory: str,\n        search_pattern: str,\n        replace_string: str,\n        xpath: str = \"\",\n        setting: str = \"\",\n        assoc_elem: str = \"\",\n    ) -&gt; bool:\n        \"\"\"Replaces all occurrences of the search pattern with the replace string in all XML files\n            in the directory and its subdirectories.\n\n        Args:\n            directory (str): directory to traverse for XML files\n            search_pattern (str): string to search in the XML file. This can be empty\n                                  if xpath is used!\n            replace_string (str): replacement string\n            xpath (str): narrow down the replacement to an XML element that es defined by the XPath\n                         for now the XPath needs to be constructed in a way the it returns\n                         one or none element.\n            setting (str): narrow down the replacement to the line that includes the setting with this name.\n                           This parameter is optional.\n            assoc_elem (str): lookup a specific assoc element. This parameter is optional.\n        Returns:\n            bool: True if a replacement happened, False otherwise\n        \"\"\"\n        # Define the regular expression pattern to search for\n        # search pattern can be empty if an xpath is used. So\n        # be careful here:\n        if search_pattern:\n            pattern = re.compile(search_pattern)\n\n        found = False\n\n        # Traverse the directory and its subdirectories\n        for subdir, _, files in os.walk(directory):\n            for filename in files:\n                # Check if the file is an XML file\n                if filename.endswith(\".xml\"):\n                    # Read the contents of the file\n                    file_path = os.path.join(subdir, filename)\n\n                    # if xpath is given we do an intelligent replacement\n                    if xpath:\n                        xml_modified = False\n                        logger.info(\"Replacement with xpath...\")\n                        logger.info(\n                            \"XML path -&gt; %s, setting -&gt; %s, assoc element -&gt; %s\",\n                            xpath,\n                            setting,\n                            assoc_elem,\n                        )\n                        tree = etree.parse(file_path)\n                        if not tree:\n                            logger.erro(\n                                \"Cannot parse XML tree -&gt; {}. Skipping...\".format(\n                                    file_path\n                                )\n                            )\n                            continue\n                        root = tree.getroot()\n                        # find the matching XML elements using the given XPath:\n                        elements = root.xpath(xpath)\n                        if not elements:\n                            logger.info(\n                                \"The XML file -&gt; %s does not have any element with the given XML path -&gt; %s. Skipping...\",\n                                file_path,\n                                xpath,\n                            )\n                            continue\n                        for element in elements:\n                            # as XPath returns a list\n                            logger.info(\n                                \"Found XML element -&gt; %s in file -&gt; %s using xpath -&gt; %s\",\n                                element.tag,\n                                filename,\n                                xpath,\n                            )\n                            # the simple case: replace the complete text of the XML element\n                            if not setting and not assoc_elem:\n                                logger.info(\n                                    \"Replace complete text of XML element -&gt; %s from -&gt; %s to -&gt; %s\",\n                                    xpath,\n                                    element.text,\n                                    replace_string,\n                                )\n                                element.text = replace_string\n                                xml_modified = True\n                            # In this case we want to set a complete value of a setting (basically replacing a whole line)\n                            elif setting and not assoc_elem:\n                                logger.info(\n                                    \"Replace single setting -&gt; %s in XML element -&gt; %s with new value -&gt; %s\",\n                                    setting,\n                                    xpath,\n                                    replace_string,\n                                )\n                                setting_value = cls.search_setting(\n                                    element.text, setting, is_simple=True\n                                )\n                                if setting_value:\n                                    logger.info(\n                                        \"Found existing setting value -&gt; %s\",\n                                        setting_value,\n                                    )\n                                    # Check if the setting value needs to be surrounded by quotes.\n                                    # Only simplistic values like booleans or numeric values don't need quotes\n                                    if (\n                                        replace_string == \"true\"\n                                        or replace_string == \"false\"\n                                        or replace_string == \"none\"\n                                        or replace_string.isnumeric()\n                                    ):\n                                        replace_setting = (\n                                            '\"' + setting + '\":' + replace_string\n                                        )\n                                    else:\n                                        replace_setting = (\n                                            '\"' + setting + '\":\"' + replace_string + '\"'\n                                        )\n                                    logger.info(\n                                        \"Replacement setting -&gt; %s\", replace_setting\n                                    )\n                                    element.text = cls.replace_setting(\n                                        element_text=element.text,\n                                        setting_key=setting,\n                                        new_value=replace_setting,\n                                        is_simple=True,\n                                    )\n                                    xml_modified = True\n                                else:\n                                    logger.warning(\n                                        \"Cannot find the value for setting -&gt; %s. Skipping...\",\n                                        setting,\n                                    )\n                                    continue\n                            # in this case the text is just one assoc (no setting substructure)\n                            elif not setting and assoc_elem:\n                                logger.info(\n                                    \"Replace single Assoc value -&gt; %s in XML element -&gt; %s with -&gt; %s\",\n                                    assoc_elem,\n                                    xpath,\n                                    replace_string,\n                                )\n                                assoc_string: str = Assoc.extract_assoc_string(\n                                    input_string=element.text\n                                )\n                                logger.debug(\"Assoc String -&gt; %s\", assoc_string)\n                                assoc_dict = Assoc.string_to_dict(\n                                    assoc_string=assoc_string\n                                )\n                                logger.debug(\"Assoc Dict -&gt; %s\", str(assoc_dict))\n                                assoc_dict[\n                                    assoc_elem\n                                ] = replace_string  # escaped_replace_string\n                                assoc_string_new: str = Assoc.dict_to_string(\n                                    assoc_dict=assoc_dict\n                                )\n                                logger.info(\n                                    \"Replace assoc with -&gt; %s\", assoc_string_new\n                                )\n                                element.text = assoc_string_new\n                                element.text = element.text.replace('\"', \"&amp;quot;\")\n                                xml_modified = True\n                            # In this case we have multiple settings with their own assocs\n                            elif setting and assoc_elem:\n                                logger.info(\n                                    \"Replace single Assoc value -&gt; %s in setting -&gt; %s in XML element -&gt; %s with -&gt; %s\",\n                                    assoc_elem,\n                                    setting,\n                                    xpath,\n                                    replace_string,\n                                )\n                                setting_value = cls.search_setting(\n                                    element.text, setting, is_simple=False\n                                )\n                                if setting_value:\n                                    logger.info(\n                                        \"Found setting value -&gt; %s\", setting_value\n                                    )\n                                    assoc_string: str = Assoc.extract_assoc_string(\n                                        input_string=setting_value\n                                    )\n                                    logger.debug(\"Assoc String -&gt; %s\", assoc_string)\n                                    assoc_dict = Assoc.string_to_dict(\n                                        assoc_string=assoc_string\n                                    )\n                                    logger.debug(\"Assoc Dict -&gt; %s\", str(assoc_dict))\n                                    escaped_replace_string = replace_string.replace(\n                                        \"'\", \"\\\\\\\\\\u0027\"\n                                    )\n                                    logger.info(\n                                        \"Escaped replacement string -&gt; %s\",\n                                        escaped_replace_string,\n                                    )\n                                    assoc_dict[\n                                        assoc_elem\n                                    ] = escaped_replace_string  # escaped_replace_string\n                                    assoc_string_new: str = Assoc.dict_to_string(\n                                        assoc_dict=assoc_dict\n                                    )\n                                    assoc_string_new = assoc_string_new.replace(\n                                        \"'\", \"\\\\u0027\"\n                                    )\n                                    # replace_setting = \"&amp;quot;\" + setting + \"&amp;quot;:&amp;quot;\" + assoc_string_new + \"&amp;quot;\"\n                                    replace_setting = (\n                                        '\"' + setting + '\":\"' + assoc_string_new + '\"'\n                                    )\n                                    logger.info(\n                                        \"Replacement setting -&gt; %s\", replace_setting\n                                    )\n                                    # here we need to apply a \"trick\". It is required\n                                    # as regexp cannot handle the special unicode escapes \\u0027\n                                    # we require. We first insert a placeholder \"PLACEHOLDER\"\n                                    # and let regexp find the right place for it. Then further\n                                    # down we use a simple search&amp;replace to switch the PLACEHOLDER\n                                    # to the real value (replace() does not have the issues with unicode escapes)\n                                    element.text = cls.replace_setting(\n                                        element_text=element.text,\n                                        setting_key=setting,\n                                        #                                        new_value=replace_setting,\n                                        new_value=\"PLACEHOLDER\",\n                                        is_simple=False,\n                                        is_escaped=False,\n                                    )\n                                    element.text = element.text.replace(\n                                        \"PLACEHOLDER\", replace_setting\n                                    )\n                                    element.text = element.text.replace('\"', \"&amp;quot;\")\n                                    xml_modified = True\n                                else:\n                                    logger.warning(\n                                        \"Cannot find the value for setting -&gt; %s. Skipping...\",\n                                        setting,\n                                    )\n                                    continue\n                        if xml_modified:\n                            logger.info(\n                                \"XML tree has been modified. Write updated file -&gt; %s...\",\n                                file_path,\n                            )\n\n                            new_contents = etree.tostring(\n                                tree,\n                                pretty_print=True,\n                                xml_declaration=True,\n                                encoding=\"UTF-8\",\n                            )\n                            # we need to undo some of the stupid things tostring() did:\n                            new_contents = new_contents.replace(\n                                b\"&amp;amp;quot;\", b\"&amp;quot;\"\n                            )\n                            new_contents = new_contents.replace(\n                                b\"&amp;amp;apos;\", b\"&amp;apos;\"\n                            )\n                            new_contents = new_contents.replace(b\"&amp;amp;gt;\", b\"&amp;gt;\")\n                            new_contents = new_contents.replace(b\"&amp;amp;lt;\", b\"&amp;lt;\")\n\n                            # Replace single quotes inside double quotes strings with \"&amp;apos;\" (manual escaping)\n                            # This is required as we next want to replace all double quotes with single quotes\n                            pattern = b'\"([^\"]*)\"'\n                            new_contents = re.sub(\n                                pattern,\n                                lambda m: m.group(0).replace(b\"'\", b\"&amp;apos;\"),\n                                new_contents,\n                            )\n\n                            # Replace single quotes in XML text elements with \"&amp;apos;\"\n                            # and replace double quotes in XML text elements with \"&amp;quot;\"\n                            # This is required as we next want to replace all double quotes with single quotes\n                            # to make the XML files as similar as possible with Extended ECM's format\n                            pattern = b\"&gt;([^&lt;&gt;]+?)&lt;\"\n                            replacement = lambda match: match.group(0).replace(\n                                b'\"', b\"&amp;quot;\"\n                            )\n                            new_contents = re.sub(pattern, replacement, new_contents)\n                            replacement = lambda match: match.group(0).replace(\n                                b\"'\", b\"&amp;apos;\"\n                            )\n                            new_contents = re.sub(pattern, replacement, new_contents)\n\n                            # Change double quotes to single quotes across the XML file - Extended ECM has it that way:\n                            new_contents = new_contents.replace(b'\"', b\"'\")\n\n                            # Write the updated contents to the file.\n                            # We DO NOT want to use tree.write() here\n                            # as it would undo the manual XML tweaks we\n                            # need for Extended ECM. We also need \"wb\"\n                            # as we have bytes and not str as a data type\n                            with open(file_path, \"wb\") as f:\n                                f.write(new_contents)\n\n                            found = True\n                    # this is not using xpath - do a simple search and replace\n                    else:\n                        logger.info(\"Replacement without xpath...\")\n                        with open(file_path, \"r\", encoding=\"UTF-8\") as f:\n                            contents = f.read()\n                        # Replace all occurrences of the search pattern with the replace string\n                        new_contents = pattern.sub(replace_string, contents)\n\n                        # Write the updated contents to the file if there were replacements\n                        if contents != new_contents:\n                            logger.info(\n                                \"Found search string -&gt; %s in XML file -&gt; %s. Write updated file...\",\n                                search_pattern,\n                                file_path,\n                            )\n                            # Write the updated contents to the file\n                            with open(file_path, \"w\", encoding=\"UTF-8\") as f:\n                                f.write(new_contents)\n                            found = True\n\n        return found\n\n    @classmethod\n    def extract_from_xml_files(\n        cls,\n        directory: str,\n        xpath: str,\n    ) -&gt; list | None:\n        \"\"\"Extracts the XML subtrees using an XPath in all XML files\n            in the directory and its subdirectories.\n\n        Args:\n            directory (str): directory to traverse for XML files\n            xpath (str): used to determine XML elements to extract\n        Returns:\n            list | None: Extracted data if it is found by the XPath, None otherwise\n        \"\"\"\n\n        extracted_data_list = []\n\n        # Traverse the directory and its subdirectories\n        for subdir, _, files in os.walk(directory):\n            for filename in files:\n                # Check if the file is an XML file\n                if filename.endswith(\".xml\"):\n                    # Read the contents of the file\n                    file_path = os.path.join(subdir, filename)\n\n                    logger.info(\"Extraction with xpath -&gt; %s...\", xpath)\n                    tree = etree.parse(file_path)\n                    if not tree:\n                        logger.erro(\n                            \"Cannot parse XML tree -&gt; {}. Skipping...\".format(file_path)\n                        )\n                        continue\n                    root = tree.getroot()\n                    # find the matching XML elements using the given XPath:\n                    elements = root.xpath(xpath)\n                    if not elements:\n                        logger.info(\n                            \"The XML file -&gt; %s does not have any element with the given XML path -&gt; %s. Skipping...\",\n                            file_path,\n                            xpath,\n                        )\n                        continue\n                    for element in elements:\n                        # as XPath returns a list\n                        logger.info(\n                            \"Found XML element -&gt; %s in file -&gt; %s using xpath -&gt; %s. Add it to result list.\",\n                            element.tag,\n                            filename,\n                            xpath,\n                        )\n                        extracted_content = etree.tostring(element)\n\n                        try:\n                            dict_content = xmltodict.parse(extracted_content)\n                        except xmltodict.expat.ExpatError:\n                            logger.error(\n                                \"Invalid XML syntax in file -&gt; %s. Please check the XML file for errors.\",\n                                filename,\n                            )\n                            continue\n\n                        extracted_data_list.append(dict_content)\n\n        return extracted_data_list\n</code></pre>"},{"location":"pyxecm/xml/#pyxecm.helper.xml.XML.extract_from_xml_files","title":"<code>extract_from_xml_files(directory, xpath)</code>  <code>classmethod</code>","text":"<p>Extracts the XML subtrees using an XPath in all XML files     in the directory and its subdirectories.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>directory to traverse for XML files</p> required <code>xpath</code> <code>str</code> <p>used to determine XML elements to extract</p> required <p>Returns:     list | None: Extracted data if it is found by the XPath, None otherwise</p> Source code in <code>pyxecm/helper/xml.py</code> <pre><code>@classmethod\ndef extract_from_xml_files(\n    cls,\n    directory: str,\n    xpath: str,\n) -&gt; list | None:\n    \"\"\"Extracts the XML subtrees using an XPath in all XML files\n        in the directory and its subdirectories.\n\n    Args:\n        directory (str): directory to traverse for XML files\n        xpath (str): used to determine XML elements to extract\n    Returns:\n        list | None: Extracted data if it is found by the XPath, None otherwise\n    \"\"\"\n\n    extracted_data_list = []\n\n    # Traverse the directory and its subdirectories\n    for subdir, _, files in os.walk(directory):\n        for filename in files:\n            # Check if the file is an XML file\n            if filename.endswith(\".xml\"):\n                # Read the contents of the file\n                file_path = os.path.join(subdir, filename)\n\n                logger.info(\"Extraction with xpath -&gt; %s...\", xpath)\n                tree = etree.parse(file_path)\n                if not tree:\n                    logger.erro(\n                        \"Cannot parse XML tree -&gt; {}. Skipping...\".format(file_path)\n                    )\n                    continue\n                root = tree.getroot()\n                # find the matching XML elements using the given XPath:\n                elements = root.xpath(xpath)\n                if not elements:\n                    logger.info(\n                        \"The XML file -&gt; %s does not have any element with the given XML path -&gt; %s. Skipping...\",\n                        file_path,\n                        xpath,\n                    )\n                    continue\n                for element in elements:\n                    # as XPath returns a list\n                    logger.info(\n                        \"Found XML element -&gt; %s in file -&gt; %s using xpath -&gt; %s. Add it to result list.\",\n                        element.tag,\n                        filename,\n                        xpath,\n                    )\n                    extracted_content = etree.tostring(element)\n\n                    try:\n                        dict_content = xmltodict.parse(extracted_content)\n                    except xmltodict.expat.ExpatError:\n                        logger.error(\n                            \"Invalid XML syntax in file -&gt; %s. Please check the XML file for errors.\",\n                            filename,\n                        )\n                        continue\n\n                    extracted_data_list.append(dict_content)\n\n    return extracted_data_list\n</code></pre>"},{"location":"pyxecm/xml/#pyxecm.helper.xml.XML.get_xml_element","title":"<code>get_xml_element(xml_content, xpath)</code>  <code>classmethod</code>","text":"<p>Retrieves an XML Element from a string using an XPath expression</p> <p>Parameters:</p> Name Type Description Default <code>xml_content</code> <code>str</code> <p>XML file as a string</p> required <code>xpath</code> <code>str</code> <p>XPath to find the element</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>text of element</p> Source code in <code>pyxecm/helper/xml.py</code> <pre><code>@classmethod\ndef get_xml_element(cls, xml_content: str, xpath: str):\n    \"\"\"Retrieves an XML Element from a string using an XPath expression\n\n    Args:\n        xml_content (str): XML file as a string\n        xpath (str): XPath to find the element\n\n    Returns:\n        str: text of element\n    \"\"\"\n\n    # Parse XML content into an etree\n    tree = etree.fromstring(xml_content)\n\n    # Find the XML element specified by XPath\n    element = tree.find(xpath)\n\n    return element\n</code></pre>"},{"location":"pyxecm/xml/#pyxecm.helper.xml.XML.modify_xml_element","title":"<code>modify_xml_element(xml_content, xpath, new_value)</code>  <code>classmethod</code>","text":"<p>Update the text (= content) of an XML element</p> <p>Parameters:</p> Name Type Description Default <code>xml_content</code> <code>str</code> <p>the content of an XML file</p> required <code>xpath</code> <code>str</code> <p>XML Path to identify the XML element</p> required <code>new_value</code> <code>str</code> <p>new text (content)</p> required Source code in <code>pyxecm/helper/xml.py</code> <pre><code>@classmethod\ndef modify_xml_element(cls, xml_content: str, xpath: str, new_value: str):\n    \"\"\"Update the text (= content) of an XML element\n\n    Args:\n        xml_content (str): the content of an XML file\n        xpath (str): XML Path to identify the XML element\n        new_value (str): new text (content)\n    \"\"\"\n    element = cls.get_xml_element(xml_content=xml_content, xpath=xpath)\n\n    if element is not None:\n        # Modify the XML element with the new value\n        element.text = new_value\n    else:\n        logger.warning(\"XML Element -&gt; %s not found.\", xpath)\n</code></pre>"},{"location":"pyxecm/xml/#pyxecm.helper.xml.XML.replace_in_xml_files","title":"<code>replace_in_xml_files(directory, search_pattern, replace_string, xpath='', setting='', assoc_elem='')</code>  <code>classmethod</code>","text":"<p>Replaces all occurrences of the search pattern with the replace string in all XML files     in the directory and its subdirectories.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>directory to traverse for XML files</p> required <code>search_pattern</code> <code>str</code> <p>string to search in the XML file. This can be empty                   if xpath is used!</p> required <code>replace_string</code> <code>str</code> <p>replacement string</p> required <code>xpath</code> <code>str</code> <p>narrow down the replacement to an XML element that es defined by the XPath          for now the XPath needs to be constructed in a way the it returns          one or none element.</p> <code>''</code> <code>setting</code> <code>str</code> <p>narrow down the replacement to the line that includes the setting with this name.            This parameter is optional.</p> <code>''</code> <code>assoc_elem</code> <code>str</code> <p>lookup a specific assoc element. This parameter is optional.</p> <code>''</code> <p>Returns:     bool: True if a replacement happened, False otherwise</p> Source code in <code>pyxecm/helper/xml.py</code> <pre><code>@classmethod\ndef replace_in_xml_files(\n    cls,\n    directory: str,\n    search_pattern: str,\n    replace_string: str,\n    xpath: str = \"\",\n    setting: str = \"\",\n    assoc_elem: str = \"\",\n) -&gt; bool:\n    \"\"\"Replaces all occurrences of the search pattern with the replace string in all XML files\n        in the directory and its subdirectories.\n\n    Args:\n        directory (str): directory to traverse for XML files\n        search_pattern (str): string to search in the XML file. This can be empty\n                              if xpath is used!\n        replace_string (str): replacement string\n        xpath (str): narrow down the replacement to an XML element that es defined by the XPath\n                     for now the XPath needs to be constructed in a way the it returns\n                     one or none element.\n        setting (str): narrow down the replacement to the line that includes the setting with this name.\n                       This parameter is optional.\n        assoc_elem (str): lookup a specific assoc element. This parameter is optional.\n    Returns:\n        bool: True if a replacement happened, False otherwise\n    \"\"\"\n    # Define the regular expression pattern to search for\n    # search pattern can be empty if an xpath is used. So\n    # be careful here:\n    if search_pattern:\n        pattern = re.compile(search_pattern)\n\n    found = False\n\n    # Traverse the directory and its subdirectories\n    for subdir, _, files in os.walk(directory):\n        for filename in files:\n            # Check if the file is an XML file\n            if filename.endswith(\".xml\"):\n                # Read the contents of the file\n                file_path = os.path.join(subdir, filename)\n\n                # if xpath is given we do an intelligent replacement\n                if xpath:\n                    xml_modified = False\n                    logger.info(\"Replacement with xpath...\")\n                    logger.info(\n                        \"XML path -&gt; %s, setting -&gt; %s, assoc element -&gt; %s\",\n                        xpath,\n                        setting,\n                        assoc_elem,\n                    )\n                    tree = etree.parse(file_path)\n                    if not tree:\n                        logger.erro(\n                            \"Cannot parse XML tree -&gt; {}. Skipping...\".format(\n                                file_path\n                            )\n                        )\n                        continue\n                    root = tree.getroot()\n                    # find the matching XML elements using the given XPath:\n                    elements = root.xpath(xpath)\n                    if not elements:\n                        logger.info(\n                            \"The XML file -&gt; %s does not have any element with the given XML path -&gt; %s. Skipping...\",\n                            file_path,\n                            xpath,\n                        )\n                        continue\n                    for element in elements:\n                        # as XPath returns a list\n                        logger.info(\n                            \"Found XML element -&gt; %s in file -&gt; %s using xpath -&gt; %s\",\n                            element.tag,\n                            filename,\n                            xpath,\n                        )\n                        # the simple case: replace the complete text of the XML element\n                        if not setting and not assoc_elem:\n                            logger.info(\n                                \"Replace complete text of XML element -&gt; %s from -&gt; %s to -&gt; %s\",\n                                xpath,\n                                element.text,\n                                replace_string,\n                            )\n                            element.text = replace_string\n                            xml_modified = True\n                        # In this case we want to set a complete value of a setting (basically replacing a whole line)\n                        elif setting and not assoc_elem:\n                            logger.info(\n                                \"Replace single setting -&gt; %s in XML element -&gt; %s with new value -&gt; %s\",\n                                setting,\n                                xpath,\n                                replace_string,\n                            )\n                            setting_value = cls.search_setting(\n                                element.text, setting, is_simple=True\n                            )\n                            if setting_value:\n                                logger.info(\n                                    \"Found existing setting value -&gt; %s\",\n                                    setting_value,\n                                )\n                                # Check if the setting value needs to be surrounded by quotes.\n                                # Only simplistic values like booleans or numeric values don't need quotes\n                                if (\n                                    replace_string == \"true\"\n                                    or replace_string == \"false\"\n                                    or replace_string == \"none\"\n                                    or replace_string.isnumeric()\n                                ):\n                                    replace_setting = (\n                                        '\"' + setting + '\":' + replace_string\n                                    )\n                                else:\n                                    replace_setting = (\n                                        '\"' + setting + '\":\"' + replace_string + '\"'\n                                    )\n                                logger.info(\n                                    \"Replacement setting -&gt; %s\", replace_setting\n                                )\n                                element.text = cls.replace_setting(\n                                    element_text=element.text,\n                                    setting_key=setting,\n                                    new_value=replace_setting,\n                                    is_simple=True,\n                                )\n                                xml_modified = True\n                            else:\n                                logger.warning(\n                                    \"Cannot find the value for setting -&gt; %s. Skipping...\",\n                                    setting,\n                                )\n                                continue\n                        # in this case the text is just one assoc (no setting substructure)\n                        elif not setting and assoc_elem:\n                            logger.info(\n                                \"Replace single Assoc value -&gt; %s in XML element -&gt; %s with -&gt; %s\",\n                                assoc_elem,\n                                xpath,\n                                replace_string,\n                            )\n                            assoc_string: str = Assoc.extract_assoc_string(\n                                input_string=element.text\n                            )\n                            logger.debug(\"Assoc String -&gt; %s\", assoc_string)\n                            assoc_dict = Assoc.string_to_dict(\n                                assoc_string=assoc_string\n                            )\n                            logger.debug(\"Assoc Dict -&gt; %s\", str(assoc_dict))\n                            assoc_dict[\n                                assoc_elem\n                            ] = replace_string  # escaped_replace_string\n                            assoc_string_new: str = Assoc.dict_to_string(\n                                assoc_dict=assoc_dict\n                            )\n                            logger.info(\n                                \"Replace assoc with -&gt; %s\", assoc_string_new\n                            )\n                            element.text = assoc_string_new\n                            element.text = element.text.replace('\"', \"&amp;quot;\")\n                            xml_modified = True\n                        # In this case we have multiple settings with their own assocs\n                        elif setting and assoc_elem:\n                            logger.info(\n                                \"Replace single Assoc value -&gt; %s in setting -&gt; %s in XML element -&gt; %s with -&gt; %s\",\n                                assoc_elem,\n                                setting,\n                                xpath,\n                                replace_string,\n                            )\n                            setting_value = cls.search_setting(\n                                element.text, setting, is_simple=False\n                            )\n                            if setting_value:\n                                logger.info(\n                                    \"Found setting value -&gt; %s\", setting_value\n                                )\n                                assoc_string: str = Assoc.extract_assoc_string(\n                                    input_string=setting_value\n                                )\n                                logger.debug(\"Assoc String -&gt; %s\", assoc_string)\n                                assoc_dict = Assoc.string_to_dict(\n                                    assoc_string=assoc_string\n                                )\n                                logger.debug(\"Assoc Dict -&gt; %s\", str(assoc_dict))\n                                escaped_replace_string = replace_string.replace(\n                                    \"'\", \"\\\\\\\\\\u0027\"\n                                )\n                                logger.info(\n                                    \"Escaped replacement string -&gt; %s\",\n                                    escaped_replace_string,\n                                )\n                                assoc_dict[\n                                    assoc_elem\n                                ] = escaped_replace_string  # escaped_replace_string\n                                assoc_string_new: str = Assoc.dict_to_string(\n                                    assoc_dict=assoc_dict\n                                )\n                                assoc_string_new = assoc_string_new.replace(\n                                    \"'\", \"\\\\u0027\"\n                                )\n                                # replace_setting = \"&amp;quot;\" + setting + \"&amp;quot;:&amp;quot;\" + assoc_string_new + \"&amp;quot;\"\n                                replace_setting = (\n                                    '\"' + setting + '\":\"' + assoc_string_new + '\"'\n                                )\n                                logger.info(\n                                    \"Replacement setting -&gt; %s\", replace_setting\n                                )\n                                # here we need to apply a \"trick\". It is required\n                                # as regexp cannot handle the special unicode escapes \\u0027\n                                # we require. We first insert a placeholder \"PLACEHOLDER\"\n                                # and let regexp find the right place for it. Then further\n                                # down we use a simple search&amp;replace to switch the PLACEHOLDER\n                                # to the real value (replace() does not have the issues with unicode escapes)\n                                element.text = cls.replace_setting(\n                                    element_text=element.text,\n                                    setting_key=setting,\n                                    #                                        new_value=replace_setting,\n                                    new_value=\"PLACEHOLDER\",\n                                    is_simple=False,\n                                    is_escaped=False,\n                                )\n                                element.text = element.text.replace(\n                                    \"PLACEHOLDER\", replace_setting\n                                )\n                                element.text = element.text.replace('\"', \"&amp;quot;\")\n                                xml_modified = True\n                            else:\n                                logger.warning(\n                                    \"Cannot find the value for setting -&gt; %s. Skipping...\",\n                                    setting,\n                                )\n                                continue\n                    if xml_modified:\n                        logger.info(\n                            \"XML tree has been modified. Write updated file -&gt; %s...\",\n                            file_path,\n                        )\n\n                        new_contents = etree.tostring(\n                            tree,\n                            pretty_print=True,\n                            xml_declaration=True,\n                            encoding=\"UTF-8\",\n                        )\n                        # we need to undo some of the stupid things tostring() did:\n                        new_contents = new_contents.replace(\n                            b\"&amp;amp;quot;\", b\"&amp;quot;\"\n                        )\n                        new_contents = new_contents.replace(\n                            b\"&amp;amp;apos;\", b\"&amp;apos;\"\n                        )\n                        new_contents = new_contents.replace(b\"&amp;amp;gt;\", b\"&amp;gt;\")\n                        new_contents = new_contents.replace(b\"&amp;amp;lt;\", b\"&amp;lt;\")\n\n                        # Replace single quotes inside double quotes strings with \"&amp;apos;\" (manual escaping)\n                        # This is required as we next want to replace all double quotes with single quotes\n                        pattern = b'\"([^\"]*)\"'\n                        new_contents = re.sub(\n                            pattern,\n                            lambda m: m.group(0).replace(b\"'\", b\"&amp;apos;\"),\n                            new_contents,\n                        )\n\n                        # Replace single quotes in XML text elements with \"&amp;apos;\"\n                        # and replace double quotes in XML text elements with \"&amp;quot;\"\n                        # This is required as we next want to replace all double quotes with single quotes\n                        # to make the XML files as similar as possible with Extended ECM's format\n                        pattern = b\"&gt;([^&lt;&gt;]+?)&lt;\"\n                        replacement = lambda match: match.group(0).replace(\n                            b'\"', b\"&amp;quot;\"\n                        )\n                        new_contents = re.sub(pattern, replacement, new_contents)\n                        replacement = lambda match: match.group(0).replace(\n                            b\"'\", b\"&amp;apos;\"\n                        )\n                        new_contents = re.sub(pattern, replacement, new_contents)\n\n                        # Change double quotes to single quotes across the XML file - Extended ECM has it that way:\n                        new_contents = new_contents.replace(b'\"', b\"'\")\n\n                        # Write the updated contents to the file.\n                        # We DO NOT want to use tree.write() here\n                        # as it would undo the manual XML tweaks we\n                        # need for Extended ECM. We also need \"wb\"\n                        # as we have bytes and not str as a data type\n                        with open(file_path, \"wb\") as f:\n                            f.write(new_contents)\n\n                        found = True\n                # this is not using xpath - do a simple search and replace\n                else:\n                    logger.info(\"Replacement without xpath...\")\n                    with open(file_path, \"r\", encoding=\"UTF-8\") as f:\n                        contents = f.read()\n                    # Replace all occurrences of the search pattern with the replace string\n                    new_contents = pattern.sub(replace_string, contents)\n\n                    # Write the updated contents to the file if there were replacements\n                    if contents != new_contents:\n                        logger.info(\n                            \"Found search string -&gt; %s in XML file -&gt; %s. Write updated file...\",\n                            search_pattern,\n                            file_path,\n                        )\n                        # Write the updated contents to the file\n                        with open(file_path, \"w\", encoding=\"UTF-8\") as f:\n                            f.write(new_contents)\n                        found = True\n\n    return found\n</code></pre>"},{"location":"pyxecm/xml/#pyxecm.helper.xml.XML.replace_setting","title":"<code>replace_setting(element_text, setting_key, new_value, is_simple=True, is_escaped=False)</code>  <code>classmethod</code>","text":"<p>Replace the value of a defined setting with a new value.</p> <p>The simple case covers settings like this: \"syncCandidates\":true, \"syncCandidates\":true, In this case the setting value is a scalar like true, false, a number or none the regular expression pattern searches for a setting name in \"...\" (quotes) followed by a colon (:). The value is taken from what follows the colon until the next comma (,)</p> <p>The more complex case is a string value that may itself have commas, so we cannot look for comma as a delimiter like in the simple case but we take the value for a string delimited by double quotes (\"...\")</p> <p>Parameters:</p> Name Type Description Default <code>element_text</code> <code>str</code> <p>original text of the XML element (that is to be updated)</p> required <code>setting_key</code> <code>str</code> <p>name of the setting</p> required <code>new_value</code> <code>str</code> <p>new value of the setting</p> required <code>is_simple</code> <code>bool</code> <p>True = value is a scalar like true, false, a number or none. Defaults to True.</p> <code>True</code> <code>is_escaped</code> <code>bool</code> <p>True if the value is surrrounded with \". Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>updated element text</p> Source code in <code>pyxecm/helper/xml.py</code> <pre><code>@classmethod\ndef replace_setting(\n    cls,\n    element_text: str,\n    setting_key: str,\n    new_value: str,\n    is_simple: bool = True,\n    is_escaped: bool = False,\n) -&gt; str:\n    \"\"\"Replace the value of a defined setting with a new value.\n\n    The simple case covers settings like this:\n    &amp;quot;syncCandidates&amp;quot;:true,\n    \"syncCandidates\":true,\n    In this case the setting value is a scalar like true, false, a number or none\n    the regular expression pattern searches for a setting name in \"...\" (quotes) followed\n    by a colon (:). The value is taken from what follows the colon until the next comma (,)\n\n    The more complex case is a string value that may itself have commas,\n    so we cannot look for comma as a delimiter like in the simple case\n    but we take the value for a string delimited by double quotes (\"...\")\n\n    Args:\n        element_text (str): original text of the XML element (that is to be updated)\n        setting_key (str): name of the setting\n        new_value (str): new value of the setting\n        is_simple (bool, optional): True = value is a scalar like true, false, a number or none. Defaults to True.\n        is_escaped (bool, optional): True if the value is surrrounded with &amp;quot;. Defaults to False.\n\n    Returns:\n        str: updated element text\n    \"\"\"\n\n    if is_simple:\n        if is_escaped:\n            pattern = r\"&amp;quot;{0}&amp;quot;:[^,]*\".format(setting_key)\n        else:\n            pattern = r'\"{0}\":[^,]*'.format(setting_key)\n    else:\n        if is_escaped:\n            pattern = r\"&amp;quot;{0}&amp;quot;:&amp;quot;.*&amp;quot;\".format(setting_key)\n        else:\n            pattern = r'\"{0}\":\"([^\"]*)\"'.format(setting_key)\n\n    new_text = re.sub(pattern, new_value, element_text)\n\n    return new_text\n</code></pre>"},{"location":"pyxecm/xml/#pyxecm.helper.xml.XML.search_setting","title":"<code>search_setting(element_text, setting_key, is_simple=True, is_escaped=False)</code>  <code>classmethod</code>","text":"<p>Search a setting in an XML element and return its value</p> <p>The simple case covers settings like this: \"syncCandidates\":true, \"syncCandidates\":true, In this case the setting value is a scalar like true, false, a number or none the regular expression pattern searches for a setting name in \"...\" (quotes) followed by a colon (:). The value is taken from what follows the colon until the next comma (,)</p> <p>The more complex case is a string value that may itself have commas, so we cannot look for comma as a delimiter like in the simple case but we take the value for a string delimited by double quotes (\"...\")</p> <p>Parameters:</p> Name Type Description Default <code>element_text</code> <code>str</code> <p>the text to examine - typically content of an XML element</p> required <code>setting_key</code> <code>str</code> <p>name of the setting key (before the colon)</p> required <code>is_simple</code> <code>bool</code> <p>True if the value is scalar (not having assocs with commas). Defaults to True.</p> <code>True</code> <code>is_escaped</code> <code>bool</code> <p>True if the quotes or escaped with \". Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>the value of the setting or None if the setting is not found.</p> Source code in <code>pyxecm/helper/xml.py</code> <pre><code>@classmethod\ndef search_setting(\n    cls,\n    element_text: str,\n    setting_key: str,\n    is_simple: bool = True,\n    is_escaped: bool = False,\n) -&gt; str | None:\n    \"\"\"Search a setting in an XML element and return its value\n\n    The simple case covers settings like this:\n    &amp;quot;syncCandidates&amp;quot;:true,\n    \"syncCandidates\":true,\n    In this case the setting value is a scalar like true, false, a number or none\n    the regular expression pattern searches for a setting name in \"...\" (quotes) followed\n    by a colon (:). The value is taken from what follows the colon until the next comma (,)\n\n    The more complex case is a string value that may itself have commas,\n    so we cannot look for comma as a delimiter like in the simple case\n    but we take the value for a string delimited by double quotes (\"...\")\n\n    Args:\n        element_text (str): the text to examine - typically content of an XML element\n        setting_key (str): name of the setting key (before the colon)\n        is_simple (bool, optional): True if the value is scalar (not having assocs with commas). Defaults to True.\n        is_escaped (bool, optional): True if the quotes or escaped with &amp;quot;. Defaults to False.\n\n    Returns:\n        str: the value of the setting or None if the setting is not found.\n    \"\"\"\n\n    if is_simple:\n        if is_escaped:\n            pattern = r\"&amp;quot;{0}&amp;quot;:[^,]*\".format(setting_key)\n        else:\n            pattern = r'\"{0}\":[^,]*'.format(setting_key)\n    else:\n        if is_escaped:\n            pattern = r\"&amp;quot;{0}&amp;quot;:&amp;quot;.*&amp;quot;\".format(setting_key)\n        else:\n            pattern = r'\"{0}\":\"([^\"]*)\"'.format(setting_key)\n\n    match = re.search(pattern, element_text)\n    if match:\n        setting_line = match.group(0)\n        setting_value = setting_line.split(\":\")[1]\n        return setting_value\n    else:\n        return None\n</code></pre>"}]}