{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PYXECM","text":"<p>A python library to interact with Opentext Extended ECM REST API.  API documentation is available on OpenText Developer</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Copyright \u00a9 2023 Open Text Corporation, All Rights Reserved. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"payload-syntax/","title":"Payload Syntax","text":""},{"location":"payload-syntax/#customizing","title":"Customizing","text":"<p>The customizing payload can be defined in either of the following standards:</p> <ul> <li>Terraform / HCL</li> <li>YAML</li> </ul> Terraform / HCLYAML <p>The Terraform language uses the following types for its values:</p> <ul> <li><code>string</code>: a sequence of Unicode characters representing some text, like <code>\"hello\"</code>.</li> <li><code>number</code>: a numeric value. The number type can represent both whole numbers like 15 and fractional values like <code>6.283185</code>.</li> <li><code>bool</code>: a boolean value, either true or false. bool values can be used in conditional logic.</li> <li><code>list (or tuple)</code>: a sequence of values, like <code>[\"user1\", \"user2\"]</code>.</li> <li><code>map (or dictionary)</code>: a group of values identified by named labels, like <code>{name = \"nwheeler\", security_clearance = 50}</code>.</li> </ul> <p>Most of the customizing settings may have an optional field called <code>enabled</code> that allows to dynamically turn on / off customization settings based on a boolean value that may be read from a Terraform variable (or could just be <code>False</code> or <code>True</code>). In case you are using additional external payload (see above) you need to provide <code>False</code> or <code>True</code> directly. If <code>enabled</code> is not specified then <code>enabled = True</code> is assumed (this is the default).</p> <p>The YAML language uses the following types for its values:</p> <ul> <li><code>string</code>: a sequence of Unicode characters representing some text, like <code>hello</code>.</li> <li><code>number</code>: a numeric value. The number type can represent both whole numbers like 15 and fractional values like <code>6.283185</code>.</li> <li><code>bool</code>: a boolean value, either <code>True</code> or <code>False</code>.</li> <li><code>list</code>: a sequence of values, like <code>[\"user1\", \"user2\"]</code> or   <pre><code>- name: user1\n- name: user2\n</code></pre></li> <li><code>dictionary</code>: a group of values identified by named labels, like <code>{name = \"nwheeler\", security_clearance = 50}</code>.   <pre><code>  name: nwheeler\nsecurity_clearance: 50\n</code></pre></li> </ul> <p>Sample usage:   <pre><code>users:\n- name: nwheeler\nsecurity_clearance: 50\n- name: adminton\nsecurity_clearance: 90\n</code></pre></p> <p>Most of the customizing settings may have an optional field called <code>enabled</code> that allows to dynamically turn on / off customization settings based on a boolean value. If <code>enabled</code> is not specified then <code>enabled = True</code> is assumed (this is the default).</p>"},{"location":"payload-syntax/#otds-customizing-syntax","title":"OTDS Customizing Syntax","text":"<p>The payload syntax for OTDS customizing uses the following lists (the list elements are maps):</p>"},{"location":"payload-syntax/#partitions","title":"partitions","text":"<p><code>partitions</code> allows to create new partitions in OTDS. It is also possible to directly put the new partition into an existing <code>access role</code>:</p> Terraform / HCLYAML <pre><code>partitions = [\n{\nname        = \"Salesforce\"\ndescription = \"Salesforce user partition\"\nsynced      = false\naccess_role = \"Access to cs\"\n}\n]\n</code></pre> <pre><code>partitions:\n- name: \"Salesforce\"\ndescription: \"Salesforce user partition\"\nsynced: False\naccess_role: \"Access to cs\"\n</code></pre>"},{"location":"payload-syntax/#oauthclients","title":"oauthClients","text":"<p><code>oauthClients</code> allows to create new OAuth client in OTDS. Each list element includes a switch <code>enabled</code> to turn them on or off. This switch can be controlled by a Terraform variable. <code>name</code> defines the name of the OTDS OAuth client and <code>description</code> should describe what the OAuth client is used for. Each OAuth client has the typical elements such as <code>confidential</code>, OTDS <code>partition</code>, a <code>redirect_url</code>, <code>permission_scope</code>, <code>default_scope</code>, and <code>allow_impersonation</code>.</p> Terraform / HCLYAML <pre><code>oauthClients = [\n{\nenabled             = var.enable_salesforce\nname                = \"salesforce\"\ndescription         = \"OAuth client for Salesforce\"\nconfidential        = true\npartition           = \"Global\"\nredirect_urls       = [\"https://salesforce.com/services/authcallback/OTDS\"]\npermission_scopes   = [\"full\"]\ndefault_scopes      = [\"full\"]\nallow_impersonation = true\n}\n]\n</code></pre> <pre><code>  oauthClients:\n- allow_impersonation: true\nconfidential: true\ndefault_scopes:\n- full\ndescription: OAuth client for Salesforce\nenabled: ${var.enable_salesforce}\nname: salesforce\npartition: Global\npermission_scopes:\n- full\nredirect_urls:\n- https://salesforce.com/services/authcallback/OTDS\n</code></pre>"},{"location":"payload-syntax/#authhandlers","title":"authHandlers","text":"<p><code>authHandlers</code> is a list of additional OTDS authentication handlers. The values can also use terraform variables.</p> Terraform / HCLYAML <pre><code>authHandlers = [\n{\nenabled                = true\nname                   = \"...\"\ndescription            = \"...\"\ntype                   = \"...\" # either SAML, OAUTH, or SAP\nprovider_name          = \"...\" # required for SAML and OAUTH\nsaml_url               = \"...\" # required for SAML\notds_url               = \"https://${local.otds_dns_name}/otdsws/login\" # required for SAML\ncertificate_file       = \"...\" # required only for SAP\ncertificate_password   = \"...\" # required only for SAP\nclient_id              = \"...\" # required only for OAUTH\nclient_secret          = \"...\" # required only for OAUTH\nactive_by_default      = false # replace standard OTDS login page\nauthorization_endpoint = \"...\" # required only for OAUTH\ntoken_endpoint         = \"...\" # required only for OAUTH\n},\n]\n</code></pre> <pre><code>  authHandlers:\n- active_by_default: false\nauthorization_endpoint: '...'\ncertificate_file: '...'\ncertificate_password: '...'\nclient_id: '...'\nclient_secret: '...'\ndescription: '...'\nenabled: true\nname: '...'\notds_url: https://${local.otds_dns_name}/otdsws/login\nprovider_name: '...'\nsaml_url: '...'\ntoken_endpoint: '...'\ntype: '...'\n</code></pre>"},{"location":"payload-syntax/#trustedsites","title":"trustedSites","text":"<p><code>trustedSites</code> allows you to define trusted sites for OTDS. Each trusted site defines a URL and can be enabled or disabled. Regular expressions are allowed to define patterns.</p> Terraform / HCLYAML <pre><code>trustedSites = [\n{\nenabled = var.enable_successfactors\nurl     = \"https://[^/]+\\\\.successfactors\\\\.eu/.*\"\n},\n{\nenabled = var.enable_successfactors\nurl     = \"https://[^/]+\\\\.successfactors\\\\.com/.*\"\n},\n{\nenabled = var.enable_salesforce\nurl     = \"https://[^/]+\\\\.salesforce\\\\.com/.*\"\n},\n{\nenabled = var.enable_salesforce\nurl     = \"https://[^/]+\\\\.force\\\\.com/.*\"\n},\n{\nenabled = var.enable_o365\nurl     = \"https://[^/]+\\\\.microsoft\\\\.com/.*\"\n},\n{\nenabled = var.enable_o365\nurl     = \"https://[^/]+\\\\.sharepoint\\\\.com/.*\"\n},\n{\nenabled = var.enable_o365\nurl     = \"https://[^/]+\\\\.office\\\\.com/.*\"\n},\n{\nenabled = var.enable_appworks\nurl     = \"https://${local.otawp_dns_name}\" # AppWorks endpoint\n},\n]\n</code></pre> <pre><code>trustedSites:\n- enabled: ${var.enable_successfactors}\nurl: https://[^/]+\\\\.successfactors\\\\.eu/.*\n- enabled: ${var.enable_successfactors}\nurl: https://[^/]+\\\\.successfactors\\\\.com/.*\n- enabled: ${var.enable_salesforce}\nurl: https://[^/]+\\\\.salesforce\\\\.com/.*\n- enabled: ${var.enable_salesforce}\nurl: https://[^/]+\\\\.force\\\\.com/.*\n- enabled: ${var.enable_o365}\nurl: https://[^/]+\\\\.microsoft\\\\.com/.*\n- enabled: ${var.enable_o365}\nurl: https://[^/]+\\\\.sharepoint\\\\.com/.*\n- enabled: ${var.enable_o365}\nurl: https://[^/]+\\\\.office\\\\.com/.*\n- enabled: ${var.enable_appworks}\nurl: https://${local.otawp_dns_name}\n</code></pre>"},{"location":"payload-syntax/#systemattributes","title":"systemAttributes","text":"<p><code>systemAttributes</code> allows you to set system attributes in OTDS. Each trusted site has a name, value and an optional description.</p> Terraform / HCLYAML <pre><code>systemAttributes = [\n{\nname        = \"otds.as.SameSiteCookieVal\"\nvalue       = \"None\"\ndescription = \"SameSite Cookie Attribute\"\n}\n]\n</code></pre> <pre><code>systemAttributes:\n- description: SameSite Cookie Attribute\nname: otds.as.SameSiteCookieVal\nvalue: None\n</code></pre>"},{"location":"payload-syntax/#additionalgroupmemberships","title":"additionalGroupMemberships","text":"<p><code>additionalGroupMemberships</code> allows to put a pre-existing users or groups into existing OTDS groups. Each element consists of a <code>parent_group</code> value combined with either a <code>group_name</code> or <code>user_name</code> value depending whether you wannt to add a user or group.</p> Terraform / HCLYAML <pre><code>additionalGroupMemberships = [\n{\nparent_group = \"Business Administrators@Content Server Members\"\nuser_name    = \"otadmin@otds.admin\"\n}\n]\n</code></pre> <pre><code>additionalGroupMemberships:\n- parent_group: Business Administrators@Content Server Members\nuser_name: otadmin@otds.admin\n</code></pre>"},{"location":"payload-syntax/#additionalaccessrolememberships","title":"additionalAccessRoleMemberships","text":"<p><code>additionalAccessRoleMemberships</code> allows to put pre-existing users for groups into existing OTDS Access Roles. Each element consists of a <code>access_role</code> value combined with either a <code>group_name</code>, <code>user_name</code>, or <code>partition_name</code> value depending whether you wannt to add a user, group, or a whole OTDS partition to the OTDS Access Role.</p> Terraform / HCLYAML <pre><code>additionalAccessRoleMemberships = [\n{\naccess_role = \"Access to cs\"\ngroup_name  = \"otdsadmins@otds.admin\"\n},\n{\n    # Add the Content Server Members partition to the AppworksGateway access role\nenabled        = var.enable_appworks_gateway\naccess_role    = \"Access to gatewayresource\"\npartition_name = \"Content Server Members\"\n}\n]\n</code></pre> <pre><code>additionalAccessRoleMemberships:\n- access_role: Access to cs\ngroup_name: otdsadmins@otds.admin\n- access_role: Access to gatewayresource\nenabled: ${var.enable_appworks_gateway}\npartition_name: Content Server Members\n</code></pre>"},{"location":"payload-syntax/#extended-ecm-customizing-syntax","title":"Extended ECM Customizing Syntax","text":"<p>The payload syntax for Extended ECM configurations uses these lists (most elements are maps, some are plain strings):</p>"},{"location":"payload-syntax/#groups","title":"groups","text":"<p><code>groups</code> is a list of Extended ECM user groups that are automatically created during the deployment. Each group has a name and (optionally) a list of parent groups. The switch <code>enabled</code> is used to turn groups on or off. This switch can be controlled by a Terraform variable. <code>enable_o365</code> is used to control whether or not a Microsoft 365 group should be created matching the Extended ECM group. The example below shows two groups. The <code>Finance</code> group is a child group of the <code>Innovate</code> group. The <code>Finance</code> group is also created in Microsoft 365 if the variable <code>var.enable_o365</code> evaluates to <code>true</code>.</p> Terraform / HCLYAML <pre><code>groups = [\n{\nname          = \"Innovate\"\nparent_groups = []\n},\n{\nname          = \"Finance\"\nparent_groups = [\"Innovate\"]\nenable_o365   = var.enable_o365\n}\n]\n</code></pre> <pre><code>groups:\n- name: Innovate\nparent_groups: []\n- enable_o365: ${var.enable_o365}\nname: Finance\nparent_groups:\n- Innovate\n</code></pre>"},{"location":"payload-syntax/#users","title":"users","text":"<p><code>users</code> is a list of Extended ECM users that are automatically created during deployment. The password of these users is randomly generated and can be printed by <code>terraform output -json</code> (all users have the same password). Each user need to have a base group that must be in the <code>groups</code> section of the payload. Optionally a user can have a list of additional groups. A user can also have a list of favorites. Favorites can either be the logical name of a workspace instance used in the payload (see workspace below) or it can be a nickname of an Extended item. Users can also have a security clearance level and multiple supplementatal markings. Both are optional. <code>security_clearance</code> is used to define the security clearance level of the user. This needs to match one of the existing security clearnace levels that have been defined in the <code>securityClearances</code>section in the payload. <code>supplemental_markings</code> defines a list of supplemental markings the user should get. These need to match markings defined in the <code>supplementalMarkings</code> section in the payload. The field <code>privileges</code> defines the standard privileges of a user. If it is omitted users get the default privileges <code>[\"Login\", \"Public Access\"]</code>. The customizing module is also able to automatically configure Microsoft 365 users for each Extended ECM user. To make this work, the Terraform variable for Office 365 / Microsoft 365 need to be configured. In particular <code>var.enable_o365</code> needs to be <code>true</code>. In the user settings <code>enable_o365</code> has to be set to <code>true</code> as well (or you use the variable <code>var.enable_o365</code> if the payload is in the <code>customization.tf</code> file). <code>m365_skus</code> defines a list of Microsoft 365 SKUs that should be assigned to the user. These are the technical SKU IDs that are documented by Microsoft: Licensing Service Plans. Inside the <code>customizing.tf</code> file you also find a convinient map called <code>m365_skus</code> that map the SKU ID to readable names (such as \"Microsoft 365 E3\" or \"Microsoft 365 E5\").</p> Terraform / HCLYAML <pre><code>users = [\n{\nname                  = \"adminton\"\npassword              = local.password\nfirstname             = \"Adam\"\nlastname              = \"Minton\"\nemail                 = \"adminton@innovate.com\"\nbase_group            = \"Administration\"\ngroups                = [\"IT\"]\nfavorites             = [\"workspace-a\", \"nickname-a\"]\nsecurity_clearance    = 50\nsupplemental_markings = [\"EUZONE\"]\nprivileges            = [\"Login\", \"Public Access\", \"Content Manager\", \"Modify Users\", \"Modify Groups\", \"User Admin Rights\", \"Grant Discovery\", \"System Admin Rights\"]\nenable_o365           = var.enable_o365\nm365_skus             = [var.m365_skus[\"Microsoft 365 E3\"]]\nextra_attributes = [\n{\nname  = \"oTExtraAttr0\"\nvalue = \"adminton${var.salesforce_username_suffix}\"\n}\n]\n},\n{\nname                  = \"nwheeler\"\npassword              = local.password\nfirstname             = \"Nick\"\nlastname              = \"Wheeler\"\nemail                 = \"nwheeler@innovate.com\"\nbase_group            = \"Sales\"\ngroups                = [\"Manager\", \"Office365\"]\nfavorites             = [\"workspace-b\", \"nickname-b\"]\nsecurity_clearance    = 95\nsupplemental_markings = [\"EU-GDPR-PD\", \"EUZONE\"]\n}\n]\n</code></pre> <pre><code>users:\n- base_group: Administration\nemail: adminton@innovate.com\nenable_o365: ${var.enable_o365}\nextra_attributes:\n- name: oTExtraAttr0\nvalue: adminton${var.salesforce_username_suffix}\nfavorites:\n- workspace-a\n- nickname-a\nfirstname: Adam\ngroups:\n- IT\nlastname: Minton\nm365_skus:\n- ${var.m365_skus[\"Microsoft 365 E3\"]}\nname: adminton\npassword: ${local.password}\nprivileges:\n- Login\n- Public Access\n- Content Manager\n- Modify Users\n- Modify Groups\n- User Admin Rights\n- Grant Discovery\n- System Admin Rights\nsecurity_clearance: 50\nsupplemental_markings:\n- EUZONE\n- base_group: Sales\nemail: nwheeler@innovate.com\nfavorites:\n- workspace-b\n- nickname-b\nfirstname: Nick\ngroups:\n- Manager\n- Office365\nlastname: Wheeler\nname: nwheeler\npassword: ${local.password}\nsecurity_clearance: 95\nsupplemental_markings:\n- EU-GDPR-PD\n- EUZONE\n</code></pre>"},{"location":"payload-syntax/#items","title":"items","text":"<p><code>items</code> and <code>itemsPost</code> are lists of Extended ECM items such as folders, shortcuts or URLs that should be created automatically but are not included in transports. All items are created in the <code>Enterprise Workspace</code> of Extended ECM or any subfolder. Each item needs to have <code>name</code> and <code>type</code> values. The parent ID of the item can either be specified by a nick name (<code>parent_nickname</code>) or by the path in the Enterprise Workspace (<code>parent_path</code>). The value <code>parent_path</code> is a list of folder names starting from the root level in the Enterprise Workspaces. <code>parent_path = [\"Administration\", \"WebReports\"]</code> creates the item in the <code>Websites</code> folder which is itself in the <code>Administration</code> top-level folder. The list <code>items</code> is processed at the beginning of the automation (before transports are applied) and <code>itemsPost</code> is applied at the end of the automation (after transports have been applied).</p> Terraform / HCLYAML <pre><code>items = [\n{\nparent_nickname   = \"\" # empty string = not set\nparent_path       = [\"Administration\", \"WebReports\"]\nname              = \"Case Management\"\ndescription       = \"Case Management with eFiles and eCases\"\ntype              = var.otcs_item_types[\"Folder\"]\nurl               = \"\" # \"\" = not set\noriginal_nickname = 0  # 0 = not set\noriginal_path     = [] # [] = not set\n},\n]\nitemsPost = [\n{\nparent_nickname = \"\" # empty string = not set\nparent_path = [\n\"Administration\", \"Websites\"\n]\nname              = \"OpenText Homepage\"\ndescription       = \"The OpenText web site\"\ntype              = var.otcs_item_types[\"URL\"]\nurl               = \"https://www.opentext.com\"\noriginal_nickname = 0  # 0 = not set\noriginal_path     = [] # [] = not set\n}\n]\n</code></pre> <pre><code>items:\n- description: Case Management with eFiles and eCases\nname: Case Management\noriginal_nickname: 0\noriginal_path: []\nparent_nickname: ''\nparent_path:\n- Administration\n- WebReports\ntype: ${var.otcs_item_types[\"Folder\"]}\nurl: ''\nitemsPost:\n- description: The OpenText web site\nname: OpenText Homepage\noriginal_nickname: 0\noriginal_path: []\nparent_nickname: ''\nparent_path:\n- Administration\n- Websites\ntype: ${var.otcs_item_types[\"URL\"]}\nurl: https://www.opentext.com\n</code></pre>"},{"location":"payload-syntax/#permissions","title":"permissions","text":"<p><code>permissions</code> and <code>permissionsPost</code> are both lists of Exteneded ECM items, each with a specific permission set that should be applied to the item. The item can be specified via a path (list of folder names in Enterprise workspace in top-down order), via a nickname, or via a volume. Permission values are listed as list strings in <code>[...]</code> for <code>owner_permissions</code>, <code>owner_group_permissions</code>, or <code>public_permissions</code>. They can be a combination of the following values: <code>see</code>, <code>see_contents</code>, <code>modify</code>, <code>edit_attributes</code>, <code>add_items</code>, <code>reserve</code>, <code>add_major_version</code>, <code>delete_versions</code>, <code>delete</code>, and <code>edit_permissions</code>. The <code>apply_to</code> specifies if the permissions should only be applied to the item itself (value 0) or only to sub-items (value 1) or the item and its sub-items (value 2). The list specified by <code>permissions</code> is applied before the transport packages are applied and <code>permissionsPost</code> is applied after the transport packages have been processed.</p> Terraform / HCLYAML <pre><code>permissions = [\n{\npath = [\"...\", \"...\"]\nvolume = \"...\"   # identified by volume type ID\nnickname = \"...\" # an item with this nick name needs to exist\nowner_permissions = []\nowner_group_permissions = []\npublic_permissions = [\"see\", \"see_content\"]\ngroups = [\n{\nname = \"...\"\npermissions = []\n}\n]\nusers = [\n{\nname = \"...\"\npermissions = []\n}\n]\napply_to = 2\n}\n]\n</code></pre> <pre><code>permissions:\n- apply_to: 2\ngroups:\n- name: '...'\npermissions: []\nnickname: '...'\nowner_group_permissions: []\nowner_permissions: []\npath:\n- '...'\n- '...'\npublic_permissions:\n- see\n- see_content\nusers:\n- name: '...'\npermissions: []\nvolume: '...'\n</code></pre>"},{"location":"payload-syntax/#renamings","title":"renamings","text":"<p><code>renamings</code> is a list of Extended ECM items (e.g. volume names) that are automatically renamed during deployment. You have to either provide the <code>nodeid</code> (only a few node IDs are really know upfront such as 2000 for the Enterprise Workspace) or a <code>volume</code> (type ID). In case of volumes there's a list of known volume types defined at the beginning of the <code>customizing.tf</code> file with the variable <code>otcs_volumes</code>. You can also specific a description that will be used to update the description of the node / item.</p> Terraform / HCLYAML <pre><code>renamings = [\n{\nnodeid      = 2000\nname        = \"Innovate\"\ndescription = \"Innovate's Enterprise Workspace\"\n},\n{\nvolume      = var.otcs_volumes[\"Content Server Document Templates\"]\nname        = \"Content Server Document Templates\"\ndescription = \"Extended ECM Workspace and Document Templates\"\n}\n]\n</code></pre> <pre><code>renamings:\n- description: Innovate's Enterprise Workspace\nname: Innovate\nnodeid: 2000\n- description: Extended ECM Workspace and Document Templates\nname: Content Server Document Templates\nvolume: ${var.otcs_volumes[\"Content Server Document Templates\"]}\n</code></pre>"},{"location":"payload-syntax/#adminsettings","title":"adminSettings","text":"<p><code>adminSettings</code> and <code>adminSettingsPost</code> are lists admin stettings that are applied before the transport packages (<code>adminSettings</code>) or directly after the transport packages (<code>adminSettingsPost</code>) in the customizing process. Each setting is defined by a <code>description</code>, the <code>filename</code> of an XML file that includes the actual Extended ECM admin settings that are applied automatically (using XML import / LLConfig). These files need to be stored inside the <code>setting/payload</code> sub-folder inside the terraform folder. Each admin setting may have a field called <code>enabled</code> that allows to dyanmically turn on / off admin settings based on a boolean value that may be read from a Terraform variable (or could just be <code>False</code> or <code>True</code>).</p> Terraform / HCLYAML <pre><code>adminSettings = [\n{\ndescription = \"Apply minimum settings for Government Desktop (Inbox) that are required before users and groups are created.\"\nfilename    = \"GovernmentSettings-Inbox.xml\", # this needs to happen before users and groups are created\n},\n{\nenabled     = var.enable_o365\ndescription = \"These settings are removed by a side-effect during MS Teams automation. We need to re-enable them.\"\nfilename    = \"O365Settings.xml\",\n}\n]\nadminSettingsPost = [\n{\ndescription = \"Apply Document Template settings that are dependent on Classification elements.\"\nfilename    = \"DocumentTemplatesSettings.xml\"\n},\n]\n</code></pre> <pre><code>adminSettings:\n- description: Apply minimum settings for Government Desktop (Inbox) that are required\nbefore users and groups are created.\nfilename: GovernmentSettings-Inbox.xml\n- description: These settings are removed by a side-effect during MS Teams automation.\nWe need to re-enable them.\nenabled: ${var.enable_o365}\nfilename: O365Settings.xml\nadminSettingsPost:\n- description: Apply Document Template settings that are dependent on Classification\nelements.\nfilename: DocumentTemplatesSettings.xml\n</code></pre>"},{"location":"payload-syntax/#externalsystems","title":"externalSystems","text":"<p><code>externalSystems</code> is a list of connections to external business applications such as SAP S/4HANA, Salesforce, or SuccessFactors. Some of the fields are common, some are specific for the type of the external system. Each external system has a field called <code>enabled</code> that allows to dyanmically turn on / off external system configurations based on a boolean value that may be read from a Terraform variable (or could just be <code>False</code> or <code>True</code>). The field <code>external_system_type</code> needs to have one of these values: <code>SAP</code>, <code>Salesforce</code>, <code>SuccessFactors</code>, or <code>AppWorks Platform</code>.</p> Terraform / HCLYAML <pre><code>externalSystems = [\n{\nenabled              = var.enable_sap\nexternal_system_type = \"SAP\"\nexternal_system_name = \"TM6\"\ndescription          = \"SAP S/4HANA on-premise\"\nas_url               = \"https://tmcerp1.eimdemo.biz:8443/sap/bc/srt/xip/otx/ecmlinkservice/100/ecmlinkspiservice/basicauthbinding\"\nbase_url             = \"https://tmcerp1.eimdemo.biz:8443\"\nusername             = \"demo\"\npassword             = local.password\ncertificate_file     = \"/certificates/TM6.pse\"\ncertificate_password = \"topsecret\"\n},\n{\nenabled                = var.enable_salesforce\nexternal_system_type   = \"Salesforce\"\nexternal_system_name   = \"SFDC-HTTP\"\ndescription            = \"Salesforce\"\nas_url                 = \"https://idea02dev-dev-ed.my.salesforce.com/services/Soap/c/48.0/\"\nbase_url               = \"https://idea02dev-dev-ed.my.salesforce.com\"\nusername               = \"idea02a2dev@opentext.com\"\npassword               = local.password\noauth_client_id        = \"...\"\noauth_client_secret    = \"...\"\nauthorization_endpoint = \"https://salesforce.com/services/oauth2/authorize\"\ntoken_endpoint         = \"https://salesforce.com/services/oauth2/token\"\n},\n{\nenabled              = var.enable_successfactors\nexternal_system_type = \"SuccessFactors\"\nexternal_system_name = \"SuccessFactors\"\ndescription          = \"SAP SuccessFactors\"\nas_url               = \"https://apisalesdemo8.successfactors.com/odata/v2\"\nbase_url             = \"https://pmsalesdemo8.successfactors.com\"\nusername             = \"sfadmin@SFPART035780\"\npassword             = local.password\nsaml_url             = \"https://salesdemo.successfactors.eu/idp/samlmetadata?company=SFSALES004711\"\notds_sp_endpoint     = \"https://otds.xecm-cloud.com/otdsws\"\noauth_client_id      = \"...\"\noauth_client_secret  = \"...\"\n}\n]\n</code></pre> <pre><code>externalSystems:\n- as_url: https://tmcerp1.eimdemo.biz:8443/sap/bc/srt/xip/otx/ecmlinkservice/100/ecmlinkspiservice/basicauthbinding\nbase_url: https://tmcerp1.eimdemo.biz:8443\ncertificate_file: /certificates/TM6.pse\ncertificate_password: topsecret\ndescription: SAP S/4HANA on-premise\nenabled: ${var.enable_sap}\nexternal_system_name: TM6\nexternal_system_type: SAP\npassword: ${local.password}\nusername: demo\n- as_url: https://idea02dev-dev-ed.my.salesforce.com/services/Soap/c/48.0/\nauthorization_endpoint: https://salesforce.com/services/oauth2/authorize\nbase_url: https://idea02dev-dev-ed.my.salesforce.com\ndescription: Salesforce\nenabled: ${var.enable_salesforce}\nexternal_system_name: SFDC-HTTP\nexternal_system_type: Salesforce\noauth_client_id: '...'\noauth_client_secret: '...'\npassword: ${local.password}\ntoken_endpoint: https://salesforce.com/services/oauth2/token\nusername: idea02a2dev@opentext.com\n- as_url: https://apisalesdemo8.successfactors.com/odata/v2\nbase_url: https://pmsalesdemo8.successfactors.com\ndescription: SAP SuccessFactors\nenabled: ${var.enable_successfactors}\nexternal_system_name: SuccessFactors\nexternal_system_type: SuccessFactors\noauth_client_id: '...'\noauth_client_secret: '...'\notds_sp_endpoint: https://otds.xecm-cloud.com/otdsws\npassword: ${local.password}\nsaml_url: https://salesdemo.successfactors.eu/idp/samlmetadata?company=SFSALES004711\nusername: sfadmin@SFPART035780\n</code></pre>"},{"location":"payload-syntax/#transportpackages","title":"transportPackages","text":"<p><code>transportPackages</code> is a list of transport packages that should be applied automatically. These packages need to be accessible via the provided URLs. The <code>name</code> must be the exact file name of the ZIP package. Description is optional.</p> Terraform / HCLYAML <pre><code>transportPackages = [\n{\nurl         = \"https://terrarium.blob.core.windows.net/transports/Terrarium-010-Categories.zip\"\nname        = \"Terrarium 010 Categories.zip\"\ndescription = \"Terrarium Category definitions\"\n},\n{\nurl         = \"https://terrarium.blob.core.windows.net/transports/Terrarium-020-Classifications.zip\"\nname        = \"Terrarium 20 Classifications.zip\"\ndescription = \"Terrarium Classification definitions\"\n}\n]\n</code></pre> <pre><code>transportPackages:\n- description: Terrarium Category definitions\nname: Terrarium 010 Categories.zip\nurl: https://terrarium.blob.core.windows.net/transports/Terrarium-010-Categories.zip\n- description: Terrarium Classification definitions\nname: Terrarium 20 Classifications.zip\nurl: https://terrarium.blob.core.windows.net/transports/Terrarium-020-Classifications.zip\n</code></pre>"},{"location":"payload-syntax/#contenttransportpackages","title":"contentTransportPackages","text":"<p><code>contentTransportPackages</code> is a list of content transport packages that should be automatically applied. Content Transport Package typically are used to import documents into workspaces that are created before. These packages need to be accessible via the provided URLs. The <code>name</code> must be the exact file name of the ZIP package. Description is optional. Other than the <code>transportPackages</code> these transports are deployed after users and wrkspace instances have been processed. This allows to transport content into workspaces instances or use users inside thse transport packages (e.g. owners, user attributes, etc.)</p> Terraform / HCLYAML <pre><code>contentTransportPackages = [\n{\nurl         = \"${var.transporturl}/Terrarium-300-Government-Content.zip\"\nname        = \"Terrarium 300 Government Content.zip\"\ndescription = \"Terrarium demo documents for Government scenario\"\n},\n{\nurl         = \"${var.transporturl}/Terrarium-310-Enterprise-Asset-Management-Content.zip\"\nname        = \"Terrarium 310 Enterprise Asset Management Content.zip\"\ndescription = \"Terrarium demo documents for Enterprise Asset Management scenario\"\n}\n]\n</code></pre> <pre><code>contentTransportPackages:\n- description: Terrarium demo documents for Government scenario\nname: Terrarium 300 Government Content.zip\nurl: ${var.transporturl}/Terrarium-300-Government-Content.zip\n- description: Terrarium demo documents for Enterprise Asset Management scenario\nname: Terrarium 310 Enterprise Asset Management Content.zip\nurl: ${var.transporturl}/Terrarium-310-Enterprise-Asset-Management-Content.zip\n</code></pre>"},{"location":"payload-syntax/#workspaces","title":"workspaces","text":"<p><code>workspaces</code> is a list of business workspaces instances that should be automatically created. Category, Roles, and Business Relationships can be provided. The <code>id</code> needs to be a unique value in the payload. It does not need to be something related to any of the actual Extended ECM workspace data. It is only used to establish relationship between different workspaces in the payload (using the list of IDs in <code>relationships</code>). Important: If the workspace type definition uses a pattern to generate the workspace name then the <code>name</code> in the payload should match the pattern in the workspace definition. Otherwise incremental deployments of the payload may not find the existing workspaces and may try to recreate them resulting in an error.</p> <p>Business Object information can be provided with a <code>business_objects</code> list. Each list item defines the external system (see above), the business object type, and business object ID. This list is optional.</p> <p>Roles and membership information is provided with the <code>members</code> list. Each list item defines membership for a single workspace role which is defined with <code>role</code>. Members can be defined by two lists: <code>users</code> and <code>groups</code>. In the first example below the role <code>Sales Representative</code> is populated with user <code>nwheeler</code> and with the groups <code>Sales</code> and <code>Management</code>.</p> <p>Classification information is optional and can be provided separately for Records Management classifications and normal/regular classifications. Both types of classifications need to be provided as pathes inside the respective classifications trees (top down). There can be only one Records Management classification but multiple regular classifications. That's why the element <code>classification_pathes</code> is a list of pathes.</p> <p>Category information is provided in a list of blocks. Each block includes the category <code>name</code>, <code>set</code> name (optional, can be empty of the attribute is not in a set), <code>attribute</code> name, and the attribute <code>value</code>. Multi-value attributes are a comma-separated list of items in square brackets. The example below shows a customer workspace and a contract workspace that are related to each other (the customer workspace has an attribute <code>Sales Organization</code> that has multiple values: 1000 and 2000). The contract workspace has a multi-line attribute set. For multi-line attribute sets the payload needs an additional <code>row</code> value that specifies the row number in the multi-line set (starting with 1 for the first row).</p> <p>A thrid workspace in the example below is for <code>Material</code> - it has an additional field called <code>template_name</code> which is optional. It can be used if there are multiple templates for one workspace type. If it is not specified and the workspace type has multiple workspace templates the first template is automatically selected.</p> Terraform / HCLYAML <pre><code>workspaces = [\n{\nid          = \"50031\"\nname        = \"Global Trade AG (50031)\"\ndescription = \"Strategic customer in Germany\"\ntype_name   = \"Customer\"\ntemplate_name = \"Customer\"\nbusiness_objects = [\n{\nexternal_system = var.sap_external_system_name\nbo_type         = \"KNA1\"\nbo_id           = \"0000050031\"\n}\n]\nmembers = [\n{\nrole   = \"Sales Representative\"\nusers  = [\"nwheeler\"]\ngroups = [\"Sales\", \"Management\"]\n}\n]\nclassification_pathes = []\nrm_classification_path = [\n\"RM Classifications\",\n\"Case Management\",\n\"Building Authorities\",\n\"01.Buildings\",\n\"01.Building applications\",\n\"02.Alteration and repair\",\n]\ncategories = [\n{\nname      = \"Customer\"\nset       = \"\"\nattribute = \"Customer Number\"\nvalue     = \"50031\"\n},\n{\nname      = \"Customer\"\nset       = \"\"\nattribute = \"Sales organisation\"\nvalue     = [\"1000\", \"2000\"]\n},\n{\nname      = \"Customer\"\nset       = \"Rating\"\nattribute = \"Institute\"\nvalue     = \"Dun &amp; Bradstreet\"\n}\n]\nrelationships = [\n\"0040000019\"\n]\n},\n{\nid          = \"0040000019\"\nname        = \"0040000019 - Global Trade AG\"\ndescription = \"\"\ntype_name   = \"Sales Contract\"\nmembers = [\n{\nrole  = \"Contract Manager\"\nusers = [\"dfoxhoven\"]\n}\n]\ncategories = [\n{\nname      = \"Contract\"\nset       = \"Contract Data\"\nattribute = \"Function\"\nvalue     = \"Sales\"\n},\n{\nname      = \"Contract\"\nset       = \"Contract Data\"\nattribute = \"Contract Number\"\nvalue     = \"0040000019\"\n},\n{\nname      = \"Contract\"\nset       = \"Contract Line Items\"\nrow       = 1\nattribute = \"Material Number\"\nvalue     = \"P-100\"\n}\n]\n},\n{\nid            = \"R-9010\"\nname          = \"R-9010 - Notebook WebCam Model '16\"\ndescription   = \"\"\ntype_name     = \"Material\"\ntemplate_name = \"Material (Operating Supplies)\"\nmembers = [\n{\nrole  = \"Master Data Management\"\nusers = [\"kmurray\"]\n}\n]\ncategories = [\n{\nname      = \"Material\"\nset       = \"\"\nattribute = \"Material Number\"\nvalue     = \"R-9010\"\n},\n{\nname      = \"Material\"\nset       = \"\"\nattribute = \"Material Description\"\nvalue     = \"Notebook WebCam Model '16\"\n}\n]\n}\n]\n</code></pre> <pre><code>workspaces:\n- business_objects:\n- bo_id: '0000050031'\nbo_type: KNA1\nexternal_system: ${var.sap_external_system_name}\ncategories:\n- attribute: Customer Number\nname: Customer\nset: ''\nvalue: '50031'\n- attribute: Sales organisation\nname: Customer\nset: ''\nvalue:\n- '1000'\n- '2000'\n- attribute: Institute\nname: Customer\nset: Rating\nvalue: Dun &amp; Bradstreet\nclassification_pathes: []\ndescription: Strategic customer in Germany\nid: '50031'\nmembers:\n- groups:\n- Sales\n- Management\nrole: Sales Representative\nusers:\n- nwheeler\nname: Global Trade AG (50031)\nrelationships:\n- 0040000019\nrm_classification_path:\n- RM Classifications\n- Case Management\n- Building Authorities\n- 01.Buildings\n- 01.Building applications\n- 02.Alteration and repair\ntemplate_name: Customer\ntype_name: Customer\n- categories:\n- attribute: Function\nname: Contract\nset: Contract Data\nvalue: Sales\n- attribute: Contract Number\nname: Contract\nset: Contract Data\nvalue: 0040000019\n- attribute: Material Number\nname: Contract\nrow: 1\nset: Contract Line Items\nvalue: P-100\ndescription: ''\nid: 0040000019\nmembers:\n- role: Contract Manager\nusers:\n- dfoxhoven\nname: 0040000019 - Global Trade AG\ntype_name: Sales Contract\n- categories:\n- attribute: Material Number\nname: Material\nset: ''\nvalue: R-9010\n- attribute: Material Description\nname: Material\nset: ''\nvalue: Notebook WebCam Model '16\ndescription: ''\nid: R-9010\nmembers:\n- role: Master Data Management\nusers:\n- kmurray\nname: R-9010 - Notebook WebCam Model '16\ntemplate_name: Material (Operating Supplies)\ntype_name: Material\n</code></pre>"},{"location":"payload-syntax/#webreports","title":"webReports","text":"<p><code>webReports</code> and <code>webReportsPost</code> are two lists of Extended ECM web reports that should be automatically executed during deployment. Having two lists give you the option to run some webReports after the business configuration and some others after demo content has been produced. These Web Reports have typically been deployd to Extended ECM system with the transport warehouse before. Each list item specifies one Web Report. The <code>nickname</code> is mandatory and defines the nickname of the Web Report to be executed. So you need to give each webReport you want to run a nickname before putting it in a transport package. The element <code>description</code> is optional. The <code>parameters</code> set defines parameter name and parameter value pairs. The corresponding Web Report in Extended ECM must have exactly these parameters defined.</p> Terraform / HCLYAML <pre><code>webReports = [\n{\nnickname    = \"web_report_unset_xgov_doc_view\"\ndescription = \"Web Report to disable the Brava document view side bar\"\nparameters = {\n\"user_name\" = \"swang\"\n}\n},\n{\nnickname    = \"web_report_set_cust_sf\"\ndescription = \"Web Report to auto-configure Extended ECM for SuccessFactors Module Specific Settings\"\n}\n]\nwebReportsPost = [\n{\nnickname    = \"web_report_set_cust_sf\"\ndescription = \"Web Report to auto-configure Extended ECM for SuccessFactors Module Specific Settings\"\n}\n]\n</code></pre> <pre><code>webReports:\n- description: Web Report to disable the Brava document view side bar\nnickname: web_report_unset_xgov_doc_view\nparameters:\nuser_name: swang\n- description: Web Report to auto-configure Extended ECM for SuccessFactors Module\nSpecific Settings\nnickname: web_report_set_cust_sf\nwebReportsPost:\n- description: Web Report to auto-configure Extended ECM for SuccessFactors Module\nSpecific Settings\nnickname: web_report_set_cust_sf\n</code></pre>"},{"location":"payload-syntax/#csapplications","title":"csApplications","text":"<p><code>csApplications</code> is a list of Content Server Applications that should autmatically be deployed. Each element has a <code>name</code> for the application and optionally a <code>description</code>.</p> Terraform / HCLYAML <pre><code>csApplications = [\n{\nname        = \"OTPOReports\"\ndescription = \"OpenText Physical Objects Reports\"\n},\n{\nname        = \"OTRMReports\"\ndescription = \"OpenText Records Management Reports\"\n},\n{\nname        = \"OTRMSecReports\"\ndescription = \"OpenText Security Clearance Reports\"\n}\n]\n</code></pre> <pre><code>csApplications:\n- description: OpenText Physical Objects Reports\nname: OTPOReports\n- description: OpenText Records Management Reports\nname: OTRMReports\n- description: OpenText Security Clearance Reports\nname: OTRMSecReports\n</code></pre>"},{"location":"payload-syntax/#assignments","title":"assignments","text":"<p><code>assignments</code> is a list of assignments. Assignments are typically used for Extended ECM for Government. Each assignment assigns either a <code>workspace</code> or an Extended ECM item with a <code>nickname</code> to a defined list of <code>users</code> or <code>groups</code>. Assignments have a <code>subject</code> (title) and <code>instructions</code> for the target users or groups.</p> Terraform / HCLYAML <pre><code>assignments = [\n{\nsubject     = \"Assignment on building extension M6P 1Y7-02-001-00001\"\ninstruction = \"Please review this building extension\"\nworkspace   = \"1063938\"\nnickname    = \"\"\nusers       = [\"swang\", \"gbecker\"]\ngroups      = [\"Case Management\"]\n}\n]\n</code></pre> <pre><code>assignments:\n- groups:\n- Case Management\ninstruction: Please review this building extension\nnickname: ''\nsubject: Assignment on building extension M6P 1Y7-02-001-00001\nusers:\n- swang\n- gbecker\nworkspace: '1063938'\n</code></pre>"},{"location":"payload-syntax/#workspacetemplateregistrations","title":"workspaceTemplateRegistrations","text":"<p><code>workspaceTemplateRegistrations</code> is used to register certain workspace templates for the use as projects in Extended ECM for Engineering demo scenarios. Each registration has two mandatory fields. <code>workspace_type_name</code> defines the name of the workspace type and <code>workspace_template_name</code> defines the specific name of the workspace templates (as each workspace type may have multiple templates).</p> Terraform / HCLYAML <pre><code>  workspaceTemplateRegistrations = [\n{\nworkspace_type_name     = \"SAP PPM Project\"\nworkspace_template_name = \"Project\"\n}\n]\n</code></pre> <pre><code>workspaceTemplateRegistrations:\n- workspace_template_name: Project\nworkspace_type_name: SAP PPM Project\n</code></pre>"},{"location":"payload-syntax/#advanced-customizing-syntax","title":"Advanced Customizing Syntax","text":"<p>For advanced use cases that are not covered by Extended ECM or OTDS APIs, there are additional customizing capabilities. This includes calling SAP Remote Function Calls (RFC), executing commands in the Kubernetes Pods or triggering web hooks (HTTP POST requests):</p>"},{"location":"payload-syntax/#execpodcommands","title":"execPodCommands","text":"<p><code>execPodCommands</code> is used to execute a Linux command inside a Kubernetes pod using the Kubernetes API (similar to what <code>kubectl exec</code> does). This may be handy to influence / change some of the intrinsics of the pods. If <code>eanbled</code> evaluates to <code>true</code> then the command will be called during the customization process. The <code>pod_name</code> must match is technical name of the pod in the Kubernetes deployment (you can get the pod names with <code>kubectl get pods</code>). <code>command</code> is a list of the command terms and parameters. The first element is typically the Linux shell that is used for executing the command and the second parameter is typically <code>-c</code> if the command is run in non-interactive mode. <code>interactive</code> defines if the command is run interactively or not. The default is to run the command non-interactively. Only for longer running commands you should prefer to run the command interactively.</p> Terraform / HCLYAML <pre><code>execPodCommands = [\n{\nenabled     = false\ndescription = \"Test\"\npod_name    = \"otcs-admin-0\"\ncommand     = [\"/bin/sh\", \"-c\", \"touch /tmp/python_was_here\"]\ninteractive = false\n}\n]\n</code></pre> <pre><code>execPodCommands:\n- command:\n- /bin/sh\n- -c\n- touch /tmp/python_was_here\ndescription: Test\nenabled: false\ninteractive: false\npod_name: otcs-admin-0\n</code></pre>"},{"location":"payload-syntax/#webhooks","title":"webHooks","text":"<p><code>webHooks</code> and <code>webHooksPost</code> are used to call (HTTP request) defined URLs that may trigger certain activities as webhooks. <code>webHooks</code> is called at the beginning of the customization process and <code>webHooksPost</code> is called at the end. If <code>eanbled</code> evaluates to <code>true</code> then the weekhook is active. <code>url</code> defines the URL of the web hook. <code>method</code> can we one of the typical HTTP request types (POST, GET, PUT, ...). If it is omitted the default is <code>POST</code>. <code>description</code> should describe the purpose of the web hook. The parameters <code>payload</code> and <code>headers</code> are maps (dictionaries) of name, value pairs. These are passed as additional header or body values to the HTTP request.</p> Terraform / HCLYAML <pre><code>webHooks = [\n{\nenabled     = var.enable_sap\nurl         = \"https://.../start_sap\"\nmethod      = \"POST\"\ndescription = \"Start SAP S/4HANA Web Hook\"\npayload     = {\nparameter = \"value\"\n}\nheaders     = {} # if empty a standard header will be set\n}\n]\nwebHooksPost = [\n{\nenabled     = var.enable_sap\nurl         = \"https://.../stop_sap\"\nmethod      = \"POST\"\ndescription = \"Stop SAP S/4HANA Web Hook\"\npayload     = {}\nheaders     = {} # if empty a standard header will be set\n}\n]\n</code></pre> <pre><code>webHooks:\n- description: Start SAP S/4HANA Web Hook\nenabled: ${var.enable_sap}\nheaders: {}\nmethod: POST\npayload:\nparameter: value\nurl: https://.../start_sap\nwebHooksPost:\n- description: Stop SAP S/4HANA Web Hook\nenabled: ${var.enable_sap}\nheaders: {}\nmethod: POST\npayload: {}\nurl: https://.../stop_sap\n</code></pre>"},{"location":"payload-syntax/#saprfcs","title":"sapRFCs","text":"<p><code>sapRFCs</code> are defining a list of SAP Remote Function Calls (RFC) that are called to automate things in SAP S/4HANA. If <code>eanbled</code> evaluates to <code>true</code> then the RFC will be called during the customization process. <code>name</code> is the technical SAP name of the RFC. <code>description</code> is optional and is just informative. If the RFC requires parameters they can be passed via the <code>parameters</code> block (name, value pairs).</p> Terraform / HCLYAML <pre><code>sapRFCs = [\n{\nenabled     = var.enable_sap\nname        = \"SM02_ADD_MESSAGE\"\ndescription = \"Write message into SAP message center\"\nparameters = {\n\"MESSAGE\" = \"Start processing Terrarium RFC calls...\"\n}\n},\n{\nenabled     = var.enable_sap\nname        = \"ZFM_GECKO_RFC_CR_UPD_ALL_WKSP\"\ndescription = \"Create workspace for all SAP Customers (KNA1)\"\nparameters = {\n\"OBJECTTYPE\" = \"KNA1\"\n\"OBJECTKEY\"  = \"\"\n\"SYNC\"       = \"\"\n}\n}\n]\n</code></pre> <pre><code>sapRFCs:\n- description: Write message into SAP message center\nenabled: ${var.enable_sap}\nname: SM02_ADD_MESSAGE\nparameters:\nMESSAGE: Start processing Terrarium RFC calls...\n- description: Create workspace for all SAP Customers (KNA1)\nenabled: ${var.enable_sap}\nname: ZFM_GECKO_RFC_CR_UPD_ALL_WKSP\nparameters:\nOBJECTKEY: ''\nOBJECTTYPE: KNA1\nSYNC: ''\n</code></pre>"},{"location":"pyxecm/browser/","title":"Browser Automation","text":"<p>browser_automation Module to implement a class to automate configuration via a browser interface. These are typically used as fallback options if no REST API or LLConfig can be used.</p> <p>Class: BrowserAutomation Methods:</p> <p>init : class initializer set_chrome_options: Sets chrome options for Selenium. Chrome options for headless browser is enabled run_otcs_login: Login to OTCS via the browser run_configure_vertex_datasource: Run the configuration of the Aviator Vertex datasource end_session: End the browser session</p>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation","title":"<code>BrowserAutomation</code>","text":"<p>Class to automate settings via a browser interface.</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>class BrowserAutomation:\n\"\"\"Class to automate settings via a browser interface.\"\"\"\ndef __init__(\nself,\nbase_url: str,\nuser_name: str,\nuser_password: str,\ndownload_directory: str = \"/tmp\",\n) -&gt; None:\nself.base_url = base_url\nself.user_name = user_name\nself.user_password = user_password\nself.logged_in = False\nself.download_directory = download_directory\nchromedriver_autoinstaller.install()\nself.browser = webdriver.Chrome(options=self.set_chrome_options())\n# end method definition\ndef __del__(self):\nif self.browser:\nself.browser.close()\ndel self.browser\nself.browser = None\ndef set_chrome_options(self) -&gt; Options:\n\"\"\"Sets chrome options for Selenium.\n           Chrome options for headless browser is enabled.\n        Returns:\n            Options: Options to call the browser with\n        \"\"\"\nchrome_options = Options()\nchrome_options.add_argument(\"--headless\")\nchrome_options.add_argument(\"--no-sandbox\")\nchrome_options.add_argument(\"--disable-dev-shm-usage\")\nchrome_prefs = {}\nchrome_options.experimental_options[\"prefs\"] = chrome_prefs\nchrome_prefs[\"profile.default_content_settings\"] = {\"images\": 2}\nchrome_options.add_experimental_option(\n\"prefs\", {\"download.default_directory\": self.download_directory}\n)\nreturn chrome_options\n# end method definition\ndef get_page(self, url: str = \"\") -&gt; bool:\n\"\"\"Load a page into the browser based on a given URL.\n           Required authorization need\n        Args:\n            url (str): URL to load. If empty just the base URL will be used\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\npage_url = self.base_url + url\ntry:\nlogger.info(\"Load page -&gt; %s\", page_url)\nself.browser.get(page_url)\nexcept WebDriverException as exception:\nlogger.error(\"Cannot load page -&gt; %s; error -&gt; %s\", page_url, exception)\nreturn False\nlogger.info(\"Page title after get page -&gt; %s\", self.browser.title)\nreturn True\n# end method definition\ndef find_elem_and_click(self, find_elem: str, find_method: str = By.ID) -&gt; bool:\n\"\"\"Find an page element and click it.\n        Args:\n            find_elem (str): name of the page element\n            find_method (str): either By.ID, By.NAME, By.CLASS_NAME, BY.XPATH\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\n# We don't want to expose class \"By\" outside this module,\n# so we map the string values to the By class values:\nif find_method == \"id\":\nfind_method = By.ID\nelif find_method == \"name\":\nfind_method = By.NAME\nelif find_method == \"class_name\":\nfind_method = By.CLASS_NAME\nelif find_method == \"xpath\":\nfind_method = By.XPATH\nelse:\nlogger.error(\"Unsupported find method!\")\nreturn False\ntry:\nelem = self.browser.find_element(by=find_method, value=find_elem)\nexcept NoSuchElementException as exception:\nlogger.error(\n\"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\nfind_elem,\nfind_method,\nexception,\n)\nreturn False\ntry:\nelem.click()\nexcept ElementClickInterceptedException as exception:\nlogger.error(\n\"Cannot click page element -&gt; %s; error -&gt; %s\", find_elem, exception\n)\nreturn False\nreturn True\n# end method definition\ndef find_elem_and_set(\nself, find_elem: str, elem_value: str, find_method: str = By.ID\n) -&gt; bool:\n\"\"\"Find an page element and fill it with a new text.\n        Args:\n            find_elem (str): name of the page element\n            elem_value (str): new text string for the page element\n            find_method (str): either By.ID, By.NAME, By.CLASS_NAME, or By.XPATH\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\n# We don't want to expose class \"By\" outside this module,\n# so we map the string values to the By class values:\nif find_method == \"id\":\nfind_method = By.ID\nelif find_method == \"name\":\nfind_method = By.NAME\nelif find_method == \"class_name\":\nfind_method = By.CLASS_NAME\nelif find_method == \"xpath\":\nfind_method = By.XPATH\nelse:\nlogger.error(\"Unsupported find method!\")\nreturn False\nlogger.info(\"Try to find element -&gt; %s by -&gt; %s...\", find_elem, find_method)\ntry:\nelem = self.browser.find_element(find_method, find_elem)\nexcept NoSuchElementException as exception:\nlogger.error(\n\"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\nfind_elem,\nfind_method,\nexception,\n)\nreturn False\nlogger.info(\"Set element -&gt; %s to value -&gt; %s...\", find_elem, elem_value)\ntry:\nelem.clear()  # clear existing text in the input field\nelem.send_keys(elem_value)  # write new text into the field\nexcept ElementNotInteractableException as exception:\nlogger.error(\n\"Cannot set page element -&gt; %s to value -&gt; %s; error -&gt; %s\",\nfind_elem,\nelem_value,\nexception,\n)\nreturn False\nreturn True\n# end method definition\ndef find_element_and_download(\nself, find_elem: str, find_method: str = By.ID, download_time: int = 30\n) -&gt; str | None:\n\"\"\"Clicks a page element to initiate a download\n        Args:\n            find_elem (str): page element to click for download\n            find_method (str, optional): method to find the element. Defaults to By.ID.\n            download_time (int, optional): time in seconds to wait for the download to complete\n        Returns:\n            str | None: filename of the download\n        \"\"\"\n# Record the list of files in the download directory before the download\ninitial_files = set(os.listdir(self.download_directory))\nif not self.find_elem_and_click(\nfind_elem=find_elem,\nfind_method=find_method,\n):\nreturn None\n# Wait for the download to complete\n#        time.sleep(download_time)\nself.browser.implicitly_wait(download_time)\n# Record the list of files in the download directory after the download\ncurrent_files = set(os.listdir(self.download_directory))\n# Determine the name of the downloaded file\nnew_file = (current_files - initial_files).pop()\nreturn new_file\n# end method definition\ndef run_login(\nself,\nuser_field: str = \"otds_username\",\npassword_field: str = \"otds_password\",\nlogin_button: str = \"loginbutton\",\n) -&gt; bool:\n\"\"\"Login to target system via the browser\"\"\"\nself.logged_in = False\nif (\nnot self.get_page()  # assuming the base URL leads towards the login page\nor not self.find_elem_and_set(\nfind_elem=user_field, elem_value=self.user_name\n)\nor not self.find_elem_and_set(\nfind_elem=password_field, elem_value=self.user_password\n)\nor not self.find_elem_and_click(find_elem=login_button)\n):\nlogger.error(\"Cannot log into target system using URL -&gt; %s\", self.base_url)\nreturn False\nlogger.info(\"Page title after login -&gt; %s\", self.browser.title)\nif \"Verify\" in self.browser.title:\nlogger.error(\n\"Site is asking for a Verification Token. You may need to whitelist your IP!\"\n)\nreturn False\nself.logged_in = True\nreturn True\n# end method definition\ndef implict_wait(self, wait_time: float):\n\"\"\"Waits for the browser to finish tasks (e.g. fully loading a page)\n        Args:\n            wait_time (float): time in seconds to wait\n        \"\"\"\nlogger.info(\"Implicit wait for max -&gt; %s seconds...\", str(wait_time))\nself.browser.implicitly_wait(wait_time)\ndef end_session(self):\n\"\"\"End the browser session\"\"\"\nself.browser.close()\nself.logged_in = False\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.end_session","title":"<code>end_session()</code>","text":"<p>End the browser session</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def end_session(self):\n\"\"\"End the browser session\"\"\"\nself.browser.close()\nself.logged_in = False\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.find_elem_and_click","title":"<code>find_elem_and_click(find_elem, find_method=By.ID)</code>","text":"<p>Find an page element and click it.</p> <p>Parameters:</p> Name Type Description Default <code>find_elem</code> <code>str</code> <p>name of the page element</p> required <code>find_method</code> <code>str</code> <p>either By.ID, By.NAME, By.CLASS_NAME, BY.XPATH</p> <code>By.ID</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def find_elem_and_click(self, find_elem: str, find_method: str = By.ID) -&gt; bool:\n\"\"\"Find an page element and click it.\n    Args:\n        find_elem (str): name of the page element\n        find_method (str): either By.ID, By.NAME, By.CLASS_NAME, BY.XPATH\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n# We don't want to expose class \"By\" outside this module,\n# so we map the string values to the By class values:\nif find_method == \"id\":\nfind_method = By.ID\nelif find_method == \"name\":\nfind_method = By.NAME\nelif find_method == \"class_name\":\nfind_method = By.CLASS_NAME\nelif find_method == \"xpath\":\nfind_method = By.XPATH\nelse:\nlogger.error(\"Unsupported find method!\")\nreturn False\ntry:\nelem = self.browser.find_element(by=find_method, value=find_elem)\nexcept NoSuchElementException as exception:\nlogger.error(\n\"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\nfind_elem,\nfind_method,\nexception,\n)\nreturn False\ntry:\nelem.click()\nexcept ElementClickInterceptedException as exception:\nlogger.error(\n\"Cannot click page element -&gt; %s; error -&gt; %s\", find_elem, exception\n)\nreturn False\nreturn True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.find_elem_and_set","title":"<code>find_elem_and_set(find_elem, elem_value, find_method=By.ID)</code>","text":"<p>Find an page element and fill it with a new text.</p> <p>Parameters:</p> Name Type Description Default <code>find_elem</code> <code>str</code> <p>name of the page element</p> required <code>elem_value</code> <code>str</code> <p>new text string for the page element</p> required <code>find_method</code> <code>str</code> <p>either By.ID, By.NAME, By.CLASS_NAME, or By.XPATH</p> <code>By.ID</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def find_elem_and_set(\nself, find_elem: str, elem_value: str, find_method: str = By.ID\n) -&gt; bool:\n\"\"\"Find an page element and fill it with a new text.\n    Args:\n        find_elem (str): name of the page element\n        elem_value (str): new text string for the page element\n        find_method (str): either By.ID, By.NAME, By.CLASS_NAME, or By.XPATH\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n# We don't want to expose class \"By\" outside this module,\n# so we map the string values to the By class values:\nif find_method == \"id\":\nfind_method = By.ID\nelif find_method == \"name\":\nfind_method = By.NAME\nelif find_method == \"class_name\":\nfind_method = By.CLASS_NAME\nelif find_method == \"xpath\":\nfind_method = By.XPATH\nelse:\nlogger.error(\"Unsupported find method!\")\nreturn False\nlogger.info(\"Try to find element -&gt; %s by -&gt; %s...\", find_elem, find_method)\ntry:\nelem = self.browser.find_element(find_method, find_elem)\nexcept NoSuchElementException as exception:\nlogger.error(\n\"Cannot find page element -&gt; %s by -&gt; %s; error -&gt; %s\",\nfind_elem,\nfind_method,\nexception,\n)\nreturn False\nlogger.info(\"Set element -&gt; %s to value -&gt; %s...\", find_elem, elem_value)\ntry:\nelem.clear()  # clear existing text in the input field\nelem.send_keys(elem_value)  # write new text into the field\nexcept ElementNotInteractableException as exception:\nlogger.error(\n\"Cannot set page element -&gt; %s to value -&gt; %s; error -&gt; %s\",\nfind_elem,\nelem_value,\nexception,\n)\nreturn False\nreturn True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.find_element_and_download","title":"<code>find_element_and_download(find_elem, find_method=By.ID, download_time=30)</code>","text":"<p>Clicks a page element to initiate a download</p> <p>Parameters:</p> Name Type Description Default <code>find_elem</code> <code>str</code> <p>page element to click for download</p> required <code>find_method</code> <code>str</code> <p>method to find the element. Defaults to By.ID.</p> <code>By.ID</code> <code>download_time</code> <code>int</code> <p>time in seconds to wait for the download to complete</p> <code>30</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: filename of the download</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def find_element_and_download(\nself, find_elem: str, find_method: str = By.ID, download_time: int = 30\n) -&gt; str | None:\n\"\"\"Clicks a page element to initiate a download\n    Args:\n        find_elem (str): page element to click for download\n        find_method (str, optional): method to find the element. Defaults to By.ID.\n        download_time (int, optional): time in seconds to wait for the download to complete\n    Returns:\n        str | None: filename of the download\n    \"\"\"\n# Record the list of files in the download directory before the download\ninitial_files = set(os.listdir(self.download_directory))\nif not self.find_elem_and_click(\nfind_elem=find_elem,\nfind_method=find_method,\n):\nreturn None\n# Wait for the download to complete\n#        time.sleep(download_time)\nself.browser.implicitly_wait(download_time)\n# Record the list of files in the download directory after the download\ncurrent_files = set(os.listdir(self.download_directory))\n# Determine the name of the downloaded file\nnew_file = (current_files - initial_files).pop()\nreturn new_file\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.get_page","title":"<code>get_page(url='')</code>","text":"<p>Load a page into the browser based on a given URL.    Required authorization need</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to load. If empty just the base URL will be used</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def get_page(self, url: str = \"\") -&gt; bool:\n\"\"\"Load a page into the browser based on a given URL.\n       Required authorization need\n    Args:\n        url (str): URL to load. If empty just the base URL will be used\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\npage_url = self.base_url + url\ntry:\nlogger.info(\"Load page -&gt; %s\", page_url)\nself.browser.get(page_url)\nexcept WebDriverException as exception:\nlogger.error(\"Cannot load page -&gt; %s; error -&gt; %s\", page_url, exception)\nreturn False\nlogger.info(\"Page title after get page -&gt; %s\", self.browser.title)\nreturn True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.implict_wait","title":"<code>implict_wait(wait_time)</code>","text":"<p>Waits for the browser to finish tasks (e.g. fully loading a page)</p> <p>Parameters:</p> Name Type Description Default <code>wait_time</code> <code>float</code> <p>time in seconds to wait</p> required Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def implict_wait(self, wait_time: float):\n\"\"\"Waits for the browser to finish tasks (e.g. fully loading a page)\n    Args:\n        wait_time (float): time in seconds to wait\n    \"\"\"\nlogger.info(\"Implicit wait for max -&gt; %s seconds...\", str(wait_time))\nself.browser.implicitly_wait(wait_time)\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.run_login","title":"<code>run_login(user_field='otds_username', password_field='otds_password', login_button='loginbutton')</code>","text":"<p>Login to target system via the browser</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def run_login(\nself,\nuser_field: str = \"otds_username\",\npassword_field: str = \"otds_password\",\nlogin_button: str = \"loginbutton\",\n) -&gt; bool:\n\"\"\"Login to target system via the browser\"\"\"\nself.logged_in = False\nif (\nnot self.get_page()  # assuming the base URL leads towards the login page\nor not self.find_elem_and_set(\nfind_elem=user_field, elem_value=self.user_name\n)\nor not self.find_elem_and_set(\nfind_elem=password_field, elem_value=self.user_password\n)\nor not self.find_elem_and_click(find_elem=login_button)\n):\nlogger.error(\"Cannot log into target system using URL -&gt; %s\", self.base_url)\nreturn False\nlogger.info(\"Page title after login -&gt; %s\", self.browser.title)\nif \"Verify\" in self.browser.title:\nlogger.error(\n\"Site is asking for a Verification Token. You may need to whitelist your IP!\"\n)\nreturn False\nself.logged_in = True\nreturn True\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.BrowserAutomation.set_chrome_options","title":"<code>set_chrome_options()</code>","text":"<p>Sets chrome options for Selenium.    Chrome options for headless browser is enabled.</p> <p>Returns:</p> Name Type Description <code>Options</code> <code>Options</code> <p>Options to call the browser with</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>def set_chrome_options(self) -&gt; Options:\n\"\"\"Sets chrome options for Selenium.\n       Chrome options for headless browser is enabled.\n    Returns:\n        Options: Options to call the browser with\n    \"\"\"\nchrome_options = Options()\nchrome_options.add_argument(\"--headless\")\nchrome_options.add_argument(\"--no-sandbox\")\nchrome_options.add_argument(\"--disable-dev-shm-usage\")\nchrome_prefs = {}\nchrome_options.experimental_options[\"prefs\"] = chrome_prefs\nchrome_prefs[\"profile.default_content_settings\"] = {\"images\": 2}\nchrome_options.add_experimental_option(\n\"prefs\", {\"download.default_directory\": self.download_directory}\n)\nreturn chrome_options\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.By","title":"<code>By</code>","text":"<p>Dummy class to avoid errors if selenium module cannot be imported</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>class By:\n\"\"\"Dummy class to avoid errors if selenium module cannot be imported\"\"\"\nID: str = \"\"\n</code></pre>"},{"location":"pyxecm/browser/#pyxecm.customizer.browser_automation.Options","title":"<code>Options</code>","text":"<p>Dummy class to avoid errors if selenium module cannot be imported</p> Source code in <code>pyxecm/customizer/browser_automation.py</code> <pre><code>class Options:\n\"\"\"Dummy class to avoid errors if selenium module cannot be imported\"\"\"\n</code></pre>"},{"location":"pyxecm/customizer/","title":"Customizer","text":"<p>[Automate OpenText Directory Services (OTDS) and Extended ECM (OTCS) configurations]</p> <p>Data classes to handle settings read from environment variables * CustomizerSettings: Class to manage settings * CustomizerSettingsOTDS: Class for OTDS related settings * CustomizerSettingsOTCS: Class for OTCS related settings * CustomizerSettingsOTAC: Class for OTAC related settings * CustomizerSettingsOTPD: Class for OTPD related settings * CustomizerSettingsOTIV: Class for OTIV related settings * CustomizerSettingsK8S: Class for K8s related settings * CustomizerSettingsOTAWP: Class for OTAWP related settings * CustomizerSettingsM365: Class for O365 related settings * CustomizerSettingsAviator: Class for Aviator related settings</p> <p>Methods of class Customizer:</p> <p>init: object initializer for class Customizer log_header: Helper method to output a section header in the log file init_browser_automation: initialize browser automation for Content Aviator init_m365: initialize the Microsoft 365 object init_k8s: initialize the Kubernetes object we use to talk to the Kubernetes API init_otds: initialize the OTDS object init_otac: initialize the OTAC object init_otcs: initialize the OTCS (Extended ECM) object init_otiv: initialize the OTIV (Intelligent Viewing) object and its OTDS settings init_otpd: initialize the PowerDocs object init_otawp: initialize OTDS settings for AppWorks Platform</p> restart the OTCS backend and frontend pods - <p>required to make certain configurations effective</p> <p>restart_otac_service: restart spawner process in Archive Center restart_otawp_pod: restart the AppWorks Platform Pod to make settings effective consolidate_otds: consolidate OTDS users / groups (to get to a fully synchronized state)</p> <p>import_powerdocs_configuration: import PowerDocs database</p> <p>set_maintenance_mode: Enable or Disable Maintenance Mode</p> <p>customization_run: Central function to initiate the customization</p>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer","title":"<code>Customizer</code>","text":"<p>Customizer Class to control the cusomization automation</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>class Customizer:\n\"\"\"Customizer Class to control the cusomization automation\n    Args: None\n    \"\"\"\ndef __init__(\nself,\nsettings: CustomizerSettings = CustomizerSettings(),\notds: CustomizerSettingsOTDS = CustomizerSettingsOTDS(),\notcs: CustomizerSettingsOTCS = CustomizerSettingsOTCS(),\notac: CustomizerSettingsOTAC = CustomizerSettingsOTAC(),\notpd: CustomizerSettingsOTPD = CustomizerSettingsOTPD(),\notiv: CustomizerSettingsOTIV = CustomizerSettingsOTIV(),\nk8s: CustomizerSettingsK8S = CustomizerSettingsK8S(),\notawp: CustomizerSettingsOTAWP = CustomizerSettingsOTAWP(),\nm365: CustomizerSettingsM365 = CustomizerSettingsM365(),\naviator: CustomizerSettingsAviator = CustomizerSettingsAviator(),\n):\nself.settings = settings\n# OTDS Constants:\nself.otds_settings = otds\n# Content Server Constants:\nself.otcs_settings = otcs\n# Archive Center constants:\nself.otac_settings = otac\n# PowerDocs constants:\nself.otpd_settings = otpd\n# Intelligent Viewing constants:\nself.otiv_settings = otiv\n# AppWorks Platform constants:\nself.otawp_settings = otawp\n# K8s Mode\nself.k8s_settings = k8s\n# Microsoft 365 Environment variables:\nself.m365_settings = m365\n# Aviator variables:\nself.aviator_settings = aviator\n# Initialize Objects for later assignment\nself.otds_object: OTDS | None = None\nself.otcs_object: OTCS | None = None\nself.otcs_backend_object: OTCS | None = None\nself.otcs_frontend_object: OTCS | None = None\nself.otpd_object: OTPD | None = None\nself.otac_object: OTAC | None = None\nself.otiv_object: OTIV | None = None\nself.k8s_object: K8s | None = None\nself.m365_object: M365 | None = None\nself.browser_automation_object: BrowserAutomation | None = None\ndef log_header(self, text: str, char: str = \"=\", length: int = 60):\n\"\"\"Helper method to output a section header in the log file\n        Args:\n            text (str): _description_\n            char (str, optional): header line character. Defaults to \"=\".\n            length (int, optional): maxium length. Defaults to 60.\n        Returns:\n            None\n        \"\"\"\n# Calculate the remaining space for the text after adding spaces\navailable_space = max(\n0, length - len(text) - 2\n)  # 2 accounts for the spaces each side of the text\n# Calculate the number of characters needed on each side\nchar_count = available_space // 2\nextra_char = available_space % 2  # do we have lost 1 char?\n# Ensure there are at least 3 characters on each side\nchar_count = max(3, char_count)\n# Build the header string, extra_char is either 0 or 1\nlogger.info(\n\"%s %s %s\", char * char_count, text, char * (char_count + extra_char)\n)\n# end function definition\ndef init_m365(self) -&gt; M365:\n\"\"\"Initialize the M365 object we use to talk to the Microsoft Graph API.\n        Args:\n            None\n        Returns:\n            object: M365 object or None if the object couldn't be created or\n                    the authentication fails.\n        \"\"\"\nlogger.info(\n\"Microsoft 365 Tenant ID             = %s\", self.m365_settings.tenant_id\n)\nlogger.info(\n\"Microsoft 365 Client ID             = %s\", self.m365_settings.client_id\n)\nlogger.debug(\n\"Microsoft 365 Client Secret         = %s\", self.m365_settings.client_secret\n)\nlogger.info(\n\"Microsoft 365 User                  = %s\",\n(\nself.m365_settings.user\nif self.m365_settings.user != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\nlogger.debug(\n\"Microsoft 365 Password              = %s\",\n(\nself.m365_settings.password\nif self.m365_settings.password != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\nlogger.info(\n\"Microsoft 365 Domain                = %s\", self.m365_settings.domain\n)\nlogger.info(\n\"Microsoft 365 Default License SKU   = %s\", self.m365_settings.sku_id\n)\nlogger.info(\n\"Microsoft 365 Teams App             = %s\",\nself.m365_settings.teams_app_name,\n)\nm365_object = M365(\ntenant_id=self.m365_settings.tenant_id,\nclient_id=self.m365_settings.client_id,\nclient_secret=self.m365_settings.client_secret,\ndomain=self.m365_settings.domain,\nsku_id=self.m365_settings.sku_id,\nteams_app_name=self.m365_settings.teams_app_name,\n)\nif m365_object and m365_object.authenticate():\nlogger.info(\"Connected to Microsoft Graph API.\")\nreturn m365_object\nelse:\nlogger.error(\"Failed to connect to Microsoft Graph API.\")\nreturn m365_object\n# end function definition\ndef init_k8s(self) -&gt; K8s:\n\"\"\"Initialize the Kubernetes object we use to talk to the Kubernetes API.\n        Args:\n            None\n        Returns:\n            K8s: K8s object\n        Side effects:\n            The global variables otcs_replicas_frontend and otcs_replicas_backend are initialized\n        \"\"\"\nlogger.info(\"Connection parameters Kubernetes (K8s):\")\nlogger.info(\"K8s inCluster -&gt; %s\", self.k8s_settings.in_cluster)\nlogger.info(\"K8s namespace -&gt; %s\", self.k8s_settings.namespace)\nlogger.info(\n\"K8s kubeconfig file -&gt; %s\",\nself.k8s_settings.kubeconfig_file,\n)\nk8s_object = K8s(\nin_cluster=self.k8s_settings.in_cluster,\nkubeconfig_file=self.k8s_settings.kubeconfig_file,\nnamespace=self.k8s_settings.namespace,\n)\nif k8s_object:\nlogger.info(\"Kubernetes API is ready now.\")\nelse:\nlogger.error(\"Cannot establish connection to Kubernetes.\")\n# Get number of replicas for frontend:\notcs_frontend_scale = k8s_object.get_stateful_set_scale(\nself.otcs_settings.k8s_statefulset_frontend\n)\nif not otcs_frontend_scale:\nlogger.error(\n\"Cannot find Kubernetes Stateful Set for OTCS Frontends -&gt; %s\",\nself.otcs_settings.k8s_statefulset_frontend,\n)\nsys.exit()\nself.otcs_settings.replicas_frontend = otcs_frontend_scale.spec.replicas  # type: ignore\nlogger.info(\n\"Stateful Set -&gt; %s has -&gt; %s replicas\",\nself.otcs_settings.k8s_statefulset_frontend,\nself.otcs_settings.replicas_frontend,\n)\n# Get number of replicas for backend:\notcs_backend_scale = k8s_object.get_stateful_set_scale(\nself.otcs_settings.k8s_statefulset_backend\n)\nif not otcs_backend_scale:\nlogger.error(\n\"Cannot find Kubernetes Stateful Set for OTCS Backends -&gt; %s\",\nself.otcs_settings.k8s_statefulset_backend,\n)\nsys.exit()\nself.otcs_settings.replicas_backend = otcs_backend_scale.spec.replicas  # type: ignore\nlogger.info(\n\"Stateful Set -&gt; %s has -&gt; %s replicas\",\nself.otcs_settings.k8s_statefulset_backend,\nself.otcs_settings.replicas_backend,\n)\nreturn k8s_object\n# end function definition\ndef init_otds(self) -&gt; OTDS:\n\"\"\"Initialize the OTDS object and parameters and authenticate at OTDS once it is ready.\n        Args:\n            None\n        Returns:\n            object: OTDS object\n        \"\"\"\nlogger.info(\"Connection parameters OTDS:\")\nlogger.info(\"OTDS Protocol          = %s\", self.otds_settings.protocol)\nlogger.info(\"OTDS Public Protocol   = %s\", self.otds_settings.public_protocol)\nlogger.info(\"OTDS Hostname          = %s\", self.otds_settings.hostname)\nlogger.info(\"OTDS Public URL        = %s\", self.otds_settings.public_url)\nlogger.info(\"OTDS Port              = %s\", str(self.otds_settings.port))\nlogger.info(\"OTDS Admin User        = %s\", self.otds_settings.username)\nlogger.debug(\"OTDS Admin Password    = %s\", self.otds_settings.password)\nlogger.debug(\"OTDS Ticket            = %s\", self.otds_settings.otds_ticket)\nlogger.info(\"OTDS Admin Partition   = %s\", self.otds_settings.admin_partition)\notds_object = OTDS(\nprotocol=self.otds_settings.protocol,\nhostname=self.otds_settings.hostname,\nport=self.otds_settings.port,\nusername=self.otds_settings.username,\npassword=self.otds_settings.password,\notds_ticket=self.otds_settings.otds_ticket,\n)\nlogger.info(\"Authenticating to OTDS...\")\notds_cookie = otds_object.authenticate()\nwhile otds_cookie is None:\nlogger.warning(\"Waiting 30 seconds for OTDS to become ready...\")\ntime.sleep(30)\notds_cookie = otds_object.authenticate()\nlogger.info(\"OTDS is ready now.\")\nlogger.info(\"Enable OTDS audit...\")\nif self.otds_settings.enable_audit:\notds_object.enable_audit()\nif self.otds_settings.disable_password_policy:\nlogger.info(\"Disable OTDS password expiry...\")\n# Setting the value to 0 disables password expiry.\n# The default is 90 days and we may have Terrarium\n# instances that are running longer than that. This\n# avoids problems with customerizer re-runs of\n# instances that are &gt; 90 days old.\notds_object.update_password_policy(\nupdate_values={\"passwordMaximumDuration\": 0}\n)\nreturn otds_object\n# end function definition\ndef init_otac(self) -&gt; OTAC:\n\"\"\"Initialize the OTAC object and parameters.\n          Configure the Archive Server as a known server\n          if environment variable OTAC_KNOWN_SERVER is set.\n        Args: None\n        Return:\n            OTAC object\n        \"\"\"\nlogger.info(\"Connection parameters OTAC:\")\nlogger.info(\"OTAC Protocol          = %s\", self.otac_settings.protocol)\nlogger.info(\"OTAC Hostname          = %s\", self.otac_settings.hostname)\nlogger.info(\"OTAC Public URL        = %s\", self.otac_settings.public_url)\nlogger.info(\"OTAC Port              = %s\", str(self.otac_settings.port))\nlogger.info(\"OTAC Admin User        = %s\", self.otac_settings.admin)\nlogger.debug(\"OTAC Admin Password   = %s\", self.otac_settings.password)\nlogger.info(\n\"OTAC Known Server      = %s\",\n(\nself.otac_settings.known_server\nif self.otac_settings.known_server != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\notac_object = OTAC(\nself.otac_settings.protocol,\nself.otac_settings.hostname,\nint(self.otac_settings.port),\nself.otac_settings.admin,\nself.otac_settings.password,\nself.otds_settings.username,\nself.otds_settings.password,\n)\n# is there a known server configured for Archive Center (to sync content with)\nif otac_object and self.otac_settings.known_server != \"\":\n# wait until the OTAC pod is in ready state\nlogger.info(\"Waiting for Archive Center to become ready...\")\nself.k8s_object.wait_pod_condition(self.otac_settings.k8s_pod_name, \"Ready\")\nlogger.info(\"Configure known host for Archive Center...\")\nresponse = otac_object.exec_command(\nf\"cf_create_host {self.otac_settings.known_server} 0 /archive 8080 8090\"\n)\nif not response or not response.ok:\nlogger.error(\"Failed to configure known host for Archive Center!\")\nlogger.info(\"Configure host alias for Archive Center...\")\nresponse = otac_object.exec_command(\nf\"cf_set_variable MY_HOST_ALIASES {self.otac_settings.k8s_pod_name},{self.otac_settings.public_url},otac DS\"\n)\nif not response or not response.ok:\nlogger.error(\"Failed to configure host alias for Archive Center!\")\n# Restart the spawner in Archive Center:\nlogger.info(\"Restart Archive Center Spawner...\")\nself.restart_otac_service()\nelse:\nlogger.info(\n\"Skip configuration of known host for Archive Center (OTAC_KNOWN_SERVER is not set).\"\n)\nreturn otac_object\n# end function definition\ndef init_otcs(\nself,\nhostname: str,\nport: int,\npartition_name: str,\nresource_name: str,\n) -&gt; OTCS:\n\"\"\"Initialize the OTCS class and parameters and authenticate at OTCS once it is ready.\n        Args:\n            hostname (str): OTCS hostname\n            port (int): port number of OTCS\n            partition_name (str): name of OTDS Partition for Extended ECM users\n            resource_name (str): name of OTDS resource for Extended ECM\n        Returns:\n            OTCS: OTCS object\n        \"\"\"\nlogger.info(\"Connection parameters OTCS (Extended ECM):\")\nlogger.info(\"OTCS Protocol              = %s\", self.otcs_settings.protocol)\nlogger.info(\n\"OTCS Public Protocol       = %s\", self.otcs_settings.public_protocol\n)\nlogger.info(\"OTCS Hostname              = %s\", hostname)\nlogger.info(\"OTCS Public URL            = %s\", self.otcs_settings.public_url)\nlogger.info(\"OTCS Port                  = %s\", str(port))\nlogger.info(\"OTCS Admin User            = %s\", self.otcs_settings.admin)\nlogger.debug(\"OTCS Admin Password        = %s\", self.otcs_settings.password)\nlogger.info(\"OTCS User Partition        = %s\", partition_name)\nlogger.info(\"OTCS Resource Name         = %s\", resource_name)\nlogger.info(\n\"OTCS User Default License  = %s\", self.otcs_settings.license_feature\n)\nlogger.info(\n\"OTCS K8s Frontend Pods     = %s\",\nself.otcs_settings.k8s_statefulset_frontend,\n)\nlogger.info(\n\"OTCS K8s Backend Pods      = %s\",\nself.otcs_settings.k8s_statefulset_backend,\n)\nlogger.debug(\"Checking if OTCS object has already been initialized\")\notds_ticket = (\nself.otds_object.cookie()[\"OTDSTicket\"] if self.otds_object else None\n)\notcs_object = OTCS(\nself.otcs_settings.protocol,\nhostname,\nint(port),\nself.otcs_settings.public_protocol + \"://\" + self.otcs_settings.public_url,\nself.otcs_settings.admin,\nself.otcs_settings.password,\npartition_name,\nresource_name,\notds_ticket=otds_ticket,\n)\n# It is important to wait for OTCS to be configured - otherwise we\n# may interfere with the OTCS container automation and run into errors\nlogger.info(\"Wait for OTCS to be configured...\")\notcs_configured = otcs_object.is_configured()\nwhile not otcs_configured:\nlogger.warning(\"OTCS is not configured yet. Waiting 30 seconds...\")\ntime.sleep(30)\notcs_configured = otcs_object.is_configured()\nlogger.info(\"OTCS is configured now.\")\nlogger.info(\"Authenticating to OTCS...\")\notcs_cookie = otcs_object.authenticate()\nwhile otcs_cookie is None:\nlogger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\ntime.sleep(30)\notcs_cookie = otcs_object.authenticate()\nlogger.info(\"OTCS is ready now.\")\nif self.otcs_settings.update_admin_user:\n# Set first name and last name of Admin user (ID = 1000):\notcs_object.update_user(1000, field=\"first_name\", value=\"Terrarium\")\notcs_object.update_user(1000, field=\"last_name\", value=\"Admin\")\nif \"OTCS_RESSOURCE_ID\" not in self.settings.placeholder_values:\nself.settings.placeholder_values[\n\"OTCS_RESSOURCE_ID\"\n] = self.otds_object.get_resource(self.otcs_settings.resource_name)[\n\"resourceID\"\n]\nlogger.debug(\n\"Placeholder values after OTCS init = %s\",\nself.settings.placeholder_values,\n)\nif self.otawp_settings.enabled:\notcs_resource = self.otds_object.get_resource(\nself.otcs_settings.resource_name\n)\notcs_resource[\n\"logoutURL\"\n] = f\"{self.otawp_settings.public_protocol}://{self.otawp_settings.public_url}/home/system/wcp/sso/sso_logout.htm\"\notcs_resource[\"logoutMethod\"] = \"GET\"\nself.otds_object.update_resource(name=\"cs\", resource=otcs_resource)\n# Allow impersonation of the resource for all users:\nself.otds_object.impersonate_resource(resource_name)\nreturn otcs_object\n# end function definition\ndef init_otiv(self) -&gt; OTIV | None:\n\"\"\"Initialize the OTIV (Intelligent Viewing) object and its OTDS settings.\n        Args:\n        Returns:\n            objects: OTIV object\n        \"\"\"\nlogger.info(\"Parameters for OTIV (Intelligent Viewing):\")\nlogger.info(\"OTDS Resource Name       = %s\", self.otiv_settings.resource_name)\nlogger.info(\"OTIV License File        = %s\", self.otiv_settings.license_file)\nlogger.info(\"OTIV Product Name        = %s\", self.otiv_settings.product_name)\nlogger.info(\n\"OTIV Product Description = %s\", self.otiv_settings.product_description\n)\nlogger.info(\"OTIV License Feature     = %s\", self.otiv_settings.license_feature)\notiv_object = OTIV(\nresource_name=self.otiv_settings.resource_name,\nproduct_name=self.otiv_settings.product_name,\nproduct_description=self.otiv_settings.product_description,\nlicense_file=self.otiv_settings.license_file,\ndefault_license=self.otiv_settings.license_feature,\n)\notiv_resource = self.otds_object.get_resource(self.otiv_settings.resource_name)\nwhile otiv_resource is None:\nlogger.warning(\n\"OTDS Resource -&gt; %s for Intelligent Viewing not found. OTIV may not be ready. Wait 30 sec...\",\nself.otiv_settings.resource_name,\n)\ntime.sleep(30)\notiv_resource = self.otds_object.get_resource(\nself.otiv_settings.resource_name\n)\notiv_license = self.otds_object.add_license_to_resource(\nself.otiv_settings.license_file,\nself.otiv_settings.product_name,\nself.otiv_settings.product_description,\notiv_resource[\"resourceID\"],\n)\nif not otiv_license:\nlogger.info(\n\"Couldn't apply license -&gt; %s for product -&gt; %s. Intelligent Viewing may not be deployed!\",\nself.otiv_settings.license_file,\nself.otiv_settings.product_name,\n)\nreturn None\nreturn otiv_object\n# end function definition\ndef init_otpd(self) -&gt; OTPD:\n\"\"\"Initialize the OTPD (PowerDocs) object and parameters.\n        Args:\n            None\n        Returns:\n            object: OTPD (PowerDocs) object\n        \"\"\"\nlogger.info(\"Connection parameters OTPD (PowerDocs):\")\nlogger.info(\"OTPD Protocol             = %s\", self.otpd_settings.protocol)\nlogger.info(\"OTPD Hostname             = %s\", self.otpd_settings.hostname)\nlogger.info(\"OTPD Port                 = %s\", str(self.otpd_settings.port))\nlogger.info(\"OTPD API User             = %s\", self.otpd_settings.user)\nlogger.info(\"OTPD Tenant               = %s\", self.otpd_settings.tenant)\nlogger.info(\n\"OTPD Database Import File = %s\",\n(\nself.otpd_settings.db_importfile\nif self.otpd_settings.db_importfile != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\nlogger.info(\"OTPD K8s Pod Name         = %s\", self.otpd_settings.k8s_pod_name)\notpd_object = OTPD(\nself.otpd_settings.protocol,\nself.otpd_settings.hostname,\nint(self.otpd_settings.port),\nself.otpd_settings.user,\nself.otpd_settings.password,\n)\n# wait until the OTPD pod is in ready state\nself.k8s_object.wait_pod_condition(self.otpd_settings.k8s_pod_name, \"Ready\")\n# We have a race condition here. Even if the pod is ready\n# it may not yet have fully initialized its database.\n# Then the \"apply_setting()\" calls below may fail with\n# an error. This should be improved in the future. For now\n# we just wait a minute hoping that the DB is initialized then.\nlogger.info(\"Wait some time for PowerDocs database to be initialized...\")\ntime.sleep(60)\nlogger.info(\"Configure some basic PowerDocs settings...\")\n# Fix settings for local Kubernetes deployments.\n# Unclear why this is not the default.\nif otpd_object:\notpd_object.apply_setting(\"LocalOtdsUrl\", \"http://otds/otdsws\")\notpd_object.apply_setting(\n\"LocalApplicationServerUrlForContentManager\",\n\"http://localhost:8080/c4ApplicationServer\",\nself.otpd_settings.tenant,\n)\nreturn otpd_object\n# end function definition\ndef init_otawp(self):\n\"\"\"Initialize OTDS for Appworks Platform\n        Args:\n        Return: None\n        \"\"\"\nlogger.info(\"Connection parameters OTAWP:\")\nlogger.info(\"OTAWP Enabled          = %s\", str(self.otawp_settings.enabled))\nlogger.info(\"OTAWP Resource         = %s\", self.otawp_settings.resource_name)\nlogger.info(\"OTAWP Access Role      = %s\", self.otawp_settings.access_role_name)\nlogger.info(\"OTAWP Admin User       = %s\", self.otawp_settings.admin)\nlogger.debug(\"OTAWP Password         = %s\", self.otawp_settings.password)\nlogger.info(\"OTAWP K8s Stateful Set = %s\", self.otawp_settings.k8s_statefulset)\nlogger.info(\"OTAWP K8s Config Map   = %s\", self.otawp_settings.k8s_configmap)\nlogger.info(\n\"Wait for OTCS to create its OTDS resource with name -&gt; %s...\",\nself.otcs_settings.resource_name,\n)\n# Loop to wait for OTCS to create its OTDS resource\n# (we need it to update the AppWorks K8s Config Map):\notcs_resource = self.otds_object.get_resource(self.otcs_settings.resource_name)\nwhile otcs_resource is None:\nlogger.warning(\n\"OTDS resource for Content Server with name -&gt; %s does not exist yet. Waiting...\",\nself.otcs_settings.resource_name,\n)\ntime.sleep(30)\notcs_resource = self.otds_object.get_resource(\nself.otcs_settings.resource_name\n)\notcs_resource_id = otcs_resource[\"resourceID\"]\nlogger.info(\"OTDS resource ID for Content Server -&gt; %s\", otcs_resource_id)\n# make sure code is idempotent and only try to add ressource if it doesn't exist already:\nawp_resource = self.otds_object.get_resource(self.otawp_settings.resource_name)\nif not awp_resource:\nlogger.info(\n\"OTDS resource -&gt; %s for AppWorks Platform does not yet exist. Creating...\",\nself.otawp_settings.resource_name,\n)\n# Create a Python dict with the special payload we need for AppWorks:\nadditional_payload = {}\nadditional_payload[\"connectorid\"] = \"rest\"\nadditional_payload[\"resourceType\"] = \"rest\"\nuser_attribute_mapping = [\n{\n\"sourceAttr\": [\"oTExternalID1\"],\n\"destAttr\": \"__NAME__\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayname\"],\n\"destAttr\": \"DisplayName\",\n\"mappingFormat\": \"%s\",\n},\n{\"sourceAttr\": [\"mail\"], \"destAttr\": \"Email\", \"mappingFormat\": \"%s\"},\n{\n\"sourceAttr\": [\"oTTelephoneNumber\"],\n\"destAttr\": \"Telephone\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTMobile\"],\n\"destAttr\": \"Mobile\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n\"destAttr\": \"Fax\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTStreetAddress,l,st,postalCode,c\"],\n\"destAttr\": \"Address\",\n\"mappingFormat\": \"%s%n%s %s %s%n%s\",\n},\n{\n\"sourceAttr\": [\"oTCompany\"],\n\"destAttr\": \"Company\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"ds-pwp-account-disabled\"],\n\"destAttr\": \"AccountDisabled\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTExtraAttr9\"],\n\"destAttr\": \"IsServiceAccount\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"custom:proxyConfiguration\"],\n\"destAttr\": \"ProxyConfiguration\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"c\"],\n\"destAttr\": \"Identity-CountryOrRegion\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"gender\"],\n\"destAttr\": \"Identity-Gender\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayName\"],\n\"destAttr\": \"Identity-DisplayName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTStreetAddress\"],\n\"destAttr\": \"Identity-Address\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"l\"],\n\"destAttr\": \"Identity-City\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"mail\"],\n\"destAttr\": \"Identity-Email\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"givenName\"],\n\"destAttr\": \"Identity-FirstName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"sn\"],\n\"destAttr\": \"Identity-LastName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"initials\"],\n\"destAttr\": \"Identity-MiddleNames\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTMobile\"],\n\"destAttr\": \"Identity-Mobile\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"postalCode\"],\n\"destAttr\": \"Identity-PostalCode\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"st\"],\n\"destAttr\": \"Identity-StateOrProvince\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"title\"],\n\"destAttr\": \"Identity-title\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"physicalDeliveryOfficeName\"],\n\"destAttr\": \"Identity-physicalDeliveryOfficeName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n\"destAttr\": \"Identity-oTFacsimileTelephoneNumber\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"notes\"],\n\"destAttr\": \"Identity-notes\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTCompany\"],\n\"destAttr\": \"Identity-oTCompany\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTDepartment\"],\n\"destAttr\": \"Identity-oTDepartment\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"birthDate\"],\n\"destAttr\": \"Identity-Birthday\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"cn\"],\n\"destAttr\": \"Identity-UserName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"Description\"],\n\"destAttr\": \"Identity-UserDescription\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTTelephoneNumber\"],\n\"destAttr\": \"Identity-Phone\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayName\"],\n\"destAttr\": \"Identity-IdentityDisplayName\",\n\"mappingFormat\": \"%s\",\n},\n]\nadditional_payload[\"userAttributeMapping\"] = user_attribute_mapping\ngroup_attribute_mapping = [\n{\n\"sourceAttr\": [\"cn\"],\n\"destAttr\": \"__NAME__\",\n\"mappingFormat\": '%js:function format(name) { return name.replace(/&amp;/g,\"-and-\"); }',\n},\n{\n\"sourceAttr\": [\"description\"],\n\"destAttr\": \"Description\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"description\"],\n\"destAttr\": \"Identity-Description\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayName\"],\n\"destAttr\": \"Identity-DisplayName\",\n\"mappingFormat\": \"%s\",\n},\n]\nadditional_payload[\"groupAttributeMapping\"] = group_attribute_mapping\nadditional_payload[\"connectorName\"] = \"REST (Generic)\"\nadditional_payload[\"pcCreatePermissionAllowed\"] = \"true\"\nadditional_payload[\"pcModifyPermissionAllowed\"] = \"true\"\nadditional_payload[\"pcDeletePermissionAllowed\"] = \"false\"\nadditional_payload[\"connectionParamInfo\"] = [\n{\n\"name\": \"fBaseURL\",\n\"value\": \"http://appworks:8080/home/system/app/otdspush\",\n},\n{\"name\": \"fUsername\", \"value\": self.otawp_settings.admin},\n{\"name\": \"fPassword\", \"value\": self.otawp_settings.password},\n]\nawp_resource = self.otds_object.add_resource(\nself.otawp_settings.resource_name,\n\"AppWorks Platform\",\n\"AppWorks Platform\",\nadditional_payload,\n)\nelse:\nlogger.info(\n\"OTDS resource -&gt; %s for AppWorks Platform does already exist.\",\nself.otawp_settings.resource_name,\n)\nawp_resource_id = awp_resource[\"resourceID\"]\nlogger.info(\"OTDS resource ID for AppWorks Platform -&gt; %s\", awp_resource_id)\nself.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = str(awp_resource_id)\nlogger.debug(\n\"Placeholder values after OTAWP init = %s\", self.settings.placeholder_values\n)\nlogger.info(\"Update AppWorks Kubernetes Config Map with OTDS resource IDs...\")\nconfig_map = self.k8s_object.get_config_map(self.otawp_settings.k8s_configmap)\nif not config_map:\nlogger.error(\n\"Failed to retrieve AppWorks Kubernetes Config Map -&gt; %s\",\nself.otawp_settings.k8s_configmap,\n)\nelse:\nsolution = yaml.safe_load(config_map.data[\"solution.yaml\"])  # type: ignore\n# Change values as required\nsolution[\"platform\"][\"organizations\"][\"system\"][\"otds\"][\n\"resourceId\"\n] = awp_resource_id\nsolution[\"platform\"][\"content\"][\"ContentServer\"][\n\"contentServerUrl\"\n] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cs/cs\"\nsolution[\"platform\"][\"content\"][\"ContentServer\"][\n\"contentServerSupportDirectoryUrl\"\n] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cssupport\"\nsolution[\"platform\"][\"content\"][\"ContentServer\"][\n\"otdsResourceId\"\n] = otcs_resource_id\nsolution[\"platform\"][\"authenticators\"][\"OTDS_auth\"][\"publicLoginUrl\"] = (\nself.otds_settings.public_protocol\n+ \"://\"\n+ self.otds_settings.public_url\n+ \"/otdsws/login\"\n)\nsolution[\"platform\"][\"security\"][\"contentSecurityPolicy\"] = (\n\"frame-ancestors 'self' \"\n+ self.otcs_settings.public_protocol\n+ \"://\"\n+ self.otcs_settings.public_url\n)\ndata = {\"solution.yaml\": yaml.dump(solution)}\nresult = self.k8s_object.replace_config_map(\nself.otawp_settings.k8s_configmap, data\n)\nif result:\nlogger.info(\"Successfully updated AppWorks Solution YAML.\")\nelse:\nlogger.error(\"Failed to update AppWorks Solution YAML.\")\nlogger.debug(\"Solution YAML for AppWorks -&gt; %s\", solution)\nlogger.info(\"Scale AppWorks Kubernetes Stateful Set to 1...\")\nself.k8s_object.scale_stateful_set(\nsts_name=self.otawp_settings.k8s_statefulset, scale=1\n)\n# Add the OTCS Admin user to the AppWorks Access Role in OTDS\nself.otds_object.add_user_to_access_role(\n\"Access to \" + self.otawp_settings.resource_name, \"otadmin@otds.admin\"\n)\n# Loop to wait for OTCS to create its OTDS user partition:\notcs_partition = self.otds_object.get_partition(\nself.otcs_settings.partition, show_error=False\n)\nwhile otcs_partition is None:\nlogger.warning(\n\"OTDS user partition for Content Server with name -&gt; %s does not exist yet. Waiting...\",\nself.otcs_settings.partition,\n)\ntime.sleep(30)\notcs_partition = self.otds_object.get_partition(\nself.otcs_settings.partition, show_error=False\n)\n# Add the OTDS user partition for OTCS to the AppWorks Platform Access Role in OTDS.\n# This will effectvely sync all OTCS users with AppWorks Platform:\nself.otds_object.add_partition_to_access_role(\nself.otawp_settings.access_role_name, self.otcs_settings.partition\n)\n# Add the OTDS admin partition to the AppWorks Platform Access Role in OTDS.\nself.otds_object.add_partition_to_access_role(\nself.otawp_settings.access_role_name, self.otds_settings.admin_partition\n)\n# Set Group inclusion for Access Role for OTAWP to \"True\":\nself.otds_object.update_access_role_attributes(\nself.otawp_settings.access_role_name,\n[{\"name\": \"pushAllGroups\", \"values\": [\"True\"]}],\n)\n# Add ResourceID User to OTDSAdmin to allow push\nself.otds_object.add_user_to_group(\nuser=str(awp_resource_id) + \"@otds.admin\", group=\"otdsadmins@otds.admin\"\n)\n# Allow impersonation for all users:\nself.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n# Add SPS license for OTAWP\n# check if the license file exists, otherwise skip for versions pre 24.1\nif os.path.isfile(self.otawp_settings.license_file):\nlogger.info(\n\"OTAWP license file (%s) found, assiging to ressource %s\",\nself.otawp_settings.license_file,\nself.otawp_settings.resource_name,\n)\notawp_license = self.otds_object.add_license_to_resource(\nself.otawp_settings.license_file,\nself.otawp_settings.product_name,\nself.otawp_settings.product_description,\nawp_resource[\"resourceID\"],\n)\nif not otawp_license:\nlogger.error(\n\"Couldn't apply license -&gt; %s for product -&gt; %s.\",\nself.otawp_settings.license_file,\nself.otawp_settings.product_name,\n)\n# Assign license to Content Server Members Partiton and otds.admin\nfor partition_name in [\"otds.admin\", self.otcs_settings.partition]:\nif self.otds_object.is_partition_licensed(\npartition_name=partition_name,\nresource_id=awp_resource[\"resourceID\"],\nlicense_feature=\"USERS\",\nlicense_name=self.otawp_settings.product_name,\n):\nlogger.info(\n\"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\npartition_name,\nself.otawp_settings.product_name,\n\"USERS\",\n)\nelse:\nassigned_license = self.otds_object.assign_partition_to_license(\npartition_name,\nawp_resource[\"resourceID\"],\n\"USERS\",\nself.otawp_settings.product_name,\n)\nif not assigned_license:\nlogger.error(\n\"Partition -&gt; %s could not be assigned to license -&gt; %s (%s)\",\npartition_name,\nself.otawp_settings.product_name,\n\"USERS\",\n)\n# end function definition\ndef restart_otcs_service(self, otcs_object: OTCS, extra_wait_time: int = 60):\n\"\"\"Restart the Content Server service in all OTCS pods\n        Args:\n            otcs_object: OTCS class instance (object)\n        Returns:\n            None\n        \"\"\"\nif not self.k8s_object:\nlogger.warning(\n\"Kubernetes integration not available, skipping restart of services\"\n)\nreturn\nlogger.info(\"Restart OTCS frontend and backend pods...\")\n# Restart all frontends:\nfor x in range(0, self.otcs_settings.replicas_frontend):\npod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\nlogger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n)\nlogger.info(\"Restarting pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n)\n# Restart all backends:\nfor x in range(0, self.otcs_settings.replicas_backend):\npod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\nlogger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n)\nlogger.info(\"Restarting pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n)\nlogger.info(\"Re-Authenticating to OTCS after restart of pods...\")\notcs_cookie = otcs_object.authenticate(revalidate=True)\nwhile otcs_cookie is None:\nlogger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\ntime.sleep(30)\notcs_cookie = otcs_object.authenticate(revalidate=True)\nlogger.info(\"OTCS is ready again.\")\n# Reactivate Liveness probes in all pods:\nfor x in range(0, self.otcs_settings.replicas_frontend):\npod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\nlogger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n)\nfor x in range(0, self.otcs_settings.replicas_backend):\npod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\nlogger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n)\nlogger.info(\"Restart OTCS frontend and backend pods has been completed.\")\n# optional, give some additional time to make sure service is responsive\nif extra_wait_time &gt; 0:\nlogger.info(\n\"Wait %s seconds to make sure OTCS is responsive again...\",\nstr(extra_wait_time),\n)\ntime.sleep(extra_wait_time)\nlogger.info(\"Continue customizing...\")\n# end function definition\ndef restart_otac_service(self) -&gt; bool:\n\"\"\"Restart the Archive Center spawner service in OTAC pod\n        Args:\n            None\n        Returns:\n            bool: True if restart was done, False if error occured\n        \"\"\"\nif not self.otac_settings.enabled:\nreturn False\nlogger.info(\n\"Restarting spawner service in Archive Center pod -&gt; %s\",\nself.otac_settings.k8s_pod_name,\n)\n# The Archive Center Spawner needs to be run in \"interactive\" mode - otherwise the command will \"hang\":\n# The \"-c\" parameter is not required in this case\n# False is given as parameter as OTAC writes non-errors to stderr\nresponse = self.k8s_object.exec_pod_command_interactive(\nself.otac_settings.k8s_pod_name,\n[\"/bin/sh\", \"/etc/init.d/spawner restart\"],\n60,\nFalse,\n)\nif response:\nreturn True\nelse:\nreturn False\n# end function definition\ndef restart_otawp_pod(self):\n\"\"\"Delete the AppWorks Platform Pod to make Kubernetes restart it.\n        Args:\n        Returns:\n            None\n        \"\"\"\nself.k8s_object.delete_pod(self.otawp_settings.k8s_statefulset + \"-0\")\n# end function definition\ndef consolidate_otds(self):\n\"\"\"Consolidate OTDS resources\n        Args:\n        Return: None\n        \"\"\"\nself.otds_object.consolidate(self.otcs_settings.resource_name)\nif self.otawp_settings.enabled:  # is AppWorks Platform deployed?\nself.otds_object.consolidate(self.otawp_settings.resource_name)\n# end function definition\ndef import_powerdocs_configuration(self, otpd_object: OTPD):\n\"\"\"Import a database export (zip file) into the PowerDocs database\n        Args:\n            otpd_object (object): PowerDocs object\n        \"\"\"\nif self.otpd_settings.db_importfile.startswith(\"http\"):\n# Download file from remote location specified by the OTPD_DBIMPORTFILE\n# this must be a public place without authentication:\nlogger.info(\n\"Download PowerDocs database file from URL -&gt; %s\",\nself.otpd_settings.db_importfile,\n)\ntry:\npackage = requests.get(self.otpd_settings.db_importfile, timeout=60)\npackage.raise_for_status()\nlogger.info(\n\"Successfully downloaded PowerDocs database file -&gt; %s; status code -&gt; %s\",\nself.otpd_settings.db_importfile,\npackage.status_code,\n)\nfilename = \"/tmp/otpd_db_import.zip\"\nwith open(filename, mode=\"wb\") as localfile:\nlocalfile.write(package.content)\nlogger.info(\n\"Starting import on %s://%s:%s of %s\",\nself.otpd_settings.protocol,\nself.otpd_settings.hostname,\nself.otpd_settings.port,\nself.otpd_settings.db_importfile,\n)\nresponse = otpd_object.import_database(filename=filename)\nlogger.info(\"Response -&gt; %s\", response)\nexcept requests.exceptions.HTTPError as err:\nlogger.error(\"Request error -&gt; %s\", err)\n# end function definition\ndef set_maintenance_mode(self, enable: bool = True):\n\"\"\"Enable or Disable Maintenance Mode\n        Args:\n            enable (bool, optional): _description_. Defaults to True.\n        \"\"\"\nif enable and self.k8s_settings.enabled:\nself.log_header(\"Enable Maintenance Mode\")\nlogger.info(\n\"Put OTCS frontends in Maitenance Mode by changing the Kubernetes Ingress backend service...\"\n)\nself.k8s_object.update_ingress_backend_services(\nself.otcs_settings.k8s_ingress,\n\"otcs\",\nself.otcs_settings.maintenance_service_name,\nself.otcs_settings.mainteance_service_port,\n)\nlogger.info(\"OTCS frontend is now in Maintenance Mode!\")\nelif not self.k8s_settings.enabled:\nlogger.warning(\n\"Kubernetes Integration disabled - Cannot Enable/Disable Maintenance Mode\"\n)\nself.k8s_object = None\nelse:\n# Changing the Ingress backend service to OTCS frontend service:\nlogger.info(\n\"Put OTCS frontend back in Production Mode by changing the Kubernetes Ingress backend service...\"\n)\nself.k8s_object.update_ingress_backend_services(\nself.otcs_settings.k8s_ingress,\n\"otcs\",\nself.otcs_settings.hostname_frontend,\nself.otcs_settings.port_frontend,\n)\nlogger.info(\"OTCS frontend is now back in Production Mode!\")\ndef customization_run(self):\n\"\"\"Central function to initiate the customization\"\"\"\n# Set Timer for duration calculation\nself.settings.customizer_start_time = (\nself.settings.customizer_end_time\n) = datetime.now()\n# Initialize the OTDS, OTCS and OTPD objects and wait for the\n# pods to be ready. If any of this fails we bail out:\nself.log_header(\"Initialize OTDS\")\nself.otds_object = self.init_otds()\nif not self.otds_object:\nlogger.error(\"Failed to initialize OTDS - exiting...\")\nsys.exit()\n# Establish in-cluster Kubernetes connection\nself.log_header(\"Initialize Kubernetes\")\nif self.k8s_settings.enabled:\nself.k8s_object = self.init_k8s()\nif not self.k8s_object:\nlogger.error(\"Failed to initialize Kubernetes - exiting...\")\nsys.exit()\n# Put Frontend in Maintenance mode to make sure nobody interferes\n# during customization:\nif self.otcs_settings.maintenance_mode:\nself.set_maintenance_mode(True)\nif self.otawp_settings.enabled:  # is AppWorks Platform deployed?\nself.log_header(\"Initialize OTAWP\")\n# Configure required OTDS resources as AppWorks doesn't do this on its own:\nself.init_otawp()\nelse:\nself.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = \"\"\nself.log_header(\"Initialize OTCS backend\")\nself.otcs_backend_object = self.init_otcs(\nself.otcs_settings.hostname_backend,\nint(self.otcs_settings.port_backend),\nself.otcs_settings.partition,\nself.otcs_settings.resource_name,\n)\nif not self.otcs_backend_object:\nlogger.error(\"Failed to initialize OTCS backend - exiting...\")\nsys.exit()\nself.log_header(\"Initialize OTCS frontend\")\nself.otcs_frontend_object = self.init_otcs(\nself.otcs_settings.hostname_frontend,\nint(self.otcs_settings.port_frontend),\nself.otcs_settings.partition,\nself.otcs_settings.resource_name,\n)\nif not self.otcs_frontend_object:\nlogger.error(\"Failed to initialize OTCS frontend - exiting...\")\nsys.exit()\nif self.otac_settings.enabled:  # is Archive Center deployed?\nself.log_header(\"Initialize OTAC\")\nself.otac_object = self.init_otac()\nif not self.otac_object:\nlogger.error(\"Failed to initialize OTAC - exiting...\")\nsys.exit()\nelse:\nself.otac_object = None\nif self.otiv_settings.enabled:  # is Intelligent Viewing deployed?\nself.log_header(\"Initialize OTIV\")\nself.otiv_object = self.init_otiv()\nelse:\nself.otiv_object = None\nif self.otpd_settings.enabled:  # is PowerDocs deployed?\nself.log_header(\"Initialize OTPD\")\nself.otpd_object = self.init_otpd()\nif not self.otpd_object:\nlogger.error(\"Failed to initialize OTPD - exiting...\")\nsys.exit()\nelse:\nself.otpd_object = None\nif (\nself.m365_settings.enabled\nand self.m365_settings.user != \"\"\nand self.m365_settings.password != \"\"\n):  # is M365 enabled?\nself.log_header(\"Initialize MS Graph API\")\n# Initialize the M365 object and connection to M365 Graph API:\nself.m365_object = self.init_m365()\nself.log_header(\"Upload MS Teams App\")\n# Download MS Teams App from OTCS (this has with 23.2 a nasty side-effect\n# of unsetting 2 checkboxes on that config page - we reset these checkboxes\n# with the settings file \"O365Settings.xml\"):\nresponse = self.otcs_frontend_object.download_config_file(\n\"/cs/cs?func=officegroups.DownloadTeamsPackage\",\n\"/tmp/ot.xecm.teams.zip\",\n)\n# this app upload will be done with the user credentials - this is required:\nself.m365_object.authenticate_user(\nself.m365_settings.user, self.m365_settings.password\n)\n# Check if the app is already installed in the apps catalog:\nresponse = self.m365_object.get_teams_apps(\nf\"contains(displayName, '{self.m365_settings.teams_app_name}')\"\n)\nif self.m365_object.exist_result_item(\nresponse, \"displayName\", self.m365_settings.teams_app_name\n):\napp_catalog_id = self.m365_object.get_result_value(\nresponse=response, key=\"id\", index=0\n)  # 0 = Index = first item\napp_catalog_version = self.m365_object.get_result_value(\nresponse=response,\nkey=\"version\",\nindex=0,\nsub_dict_name=\"appDefinitions\",\n)\nlogger.info(\n\"Extended ECM Teams App is already in app catalog with app catalog ID -&gt; %s and version -&gt; %s. Check if we have a newer version to upload...\",\napp_catalog_id,\napp_catalog_version,\n)\napp_upload_version = self.m365_object.extract_version_from_app_manifest(\napp_path=\"/tmp/ot.xecm.teams.zip\"\n)\nif app_catalog_version &lt; app_upload_version:\nlogger.info(\n\"Upgrading Extended ECM Teams App in catalog from version -&gt; %s to version -&gt; %s...\",\napp_catalog_version,\napp_upload_version,\n)\nresponse = self.m365_object.upload_teams_app(\napp_path=\"/tmp/ot.xecm.teams.zip\",\nupdate_existing_app=True,\napp_catalog_id=app_catalog_id,\n)\nelse:\nlogger.info(\n\"No upgrade required. The upload version -&gt; %s is not newer than the version -&gt; %s which is in the M365 app catalog.\",\napp_upload_version,\napp_catalog_version,\n)\nelse:\nlogger.info(\n\"Extended Teams ECM App is not yet in app catalog. Installing as new app...\"\n)\nresponse = self.m365_object.upload_teams_app(\napp_path=\"/tmp/ot.xecm.teams.zip\"\n)\n# logger.info(\"======== Upload Outlook Add-In ============\")\n# # Download MS Outlook Add-In from OTCS:\n# MANIFEST_FILE = \"/tmp/BusinessWorkspace.Manifest.xml\"\n# if not self.otcs_frontend_object.download_config_file(\n#     \"/cs/cs?func=outlookaddin.DownloadManifest\",\n#     MANIFEST_FILE,\n#     \"DeployedContentServer\",\n#     self.otcs_settings.public_url,\n# ):\n#     logger.error(\"Failed to download M365 Outlook Add-In from Extended ECM!\")\n# else:\n#     # THIS IS NOT IMPLEMENTED DUE TO LACK OF M365 GRAPH API SUPPORT!\n#     # Do it manually for now: https://admin.microsoft.com/#/Settings/IntegratedApps\n#     logger.info(\"Successfully downloaded M365 Outlook Add-In from Extended ECM to %s\", MANIFEST_FILE)\n#     self.m365_object.upload_outlook_app(MANIFEST_FILE)\nelse:\nself.m365_object = None\n# self.log_header(\"Initialize Browser Automation...\")\n# We initialize a Selenium based browser automation for\n# those die-hard settings that cannot be automated via REST API\n# nor LLConfig nor Transport:\n# self.browser_automation_object = self.init_browser_automation()\n# if not self.browser_automation_object:\n#     logger.error(\"Failed to initialize Browser Automation - exiting...\")\n#     sys.exit()\nself.log_header(\"Processing Payload\")\ncust_payload_list = []\n# Is uncompressed payload provided?\nif os.path.exists(self.settings.cust_payload):\nlogger.info(\"Found payload file -&gt; %s\", self.settings.cust_payload)\ncust_payload_list.append(self.settings.cust_payload)\n# Is compressed payload provided?\nif os.path.exists(self.settings.cust_payload_gz):\nlogger.info(\n\"Found compressed payload file -&gt; %s\", self.settings.cust_payload_gz\n)\ncust_payload_list.append(self.settings.cust_payload_gz)\n# do we have additional payload as an external file?\nif os.path.exists(self.settings.cust_payload_external):\nfor filename in os.scandir(self.settings.cust_payload_external):\nif filename.is_file() and os.path.getsize(filename) &gt; 0:\nlogger.info(\"Found external payload file -&gt; %s\", filename.path)\ncust_payload_list.append(filename.path)\nelse:\nlogger.info(\n\"No external payload file -&gt; %s\", self.settings.cust_payload_external\n)\nfor cust_payload in cust_payload_list:\n# Open the payload file. If this fails we bail out:\nlogger.info(\"Starting processing of payload -&gt; %s\", cust_payload)\n# Set startTime for duration calculation\nstart_time = datetime.now()\npayload_object = Payload(\npayload_source=cust_payload,\ncustom_settings_dir=self.settings.cust_settings_dir,\nk8s_object=self.k8s_object,\notds_object=self.otds_object,\notac_object=self.otac_object,\notcs_backend_object=self.otcs_backend_object,\notcs_frontend_object=self.otcs_frontend_object,\notcs_restart_callback=self.restart_otcs_service,\notiv_object=self.otiv_object,\nm365_object=self.m365_object,\nbrowser_automation_object=self.browser_automation_object,\nplaceholder_values=self.settings.placeholder_values,  # this dict includes placeholder replacements for the Ressource IDs of OTAWP and OTCS\nlog_header_callback=self.log_header,\nstop_on_error=self.settings.stop_on_error,\naviator_enabled=self.aviator_settings.enabled,\n)\n# Load the payload file and initialize the payload sections:\nif not payload_object.init_payload():\nlogger.error(\n\"Failed to initialize payload -&gt; %s - skipping...\", cust_payload\n)\ncontinue\n# Now process the payload in the defined ordering:\npayload_object.process_payload()\nself.log_header(\"Consolidate OTDS Resources\")\nself.consolidate_otds()\n# Upload payload file for later review to Enterprise Workspace\nself.log_header(\"Upload Payload file to Extended ECM\")\nresponse = self.otcs_backend_object.get_node_from_nickname(\nself.settings.cust_target_folder_nickname\n)\ntarget_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2000  # use Enterprise Workspace as fallback\n# Write YAML file with upadated payload (including IDs, etc.).\n# We need to write to /tmp as initial location is read-only:\npayload_file = os.path.basename(cust_payload)\npayload_file = (\npayload_file[: -len(\".gz.b64\")]\nif payload_file.endswith(\".gz.b64\")\nelse payload_file\n)\ncust_payload = \"/tmp/\" + payload_file\nwith open(cust_payload, \"w\", encoding=\"utf-8\") as file:\nyaml.dump(payload_object.get_payload(), file)\n# Check if the payload file has been uploaded before.\n# This can happen if we re-run the python container.\n# In this case we add a version to the existing document:\nresponse = self.otcs_backend_object.get_node_by_parent_and_name(\nint(target_folder_id), os.path.basename(cust_payload)\n)\ntarget_document_id = self.otcs_backend_object.get_result_value(\nresponse, \"id\"\n)\nif target_document_id:\nresponse = self.otcs_backend_object.add_document_version(\nint(target_document_id),\ncust_payload,\nos.path.basename(cust_payload),\n\"text/plain\",\n\"Updated payload file after re-run of customization\",\n)\nelse:\nresponse = self.otcs_backend_object.upload_file_to_parent(\ncust_payload,\nos.path.basename(cust_payload),\n\"text/plain\",\nint(target_folder_id),\n)\nduration = datetime.now() - start_time\nself.log_header(\n\"Customizer completed processing of payload -&gt; {} in {}\".format(\ncust_payload,\nduration,\n)\n)\nif self.otcs_settings.maintenance_mode:\nself.set_maintenance_mode(False)\n# Restart AppWorksPlatform pod if it is deployed (to make settings effective):\nif self.otawp_settings.enabled:  # is AppWorks Platform deployed?\notawp_resource = self.otds_object.get_resource(\nself.otawp_settings.resource_name\n)\nif (\nnot \"allowImpersonation\" in otawp_resource\nor not otawp_resource[\"allowImpersonation\"]\n):\n# Allow impersonation for all users:\nlogger.warning(\n\"OTAWP impersonation is not correct in OTDS before OTAWP pod restart!\"\n)\nelse:\nlogger.info(\n\"OTAWP impersonation is correct in OTDS before OTAWP pod restart!\"\n)\nlogger.info(\"Restart OTAWP pod...\")\nself.restart_otawp_pod()\n# For some reason we need to double-check that the impersonation for OTAWP has been set correctly\n# and if not set it again:\notawp_resource = self.otds_object.get_resource(\nself.otawp_settings.resource_name\n)\nif (\nnot \"allowImpersonation\" in otawp_resource\nor not otawp_resource[\"allowImpersonation\"]\n):\n# Allow impersonation for all users:\nlogger.warning(\n\"OTAWP impersonation is not correct in OTDS - set it once more...\"\n)\nself.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n# Upload log file for later review to \"Deployment\" folder in \"Administration\" folder\nif os.path.exists(self.settings.cust_log_file):\nself.log_header(\"Upload log file to Extended ECM\")\n#            logger.info(\"========== Upload log file to Extended ECM =============\")\nresponse = self.otcs_backend_object.get_node_from_nickname(\nself.settings.cust_target_folder_nickname\n)\ntarget_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2000  # use Enterprise Workspace as fallback\n# Check if the log file has been uploaded before.\n# This can happen if we re-run the python container:\n# In this case we add a version to the existing document:\nresponse = self.otcs_backend_object.get_node_by_parent_and_name(\nint(target_folder_id), os.path.basename(self.settings.cust_log_file)\n)\ntarget_document_id = self.otcs_backend_object.get_result_value(\nresponse, \"id\"\n)\nif target_document_id:\nresponse = self.otcs_backend_object.add_document_version(\nint(target_document_id),\nself.settings.cust_log_file,\nos.path.basename(self.settings.cust_log_file),\n\"text/plain\",\n\"Updated Python Log after re-run of customization\",\n)\nelse:\nresponse = self.otcs_backend_object.upload_file_to_parent(\nself.settings.cust_log_file,\nos.path.basename(self.settings.cust_log_file),\n\"text/plain\",\nint(target_folder_id),\n)\nself.settings.customizer_end_time = datetime.now()\nself.log_header(\n\"Customizer completed in {}\".format(\nself.settings.customizer_end_time - self.settings.customizer_start_time\n)\n)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.consolidate_otds","title":"<code>consolidate_otds()</code>","text":"<p>Consolidate OTDS resources</p> <p>Return: None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def consolidate_otds(self):\n\"\"\"Consolidate OTDS resources\n    Args:\n    Return: None\n    \"\"\"\nself.otds_object.consolidate(self.otcs_settings.resource_name)\nif self.otawp_settings.enabled:  # is AppWorks Platform deployed?\nself.otds_object.consolidate(self.otawp_settings.resource_name)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.customization_run","title":"<code>customization_run()</code>","text":"<p>Central function to initiate the customization</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def customization_run(self):\n\"\"\"Central function to initiate the customization\"\"\"\n# Set Timer for duration calculation\nself.settings.customizer_start_time = (\nself.settings.customizer_end_time\n) = datetime.now()\n# Initialize the OTDS, OTCS and OTPD objects and wait for the\n# pods to be ready. If any of this fails we bail out:\nself.log_header(\"Initialize OTDS\")\nself.otds_object = self.init_otds()\nif not self.otds_object:\nlogger.error(\"Failed to initialize OTDS - exiting...\")\nsys.exit()\n# Establish in-cluster Kubernetes connection\nself.log_header(\"Initialize Kubernetes\")\nif self.k8s_settings.enabled:\nself.k8s_object = self.init_k8s()\nif not self.k8s_object:\nlogger.error(\"Failed to initialize Kubernetes - exiting...\")\nsys.exit()\n# Put Frontend in Maintenance mode to make sure nobody interferes\n# during customization:\nif self.otcs_settings.maintenance_mode:\nself.set_maintenance_mode(True)\nif self.otawp_settings.enabled:  # is AppWorks Platform deployed?\nself.log_header(\"Initialize OTAWP\")\n# Configure required OTDS resources as AppWorks doesn't do this on its own:\nself.init_otawp()\nelse:\nself.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = \"\"\nself.log_header(\"Initialize OTCS backend\")\nself.otcs_backend_object = self.init_otcs(\nself.otcs_settings.hostname_backend,\nint(self.otcs_settings.port_backend),\nself.otcs_settings.partition,\nself.otcs_settings.resource_name,\n)\nif not self.otcs_backend_object:\nlogger.error(\"Failed to initialize OTCS backend - exiting...\")\nsys.exit()\nself.log_header(\"Initialize OTCS frontend\")\nself.otcs_frontend_object = self.init_otcs(\nself.otcs_settings.hostname_frontend,\nint(self.otcs_settings.port_frontend),\nself.otcs_settings.partition,\nself.otcs_settings.resource_name,\n)\nif not self.otcs_frontend_object:\nlogger.error(\"Failed to initialize OTCS frontend - exiting...\")\nsys.exit()\nif self.otac_settings.enabled:  # is Archive Center deployed?\nself.log_header(\"Initialize OTAC\")\nself.otac_object = self.init_otac()\nif not self.otac_object:\nlogger.error(\"Failed to initialize OTAC - exiting...\")\nsys.exit()\nelse:\nself.otac_object = None\nif self.otiv_settings.enabled:  # is Intelligent Viewing deployed?\nself.log_header(\"Initialize OTIV\")\nself.otiv_object = self.init_otiv()\nelse:\nself.otiv_object = None\nif self.otpd_settings.enabled:  # is PowerDocs deployed?\nself.log_header(\"Initialize OTPD\")\nself.otpd_object = self.init_otpd()\nif not self.otpd_object:\nlogger.error(\"Failed to initialize OTPD - exiting...\")\nsys.exit()\nelse:\nself.otpd_object = None\nif (\nself.m365_settings.enabled\nand self.m365_settings.user != \"\"\nand self.m365_settings.password != \"\"\n):  # is M365 enabled?\nself.log_header(\"Initialize MS Graph API\")\n# Initialize the M365 object and connection to M365 Graph API:\nself.m365_object = self.init_m365()\nself.log_header(\"Upload MS Teams App\")\n# Download MS Teams App from OTCS (this has with 23.2 a nasty side-effect\n# of unsetting 2 checkboxes on that config page - we reset these checkboxes\n# with the settings file \"O365Settings.xml\"):\nresponse = self.otcs_frontend_object.download_config_file(\n\"/cs/cs?func=officegroups.DownloadTeamsPackage\",\n\"/tmp/ot.xecm.teams.zip\",\n)\n# this app upload will be done with the user credentials - this is required:\nself.m365_object.authenticate_user(\nself.m365_settings.user, self.m365_settings.password\n)\n# Check if the app is already installed in the apps catalog:\nresponse = self.m365_object.get_teams_apps(\nf\"contains(displayName, '{self.m365_settings.teams_app_name}')\"\n)\nif self.m365_object.exist_result_item(\nresponse, \"displayName\", self.m365_settings.teams_app_name\n):\napp_catalog_id = self.m365_object.get_result_value(\nresponse=response, key=\"id\", index=0\n)  # 0 = Index = first item\napp_catalog_version = self.m365_object.get_result_value(\nresponse=response,\nkey=\"version\",\nindex=0,\nsub_dict_name=\"appDefinitions\",\n)\nlogger.info(\n\"Extended ECM Teams App is already in app catalog with app catalog ID -&gt; %s and version -&gt; %s. Check if we have a newer version to upload...\",\napp_catalog_id,\napp_catalog_version,\n)\napp_upload_version = self.m365_object.extract_version_from_app_manifest(\napp_path=\"/tmp/ot.xecm.teams.zip\"\n)\nif app_catalog_version &lt; app_upload_version:\nlogger.info(\n\"Upgrading Extended ECM Teams App in catalog from version -&gt; %s to version -&gt; %s...\",\napp_catalog_version,\napp_upload_version,\n)\nresponse = self.m365_object.upload_teams_app(\napp_path=\"/tmp/ot.xecm.teams.zip\",\nupdate_existing_app=True,\napp_catalog_id=app_catalog_id,\n)\nelse:\nlogger.info(\n\"No upgrade required. The upload version -&gt; %s is not newer than the version -&gt; %s which is in the M365 app catalog.\",\napp_upload_version,\napp_catalog_version,\n)\nelse:\nlogger.info(\n\"Extended Teams ECM App is not yet in app catalog. Installing as new app...\"\n)\nresponse = self.m365_object.upload_teams_app(\napp_path=\"/tmp/ot.xecm.teams.zip\"\n)\n# logger.info(\"======== Upload Outlook Add-In ============\")\n# # Download MS Outlook Add-In from OTCS:\n# MANIFEST_FILE = \"/tmp/BusinessWorkspace.Manifest.xml\"\n# if not self.otcs_frontend_object.download_config_file(\n#     \"/cs/cs?func=outlookaddin.DownloadManifest\",\n#     MANIFEST_FILE,\n#     \"DeployedContentServer\",\n#     self.otcs_settings.public_url,\n# ):\n#     logger.error(\"Failed to download M365 Outlook Add-In from Extended ECM!\")\n# else:\n#     # THIS IS NOT IMPLEMENTED DUE TO LACK OF M365 GRAPH API SUPPORT!\n#     # Do it manually for now: https://admin.microsoft.com/#/Settings/IntegratedApps\n#     logger.info(\"Successfully downloaded M365 Outlook Add-In from Extended ECM to %s\", MANIFEST_FILE)\n#     self.m365_object.upload_outlook_app(MANIFEST_FILE)\nelse:\nself.m365_object = None\n# self.log_header(\"Initialize Browser Automation...\")\n# We initialize a Selenium based browser automation for\n# those die-hard settings that cannot be automated via REST API\n# nor LLConfig nor Transport:\n# self.browser_automation_object = self.init_browser_automation()\n# if not self.browser_automation_object:\n#     logger.error(\"Failed to initialize Browser Automation - exiting...\")\n#     sys.exit()\nself.log_header(\"Processing Payload\")\ncust_payload_list = []\n# Is uncompressed payload provided?\nif os.path.exists(self.settings.cust_payload):\nlogger.info(\"Found payload file -&gt; %s\", self.settings.cust_payload)\ncust_payload_list.append(self.settings.cust_payload)\n# Is compressed payload provided?\nif os.path.exists(self.settings.cust_payload_gz):\nlogger.info(\n\"Found compressed payload file -&gt; %s\", self.settings.cust_payload_gz\n)\ncust_payload_list.append(self.settings.cust_payload_gz)\n# do we have additional payload as an external file?\nif os.path.exists(self.settings.cust_payload_external):\nfor filename in os.scandir(self.settings.cust_payload_external):\nif filename.is_file() and os.path.getsize(filename) &gt; 0:\nlogger.info(\"Found external payload file -&gt; %s\", filename.path)\ncust_payload_list.append(filename.path)\nelse:\nlogger.info(\n\"No external payload file -&gt; %s\", self.settings.cust_payload_external\n)\nfor cust_payload in cust_payload_list:\n# Open the payload file. If this fails we bail out:\nlogger.info(\"Starting processing of payload -&gt; %s\", cust_payload)\n# Set startTime for duration calculation\nstart_time = datetime.now()\npayload_object = Payload(\npayload_source=cust_payload,\ncustom_settings_dir=self.settings.cust_settings_dir,\nk8s_object=self.k8s_object,\notds_object=self.otds_object,\notac_object=self.otac_object,\notcs_backend_object=self.otcs_backend_object,\notcs_frontend_object=self.otcs_frontend_object,\notcs_restart_callback=self.restart_otcs_service,\notiv_object=self.otiv_object,\nm365_object=self.m365_object,\nbrowser_automation_object=self.browser_automation_object,\nplaceholder_values=self.settings.placeholder_values,  # this dict includes placeholder replacements for the Ressource IDs of OTAWP and OTCS\nlog_header_callback=self.log_header,\nstop_on_error=self.settings.stop_on_error,\naviator_enabled=self.aviator_settings.enabled,\n)\n# Load the payload file and initialize the payload sections:\nif not payload_object.init_payload():\nlogger.error(\n\"Failed to initialize payload -&gt; %s - skipping...\", cust_payload\n)\ncontinue\n# Now process the payload in the defined ordering:\npayload_object.process_payload()\nself.log_header(\"Consolidate OTDS Resources\")\nself.consolidate_otds()\n# Upload payload file for later review to Enterprise Workspace\nself.log_header(\"Upload Payload file to Extended ECM\")\nresponse = self.otcs_backend_object.get_node_from_nickname(\nself.settings.cust_target_folder_nickname\n)\ntarget_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2000  # use Enterprise Workspace as fallback\n# Write YAML file with upadated payload (including IDs, etc.).\n# We need to write to /tmp as initial location is read-only:\npayload_file = os.path.basename(cust_payload)\npayload_file = (\npayload_file[: -len(\".gz.b64\")]\nif payload_file.endswith(\".gz.b64\")\nelse payload_file\n)\ncust_payload = \"/tmp/\" + payload_file\nwith open(cust_payload, \"w\", encoding=\"utf-8\") as file:\nyaml.dump(payload_object.get_payload(), file)\n# Check if the payload file has been uploaded before.\n# This can happen if we re-run the python container.\n# In this case we add a version to the existing document:\nresponse = self.otcs_backend_object.get_node_by_parent_and_name(\nint(target_folder_id), os.path.basename(cust_payload)\n)\ntarget_document_id = self.otcs_backend_object.get_result_value(\nresponse, \"id\"\n)\nif target_document_id:\nresponse = self.otcs_backend_object.add_document_version(\nint(target_document_id),\ncust_payload,\nos.path.basename(cust_payload),\n\"text/plain\",\n\"Updated payload file after re-run of customization\",\n)\nelse:\nresponse = self.otcs_backend_object.upload_file_to_parent(\ncust_payload,\nos.path.basename(cust_payload),\n\"text/plain\",\nint(target_folder_id),\n)\nduration = datetime.now() - start_time\nself.log_header(\n\"Customizer completed processing of payload -&gt; {} in {}\".format(\ncust_payload,\nduration,\n)\n)\nif self.otcs_settings.maintenance_mode:\nself.set_maintenance_mode(False)\n# Restart AppWorksPlatform pod if it is deployed (to make settings effective):\nif self.otawp_settings.enabled:  # is AppWorks Platform deployed?\notawp_resource = self.otds_object.get_resource(\nself.otawp_settings.resource_name\n)\nif (\nnot \"allowImpersonation\" in otawp_resource\nor not otawp_resource[\"allowImpersonation\"]\n):\n# Allow impersonation for all users:\nlogger.warning(\n\"OTAWP impersonation is not correct in OTDS before OTAWP pod restart!\"\n)\nelse:\nlogger.info(\n\"OTAWP impersonation is correct in OTDS before OTAWP pod restart!\"\n)\nlogger.info(\"Restart OTAWP pod...\")\nself.restart_otawp_pod()\n# For some reason we need to double-check that the impersonation for OTAWP has been set correctly\n# and if not set it again:\notawp_resource = self.otds_object.get_resource(\nself.otawp_settings.resource_name\n)\nif (\nnot \"allowImpersonation\" in otawp_resource\nor not otawp_resource[\"allowImpersonation\"]\n):\n# Allow impersonation for all users:\nlogger.warning(\n\"OTAWP impersonation is not correct in OTDS - set it once more...\"\n)\nself.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n# Upload log file for later review to \"Deployment\" folder in \"Administration\" folder\nif os.path.exists(self.settings.cust_log_file):\nself.log_header(\"Upload log file to Extended ECM\")\n#            logger.info(\"========== Upload log file to Extended ECM =============\")\nresponse = self.otcs_backend_object.get_node_from_nickname(\nself.settings.cust_target_folder_nickname\n)\ntarget_folder_id = self.otcs_backend_object.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2000  # use Enterprise Workspace as fallback\n# Check if the log file has been uploaded before.\n# This can happen if we re-run the python container:\n# In this case we add a version to the existing document:\nresponse = self.otcs_backend_object.get_node_by_parent_and_name(\nint(target_folder_id), os.path.basename(self.settings.cust_log_file)\n)\ntarget_document_id = self.otcs_backend_object.get_result_value(\nresponse, \"id\"\n)\nif target_document_id:\nresponse = self.otcs_backend_object.add_document_version(\nint(target_document_id),\nself.settings.cust_log_file,\nos.path.basename(self.settings.cust_log_file),\n\"text/plain\",\n\"Updated Python Log after re-run of customization\",\n)\nelse:\nresponse = self.otcs_backend_object.upload_file_to_parent(\nself.settings.cust_log_file,\nos.path.basename(self.settings.cust_log_file),\n\"text/plain\",\nint(target_folder_id),\n)\nself.settings.customizer_end_time = datetime.now()\nself.log_header(\n\"Customizer completed in {}\".format(\nself.settings.customizer_end_time - self.settings.customizer_start_time\n)\n)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.import_powerdocs_configuration","title":"<code>import_powerdocs_configuration(otpd_object)</code>","text":"<p>Import a database export (zip file) into the PowerDocs database</p> <p>Parameters:</p> Name Type Description Default <code>otpd_object</code> <code>object</code> <p>PowerDocs object</p> required Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def import_powerdocs_configuration(self, otpd_object: OTPD):\n\"\"\"Import a database export (zip file) into the PowerDocs database\n    Args:\n        otpd_object (object): PowerDocs object\n    \"\"\"\nif self.otpd_settings.db_importfile.startswith(\"http\"):\n# Download file from remote location specified by the OTPD_DBIMPORTFILE\n# this must be a public place without authentication:\nlogger.info(\n\"Download PowerDocs database file from URL -&gt; %s\",\nself.otpd_settings.db_importfile,\n)\ntry:\npackage = requests.get(self.otpd_settings.db_importfile, timeout=60)\npackage.raise_for_status()\nlogger.info(\n\"Successfully downloaded PowerDocs database file -&gt; %s; status code -&gt; %s\",\nself.otpd_settings.db_importfile,\npackage.status_code,\n)\nfilename = \"/tmp/otpd_db_import.zip\"\nwith open(filename, mode=\"wb\") as localfile:\nlocalfile.write(package.content)\nlogger.info(\n\"Starting import on %s://%s:%s of %s\",\nself.otpd_settings.protocol,\nself.otpd_settings.hostname,\nself.otpd_settings.port,\nself.otpd_settings.db_importfile,\n)\nresponse = otpd_object.import_database(filename=filename)\nlogger.info(\"Response -&gt; %s\", response)\nexcept requests.exceptions.HTTPError as err:\nlogger.error(\"Request error -&gt; %s\", err)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_k8s","title":"<code>init_k8s()</code>","text":"<p>Initialize the Kubernetes object we use to talk to the Kubernetes API.</p> <p>Returns:</p> Name Type Description <code>K8s</code> <code>K8s</code> <p>K8s object</p> Side effects <p>The global variables otcs_replicas_frontend and otcs_replicas_backend are initialized</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_k8s(self) -&gt; K8s:\n\"\"\"Initialize the Kubernetes object we use to talk to the Kubernetes API.\n    Args:\n        None\n    Returns:\n        K8s: K8s object\n    Side effects:\n        The global variables otcs_replicas_frontend and otcs_replicas_backend are initialized\n    \"\"\"\nlogger.info(\"Connection parameters Kubernetes (K8s):\")\nlogger.info(\"K8s inCluster -&gt; %s\", self.k8s_settings.in_cluster)\nlogger.info(\"K8s namespace -&gt; %s\", self.k8s_settings.namespace)\nlogger.info(\n\"K8s kubeconfig file -&gt; %s\",\nself.k8s_settings.kubeconfig_file,\n)\nk8s_object = K8s(\nin_cluster=self.k8s_settings.in_cluster,\nkubeconfig_file=self.k8s_settings.kubeconfig_file,\nnamespace=self.k8s_settings.namespace,\n)\nif k8s_object:\nlogger.info(\"Kubernetes API is ready now.\")\nelse:\nlogger.error(\"Cannot establish connection to Kubernetes.\")\n# Get number of replicas for frontend:\notcs_frontend_scale = k8s_object.get_stateful_set_scale(\nself.otcs_settings.k8s_statefulset_frontend\n)\nif not otcs_frontend_scale:\nlogger.error(\n\"Cannot find Kubernetes Stateful Set for OTCS Frontends -&gt; %s\",\nself.otcs_settings.k8s_statefulset_frontend,\n)\nsys.exit()\nself.otcs_settings.replicas_frontend = otcs_frontend_scale.spec.replicas  # type: ignore\nlogger.info(\n\"Stateful Set -&gt; %s has -&gt; %s replicas\",\nself.otcs_settings.k8s_statefulset_frontend,\nself.otcs_settings.replicas_frontend,\n)\n# Get number of replicas for backend:\notcs_backend_scale = k8s_object.get_stateful_set_scale(\nself.otcs_settings.k8s_statefulset_backend\n)\nif not otcs_backend_scale:\nlogger.error(\n\"Cannot find Kubernetes Stateful Set for OTCS Backends -&gt; %s\",\nself.otcs_settings.k8s_statefulset_backend,\n)\nsys.exit()\nself.otcs_settings.replicas_backend = otcs_backend_scale.spec.replicas  # type: ignore\nlogger.info(\n\"Stateful Set -&gt; %s has -&gt; %s replicas\",\nself.otcs_settings.k8s_statefulset_backend,\nself.otcs_settings.replicas_backend,\n)\nreturn k8s_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_m365","title":"<code>init_m365()</code>","text":"<p>Initialize the M365 object we use to talk to the Microsoft Graph API.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>M365</code> <p>M365 object or None if the object couldn't be created or     the authentication fails.</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_m365(self) -&gt; M365:\n\"\"\"Initialize the M365 object we use to talk to the Microsoft Graph API.\n    Args:\n        None\n    Returns:\n        object: M365 object or None if the object couldn't be created or\n                the authentication fails.\n    \"\"\"\nlogger.info(\n\"Microsoft 365 Tenant ID             = %s\", self.m365_settings.tenant_id\n)\nlogger.info(\n\"Microsoft 365 Client ID             = %s\", self.m365_settings.client_id\n)\nlogger.debug(\n\"Microsoft 365 Client Secret         = %s\", self.m365_settings.client_secret\n)\nlogger.info(\n\"Microsoft 365 User                  = %s\",\n(\nself.m365_settings.user\nif self.m365_settings.user != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\nlogger.debug(\n\"Microsoft 365 Password              = %s\",\n(\nself.m365_settings.password\nif self.m365_settings.password != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\nlogger.info(\n\"Microsoft 365 Domain                = %s\", self.m365_settings.domain\n)\nlogger.info(\n\"Microsoft 365 Default License SKU   = %s\", self.m365_settings.sku_id\n)\nlogger.info(\n\"Microsoft 365 Teams App             = %s\",\nself.m365_settings.teams_app_name,\n)\nm365_object = M365(\ntenant_id=self.m365_settings.tenant_id,\nclient_id=self.m365_settings.client_id,\nclient_secret=self.m365_settings.client_secret,\ndomain=self.m365_settings.domain,\nsku_id=self.m365_settings.sku_id,\nteams_app_name=self.m365_settings.teams_app_name,\n)\nif m365_object and m365_object.authenticate():\nlogger.info(\"Connected to Microsoft Graph API.\")\nreturn m365_object\nelse:\nlogger.error(\"Failed to connect to Microsoft Graph API.\")\nreturn m365_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otac","title":"<code>init_otac()</code>","text":"<p>Initialize the OTAC object and parameters.   Configure the Archive Server as a known server   if environment variable OTAC_KNOWN_SERVER is set.</p> Return <p>OTAC object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otac(self) -&gt; OTAC:\n\"\"\"Initialize the OTAC object and parameters.\n      Configure the Archive Server as a known server\n      if environment variable OTAC_KNOWN_SERVER is set.\n    Args: None\n    Return:\n        OTAC object\n    \"\"\"\nlogger.info(\"Connection parameters OTAC:\")\nlogger.info(\"OTAC Protocol          = %s\", self.otac_settings.protocol)\nlogger.info(\"OTAC Hostname          = %s\", self.otac_settings.hostname)\nlogger.info(\"OTAC Public URL        = %s\", self.otac_settings.public_url)\nlogger.info(\"OTAC Port              = %s\", str(self.otac_settings.port))\nlogger.info(\"OTAC Admin User        = %s\", self.otac_settings.admin)\nlogger.debug(\"OTAC Admin Password   = %s\", self.otac_settings.password)\nlogger.info(\n\"OTAC Known Server      = %s\",\n(\nself.otac_settings.known_server\nif self.otac_settings.known_server != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\notac_object = OTAC(\nself.otac_settings.protocol,\nself.otac_settings.hostname,\nint(self.otac_settings.port),\nself.otac_settings.admin,\nself.otac_settings.password,\nself.otds_settings.username,\nself.otds_settings.password,\n)\n# is there a known server configured for Archive Center (to sync content with)\nif otac_object and self.otac_settings.known_server != \"\":\n# wait until the OTAC pod is in ready state\nlogger.info(\"Waiting for Archive Center to become ready...\")\nself.k8s_object.wait_pod_condition(self.otac_settings.k8s_pod_name, \"Ready\")\nlogger.info(\"Configure known host for Archive Center...\")\nresponse = otac_object.exec_command(\nf\"cf_create_host {self.otac_settings.known_server} 0 /archive 8080 8090\"\n)\nif not response or not response.ok:\nlogger.error(\"Failed to configure known host for Archive Center!\")\nlogger.info(\"Configure host alias for Archive Center...\")\nresponse = otac_object.exec_command(\nf\"cf_set_variable MY_HOST_ALIASES {self.otac_settings.k8s_pod_name},{self.otac_settings.public_url},otac DS\"\n)\nif not response or not response.ok:\nlogger.error(\"Failed to configure host alias for Archive Center!\")\n# Restart the spawner in Archive Center:\nlogger.info(\"Restart Archive Center Spawner...\")\nself.restart_otac_service()\nelse:\nlogger.info(\n\"Skip configuration of known host for Archive Center (OTAC_KNOWN_SERVER is not set).\"\n)\nreturn otac_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otawp","title":"<code>init_otawp()</code>","text":"<p>Initialize OTDS for Appworks Platform</p> <p>Return: None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otawp(self):\n\"\"\"Initialize OTDS for Appworks Platform\n    Args:\n    Return: None\n    \"\"\"\nlogger.info(\"Connection parameters OTAWP:\")\nlogger.info(\"OTAWP Enabled          = %s\", str(self.otawp_settings.enabled))\nlogger.info(\"OTAWP Resource         = %s\", self.otawp_settings.resource_name)\nlogger.info(\"OTAWP Access Role      = %s\", self.otawp_settings.access_role_name)\nlogger.info(\"OTAWP Admin User       = %s\", self.otawp_settings.admin)\nlogger.debug(\"OTAWP Password         = %s\", self.otawp_settings.password)\nlogger.info(\"OTAWP K8s Stateful Set = %s\", self.otawp_settings.k8s_statefulset)\nlogger.info(\"OTAWP K8s Config Map   = %s\", self.otawp_settings.k8s_configmap)\nlogger.info(\n\"Wait for OTCS to create its OTDS resource with name -&gt; %s...\",\nself.otcs_settings.resource_name,\n)\n# Loop to wait for OTCS to create its OTDS resource\n# (we need it to update the AppWorks K8s Config Map):\notcs_resource = self.otds_object.get_resource(self.otcs_settings.resource_name)\nwhile otcs_resource is None:\nlogger.warning(\n\"OTDS resource for Content Server with name -&gt; %s does not exist yet. Waiting...\",\nself.otcs_settings.resource_name,\n)\ntime.sleep(30)\notcs_resource = self.otds_object.get_resource(\nself.otcs_settings.resource_name\n)\notcs_resource_id = otcs_resource[\"resourceID\"]\nlogger.info(\"OTDS resource ID for Content Server -&gt; %s\", otcs_resource_id)\n# make sure code is idempotent and only try to add ressource if it doesn't exist already:\nawp_resource = self.otds_object.get_resource(self.otawp_settings.resource_name)\nif not awp_resource:\nlogger.info(\n\"OTDS resource -&gt; %s for AppWorks Platform does not yet exist. Creating...\",\nself.otawp_settings.resource_name,\n)\n# Create a Python dict with the special payload we need for AppWorks:\nadditional_payload = {}\nadditional_payload[\"connectorid\"] = \"rest\"\nadditional_payload[\"resourceType\"] = \"rest\"\nuser_attribute_mapping = [\n{\n\"sourceAttr\": [\"oTExternalID1\"],\n\"destAttr\": \"__NAME__\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayname\"],\n\"destAttr\": \"DisplayName\",\n\"mappingFormat\": \"%s\",\n},\n{\"sourceAttr\": [\"mail\"], \"destAttr\": \"Email\", \"mappingFormat\": \"%s\"},\n{\n\"sourceAttr\": [\"oTTelephoneNumber\"],\n\"destAttr\": \"Telephone\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTMobile\"],\n\"destAttr\": \"Mobile\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n\"destAttr\": \"Fax\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTStreetAddress,l,st,postalCode,c\"],\n\"destAttr\": \"Address\",\n\"mappingFormat\": \"%s%n%s %s %s%n%s\",\n},\n{\n\"sourceAttr\": [\"oTCompany\"],\n\"destAttr\": \"Company\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"ds-pwp-account-disabled\"],\n\"destAttr\": \"AccountDisabled\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTExtraAttr9\"],\n\"destAttr\": \"IsServiceAccount\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"custom:proxyConfiguration\"],\n\"destAttr\": \"ProxyConfiguration\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"c\"],\n\"destAttr\": \"Identity-CountryOrRegion\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"gender\"],\n\"destAttr\": \"Identity-Gender\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayName\"],\n\"destAttr\": \"Identity-DisplayName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTStreetAddress\"],\n\"destAttr\": \"Identity-Address\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"l\"],\n\"destAttr\": \"Identity-City\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"mail\"],\n\"destAttr\": \"Identity-Email\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"givenName\"],\n\"destAttr\": \"Identity-FirstName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"sn\"],\n\"destAttr\": \"Identity-LastName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"initials\"],\n\"destAttr\": \"Identity-MiddleNames\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTMobile\"],\n\"destAttr\": \"Identity-Mobile\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"postalCode\"],\n\"destAttr\": \"Identity-PostalCode\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"st\"],\n\"destAttr\": \"Identity-StateOrProvince\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"title\"],\n\"destAttr\": \"Identity-title\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"physicalDeliveryOfficeName\"],\n\"destAttr\": \"Identity-physicalDeliveryOfficeName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTFacsimileTelephoneNumber\"],\n\"destAttr\": \"Identity-oTFacsimileTelephoneNumber\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"notes\"],\n\"destAttr\": \"Identity-notes\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTCompany\"],\n\"destAttr\": \"Identity-oTCompany\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTDepartment\"],\n\"destAttr\": \"Identity-oTDepartment\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"birthDate\"],\n\"destAttr\": \"Identity-Birthday\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"cn\"],\n\"destAttr\": \"Identity-UserName\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"Description\"],\n\"destAttr\": \"Identity-UserDescription\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"oTTelephoneNumber\"],\n\"destAttr\": \"Identity-Phone\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayName\"],\n\"destAttr\": \"Identity-IdentityDisplayName\",\n\"mappingFormat\": \"%s\",\n},\n]\nadditional_payload[\"userAttributeMapping\"] = user_attribute_mapping\ngroup_attribute_mapping = [\n{\n\"sourceAttr\": [\"cn\"],\n\"destAttr\": \"__NAME__\",\n\"mappingFormat\": '%js:function format(name) { return name.replace(/&amp;/g,\"-and-\"); }',\n},\n{\n\"sourceAttr\": [\"description\"],\n\"destAttr\": \"Description\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"description\"],\n\"destAttr\": \"Identity-Description\",\n\"mappingFormat\": \"%s\",\n},\n{\n\"sourceAttr\": [\"displayName\"],\n\"destAttr\": \"Identity-DisplayName\",\n\"mappingFormat\": \"%s\",\n},\n]\nadditional_payload[\"groupAttributeMapping\"] = group_attribute_mapping\nadditional_payload[\"connectorName\"] = \"REST (Generic)\"\nadditional_payload[\"pcCreatePermissionAllowed\"] = \"true\"\nadditional_payload[\"pcModifyPermissionAllowed\"] = \"true\"\nadditional_payload[\"pcDeletePermissionAllowed\"] = \"false\"\nadditional_payload[\"connectionParamInfo\"] = [\n{\n\"name\": \"fBaseURL\",\n\"value\": \"http://appworks:8080/home/system/app/otdspush\",\n},\n{\"name\": \"fUsername\", \"value\": self.otawp_settings.admin},\n{\"name\": \"fPassword\", \"value\": self.otawp_settings.password},\n]\nawp_resource = self.otds_object.add_resource(\nself.otawp_settings.resource_name,\n\"AppWorks Platform\",\n\"AppWorks Platform\",\nadditional_payload,\n)\nelse:\nlogger.info(\n\"OTDS resource -&gt; %s for AppWorks Platform does already exist.\",\nself.otawp_settings.resource_name,\n)\nawp_resource_id = awp_resource[\"resourceID\"]\nlogger.info(\"OTDS resource ID for AppWorks Platform -&gt; %s\", awp_resource_id)\nself.settings.placeholder_values[\"OTAWP_RESOURCE_ID\"] = str(awp_resource_id)\nlogger.debug(\n\"Placeholder values after OTAWP init = %s\", self.settings.placeholder_values\n)\nlogger.info(\"Update AppWorks Kubernetes Config Map with OTDS resource IDs...\")\nconfig_map = self.k8s_object.get_config_map(self.otawp_settings.k8s_configmap)\nif not config_map:\nlogger.error(\n\"Failed to retrieve AppWorks Kubernetes Config Map -&gt; %s\",\nself.otawp_settings.k8s_configmap,\n)\nelse:\nsolution = yaml.safe_load(config_map.data[\"solution.yaml\"])  # type: ignore\n# Change values as required\nsolution[\"platform\"][\"organizations\"][\"system\"][\"otds\"][\n\"resourceId\"\n] = awp_resource_id\nsolution[\"platform\"][\"content\"][\"ContentServer\"][\n\"contentServerUrl\"\n] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cs/cs\"\nsolution[\"platform\"][\"content\"][\"ContentServer\"][\n\"contentServerSupportDirectoryUrl\"\n] = f\"{self.otcs_settings.public_protocol}://{self.otcs_settings.public_url}/cssupport\"\nsolution[\"platform\"][\"content\"][\"ContentServer\"][\n\"otdsResourceId\"\n] = otcs_resource_id\nsolution[\"platform\"][\"authenticators\"][\"OTDS_auth\"][\"publicLoginUrl\"] = (\nself.otds_settings.public_protocol\n+ \"://\"\n+ self.otds_settings.public_url\n+ \"/otdsws/login\"\n)\nsolution[\"platform\"][\"security\"][\"contentSecurityPolicy\"] = (\n\"frame-ancestors 'self' \"\n+ self.otcs_settings.public_protocol\n+ \"://\"\n+ self.otcs_settings.public_url\n)\ndata = {\"solution.yaml\": yaml.dump(solution)}\nresult = self.k8s_object.replace_config_map(\nself.otawp_settings.k8s_configmap, data\n)\nif result:\nlogger.info(\"Successfully updated AppWorks Solution YAML.\")\nelse:\nlogger.error(\"Failed to update AppWorks Solution YAML.\")\nlogger.debug(\"Solution YAML for AppWorks -&gt; %s\", solution)\nlogger.info(\"Scale AppWorks Kubernetes Stateful Set to 1...\")\nself.k8s_object.scale_stateful_set(\nsts_name=self.otawp_settings.k8s_statefulset, scale=1\n)\n# Add the OTCS Admin user to the AppWorks Access Role in OTDS\nself.otds_object.add_user_to_access_role(\n\"Access to \" + self.otawp_settings.resource_name, \"otadmin@otds.admin\"\n)\n# Loop to wait for OTCS to create its OTDS user partition:\notcs_partition = self.otds_object.get_partition(\nself.otcs_settings.partition, show_error=False\n)\nwhile otcs_partition is None:\nlogger.warning(\n\"OTDS user partition for Content Server with name -&gt; %s does not exist yet. Waiting...\",\nself.otcs_settings.partition,\n)\ntime.sleep(30)\notcs_partition = self.otds_object.get_partition(\nself.otcs_settings.partition, show_error=False\n)\n# Add the OTDS user partition for OTCS to the AppWorks Platform Access Role in OTDS.\n# This will effectvely sync all OTCS users with AppWorks Platform:\nself.otds_object.add_partition_to_access_role(\nself.otawp_settings.access_role_name, self.otcs_settings.partition\n)\n# Add the OTDS admin partition to the AppWorks Platform Access Role in OTDS.\nself.otds_object.add_partition_to_access_role(\nself.otawp_settings.access_role_name, self.otds_settings.admin_partition\n)\n# Set Group inclusion for Access Role for OTAWP to \"True\":\nself.otds_object.update_access_role_attributes(\nself.otawp_settings.access_role_name,\n[{\"name\": \"pushAllGroups\", \"values\": [\"True\"]}],\n)\n# Add ResourceID User to OTDSAdmin to allow push\nself.otds_object.add_user_to_group(\nuser=str(awp_resource_id) + \"@otds.admin\", group=\"otdsadmins@otds.admin\"\n)\n# Allow impersonation for all users:\nself.otds_object.impersonate_resource(self.otawp_settings.resource_name)\n# Add SPS license for OTAWP\n# check if the license file exists, otherwise skip for versions pre 24.1\nif os.path.isfile(self.otawp_settings.license_file):\nlogger.info(\n\"OTAWP license file (%s) found, assiging to ressource %s\",\nself.otawp_settings.license_file,\nself.otawp_settings.resource_name,\n)\notawp_license = self.otds_object.add_license_to_resource(\nself.otawp_settings.license_file,\nself.otawp_settings.product_name,\nself.otawp_settings.product_description,\nawp_resource[\"resourceID\"],\n)\nif not otawp_license:\nlogger.error(\n\"Couldn't apply license -&gt; %s for product -&gt; %s.\",\nself.otawp_settings.license_file,\nself.otawp_settings.product_name,\n)\n# Assign license to Content Server Members Partiton and otds.admin\nfor partition_name in [\"otds.admin\", self.otcs_settings.partition]:\nif self.otds_object.is_partition_licensed(\npartition_name=partition_name,\nresource_id=awp_resource[\"resourceID\"],\nlicense_feature=\"USERS\",\nlicense_name=self.otawp_settings.product_name,\n):\nlogger.info(\n\"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\npartition_name,\nself.otawp_settings.product_name,\n\"USERS\",\n)\nelse:\nassigned_license = self.otds_object.assign_partition_to_license(\npartition_name,\nawp_resource[\"resourceID\"],\n\"USERS\",\nself.otawp_settings.product_name,\n)\nif not assigned_license:\nlogger.error(\n\"Partition -&gt; %s could not be assigned to license -&gt; %s (%s)\",\npartition_name,\nself.otawp_settings.product_name,\n\"USERS\",\n)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otcs","title":"<code>init_otcs(hostname, port, partition_name, resource_name)</code>","text":"<p>Initialize the OTCS class and parameters and authenticate at OTCS once it is ready.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>OTCS hostname</p> required <code>port</code> <code>int</code> <p>port number of OTCS</p> required <code>partition_name</code> <code>str</code> <p>name of OTDS Partition for Extended ECM users</p> required <code>resource_name</code> <code>str</code> <p>name of OTDS resource for Extended ECM</p> required <p>Returns:</p> Name Type Description <code>OTCS</code> <code>OTCS</code> <p>OTCS object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otcs(\nself,\nhostname: str,\nport: int,\npartition_name: str,\nresource_name: str,\n) -&gt; OTCS:\n\"\"\"Initialize the OTCS class and parameters and authenticate at OTCS once it is ready.\n    Args:\n        hostname (str): OTCS hostname\n        port (int): port number of OTCS\n        partition_name (str): name of OTDS Partition for Extended ECM users\n        resource_name (str): name of OTDS resource for Extended ECM\n    Returns:\n        OTCS: OTCS object\n    \"\"\"\nlogger.info(\"Connection parameters OTCS (Extended ECM):\")\nlogger.info(\"OTCS Protocol              = %s\", self.otcs_settings.protocol)\nlogger.info(\n\"OTCS Public Protocol       = %s\", self.otcs_settings.public_protocol\n)\nlogger.info(\"OTCS Hostname              = %s\", hostname)\nlogger.info(\"OTCS Public URL            = %s\", self.otcs_settings.public_url)\nlogger.info(\"OTCS Port                  = %s\", str(port))\nlogger.info(\"OTCS Admin User            = %s\", self.otcs_settings.admin)\nlogger.debug(\"OTCS Admin Password        = %s\", self.otcs_settings.password)\nlogger.info(\"OTCS User Partition        = %s\", partition_name)\nlogger.info(\"OTCS Resource Name         = %s\", resource_name)\nlogger.info(\n\"OTCS User Default License  = %s\", self.otcs_settings.license_feature\n)\nlogger.info(\n\"OTCS K8s Frontend Pods     = %s\",\nself.otcs_settings.k8s_statefulset_frontend,\n)\nlogger.info(\n\"OTCS K8s Backend Pods      = %s\",\nself.otcs_settings.k8s_statefulset_backend,\n)\nlogger.debug(\"Checking if OTCS object has already been initialized\")\notds_ticket = (\nself.otds_object.cookie()[\"OTDSTicket\"] if self.otds_object else None\n)\notcs_object = OTCS(\nself.otcs_settings.protocol,\nhostname,\nint(port),\nself.otcs_settings.public_protocol + \"://\" + self.otcs_settings.public_url,\nself.otcs_settings.admin,\nself.otcs_settings.password,\npartition_name,\nresource_name,\notds_ticket=otds_ticket,\n)\n# It is important to wait for OTCS to be configured - otherwise we\n# may interfere with the OTCS container automation and run into errors\nlogger.info(\"Wait for OTCS to be configured...\")\notcs_configured = otcs_object.is_configured()\nwhile not otcs_configured:\nlogger.warning(\"OTCS is not configured yet. Waiting 30 seconds...\")\ntime.sleep(30)\notcs_configured = otcs_object.is_configured()\nlogger.info(\"OTCS is configured now.\")\nlogger.info(\"Authenticating to OTCS...\")\notcs_cookie = otcs_object.authenticate()\nwhile otcs_cookie is None:\nlogger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\ntime.sleep(30)\notcs_cookie = otcs_object.authenticate()\nlogger.info(\"OTCS is ready now.\")\nif self.otcs_settings.update_admin_user:\n# Set first name and last name of Admin user (ID = 1000):\notcs_object.update_user(1000, field=\"first_name\", value=\"Terrarium\")\notcs_object.update_user(1000, field=\"last_name\", value=\"Admin\")\nif \"OTCS_RESSOURCE_ID\" not in self.settings.placeholder_values:\nself.settings.placeholder_values[\n\"OTCS_RESSOURCE_ID\"\n] = self.otds_object.get_resource(self.otcs_settings.resource_name)[\n\"resourceID\"\n]\nlogger.debug(\n\"Placeholder values after OTCS init = %s\",\nself.settings.placeholder_values,\n)\nif self.otawp_settings.enabled:\notcs_resource = self.otds_object.get_resource(\nself.otcs_settings.resource_name\n)\notcs_resource[\n\"logoutURL\"\n] = f\"{self.otawp_settings.public_protocol}://{self.otawp_settings.public_url}/home/system/wcp/sso/sso_logout.htm\"\notcs_resource[\"logoutMethod\"] = \"GET\"\nself.otds_object.update_resource(name=\"cs\", resource=otcs_resource)\n# Allow impersonation of the resource for all users:\nself.otds_object.impersonate_resource(resource_name)\nreturn otcs_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otds","title":"<code>init_otds()</code>","text":"<p>Initialize the OTDS object and parameters and authenticate at OTDS once it is ready.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>OTDS</code> <p>OTDS object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otds(self) -&gt; OTDS:\n\"\"\"Initialize the OTDS object and parameters and authenticate at OTDS once it is ready.\n    Args:\n        None\n    Returns:\n        object: OTDS object\n    \"\"\"\nlogger.info(\"Connection parameters OTDS:\")\nlogger.info(\"OTDS Protocol          = %s\", self.otds_settings.protocol)\nlogger.info(\"OTDS Public Protocol   = %s\", self.otds_settings.public_protocol)\nlogger.info(\"OTDS Hostname          = %s\", self.otds_settings.hostname)\nlogger.info(\"OTDS Public URL        = %s\", self.otds_settings.public_url)\nlogger.info(\"OTDS Port              = %s\", str(self.otds_settings.port))\nlogger.info(\"OTDS Admin User        = %s\", self.otds_settings.username)\nlogger.debug(\"OTDS Admin Password    = %s\", self.otds_settings.password)\nlogger.debug(\"OTDS Ticket            = %s\", self.otds_settings.otds_ticket)\nlogger.info(\"OTDS Admin Partition   = %s\", self.otds_settings.admin_partition)\notds_object = OTDS(\nprotocol=self.otds_settings.protocol,\nhostname=self.otds_settings.hostname,\nport=self.otds_settings.port,\nusername=self.otds_settings.username,\npassword=self.otds_settings.password,\notds_ticket=self.otds_settings.otds_ticket,\n)\nlogger.info(\"Authenticating to OTDS...\")\notds_cookie = otds_object.authenticate()\nwhile otds_cookie is None:\nlogger.warning(\"Waiting 30 seconds for OTDS to become ready...\")\ntime.sleep(30)\notds_cookie = otds_object.authenticate()\nlogger.info(\"OTDS is ready now.\")\nlogger.info(\"Enable OTDS audit...\")\nif self.otds_settings.enable_audit:\notds_object.enable_audit()\nif self.otds_settings.disable_password_policy:\nlogger.info(\"Disable OTDS password expiry...\")\n# Setting the value to 0 disables password expiry.\n# The default is 90 days and we may have Terrarium\n# instances that are running longer than that. This\n# avoids problems with customerizer re-runs of\n# instances that are &gt; 90 days old.\notds_object.update_password_policy(\nupdate_values={\"passwordMaximumDuration\": 0}\n)\nreturn otds_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otiv","title":"<code>init_otiv()</code>","text":"<p>Initialize the OTIV (Intelligent Viewing) object and its OTDS settings.</p> <p>Returns:</p> Name Type Description <code>objects</code> <code>OTIV | None</code> <p>OTIV object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otiv(self) -&gt; OTIV | None:\n\"\"\"Initialize the OTIV (Intelligent Viewing) object and its OTDS settings.\n    Args:\n    Returns:\n        objects: OTIV object\n    \"\"\"\nlogger.info(\"Parameters for OTIV (Intelligent Viewing):\")\nlogger.info(\"OTDS Resource Name       = %s\", self.otiv_settings.resource_name)\nlogger.info(\"OTIV License File        = %s\", self.otiv_settings.license_file)\nlogger.info(\"OTIV Product Name        = %s\", self.otiv_settings.product_name)\nlogger.info(\n\"OTIV Product Description = %s\", self.otiv_settings.product_description\n)\nlogger.info(\"OTIV License Feature     = %s\", self.otiv_settings.license_feature)\notiv_object = OTIV(\nresource_name=self.otiv_settings.resource_name,\nproduct_name=self.otiv_settings.product_name,\nproduct_description=self.otiv_settings.product_description,\nlicense_file=self.otiv_settings.license_file,\ndefault_license=self.otiv_settings.license_feature,\n)\notiv_resource = self.otds_object.get_resource(self.otiv_settings.resource_name)\nwhile otiv_resource is None:\nlogger.warning(\n\"OTDS Resource -&gt; %s for Intelligent Viewing not found. OTIV may not be ready. Wait 30 sec...\",\nself.otiv_settings.resource_name,\n)\ntime.sleep(30)\notiv_resource = self.otds_object.get_resource(\nself.otiv_settings.resource_name\n)\notiv_license = self.otds_object.add_license_to_resource(\nself.otiv_settings.license_file,\nself.otiv_settings.product_name,\nself.otiv_settings.product_description,\notiv_resource[\"resourceID\"],\n)\nif not otiv_license:\nlogger.info(\n\"Couldn't apply license -&gt; %s for product -&gt; %s. Intelligent Viewing may not be deployed!\",\nself.otiv_settings.license_file,\nself.otiv_settings.product_name,\n)\nreturn None\nreturn otiv_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.init_otpd","title":"<code>init_otpd()</code>","text":"<p>Initialize the OTPD (PowerDocs) object and parameters.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>OTPD</code> <p>OTPD (PowerDocs) object</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def init_otpd(self) -&gt; OTPD:\n\"\"\"Initialize the OTPD (PowerDocs) object and parameters.\n    Args:\n        None\n    Returns:\n        object: OTPD (PowerDocs) object\n    \"\"\"\nlogger.info(\"Connection parameters OTPD (PowerDocs):\")\nlogger.info(\"OTPD Protocol             = %s\", self.otpd_settings.protocol)\nlogger.info(\"OTPD Hostname             = %s\", self.otpd_settings.hostname)\nlogger.info(\"OTPD Port                 = %s\", str(self.otpd_settings.port))\nlogger.info(\"OTPD API User             = %s\", self.otpd_settings.user)\nlogger.info(\"OTPD Tenant               = %s\", self.otpd_settings.tenant)\nlogger.info(\n\"OTPD Database Import File = %s\",\n(\nself.otpd_settings.db_importfile\nif self.otpd_settings.db_importfile != \"\"\nelse \"&lt;not configured&gt;\"\n),\n)\nlogger.info(\"OTPD K8s Pod Name         = %s\", self.otpd_settings.k8s_pod_name)\notpd_object = OTPD(\nself.otpd_settings.protocol,\nself.otpd_settings.hostname,\nint(self.otpd_settings.port),\nself.otpd_settings.user,\nself.otpd_settings.password,\n)\n# wait until the OTPD pod is in ready state\nself.k8s_object.wait_pod_condition(self.otpd_settings.k8s_pod_name, \"Ready\")\n# We have a race condition here. Even if the pod is ready\n# it may not yet have fully initialized its database.\n# Then the \"apply_setting()\" calls below may fail with\n# an error. This should be improved in the future. For now\n# we just wait a minute hoping that the DB is initialized then.\nlogger.info(\"Wait some time for PowerDocs database to be initialized...\")\ntime.sleep(60)\nlogger.info(\"Configure some basic PowerDocs settings...\")\n# Fix settings for local Kubernetes deployments.\n# Unclear why this is not the default.\nif otpd_object:\notpd_object.apply_setting(\"LocalOtdsUrl\", \"http://otds/otdsws\")\notpd_object.apply_setting(\n\"LocalApplicationServerUrlForContentManager\",\n\"http://localhost:8080/c4ApplicationServer\",\nself.otpd_settings.tenant,\n)\nreturn otpd_object\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.log_header","title":"<code>log_header(text, char='=', length=60)</code>","text":"<p>Helper method to output a section header in the log file</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>description</p> required <code>char</code> <code>str</code> <p>header line character. Defaults to \"=\".</p> <code>'='</code> <code>length</code> <code>int</code> <p>maxium length. Defaults to 60.</p> <code>60</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def log_header(self, text: str, char: str = \"=\", length: int = 60):\n\"\"\"Helper method to output a section header in the log file\n    Args:\n        text (str): _description_\n        char (str, optional): header line character. Defaults to \"=\".\n        length (int, optional): maxium length. Defaults to 60.\n    Returns:\n        None\n    \"\"\"\n# Calculate the remaining space for the text after adding spaces\navailable_space = max(\n0, length - len(text) - 2\n)  # 2 accounts for the spaces each side of the text\n# Calculate the number of characters needed on each side\nchar_count = available_space // 2\nextra_char = available_space % 2  # do we have lost 1 char?\n# Ensure there are at least 3 characters on each side\nchar_count = max(3, char_count)\n# Build the header string, extra_char is either 0 or 1\nlogger.info(\n\"%s %s %s\", char * char_count, text, char * (char_count + extra_char)\n)\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.restart_otac_service","title":"<code>restart_otac_service()</code>","text":"<p>Restart the Archive Center spawner service in OTAC pod</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if restart was done, False if error occured</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def restart_otac_service(self) -&gt; bool:\n\"\"\"Restart the Archive Center spawner service in OTAC pod\n    Args:\n        None\n    Returns:\n        bool: True if restart was done, False if error occured\n    \"\"\"\nif not self.otac_settings.enabled:\nreturn False\nlogger.info(\n\"Restarting spawner service in Archive Center pod -&gt; %s\",\nself.otac_settings.k8s_pod_name,\n)\n# The Archive Center Spawner needs to be run in \"interactive\" mode - otherwise the command will \"hang\":\n# The \"-c\" parameter is not required in this case\n# False is given as parameter as OTAC writes non-errors to stderr\nresponse = self.k8s_object.exec_pod_command_interactive(\nself.otac_settings.k8s_pod_name,\n[\"/bin/sh\", \"/etc/init.d/spawner restart\"],\n60,\nFalse,\n)\nif response:\nreturn True\nelse:\nreturn False\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.restart_otawp_pod","title":"<code>restart_otawp_pod()</code>","text":"<p>Delete the AppWorks Platform Pod to make Kubernetes restart it.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def restart_otawp_pod(self):\n\"\"\"Delete the AppWorks Platform Pod to make Kubernetes restart it.\n    Args:\n    Returns:\n        None\n    \"\"\"\nself.k8s_object.delete_pod(self.otawp_settings.k8s_statefulset + \"-0\")\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.restart_otcs_service","title":"<code>restart_otcs_service(otcs_object, extra_wait_time=60)</code>","text":"<p>Restart the Content Server service in all OTCS pods</p> <p>Parameters:</p> Name Type Description Default <code>otcs_object</code> <code>OTCS</code> <p>OTCS class instance (object)</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def restart_otcs_service(self, otcs_object: OTCS, extra_wait_time: int = 60):\n\"\"\"Restart the Content Server service in all OTCS pods\n    Args:\n        otcs_object: OTCS class instance (object)\n    Returns:\n        None\n    \"\"\"\nif not self.k8s_object:\nlogger.warning(\n\"Kubernetes integration not available, skipping restart of services\"\n)\nreturn\nlogger.info(\"Restart OTCS frontend and backend pods...\")\n# Restart all frontends:\nfor x in range(0, self.otcs_settings.replicas_frontend):\npod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\nlogger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n)\nlogger.info(\"Restarting pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n)\n# Restart all backends:\nfor x in range(0, self.otcs_settings.replicas_backend):\npod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\nlogger.info(\"Deactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"touch /tmp/keepalive\"]\n)\nlogger.info(\"Restarting pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/stop_csserver\"]\n)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"/opt/opentext/cs/start_csserver\"]\n)\nlogger.info(\"Re-Authenticating to OTCS after restart of pods...\")\notcs_cookie = otcs_object.authenticate(revalidate=True)\nwhile otcs_cookie is None:\nlogger.warning(\"Waiting 30 seconds for OTCS to become ready...\")\ntime.sleep(30)\notcs_cookie = otcs_object.authenticate(revalidate=True)\nlogger.info(\"OTCS is ready again.\")\n# Reactivate Liveness probes in all pods:\nfor x in range(0, self.otcs_settings.replicas_frontend):\npod_name = self.otcs_settings.k8s_statefulset_frontend + \"-\" + str(x)\nlogger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n)\nfor x in range(0, self.otcs_settings.replicas_backend):\npod_name = self.otcs_settings.k8s_statefulset_backend + \"-\" + str(x)\nlogger.info(\"Reactivate Liveness probe for pod -&gt; %s\", pod_name)\nself.k8s_object.exec_pod_command(\npod_name, [\"/bin/sh\", \"-c\", \"rm /tmp/keepalive\"]\n)\nlogger.info(\"Restart OTCS frontend and backend pods has been completed.\")\n# optional, give some additional time to make sure service is responsive\nif extra_wait_time &gt; 0:\nlogger.info(\n\"Wait %s seconds to make sure OTCS is responsive again...\",\nstr(extra_wait_time),\n)\ntime.sleep(extra_wait_time)\nlogger.info(\"Continue customizing...\")\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.Customizer.set_maintenance_mode","title":"<code>set_maintenance_mode(enable=True)</code>","text":"<p>Enable or Disable Maintenance Mode</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>def set_maintenance_mode(self, enable: bool = True):\n\"\"\"Enable or Disable Maintenance Mode\n    Args:\n        enable (bool, optional): _description_. Defaults to True.\n    \"\"\"\nif enable and self.k8s_settings.enabled:\nself.log_header(\"Enable Maintenance Mode\")\nlogger.info(\n\"Put OTCS frontends in Maitenance Mode by changing the Kubernetes Ingress backend service...\"\n)\nself.k8s_object.update_ingress_backend_services(\nself.otcs_settings.k8s_ingress,\n\"otcs\",\nself.otcs_settings.maintenance_service_name,\nself.otcs_settings.mainteance_service_port,\n)\nlogger.info(\"OTCS frontend is now in Maintenance Mode!\")\nelif not self.k8s_settings.enabled:\nlogger.warning(\n\"Kubernetes Integration disabled - Cannot Enable/Disable Maintenance Mode\"\n)\nself.k8s_object = None\nelse:\n# Changing the Ingress backend service to OTCS frontend service:\nlogger.info(\n\"Put OTCS frontend back in Production Mode by changing the Kubernetes Ingress backend service...\"\n)\nself.k8s_object.update_ingress_backend_services(\nself.otcs_settings.k8s_ingress,\n\"otcs\",\nself.otcs_settings.hostname_frontend,\nself.otcs_settings.port_frontend,\n)\nlogger.info(\"OTCS frontend is now back in Production Mode!\")\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettings","title":"<code>CustomizerSettings</code>  <code>dataclass</code>","text":"<p>Class to manage settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettings:\n\"\"\"Class to manage settings\"\"\"\nplaceholder_values: dict = field(default_factory=dict)\nstop_on_error: bool = os.environ.get(\"LOGLEVEL\", \"INFO\") == \"DEBUG\"\ncust_log_file: str = \"/tmp/customizing.log\"\ncustomizer_start_time = customizer_end_time = datetime.now()\n# The following CUST artifacts are created by the main.tf in the python module:\ncust_settings_dir: str = \"/settings/\"\ncust_payload_dir: str = \"/payload/\"\ncust_payload: str = cust_payload_dir + \"payload.yaml\"\ncust_payload_gz: str = cust_payload_dir + \"payload.yml.gz.b64\"\ncust_payload_external: str = \"/payload-external/\"\ncust_target_folder_nickname: str = (\n\"deployment\"  # nickname of folder to upload payload and log files\n)\n# CUST_RM_SETTINGS_DIR = \"/opt/opentext/cs/appData/supportasset/Settings/\"\ncust_rm_settings_dir = cust_settings_dir\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsAviator","title":"<code>CustomizerSettingsAviator</code>  <code>dataclass</code>","text":"<p>Class for Aviator related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsAviator:\n\"\"\"Class for Aviator related settings\"\"\"\nenabled: bool = os.environ.get(\"AVIATOR_ENABLED\", \"false\").lower() == \"true\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsK8S","title":"<code>CustomizerSettingsK8S</code>  <code>dataclass</code>","text":"<p>Class for K8s related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsK8S:\n\"\"\"Class for K8s related settings\"\"\"\nenabled: bool = os.environ.get(\"K8S_ENABLED\", \"true\").lower() == \"true\"\nin_cluster: bool = True\nkubeconfig_file: str = \"~/.kube/config\"\nnamespace: str = \"default\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsM365","title":"<code>CustomizerSettingsM365</code>  <code>dataclass</code>","text":"<p>Class for O365 related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsM365:\n\"\"\"Class for O365 related settings\"\"\"\nenabled: bool = os.environ.get(\"O365_ENABLED\", \"false\").lower() == \"true\"\ntenant_id: str = os.environ.get(\"O365_TENANT_ID\", \"\")\nclient_id: str = os.environ.get(\"O365_CLIENT_ID\", \"\")\nclient_secret: str = os.environ.get(\"O365_CLIENT_SECRET\", \"\")\nuser: str = os.environ.get(\"O365_USER\", \"\")\npassword: str = os.environ.get(\"O365_PASSWORD\", \"\")\ndomain: str = os.environ.get(\"O365_DOMAIN\", \"\")\nsku_id: str = os.environ.get(\"O365_SKU_ID\", \"c7df2760-2c81-4ef7-b578-5b5392b571df\")\nteams_app_name: str = \"OpenText Extended ECM\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTAC","title":"<code>CustomizerSettingsOTAC</code>  <code>dataclass</code>","text":"<p>Class for OTAC related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTAC:\n\"\"\"Class for OTAC related settings\"\"\"\nenabled: bool = os.environ.get(\"OTAC_ENABLED\", \"false\").lower() == \"true\"\nhostname: str = os.environ.get(\"OTAC_SERVICE_HOST\", \"otac-0\")\nport: int = os.environ.get(\"OTAC_SERVICE_PORT\", 8080)\nprotocol: str = os.environ.get(\"OTAC_PROTOCOL\", \"http\")\npublic_url: str = os.environ.get(\"OTAC_PUBLIC_URL\")\nadmin: str = os.environ.get(\"OTAC_ADMIN\", \"dsadmin\")\npassword: str = os.environ.get(\"OTAC_PASSWORD\", \"\")\nknown_server: str = os.environ.get(\"OTAC_KNOWN_SERVER\", \"\")\nk8s_pod_name: str = \"otac-0\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTAWP","title":"<code>CustomizerSettingsOTAWP</code>  <code>dataclass</code>","text":"<p>Class for OTAWP related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTAWP:\n\"\"\"Class for OTAWP related settings\"\"\"\nenabled: bool = os.environ.get(\"OTAWP_ENABLED\", \"false\").lower() == \"true\"\nlicense_file: str = \"/payload/otawp-license.lic\"\nproduct_name: str = \"APPWORKS_PLATFORM\"\nproduct_description: str = \"OpenText Appworks Platform\"\nresource_name: str = \"awp\"\naccess_role_name: str = \"Access to \" + resource_name\nadmin: str = os.environ.get(\"OTAWP_ADMIN\", \"sysadmin\")\npassword: str = os.environ.get(\"OTAWP_PASSWORD\")\npublic_protocol: str = os.environ.get(\"OTAWP_PROTOCOL\", \"https\")\npublic_url: str = os.environ.get(\"OTAWP_PUBLIC_URL\")\nk8s_statefulset: str = \"appworks\"\nk8s_configmap: str = \"appworks-config-ymls\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTCS","title":"<code>CustomizerSettingsOTCS</code>  <code>dataclass</code>","text":"<p>Class for OTCS related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTCS:\n\"\"\"Class for OTCS related settings\"\"\"\n# Content Server Constants:\nprotocol: str = os.environ.get(\"OTCS_PROTOCOL\", \"http\")\npublic_protocol: str = os.environ.get(\"OTCS_PUBLIC_PROTOCOL\", \"https\")\nhostname: str = os.environ.get(\"OTCS_HOSTNAME\", \"otcs-admin-0\")\nhostname_backend: str = os.environ.get(\"OTCS_HOSTNAME\", \"otcs-admin-0\")\nhostname_frontend: str = os.environ.get(\"OTCS_HOSTNAME_FRONTEND\", \"otcs-frontend\")\npublic_url: str = os.environ.get(\"OTCS_PUBLIC_URL\", \"otcs.public-url.undefined\")\nport: int = os.environ.get(\"OTCS_SERVICE_PORT_OTCS\", 8080)\nport_backend: int = os.environ.get(\"OTCS_SERVICE_PORT_OTCS\", 8080)\nport_frontend: int = 80\nadmin: str = os.environ.get(\"OTCS_ADMIN\", \"admin\")\npassword: str = os.environ.get(\"OTCS_PASSWORD\")\npartition: str = os.environ.get(\"OTCS_PARTITION\", \"Content Server Members\")\nresource_name: str = \"cs\"\nk8s_statefulset_frontend: str = \"otcs-frontend\"\nk8s_statefulset_backend: str = \"otcs-admin\"\nk8s_ingress: str = \"otxecm-ingress\"\nmaintenance_mode: bool = (\nos.environ.get(\"OTCS_MAINTENANCE_MODE\", \"true\").lower() == \"true\"\n)\nlicense_feature: str = \"X3\"\n# K8s service name and port for maintenance pod\nmaintenance_service_name: str = \"otxecm-customizer\"\nmainteance_service_port: int = 5555\nreplicas_frontend = 0\nreplicas_backend = 0\nupdate_admin_user: bool = True\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTDS","title":"<code>CustomizerSettingsOTDS</code>  <code>dataclass</code>","text":"<p>Class for OTDS related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTDS:\n\"\"\"Class for OTDS related settings\"\"\"\nprotocol: str = os.environ.get(\"OTDS_PROTOCOL\", \"http\")\npublic_protocol: str = os.environ.get(\"OTDS_PUBLIC_PROTOCOL\", \"https\")\nhostname: str = os.environ.get(\"OTDS_HOSTNAME\", \"otds\")\nport: int = os.environ.get(\"OTDS_SERVICE_PORT_OTDS\", 80)\nusername: str = os.environ.get(\"OTDS_ADMIN\", \"admin\")\notds_ticket: str | None = None\nadmin_partition: str = \"otds.admin\"\npublic_url: str = os.environ.get(\"OTDS_PUBLIC_URL\")\npassword: str = os.environ.get(\"OTDS_PASSWORD\")\ndisable_password_policy: bool = True\nenable_audit: bool = True\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTIV","title":"<code>CustomizerSettingsOTIV</code>  <code>dataclass</code>","text":"<p>Class for OTIV related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTIV:\n\"\"\"Class for OTIV related settings\"\"\"\nenabled: bool = os.environ.get(\"OTIV_ENABLED\", \"false\").lower() == \"true\"\nlicense_file: str = \"/payload/otiv-license.lic\"\nlicense_feature: str = \"FULLTIME_USERS_REGULAR\"\nproduct_name: str = \"Viewing\"\nproduct_description: str = \"OpenText Intelligent Viewing\"\nresource_name: str = \"iv\"\n</code></pre>"},{"location":"pyxecm/customizer/#pyxecm.customizer.customizer.CustomizerSettingsOTPD","title":"<code>CustomizerSettingsOTPD</code>  <code>dataclass</code>","text":"<p>Class for OTPD related settings</p> Source code in <code>pyxecm/customizer/customizer.py</code> <pre><code>@dataclass\nclass CustomizerSettingsOTPD:\n\"\"\"Class for OTPD related settings\"\"\"\nenabled: bool = os.environ.get(\"OTPD_ENABLED\", \"false\").lower() == \"true\"\nhostname: str = os.environ.get(\"OTPD_SERVICE_HOST\", \"otpd\")\nport: int = os.environ.get(\"OTPD_SERVICE_PORT\", 8080)\nprotocol: str = os.environ.get(\"OTPD_PROTOCOL\", \"http\")\ndb_importfile: str = os.environ.get(\n\"OTPD_DBIMPORTFILE\", \"URL://url.download.location/file.zip\"\n)\ntenant: str = os.environ.get(\"OTPD_TENANT\", \"Successfactors\")\nuser: str = os.environ.get(\"OTPD_USER\", \"powerdocsapiuser\")\npassword: str = os.environ.get(\n\"OTPD_PASSWORD\",\n)\nk8s_pod_name: str = \"otpd-0\"\n</code></pre>"},{"location":"pyxecm/k8s/","title":"K8s","text":"<p>Kubernetes Module to implement functions to read / write Kubernetes objects such as Pods, Stateful Sets, Config Maps, ...</p> <p>https://github.com/kubernetes-client/python  https://github.com/kubernetes-client/python/blob/master/kubernetes/README.md https://github.com/kubernetes-client/python/tree/master/examples</p> <p>Class: K8s Methods:</p> <p>init : class initializer get_core_v1_api: Get Kubernetes API object for Core APIs get_apps_v1_api: Get Kubernetes API object for Applications (e.g. Stateful Sets) get_networking_v1_api: Get Kubernetes API object for Networking (e.g. Ingress) get_namespace: Get the Kubernetes namespace the K8s object is configured for</p> <p>get_pod: Get a Kubernetes Pod based on its name list_pods: Get a list of Kubernetes pods based on field and label selectors exec_pod_command: Execute a list of commands in a Kubernetes Pod exec_pod_command_interactive: Write commands to stdin and wait for response delete_pod: Delete a running pod (e.g. to make Kubernetes restart it)</p> <p>get_config_map: Get a Kubernetes Config Map based on its name list_config_maps: Get a list of Kubernetes Config Maps based on field and label selectors find_config_map: Find a Kubernetes Config Map based on its name replace_config_map: Replace the data body of a Kubernetes Config Map</p> <p>get_stateful_set: Gets a Kubernetes Stateful Set based on its name get_stateful_set_scale: Gets the number of replicas for a Kubernetes Stateful Set patch_stateful_set: Updates the specification of a Kubernetes Stateful Set scale_stateful_set: Changes number of replicas for a Kubernetes Stateful Set</p> <p>get_service: Get a Kubernetes Service based on its name list_services: Get a list of Kubernetes Services based on field and label selectors patch_service: Update the specification of a Kubernetes Service</p> <p>get_ingress: Get a Kubernetes Ingress based on its name patch_ingress: Update the specification of a Kubernetes Ingress update_ingress_backend_services: Replace the backend service and port for an ingress host</p>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s","title":"<code>K8s</code>","text":"<p>Used to automate stettings in Kubernetes.</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>class K8s:\n\"\"\"Used to automate stettings in Kubernetes.\"\"\"\n_core_v1_api = None\n_apps_v1_api = None\n_networking_v1_api = None\n_namespace = None\ndef __init__(\nself,\nin_cluster: bool,\nkubeconfig_file: str = \"~/.kube/config\",\nnamespace: str = \"default\",\n):\n\"\"\"Initialize the Kubernetes object.\"\"\"\n# Configure Kubernetes API authentication to use pod serviceAccount\nif in_cluster:\nconfig.load_incluster_config()\nelse:\nif kubeconfig_file:\nconfig.load_kube_config(config_file=kubeconfig_file)\nelse:\nlogger.warning(\n\"Not runnig in cluster but kubeconfig file not specified!\"\n)\nself._core_v1_api = client.CoreV1Api()\nself._apps_v1_api = client.AppsV1Api()\nself._networking_v1_api = client.NetworkingV1Api()\nif namespace and not in_cluster:\nself._namespace = namespace\nelse:\n# Read current namespace\nwith open(\n\"/var/run/secrets/kubernetes.io/serviceaccount/namespace\",\n\"r\",\nencoding=\"utf-8\",\n) as namespace_file:\nself._namespace = namespace_file.read()\ndef get_core_v1_api(self):\n\"\"\"Returns Kubernetes Core V1 API object\n        Returns:\n            object: Kubernetes API object\n        \"\"\"\nreturn self._core_v1_api\ndef get_apps_v1_api(self):\n\"\"\"Returns Kubernetes Apps V1 API object\n        Returns:\n            object: Kubernetes API object\n        \"\"\"\nreturn self._apps_v1_api\ndef get_networking_v1_api(self):\n\"\"\"Returns Kubernetes Networking V1 API object\n        Returns:\n            object: Kubernetes API object\n        \"\"\"\nreturn self._networking_v1_api\ndef get_namespace(self):\n\"\"\"Returns Kubernetes Namespace\n        Returns:\n            str: Kubernetes namespace\n        \"\"\"\nreturn self._namespace\ndef get_pod(self, pod_name: str):\n\"\"\"Get a pod in the configured namespace (the namespace is defined\n            in the class constructor).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_pod\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n        Returns:\n            V1Pod (object) or None if the call fails.\n            - api_version='v1',\n            - kind='Pod',\n            - metadata=V1ObjectMeta(...),\n            - spec=V1PodSpec(...),\n            - status=V1PodStatus(...)\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().read_namespaced_pod(\nname=pod_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n)\nreturn None\nreturn response\n# end method definition\ndef list_pods(self, field_selector: str = \"\", label_selector: str = \"\"):\n\"\"\"List all Kubernetes pods in a given namespace. The list can be further restricted\n            by specifying a field or label selector.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_pod\n        Args:\n            field_selector (str): filter result based on fields\n            label_selector (str): filter result based on labels\n        Returns:\n            V1PodList (object) or None if the call fails\n            Properties can be accessed with the \".\" notation (this is an object not a dict!):\n            - api_version: The Kubernetes API version.\n            - items: A list of V1Pod objects, each representing a pod. You can access the fields of a\n                    V1Pod object using dot notation, for example, pod.metadata.name to access the name of the pod\n            - kind: The Kubernetes object kind, which is always \"PodList\".\n            - metadata: Additional metadata about the pod list, such as the resource version.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1PodList.md\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().list_namespaced_pod(\nfield_selector=field_selector,\nlabel_selector=label_selector,\nnamespace=self.get_namespace(),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to list Pods with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\nfield_selector,\nlabel_selector,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef wait_pod_condition(\nself, pod_name: str, condition_name: str, sleep_time: int = 30\n):\n\"\"\"Wait for the pod to reach a defined condition (e.g. \"Ready\").\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n            condition_name (str): name of the condition, e.g. \"Ready\"\n        Returns:\n            True once the pod reaches the condition - otherwise wait forever\n        \"\"\"\nready = False\nwhile not ready:\ntry:\npod_status = self.get_core_v1_api().read_namespaced_pod_status(\npod_name, self.get_namespace()\n)\n# Check if the pod has reached the defined condition:\nfor cond in pod_status.status.conditions:\nif cond.type == condition_name and cond.status == \"True\":\nlogger.info(\n\"Pod -&gt; %s is in state -&gt; %s!\", pod_name, condition_name\n)\nready = True\nbreak\nelse:\nlogger.info(\n\"Pod -&gt; %s is not yet in state -&gt; %s. Waiting...\",\npod_name,\ncondition_name,\n)\ntime.sleep(sleep_time)\ncontinue\nexcept ApiException as exception:\nlogger.error(\n\"Failed to wait for pod -&gt; %s; error -&gt; %s\",\npod_name,\nstr(exception),\n)\n# end method definition\ndef exec_pod_command(self, pod_name: str, command: list):\n\"\"\"Execute a command inside a Kubernetes Pod (similar to kubectl exec on command line).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#connect_get_namespaced_pod_exec\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n            command (list): list of command and its parameters, e.g. [\"/bin/bash\", \"-c\", \"pwd\"]\n                            The \"-c\" is required to make the shell executing the command.\n        Returns:\n            Response of the command or None if the call fails\n        \"\"\"\npod = self.get_pod(pod_name)\nif not pod:\nlogger.error(\"Pod -&gt; %s does not exist\", pod_name)\nlogger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\ntry:\nresponse = stream(\nself.get_core_v1_api().connect_get_namespaced_pod_exec,\npod_name,\nself.get_namespace(),\ncommand=command,\nstderr=True,\nstdin=False,\nstdout=True,\ntty=False,\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to execute command -&gt; %s in pod -&gt; %s; error -&gt; %s\",\ncommand,\npod_name,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\n# Some commands like the OTAC spawner need to run interactive - otherwise the command \"hangs\"\ndef exec_pod_command_interactive(\nself,\npod_name: str,\ncommands: list,\ntimeout: int = 30,\nwrite_stderr_to_error_log: bool = True,\n):\n\"\"\"Execute a command inside a Kubernetes pod (similar to kubectl exec on command line).\n            Other than exec_pod_command() method above this is an interactive execution using\n            stdin and reading the output from stdout and stderr. This is required for longer\n            running commands. It is currently used for restarting the spawner of Archive Center.\n            The output of the command is pushed into the logging.\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n            commands (list): list of command and its parameters, e.g. [\"/bin/bash\", \"/etc/init.d/spawner restart\"]\n                             Here we should NOT have a \"-c\" parameter!\n            timeout (int): timeout duration that is waited for any response.\n                           Each time a resonse is found in stdout or stderr we wait another timeout duration\n                           to make sure we get the full output of the command.\n            write_stderr_to_error_log (bool): flag to control if output in stderr should be written to info or error log stream.\n                                              Default is write to error log (True)\n        Returns:\n            str: Response of the command or None if the call fails\n        \"\"\"\npod = self.get_pod(pod_name)\nif not pod:\nlogger.error(\"Pod -&gt; %s does not exist\", pod_name)\nif not commands:\nlogger.error(\"No commands to execute on Pod -&gt; %s\", pod_name)\nreturn None\n# Get first command - this should be the shell:\ncommand = commands.pop(0)\ntry:\nresponse = stream(\nself.get_core_v1_api().connect_get_namespaced_pod_exec,\npod_name,\nself.get_namespace(),\ncommand=command,\nstderr=True,\nstdin=True,  # This is important!\nstdout=True,\ntty=False,\n_preload_content=False,  # This is important!\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to execute command -&gt; %s in pod -&gt; %s; error -&gt; %s\",\ncommand,\npod_name,\nstr(exception),\n)\nreturn None\nwhile response.is_open():\ngot_response = False\nresponse.update(timeout=timeout)\nif response.peek_stdout():\nlogger.info(response.read_stdout().replace(\"\\n\", \" \"))\ngot_response = True\nif response.peek_stderr():\nif write_stderr_to_error_log:\nlogger.error(response.read_stderr().replace(\"\\n\", \" \"))\nelse:\nlogger.info(response.read_stderr().replace(\"\\n\", \" \"))\ngot_response = True\nif commands:\ncommand = commands.pop(0)\nlogger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\nresponse.write_stdin(command + \"\\n\")\nelse:\n# We continue as long as we get some response during timeout period\nif not got_response:\nbreak\nresponse.close()\nreturn response\n# end method definition\ndef delete_pod(self, pod_name: str):\n\"\"\"Delete a pod in the configured namespace (the namespace is defined in the class constructor).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#delete_namespaced_pod\n        Args:\n            pod_name (str): name of the Kubernetes pod in the current namespace\n        Return:\n            V1Status (object) or None if the call fails.\n            - api_version: The Kubernetes API version.\n            - kind: The Kubernetes object kind, which is always \"Status\".\n            - metadata: Additional metadata about the status object, such as the resource version.\n            - status: The status of the operation, which is either \"Success\" or an error status.\n            - message: A human-readable message explaining the status.\n            - reason: A short string that describes the reason for the status.\n            - code: An HTTP status code that corresponds to the status.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Status.md\n        \"\"\"\npod = self.get_pod(pod_name)\nif not pod:\nlogger.error(\"Pod -&gt; %s does not exist\", pod_name)\ntry:\nresponse = self.get_core_v1_api().delete_namespaced_pod(\npod_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to delete Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n)\nreturn None\nreturn response\n# end method definition\ndef get_config_map(self, config_map_name: str):\n\"\"\"Get a config map in the configured namespace (the namespace is defined in the class constructor).\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_config_map\n        Args:\n            config_map_name (str): name of the Kubernetes config map in the current namespace\n        Returns:\n            V1ConfigMap (object): Kubernetes Config Map object that includes these fields:\n            - api_version: The Kubernetes API version.\n            - metadata: A V1ObjectMeta object representing metadata about the V1ConfigMap object,\n                        such as its name, labels, and annotations.\n            - data: A dictionary containing the non-binary data stored in the ConfigMap,\n                    where the keys represent the keys of the data items and the values represent\n                    the values of the data items.\n            - binary_data: A dictionary containing the binary data stored in the ConfigMap,\n                           where the keys represent the keys of the binary data items and the values\n                           represent the values of the binary data items. Binary data is encoded as base64\n                           strings in the dictionary values.\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().read_namespaced_config_map(\nname=config_map_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Config Map -&gt; %s; error -&gt; %s\",\nconfig_map_name,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef list_config_maps(self, field_selector: str = \"\", label_selector: str = \"\"):\n\"\"\"List all Kubernetes Config Maps in the current namespace.\n            The list can be filtered by providing field selectors and label selectors.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_config_map\n        Args:\n            field_selector (str): filter result based on fields\n            label_selector (str): filter result based on labels\n        Returns:\n            V1ConfigMapList (object) or None if the call fails\n            Properties can be accessed with the \".\" notation (this is an object not a dict!):\n            - api_version: The Kubernetes API version.\n            - items: A list of V1ConfigMap objects, each representing a config map. You can access the fields of a\n                     V1Pod object using dot notation, for example, cm.metadata.name to access the name of the config map\n            - kind: The Kubernetes object kind, which is always \"ConfigMapList\".\n            - metadata: Additional metadata about the config map list, such as the resource version.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMapList.md\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().list_namespaced_config_map(\nfield_selector=field_selector,\nlabel_selector=label_selector,\nnamespace=self.get_namespace(),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to list Config Maps with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\nfield_selector,\nlabel_selector,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef find_config_map(self, config_map_name: str):\n\"\"\"Find a Kubernetes Config Map based on its name.\n           This is just a wrapper method for list_config_maps()\n           that uses the name as a field selector.\n        Args:\n            config_map_name (str): name of the Config Map\n        Returns:\n            object: V1ConfigMapList (object) or None if the call fails\n        \"\"\"\ntry:\nresponse = self.list_config_maps(\nfield_selector=\"metadata.name={}\".format(config_map_name)\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to find Config Map -&gt; %s; error -&gt; %s\",\nconfig_map_name,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef replace_config_map(self, config_map_name: str, config_map_data: dict):\n\"\"\"Replace a Config Map with a new specification.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#replace_namespaced_config_map\n        Args:\n            config_map_name (str): name of the Kubernetes Config Map\n            config_map_data (dict): new specification of the Config Map\n        Returns:\n            V1ConfigMap (object): updated Kubernetes Config Map object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMap.md\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().replace_namespaced_config_map(\nname=config_map_name,\nnamespace=self.get_namespace(),\nbody=client.V1ConfigMap(\nmetadata=client.V1ObjectMeta(\nname=config_map_name,\n),\ndata=config_map_data,\n),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to replace Config Map -&gt; %s; error -&gt; %s\",\nconfig_map_name,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef get_stateful_set(self, sts_name: str):\n\"\"\"Get a Kubernetes Stateful Set based on its name.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set\n        Args:\n            sts_name (str): name of the Kubernetes stateful set\n        Returns:\n            V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n            See : https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n        \"\"\"\ntry:\nresponse = self.get_apps_v1_api().read_namespaced_stateful_set(\nname=sts_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Stateful Set -&gt; %s; error -&gt; %s\",\nsts_name,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef get_stateful_set_scale(self, sts_name: str):\n\"\"\"Get the number of replicas for a Kubernetes Stateful Set.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set_scale\n        Args:\n            sts_name (str): name of the Kubernetes Stateful Set\n        Returns:\n            V1Scale (object): Kubernetes Scale object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Scale.md\n        \"\"\"\ntry:\nresponse = self.get_apps_v1_api().read_namespaced_stateful_set_scale(\nname=sts_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get scaling (replicas) of Stateful Set -&gt; %s; error -&gt; %s\",\nsts_name,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef patch_stateful_set(self, sts_name: str, sts_body: dict):\n\"\"\"Patch a Stateful set with new values.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#patch_namespaced_stateful_set\n        Args:\n            sts_name (str): name of the Kubernetes stateful set in the current namespace\n            sts_body (str): patch string\n        Returns:\n            V1StatefulSet (object): patched Kubernetes Stateful Set object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n        \"\"\"\ntry:\nresponse = self.get_apps_v1_api().patch_namespaced_stateful_set(\nname=sts_name, namespace=self.get_namespace(), body=sts_body\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to patch Stateful Set -&gt; %s with -&gt; %s; error -&gt; %s\",\nsts_name,\nsts_body,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef scale_stateful_set(self, sts_name: str, scale: int):\n\"\"\"Scale a stateful set to a specific number of replicas.\n           It uses the class method patch_stateful_set() above.\n        Args:\n            sts_name (str): name of the Kubernetes stateful set in the current namespace\n            scale (int): number of replicas (pods) the stateful set shall be scaled to\n        Returns:\n            V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n        \"\"\"\ntry:\nresponse = self.patch_stateful_set(\nsts_name, sts_body={\"spec\": {\"replicas\": scale}}\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to scale Stateful Set -&gt; %s to -&gt; %s replicas; error -&gt; %s\",\nsts_name,\nscale,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef get_service(self, service_name: str):\n\"\"\"Get a Kubernetes Service with a defined name in the current namespace\n        Args:\n            service_name (str): name of the Kubernetes Service in the current namespace\n        Returns:\n            V1Service (object): Kubernetes Service object or None if the call fails\n            This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().read_namespaced_service(\nname=service_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Service -&gt; %s; error -&gt; %s\", service_name, str(exception)\n)\nreturn None\nreturn response\n# end method definition\ndef list_services(self, field_selector: str = \"\", label_selector: str = \"\"):\n\"\"\"List all Kubernetes Service in the current namespace.\n            The list can be filtered by providing field selectors and label selectors.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_service\n        Args:\n            field_selector (str): filter result based on fields\n            label_selector (str): filter result based on labels\n        Returns:\n            V1ServiceList (object): list of Kubernetes Services or None if the call fails\n            Properties can be accessed with the \".\" notation (this is an object not a dict!):\n            - api_version: The Kubernetes API version.\n            - items: A list of V1Service objects, each representing a service.\n                     You can access the fields of a V1Service object using dot notation,\n                     for example, service.metadata.name to access the name of the service\n            - kind: The Kubernetes object kind, which is always \"ServiceList\".\n            - metadata: Additional metadata about the pod list, such as the resource version.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ServiceList.md\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().list_namespaced_service(\nfield_selector=field_selector,\nlabel_selector=label_selector,\nnamespace=self.get_namespace(),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to list Services with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\nfield_selector,\nlabel_selector,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef patch_service(self, service_name: str, service_body: dict):\n\"\"\"Patches a Kubernetes Service with an updated spec\n        Args:\n            service_name (str): name of the Kubernetes Ingress in the current namespace\n            service_body (dict): new / updated Service body spec\n                                 (will be merged with existing values)\n        Returns:\n            V1Service (object): patched Kubernetes Service or None if the call fails\n            This is NOT a dict but an object - you have to use the \".\" syntax\n            to access to returned elements\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n        \"\"\"\ntry:\nresponse = self.get_core_v1_api().patch_namespaced_service(\nname=service_name, namespace=self.get_namespace(), body=service_body\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to patch Service -&gt; %s with -&gt; %s; error -&gt; %s\",\nservice_name,\nservice_body,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef get_ingress(self, ingress_name: str):\n\"\"\"Get a Kubernetes Ingress with a defined name in the current namespace\n        Args:\n            ingress_name (str): name of the Kubernetes Ingress in the current namespace\n        Returns:\n            V1Ingress (object): Kubernetes Ingress or None if the call fails\n            This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n        \"\"\"\ntry:\nresponse = self.get_networking_v1_api().read_namespaced_ingress(\nname=ingress_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Ingress -&gt; %s; error -&gt; %s\", ingress_name, str(exception)\n)\nreturn None\nreturn response\n# end method definition\ndef patch_ingress(self, ingress_name: str, ingress_body: dict):\n\"\"\"Patch a Kubernetes Ingress with a updated spec.\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/NetworkingV1Api.md#patch_namespaced_ingress\n        Args:\n            ingress_name (str): name of the Kubernetes Ingress in the current namespace\n            ingress_body (dict): new / updated ingress body spec\n                                 (will be merged with existing values)\n        Returns:\n            V1Ingress (object): patched Kubernetes Ingress object or None if the call fails\n            This is NOT a dict but an object - you have to use the\n            \".\" syntax to access to returned elements\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n        \"\"\"\ntry:\nresponse = self.get_networking_v1_api().patch_namespaced_ingress(\nname=ingress_name,\nnamespace=self.get_namespace(),\nbody=ingress_body,\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to patch Ingress -&gt; %s with -&gt; %s; error -&gt; %s\",\ningress_name,\ningress_body,\nstr(exception),\n)\nreturn None\nreturn response\n# end method definition\ndef update_ingress_backend_services(\nself, ingress_name: str, hostname: str, service_name: str, service_port: int\n):\n\"\"\"Updates a backend service and port of an Kubernetes Ingress\n        \"spec\": {\n            \"rules\": [\n                {\n                    \"host\": host,\n                    \"http\": {\n                        \"paths\": [\n                            {\n                                \"path\": \"/\",\n                                \"pathType\": \"Prefix\",\n                                \"backend\": {\n                                    \"service\": {\n                                        \"name\": &lt;service_name&gt;,\n                                        \"port\": {\n                                            \"name\": None,\n                                            \"number\": &lt;service_port&gt;,\n                                        },\n                                    },\n                                },\n                            }\n                        ]\n                    },\n                }\n            ]\n        }\n        Args:\n            ingress_name (str): name of the Kubernetes Ingress in the current namespace\n            hostname (str): hostname that should get an updated backend service / port\n            service_name (str): new backend service name\n            service_port (int): new backend service port\n        Returns:\n            V1Ingress (object): updated Kubernetes Ingress object or None if the call fails\n            This is NOT a dict but an object - you have to use the \".\" syntax\n            to access to returned elements\n            See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n        \"\"\"\ningress = self.get_ingress(ingress_name)\nif not ingress:\nreturn None\nhost = \"\"\nrules = ingress.spec.rules\nrule_index = 0\nfor rule in rules:\nif hostname in rule.host:\nhost = rule.host\npath = rule.http.paths[0]\nbackend = path.backend\nservice = backend.service\nlogger.info(\n\"Replace backend service -&gt; %s (%s) with new backend service -&gt; %s (%s)\",\nservice.name,\nservice.port.number,\nservice_name,\nservice_port,\n)\nservice.name = service_name\nservice.port.number = service_port\nbreak\nelse:\nrule_index += 1\nif not host:\nlogger.error(\"Cannot find host -&gt; {}.\")\nreturn None\nbody = [\n{\n\"op\": \"replace\",\n\"path\": \"/spec/rules/{}/http/paths/0/backend/service/name\".format(\nrule_index\n),\n\"value\": service_name,\n},\n{\n\"op\": \"replace\",\n\"path\": \"/spec/rules/{}/http/paths/0/backend/service/port/number\".format(\nrule_index\n),\n\"value\": service_port,\n},\n]\nreturn self.patch_ingress(ingress_name, body)\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.__init__","title":"<code>__init__(in_cluster, kubeconfig_file='~/.kube/config', namespace='default')</code>","text":"<p>Initialize the Kubernetes object.</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def __init__(\nself,\nin_cluster: bool,\nkubeconfig_file: str = \"~/.kube/config\",\nnamespace: str = \"default\",\n):\n\"\"\"Initialize the Kubernetes object.\"\"\"\n# Configure Kubernetes API authentication to use pod serviceAccount\nif in_cluster:\nconfig.load_incluster_config()\nelse:\nif kubeconfig_file:\nconfig.load_kube_config(config_file=kubeconfig_file)\nelse:\nlogger.warning(\n\"Not runnig in cluster but kubeconfig file not specified!\"\n)\nself._core_v1_api = client.CoreV1Api()\nself._apps_v1_api = client.AppsV1Api()\nself._networking_v1_api = client.NetworkingV1Api()\nif namespace and not in_cluster:\nself._namespace = namespace\nelse:\n# Read current namespace\nwith open(\n\"/var/run/secrets/kubernetes.io/serviceaccount/namespace\",\n\"r\",\nencoding=\"utf-8\",\n) as namespace_file:\nself._namespace = namespace_file.read()\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.delete_pod","title":"<code>delete_pod(pod_name)</code>","text":"<p>Delete a pod in the configured namespace (the namespace is defined in the class constructor).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#delete_namespaced_pod</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required Return <p>V1Status (object) or None if the call fails. - api_version: The Kubernetes API version. - kind: The Kubernetes object kind, which is always \"Status\". - metadata: Additional metadata about the status object, such as the resource version. - status: The status of the operation, which is either \"Success\" or an error status. - message: A human-readable message explaining the status. - reason: A short string that describes the reason for the status. - code: An HTTP status code that corresponds to the status. See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Status.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def delete_pod(self, pod_name: str):\n\"\"\"Delete a pod in the configured namespace (the namespace is defined in the class constructor).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#delete_namespaced_pod\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n    Return:\n        V1Status (object) or None if the call fails.\n        - api_version: The Kubernetes API version.\n        - kind: The Kubernetes object kind, which is always \"Status\".\n        - metadata: Additional metadata about the status object, such as the resource version.\n        - status: The status of the operation, which is either \"Success\" or an error status.\n        - message: A human-readable message explaining the status.\n        - reason: A short string that describes the reason for the status.\n        - code: An HTTP status code that corresponds to the status.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Status.md\n    \"\"\"\npod = self.get_pod(pod_name)\nif not pod:\nlogger.error(\"Pod -&gt; %s does not exist\", pod_name)\ntry:\nresponse = self.get_core_v1_api().delete_namespaced_pod(\npod_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to delete Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.exec_pod_command","title":"<code>exec_pod_command(pod_name, command)</code>","text":"<p>Execute a command inside a Kubernetes Pod (similar to kubectl exec on command line).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#connect_get_namespaced_pod_exec</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <code>command</code> <code>list</code> <p>list of command and its parameters, e.g. [\"/bin/bash\", \"-c\", \"pwd\"]             The \"-c\" is required to make the shell executing the command.</p> required <p>Returns:</p> Type Description <p>Response of the command or None if the call fails</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def exec_pod_command(self, pod_name: str, command: list):\n\"\"\"Execute a command inside a Kubernetes Pod (similar to kubectl exec on command line).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#connect_get_namespaced_pod_exec\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n        command (list): list of command and its parameters, e.g. [\"/bin/bash\", \"-c\", \"pwd\"]\n                        The \"-c\" is required to make the shell executing the command.\n    Returns:\n        Response of the command or None if the call fails\n    \"\"\"\npod = self.get_pod(pod_name)\nif not pod:\nlogger.error(\"Pod -&gt; %s does not exist\", pod_name)\nlogger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\ntry:\nresponse = stream(\nself.get_core_v1_api().connect_get_namespaced_pod_exec,\npod_name,\nself.get_namespace(),\ncommand=command,\nstderr=True,\nstdin=False,\nstdout=True,\ntty=False,\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to execute command -&gt; %s in pod -&gt; %s; error -&gt; %s\",\ncommand,\npod_name,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.exec_pod_command_interactive","title":"<code>exec_pod_command_interactive(pod_name, commands, timeout=30, write_stderr_to_error_log=True)</code>","text":"<p>Execute a command inside a Kubernetes pod (similar to kubectl exec on command line).     Other than exec_pod_command() method above this is an interactive execution using     stdin and reading the output from stdout and stderr. This is required for longer     running commands. It is currently used for restarting the spawner of Archive Center.     The output of the command is pushed into the logging.</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <code>commands</code> <code>list</code> <p>list of command and its parameters, e.g. [\"/bin/bash\", \"/etc/init.d/spawner restart\"]              Here we should NOT have a \"-c\" parameter!</p> required <code>timeout</code> <code>int</code> <p>timeout duration that is waited for any response.            Each time a resonse is found in stdout or stderr we wait another timeout duration            to make sure we get the full output of the command.</p> <code>30</code> <code>write_stderr_to_error_log</code> <code>bool</code> <p>flag to control if output in stderr should be written to info or error log stream.                               Default is write to error log (True)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Response of the command or None if the call fails</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def exec_pod_command_interactive(\nself,\npod_name: str,\ncommands: list,\ntimeout: int = 30,\nwrite_stderr_to_error_log: bool = True,\n):\n\"\"\"Execute a command inside a Kubernetes pod (similar to kubectl exec on command line).\n        Other than exec_pod_command() method above this is an interactive execution using\n        stdin and reading the output from stdout and stderr. This is required for longer\n        running commands. It is currently used for restarting the spawner of Archive Center.\n        The output of the command is pushed into the logging.\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n        commands (list): list of command and its parameters, e.g. [\"/bin/bash\", \"/etc/init.d/spawner restart\"]\n                         Here we should NOT have a \"-c\" parameter!\n        timeout (int): timeout duration that is waited for any response.\n                       Each time a resonse is found in stdout or stderr we wait another timeout duration\n                       to make sure we get the full output of the command.\n        write_stderr_to_error_log (bool): flag to control if output in stderr should be written to info or error log stream.\n                                          Default is write to error log (True)\n    Returns:\n        str: Response of the command or None if the call fails\n    \"\"\"\npod = self.get_pod(pod_name)\nif not pod:\nlogger.error(\"Pod -&gt; %s does not exist\", pod_name)\nif not commands:\nlogger.error(\"No commands to execute on Pod -&gt; %s\", pod_name)\nreturn None\n# Get first command - this should be the shell:\ncommand = commands.pop(0)\ntry:\nresponse = stream(\nself.get_core_v1_api().connect_get_namespaced_pod_exec,\npod_name,\nself.get_namespace(),\ncommand=command,\nstderr=True,\nstdin=True,  # This is important!\nstdout=True,\ntty=False,\n_preload_content=False,  # This is important!\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to execute command -&gt; %s in pod -&gt; %s; error -&gt; %s\",\ncommand,\npod_name,\nstr(exception),\n)\nreturn None\nwhile response.is_open():\ngot_response = False\nresponse.update(timeout=timeout)\nif response.peek_stdout():\nlogger.info(response.read_stdout().replace(\"\\n\", \" \"))\ngot_response = True\nif response.peek_stderr():\nif write_stderr_to_error_log:\nlogger.error(response.read_stderr().replace(\"\\n\", \" \"))\nelse:\nlogger.info(response.read_stderr().replace(\"\\n\", \" \"))\ngot_response = True\nif commands:\ncommand = commands.pop(0)\nlogger.info(\"Execute command -&gt; %s in pod -&gt; %s\", command, pod_name)\nresponse.write_stdin(command + \"\\n\")\nelse:\n# We continue as long as we get some response during timeout period\nif not got_response:\nbreak\nresponse.close()\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.find_config_map","title":"<code>find_config_map(config_map_name)</code>","text":"<p>Find a Kubernetes Config Map based on its name.    This is just a wrapper method for list_config_maps()    that uses the name as a field selector.</p> <p>Parameters:</p> Name Type Description Default <code>config_map_name</code> <code>str</code> <p>name of the Config Map</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>V1ConfigMapList (object) or None if the call fails</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def find_config_map(self, config_map_name: str):\n\"\"\"Find a Kubernetes Config Map based on its name.\n       This is just a wrapper method for list_config_maps()\n       that uses the name as a field selector.\n    Args:\n        config_map_name (str): name of the Config Map\n    Returns:\n        object: V1ConfigMapList (object) or None if the call fails\n    \"\"\"\ntry:\nresponse = self.list_config_maps(\nfield_selector=\"metadata.name={}\".format(config_map_name)\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to find Config Map -&gt; %s; error -&gt; %s\",\nconfig_map_name,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_apps_v1_api","title":"<code>get_apps_v1_api()</code>","text":"<p>Returns Kubernetes Apps V1 API object</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Kubernetes API object</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_apps_v1_api(self):\n\"\"\"Returns Kubernetes Apps V1 API object\n    Returns:\n        object: Kubernetes API object\n    \"\"\"\nreturn self._apps_v1_api\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_config_map","title":"<code>get_config_map(config_map_name)</code>","text":"<p>Get a config map in the configured namespace (the namespace is defined in the class constructor).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_config_map</p> <p>Parameters:</p> Name Type Description Default <code>config_map_name</code> <code>str</code> <p>name of the Kubernetes config map in the current namespace</p> required <p>Returns:</p> Name Type Description <code>V1ConfigMap</code> <code>object</code> <p>Kubernetes Config Map object that includes these fields:</p> <ul> <li>api_version: The Kubernetes API version.</li> </ul> <ul> <li>metadata: A V1ObjectMeta object representing metadata about the V1ConfigMap object,         such as its name, labels, and annotations.</li> </ul> <ul> <li>data: A dictionary containing the non-binary data stored in the ConfigMap,     where the keys represent the keys of the data items and the values represent     the values of the data items.</li> </ul> <ul> <li>binary_data: A dictionary containing the binary data stored in the ConfigMap,            where the keys represent the keys of the binary data items and the values            represent the values of the binary data items. Binary data is encoded as base64            strings in the dictionary values.</li> </ul> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_config_map(self, config_map_name: str):\n\"\"\"Get a config map in the configured namespace (the namespace is defined in the class constructor).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_config_map\n    Args:\n        config_map_name (str): name of the Kubernetes config map in the current namespace\n    Returns:\n        V1ConfigMap (object): Kubernetes Config Map object that includes these fields:\n        - api_version: The Kubernetes API version.\n        - metadata: A V1ObjectMeta object representing metadata about the V1ConfigMap object,\n                    such as its name, labels, and annotations.\n        - data: A dictionary containing the non-binary data stored in the ConfigMap,\n                where the keys represent the keys of the data items and the values represent\n                the values of the data items.\n        - binary_data: A dictionary containing the binary data stored in the ConfigMap,\n                       where the keys represent the keys of the binary data items and the values\n                       represent the values of the binary data items. Binary data is encoded as base64\n                       strings in the dictionary values.\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().read_namespaced_config_map(\nname=config_map_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Config Map -&gt; %s; error -&gt; %s\",\nconfig_map_name,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_core_v1_api","title":"<code>get_core_v1_api()</code>","text":"<p>Returns Kubernetes Core V1 API object</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Kubernetes API object</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_core_v1_api(self):\n\"\"\"Returns Kubernetes Core V1 API object\n    Returns:\n        object: Kubernetes API object\n    \"\"\"\nreturn self._core_v1_api\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_ingress","title":"<code>get_ingress(ingress_name)</code>","text":"<p>Get a Kubernetes Ingress with a defined name in the current namespace</p> <p>Parameters:</p> Name Type Description Default <code>ingress_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <p>Returns:</p> Name Type Description <code>V1Ingress</code> <code>object</code> <p>Kubernetes Ingress or None if the call fails</p> <p>This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_ingress(self, ingress_name: str):\n\"\"\"Get a Kubernetes Ingress with a defined name in the current namespace\n    Args:\n        ingress_name (str): name of the Kubernetes Ingress in the current namespace\n    Returns:\n        V1Ingress (object): Kubernetes Ingress or None if the call fails\n        This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n    \"\"\"\ntry:\nresponse = self.get_networking_v1_api().read_namespaced_ingress(\nname=ingress_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Ingress -&gt; %s; error -&gt; %s\", ingress_name, str(exception)\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_namespace","title":"<code>get_namespace()</code>","text":"<p>Returns Kubernetes Namespace</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Kubernetes namespace</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_namespace(self):\n\"\"\"Returns Kubernetes Namespace\n    Returns:\n        str: Kubernetes namespace\n    \"\"\"\nreturn self._namespace\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_networking_v1_api","title":"<code>get_networking_v1_api()</code>","text":"<p>Returns Kubernetes Networking V1 API object</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Kubernetes API object</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_networking_v1_api(self):\n\"\"\"Returns Kubernetes Networking V1 API object\n    Returns:\n        object: Kubernetes API object\n    \"\"\"\nreturn self._networking_v1_api\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_pod","title":"<code>get_pod(pod_name)</code>","text":"<p>Get a pod in the configured namespace (the namespace is defined     in the class constructor).     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_pod</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <p>Returns:</p> Type Description <p>V1Pod (object) or None if the call fails.</p> <ul> <li>api_version='v1',</li> </ul> <ul> <li>kind='Pod',</li> </ul> <ul> <li>metadata=V1ObjectMeta(...),</li> </ul> <ul> <li>spec=V1PodSpec(...),</li> </ul> <ul> <li>status=V1PodStatus(...)</li> </ul> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_pod(self, pod_name: str):\n\"\"\"Get a pod in the configured namespace (the namespace is defined\n        in the class constructor).\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#read_namespaced_pod\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n    Returns:\n        V1Pod (object) or None if the call fails.\n        - api_version='v1',\n        - kind='Pod',\n        - metadata=V1ObjectMeta(...),\n        - spec=V1PodSpec(...),\n        - status=V1PodStatus(...)\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().read_namespaced_pod(\nname=pod_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Pod -&gt; %s; error -&gt; %s\", pod_name, str(exception)\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_service","title":"<code>get_service(service_name)</code>","text":"<p>Get a Kubernetes Service with a defined name in the current namespace</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>name of the Kubernetes Service in the current namespace</p> required <p>Returns:</p> Name Type Description <code>V1Service</code> <code>object</code> <p>Kubernetes Service object or None if the call fails</p> <p>This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_service(self, service_name: str):\n\"\"\"Get a Kubernetes Service with a defined name in the current namespace\n    Args:\n        service_name (str): name of the Kubernetes Service in the current namespace\n    Returns:\n        V1Service (object): Kubernetes Service object or None if the call fails\n        This is NOT a dict but an object - the you have to use the \".\" syntax to access to returned elements.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().read_namespaced_service(\nname=service_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Service -&gt; %s; error -&gt; %s\", service_name, str(exception)\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_stateful_set","title":"<code>get_stateful_set(sts_name)</code>","text":"<p>Get a Kubernetes Stateful Set based on its name.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes stateful set</p> required <p>Returns:</p> Name Type Description <code>V1StatefulSet</code> <code>object</code> <p>Kubernetes Stateful Set object or None if the call fails.</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_stateful_set(self, sts_name: str):\n\"\"\"Get a Kubernetes Stateful Set based on its name.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set\n    Args:\n        sts_name (str): name of the Kubernetes stateful set\n    Returns:\n        V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n        See : https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n    \"\"\"\ntry:\nresponse = self.get_apps_v1_api().read_namespaced_stateful_set(\nname=sts_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get Stateful Set -&gt; %s; error -&gt; %s\",\nsts_name,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.get_stateful_set_scale","title":"<code>get_stateful_set_scale(sts_name)</code>","text":"<p>Get the number of replicas for a Kubernetes Stateful Set.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set_scale</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes Stateful Set</p> required <p>Returns:</p> Name Type Description <code>V1Scale</code> <code>object</code> <p>Kubernetes Scale object or None if the call fails.</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Scale.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def get_stateful_set_scale(self, sts_name: str):\n\"\"\"Get the number of replicas for a Kubernetes Stateful Set.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#read_namespaced_stateful_set_scale\n    Args:\n        sts_name (str): name of the Kubernetes Stateful Set\n    Returns:\n        V1Scale (object): Kubernetes Scale object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Scale.md\n    \"\"\"\ntry:\nresponse = self.get_apps_v1_api().read_namespaced_stateful_set_scale(\nname=sts_name, namespace=self.get_namespace()\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to get scaling (replicas) of Stateful Set -&gt; %s; error -&gt; %s\",\nsts_name,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.list_config_maps","title":"<code>list_config_maps(field_selector='', label_selector='')</code>","text":"<p>List all Kubernetes Config Maps in the current namespace.     The list can be filtered by providing field selectors and label selectors.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_config_map</p> <p>Parameters:</p> Name Type Description Default <code>field_selector</code> <code>str</code> <p>filter result based on fields</p> <code>''</code> <code>label_selector</code> <code>str</code> <p>filter result based on labels</p> <code>''</code> <p>Returns:</p> Name Type Description <p>V1ConfigMapList (object) or None if the call fails</p> <p>Properties can be accessed with the \".\" notation (this is an object not a dict!):</p> <ul> <li>api_version: The Kubernetes API version.</li> </ul> <ul> <li>items: A list of V1ConfigMap objects, each representing a config map. You can access the fields of a      V1Pod object using dot notation, for example, cm.metadata.name to access the name of the config map</li> </ul> <ul> <li>kind: The Kubernetes object kind, which is always \"ConfigMapList\".</li> </ul> <ul> <li>metadata: Additional metadata about the config map list, such as the resource version.</li> </ul> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMapList.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def list_config_maps(self, field_selector: str = \"\", label_selector: str = \"\"):\n\"\"\"List all Kubernetes Config Maps in the current namespace.\n        The list can be filtered by providing field selectors and label selectors.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_config_map\n    Args:\n        field_selector (str): filter result based on fields\n        label_selector (str): filter result based on labels\n    Returns:\n        V1ConfigMapList (object) or None if the call fails\n        Properties can be accessed with the \".\" notation (this is an object not a dict!):\n        - api_version: The Kubernetes API version.\n        - items: A list of V1ConfigMap objects, each representing a config map. You can access the fields of a\n                 V1Pod object using dot notation, for example, cm.metadata.name to access the name of the config map\n        - kind: The Kubernetes object kind, which is always \"ConfigMapList\".\n        - metadata: Additional metadata about the config map list, such as the resource version.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMapList.md\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().list_namespaced_config_map(\nfield_selector=field_selector,\nlabel_selector=label_selector,\nnamespace=self.get_namespace(),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to list Config Maps with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\nfield_selector,\nlabel_selector,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.list_pods","title":"<code>list_pods(field_selector='', label_selector='')</code>","text":"<p>List all Kubernetes pods in a given namespace. The list can be further restricted     by specifying a field or label selector.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_pod</p> <p>Parameters:</p> Name Type Description Default <code>field_selector</code> <code>str</code> <p>filter result based on fields</p> <code>''</code> <code>label_selector</code> <code>str</code> <p>filter result based on labels</p> <code>''</code> <p>Returns:</p> Name Type Description <p>V1PodList (object) or None if the call fails</p> <p>Properties can be accessed with the \".\" notation (this is an object not a dict!):</p> <ul> <li>api_version: The Kubernetes API version.</li> </ul> <ul> <li>items: A list of V1Pod objects, each representing a pod. You can access the fields of a     V1Pod object using dot notation, for example, pod.metadata.name to access the name of the pod</li> </ul> <ul> <li>kind: The Kubernetes object kind, which is always \"PodList\".</li> </ul> <ul> <li>metadata: Additional metadata about the pod list, such as the resource version.</li> </ul> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1PodList.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def list_pods(self, field_selector: str = \"\", label_selector: str = \"\"):\n\"\"\"List all Kubernetes pods in a given namespace. The list can be further restricted\n        by specifying a field or label selector.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_pod\n    Args:\n        field_selector (str): filter result based on fields\n        label_selector (str): filter result based on labels\n    Returns:\n        V1PodList (object) or None if the call fails\n        Properties can be accessed with the \".\" notation (this is an object not a dict!):\n        - api_version: The Kubernetes API version.\n        - items: A list of V1Pod objects, each representing a pod. You can access the fields of a\n                V1Pod object using dot notation, for example, pod.metadata.name to access the name of the pod\n        - kind: The Kubernetes object kind, which is always \"PodList\".\n        - metadata: Additional metadata about the pod list, such as the resource version.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1PodList.md\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().list_namespaced_pod(\nfield_selector=field_selector,\nlabel_selector=label_selector,\nnamespace=self.get_namespace(),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to list Pods with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\nfield_selector,\nlabel_selector,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.list_services","title":"<code>list_services(field_selector='', label_selector='')</code>","text":"<p>List all Kubernetes Service in the current namespace.     The list can be filtered by providing field selectors and label selectors.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_service</p> <p>Parameters:</p> Name Type Description Default <code>field_selector</code> <code>str</code> <p>filter result based on fields</p> <code>''</code> <code>label_selector</code> <code>str</code> <p>filter result based on labels</p> <code>''</code> <p>Returns:</p> Name Type Description <code>V1ServiceList</code> <code>object</code> <p>list of Kubernetes Services or None if the call fails</p> <p>Properties can be accessed with the \".\" notation (this is an object not a dict!):</p> <ul> <li>api_version: The Kubernetes API version.</li> </ul> <ul> <li>items: A list of V1Service objects, each representing a service.      You can access the fields of a V1Service object using dot notation,      for example, service.metadata.name to access the name of the service</li> </ul> <ul> <li>kind: The Kubernetes object kind, which is always \"ServiceList\".</li> </ul> <ul> <li>metadata: Additional metadata about the pod list, such as the resource version.</li> </ul> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ServiceList.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def list_services(self, field_selector: str = \"\", label_selector: str = \"\"):\n\"\"\"List all Kubernetes Service in the current namespace.\n        The list can be filtered by providing field selectors and label selectors.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#list_namespaced_service\n    Args:\n        field_selector (str): filter result based on fields\n        label_selector (str): filter result based on labels\n    Returns:\n        V1ServiceList (object): list of Kubernetes Services or None if the call fails\n        Properties can be accessed with the \".\" notation (this is an object not a dict!):\n        - api_version: The Kubernetes API version.\n        - items: A list of V1Service objects, each representing a service.\n                 You can access the fields of a V1Service object using dot notation,\n                 for example, service.metadata.name to access the name of the service\n        - kind: The Kubernetes object kind, which is always \"ServiceList\".\n        - metadata: Additional metadata about the pod list, such as the resource version.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ServiceList.md\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().list_namespaced_service(\nfield_selector=field_selector,\nlabel_selector=label_selector,\nnamespace=self.get_namespace(),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to list Services with field_selector -&gt; %s and label_selector -&gt; %s; error -&gt; %s\",\nfield_selector,\nlabel_selector,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.patch_ingress","title":"<code>patch_ingress(ingress_name, ingress_body)</code>","text":"<p>Patch a Kubernetes Ingress with a updated spec.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/NetworkingV1Api.md#patch_namespaced_ingress</p> <p>Parameters:</p> Name Type Description Default <code>ingress_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <code>ingress_body</code> <code>dict</code> <p>new / updated ingress body spec                  (will be merged with existing values)</p> required <p>Returns:</p> Name Type Description <code>V1Ingress</code> <code>object</code> <p>patched Kubernetes Ingress object or None if the call fails</p> <p>This is NOT a dict but an object - you have to use the</p> <p>\".\" syntax to access to returned elements</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def patch_ingress(self, ingress_name: str, ingress_body: dict):\n\"\"\"Patch a Kubernetes Ingress with a updated spec.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/NetworkingV1Api.md#patch_namespaced_ingress\n    Args:\n        ingress_name (str): name of the Kubernetes Ingress in the current namespace\n        ingress_body (dict): new / updated ingress body spec\n                             (will be merged with existing values)\n    Returns:\n        V1Ingress (object): patched Kubernetes Ingress object or None if the call fails\n        This is NOT a dict but an object - you have to use the\n        \".\" syntax to access to returned elements\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n    \"\"\"\ntry:\nresponse = self.get_networking_v1_api().patch_namespaced_ingress(\nname=ingress_name,\nnamespace=self.get_namespace(),\nbody=ingress_body,\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to patch Ingress -&gt; %s with -&gt; %s; error -&gt; %s\",\ningress_name,\ningress_body,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.patch_service","title":"<code>patch_service(service_name, service_body)</code>","text":"<p>Patches a Kubernetes Service with an updated spec</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <code>service_body</code> <code>dict</code> <p>new / updated Service body spec                  (will be merged with existing values)</p> required <p>Returns:</p> Name Type Description <code>V1Service</code> <code>object</code> <p>patched Kubernetes Service or None if the call fails</p> <p>This is NOT a dict but an object - you have to use the \".\" syntax</p> <p>to access to returned elements</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def patch_service(self, service_name: str, service_body: dict):\n\"\"\"Patches a Kubernetes Service with an updated spec\n    Args:\n        service_name (str): name of the Kubernetes Ingress in the current namespace\n        service_body (dict): new / updated Service body spec\n                             (will be merged with existing values)\n    Returns:\n        V1Service (object): patched Kubernetes Service or None if the call fails\n        This is NOT a dict but an object - you have to use the \".\" syntax\n        to access to returned elements\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Service.md\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().patch_namespaced_service(\nname=service_name, namespace=self.get_namespace(), body=service_body\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to patch Service -&gt; %s with -&gt; %s; error -&gt; %s\",\nservice_name,\nservice_body,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.patch_stateful_set","title":"<code>patch_stateful_set(sts_name, sts_body)</code>","text":"<p>Patch a Stateful set with new values.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#patch_namespaced_stateful_set</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes stateful set in the current namespace</p> required <code>sts_body</code> <code>str</code> <p>patch string</p> required <p>Returns:</p> Name Type Description <code>V1StatefulSet</code> <code>object</code> <p>patched Kubernetes Stateful Set object or None if the call fails.</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def patch_stateful_set(self, sts_name: str, sts_body: dict):\n\"\"\"Patch a Stateful set with new values.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/AppsV1Api.md#patch_namespaced_stateful_set\n    Args:\n        sts_name (str): name of the Kubernetes stateful set in the current namespace\n        sts_body (str): patch string\n    Returns:\n        V1StatefulSet (object): patched Kubernetes Stateful Set object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n    \"\"\"\ntry:\nresponse = self.get_apps_v1_api().patch_namespaced_stateful_set(\nname=sts_name, namespace=self.get_namespace(), body=sts_body\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to patch Stateful Set -&gt; %s with -&gt; %s; error -&gt; %s\",\nsts_name,\nsts_body,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.replace_config_map","title":"<code>replace_config_map(config_map_name, config_map_data)</code>","text":"<p>Replace a Config Map with a new specification.     See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#replace_namespaced_config_map</p> <p>Parameters:</p> Name Type Description Default <code>config_map_name</code> <code>str</code> <p>name of the Kubernetes Config Map</p> required <code>config_map_data</code> <code>dict</code> <p>new specification of the Config Map</p> required <p>Returns:</p> Name Type Description <code>V1ConfigMap</code> <code>object</code> <p>updated Kubernetes Config Map object or None if the call fails.</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMap.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def replace_config_map(self, config_map_name: str, config_map_data: dict):\n\"\"\"Replace a Config Map with a new specification.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/CoreV1Api.md#replace_namespaced_config_map\n    Args:\n        config_map_name (str): name of the Kubernetes Config Map\n        config_map_data (dict): new specification of the Config Map\n    Returns:\n        V1ConfigMap (object): updated Kubernetes Config Map object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1ConfigMap.md\n    \"\"\"\ntry:\nresponse = self.get_core_v1_api().replace_namespaced_config_map(\nname=config_map_name,\nnamespace=self.get_namespace(),\nbody=client.V1ConfigMap(\nmetadata=client.V1ObjectMeta(\nname=config_map_name,\n),\ndata=config_map_data,\n),\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to replace Config Map -&gt; %s; error -&gt; %s\",\nconfig_map_name,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.scale_stateful_set","title":"<code>scale_stateful_set(sts_name, scale)</code>","text":"<p>Scale a stateful set to a specific number of replicas.    It uses the class method patch_stateful_set() above.</p> <p>Parameters:</p> Name Type Description Default <code>sts_name</code> <code>str</code> <p>name of the Kubernetes stateful set in the current namespace</p> required <code>scale</code> <code>int</code> <p>number of replicas (pods) the stateful set shall be scaled to</p> required <p>Returns:</p> Name Type Description <code>V1StatefulSet</code> <code>object</code> <p>Kubernetes Stateful Set object or None if the call fails.</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def scale_stateful_set(self, sts_name: str, scale: int):\n\"\"\"Scale a stateful set to a specific number of replicas.\n       It uses the class method patch_stateful_set() above.\n    Args:\n        sts_name (str): name of the Kubernetes stateful set in the current namespace\n        scale (int): number of replicas (pods) the stateful set shall be scaled to\n    Returns:\n        V1StatefulSet (object): Kubernetes Stateful Set object or None if the call fails.\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1StatefulSet.md\n    \"\"\"\ntry:\nresponse = self.patch_stateful_set(\nsts_name, sts_body={\"spec\": {\"replicas\": scale}}\n)\nexcept ApiException as exception:\nlogger.error(\n\"Failed to scale Stateful Set -&gt; %s to -&gt; %s replicas; error -&gt; %s\",\nsts_name,\nscale,\nstr(exception),\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.update_ingress_backend_services","title":"<code>update_ingress_backend_services(ingress_name, hostname, service_name, service_port)</code>","text":"<p>Updates a backend service and port of an Kubernetes Ingress</p> <p>\"spec\": {     \"rules\": [         {             \"host\": host,             \"http\": {                 \"paths\": [                     {                         \"path\": \"/\",                         \"pathType\": \"Prefix\",                         \"backend\": {                             \"service\": {                                 \"name\": ,                                 \"port\": {                                     \"name\": None,                                     \"number\": ,                                 },                             },                         },                     }                 ]             },         }     ] } <p>Parameters:</p> Name Type Description Default <code>ingress_name</code> <code>str</code> <p>name of the Kubernetes Ingress in the current namespace</p> required <code>hostname</code> <code>str</code> <p>hostname that should get an updated backend service / port</p> required <code>service_name</code> <code>str</code> <p>new backend service name</p> required <code>service_port</code> <code>int</code> <p>new backend service port</p> required <p>Returns:</p> Name Type Description <code>V1Ingress</code> <code>object</code> <p>updated Kubernetes Ingress object or None if the call fails</p> <p>This is NOT a dict but an object - you have to use the \".\" syntax</p> <p>to access to returned elements</p> <code>See</code> <p>https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def update_ingress_backend_services(\nself, ingress_name: str, hostname: str, service_name: str, service_port: int\n):\n\"\"\"Updates a backend service and port of an Kubernetes Ingress\n    \"spec\": {\n        \"rules\": [\n            {\n                \"host\": host,\n                \"http\": {\n                    \"paths\": [\n                        {\n                            \"path\": \"/\",\n                            \"pathType\": \"Prefix\",\n                            \"backend\": {\n                                \"service\": {\n                                    \"name\": &lt;service_name&gt;,\n                                    \"port\": {\n                                        \"name\": None,\n                                        \"number\": &lt;service_port&gt;,\n                                    },\n                                },\n                            },\n                        }\n                    ]\n                },\n            }\n        ]\n    }\n    Args:\n        ingress_name (str): name of the Kubernetes Ingress in the current namespace\n        hostname (str): hostname that should get an updated backend service / port\n        service_name (str): new backend service name\n        service_port (int): new backend service port\n    Returns:\n        V1Ingress (object): updated Kubernetes Ingress object or None if the call fails\n        This is NOT a dict but an object - you have to use the \".\" syntax\n        to access to returned elements\n        See: https://github.com/kubernetes-client/python/blob/master/kubernetes/docs/V1Ingress.md\n    \"\"\"\ningress = self.get_ingress(ingress_name)\nif not ingress:\nreturn None\nhost = \"\"\nrules = ingress.spec.rules\nrule_index = 0\nfor rule in rules:\nif hostname in rule.host:\nhost = rule.host\npath = rule.http.paths[0]\nbackend = path.backend\nservice = backend.service\nlogger.info(\n\"Replace backend service -&gt; %s (%s) with new backend service -&gt; %s (%s)\",\nservice.name,\nservice.port.number,\nservice_name,\nservice_port,\n)\nservice.name = service_name\nservice.port.number = service_port\nbreak\nelse:\nrule_index += 1\nif not host:\nlogger.error(\"Cannot find host -&gt; {}.\")\nreturn None\nbody = [\n{\n\"op\": \"replace\",\n\"path\": \"/spec/rules/{}/http/paths/0/backend/service/name\".format(\nrule_index\n),\n\"value\": service_name,\n},\n{\n\"op\": \"replace\",\n\"path\": \"/spec/rules/{}/http/paths/0/backend/service/port/number\".format(\nrule_index\n),\n\"value\": service_port,\n},\n]\nreturn self.patch_ingress(ingress_name, body)\n</code></pre>"},{"location":"pyxecm/k8s/#pyxecm.customizer.k8s.K8s.wait_pod_condition","title":"<code>wait_pod_condition(pod_name, condition_name, sleep_time=30)</code>","text":"<p>Wait for the pod to reach a defined condition (e.g. \"Ready\").</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>name of the Kubernetes pod in the current namespace</p> required <code>condition_name</code> <code>str</code> <p>name of the condition, e.g. \"Ready\"</p> required <p>Returns:</p> Type Description <p>True once the pod reaches the condition - otherwise wait forever</p> Source code in <code>pyxecm/customizer/k8s.py</code> <pre><code>def wait_pod_condition(\nself, pod_name: str, condition_name: str, sleep_time: int = 30\n):\n\"\"\"Wait for the pod to reach a defined condition (e.g. \"Ready\").\n    Args:\n        pod_name (str): name of the Kubernetes pod in the current namespace\n        condition_name (str): name of the condition, e.g. \"Ready\"\n    Returns:\n        True once the pod reaches the condition - otherwise wait forever\n    \"\"\"\nready = False\nwhile not ready:\ntry:\npod_status = self.get_core_v1_api().read_namespaced_pod_status(\npod_name, self.get_namespace()\n)\n# Check if the pod has reached the defined condition:\nfor cond in pod_status.status.conditions:\nif cond.type == condition_name and cond.status == \"True\":\nlogger.info(\n\"Pod -&gt; %s is in state -&gt; %s!\", pod_name, condition_name\n)\nready = True\nbreak\nelse:\nlogger.info(\n\"Pod -&gt; %s is not yet in state -&gt; %s. Waiting...\",\npod_name,\ncondition_name,\n)\ntime.sleep(sleep_time)\ncontinue\nexcept ApiException as exception:\nlogger.error(\n\"Failed to wait for pod -&gt; %s; error -&gt; %s\",\npod_name,\nstr(exception),\n)\n</code></pre>"},{"location":"pyxecm/m365/","title":"M365","text":"<p>M365 Module to interact with the MS Graph API See also https://learn.microsoft.com/en-us/graph/ </p> <p>Class: M365 Methods:</p> <p>init : class initializer config : Returns config data set credentials: Returns the token data</p> In some cases MS Graph APIs cannot be called via <p>application permissions (client_id, client_secret) but requires a token of a user authenticated with username + password</p> <p>request_header: Returns the request header for MS Graph API calls request_header_user: Returns the request header used for user specific calls</p> Parse the REST API responses and convert <p>them to Python dict in a safe way</p> Check if an dict item is in the response <p>of the Graph REST API call</p> <p>get_result_value: Check if a defined value (based on a key) is in the Graph API response</p> <p>authenticate : Authenticates at M365 Graph API authenticate_user: Authenticate at M365 Graph API with username and password</p> <p>get_users: Get list all all users in M365 tenant  get_user: Get a M365 User based on its email add_user: Add a M365 User update_user: Update selected properties of an M365 user get_user_licenses: Get the assigned license SKUs of a user assign_license_to_user: Add an M365 license to a user (e.g. to use Office 365) get_user_photo: Get the photo of a M365 user update_user_photo: Update a user with a profile photo (which must be in local file system)</p> <p>get_groups: Get list all all groups in M365 tenant get_group: Get a M365 Group based on its name add_group: Add a M365 Group get_group_members: Get members (users and groups) of the specified group add_group_member: Add a user or group to a target group is_member: Check whether a M365 user is already in a M365 group get_group_owners: Get owners (users) of the specified group add_group_owner: Add a user as owner to a group</p> <p>purge_deleted_items: Purge all deleted users and groups in the organization purge_deleted_item: Help function that purges a single user or group</p> <p>has_team: Check if a M365 Group has a M365 Team connected or not get_team: get a M365 Team based on its name add_team: Add a M365 Team (based on an existing group) delete_team: delete a single M365 Team witha given ID delete_teams: Delete MS teams with a given name</p> Delete all teams (groups) that are NOT on the exception list AND <p>that are matching at least one of the patterns in the provided pattern list</p> <p>get_team_channels: get a list of channels for a M365 Team get_team_channel_tabs: get tabs of an M365 Team channel based on the team and channel names</p> <p>get_teams_apps: Get a list of MS Teams apps in catalog that match a given filter criterium get_teams_app: get a specific app from the catalog based on its (known) ID get_teams_apps_of_user: Get a list of MS Teams apps of a user that match a given filter criterium get_teams_apps_of_team: Get a list of MS Teams apps of a M365 team that match a given filter criterium extract_version_from_app_manifest: Extract the version number from the MS Teams app manifest file upload_teams_app: Upload a new app package to the catalog of MS Teams apps remove_teams_app: Remove MS Teams App for the app catalog assign_teams_app_to_user: Assign (add) a MS Teams app to a M365 user. upgrade_teams_app_of_user: Upgrade a MS teams app for a user.</p> Assign (add) a MS Teams app to a M365 team <p>(so that it afterwards can be added as a Tab in a M365 Teams Channel)</p> <p>upgrade_teams_app_of_team: Upgrade a MS teams app for a specific team. add_teams_app_to_channel: Add tab for Extended ECM app to an M365 Team channel update_teams_app_of_channel: Update in existing teams app (e.g. to change the URLs with new node ID) delete_teams_app_from_channel: Delete an app (and its tab) from a M365 Teams channel</p> Assign a existing sensitivity label to a user. <p>THIS IS CURRENTLY NOT WORKING!</p> Create a new sensitivity label in M365 <p>THIS IS CURRENTLY NOT WORKING!</p>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365","title":"<code>M365</code>","text":"<p>         Bases: <code>object</code></p> <p>Used to automate stettings in Microsoft 365 via the Graph API.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>class M365(object):\n\"\"\"Used to automate stettings in Microsoft 365 via the Graph API.\"\"\"\n_config: dict\n_access_token = None\n_user_access_token = None\ndef __init__(\nself,\ntenant_id: str,\nclient_id: str,\nclient_secret: str,\ndomain: str,\nsku_id: str,\nteams_app_name: str,\n):\n\"\"\"Initialize the M365 object\n        Args:\n            tenant_id (str): M365 Tenant ID\n            client_id (str): M365 Client ID\n            client_secret (str): M365 Client Secret\n            domain (str): M365 domain\n            sku_id (str): License SKU for M365 users\n            teams_app_name (str): name of the Extended ECM app for MS Teams\n        \"\"\"\nm365_config = {}\n# Set the authentication endpoints and credentials\nm365_config[\"tenantId\"] = tenant_id\nm365_config[\"clientId\"] = client_id\nm365_config[\"clientSecret\"] = client_secret\nm365_config[\"domain\"] = domain\nm365_config[\"skuId\"] = sku_id\nm365_config[\"teamsAppName\"] = teams_app_name\nm365_config[\n\"authenticationUrl\"\n] = \"https://login.microsoftonline.com/{}/oauth2/v2.0/token\".format(tenant_id)\nm365_config[\"graphUrl\"] = \"https://graph.microsoft.com/v1.0/\"\nm365_config[\"betaUrl\"] = \"https://graph.microsoft.com/beta/\"\nm365_config[\"directoryObjects\"] = m365_config[\"graphUrl\"] + \"directoryObjects\"\n# Set the data for the token request\nm365_config[\"tokenData\"] = {\n\"client_id\": client_id,\n\"scope\": \"https://graph.microsoft.com/.default\",\n\"client_secret\": client_secret,\n\"grant_type\": \"client_credentials\",\n}\nm365_config[\"groupsUrl\"] = m365_config[\"graphUrl\"] + \"groups\"\nm365_config[\"usersUrl\"] = m365_config[\"graphUrl\"] + \"users\"\nm365_config[\"teamsUrl\"] = m365_config[\"graphUrl\"] + \"teams\"\nm365_config[\"teamsTemplatesUrl\"] = m365_config[\"graphUrl\"] + \"teamsTemplates\"\nm365_config[\"teamsAppsUrl\"] = m365_config[\"graphUrl\"] + \"appCatalogs/teamsApps\"\nm365_config[\"directoryUrl\"] = m365_config[\"graphUrl\"] + \"directory\"\nm365_config[\"securityUrl\"] = m365_config[\"betaUrl\"] + \"security\"\nm365_config[\"applicationsUrl\"] = m365_config[\"graphUrl\"] + \"applications\"\nself._config = m365_config\ndef config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\nreturn self._config\ndef credentials(self) -&gt; dict:\n\"\"\"Return the login credentials\n        Returns:\n            dict: dictionary with login credentials for M365\n        \"\"\"\nreturn self.config()[\"tokenData\"]\ndef credentials_user(self, username: str, password: str) -&gt; dict:\n\"\"\"In some cases MS Graph APIs cannot be called via\n            application permissions (client_id, client_secret)\n            but requires a token of a user authenticated\n            with username + password. This is e.g. the case\n            to upload a MS teams app to the catalog.\n            See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n        Args:\n            username (str): username\n            password (str): password\n        Returns:\n            dict: user credentials for M365\n        \"\"\"\ncredentials = {\n\"client_id\": self.config()[\"clientId\"],\n\"scope\": \"https://graph.microsoft.com/.default\",\n\"client_secret\": self.config()[\"clientSecret\"],\n\"grant_type\": \"password\",\n\"username\": username,\n\"password\": password,\n}\nreturn credentials\n# end method definition\ndef request_header(self, content_type: str = \"application/json\") -&gt; dict:\n\"\"\"Returns the request header used for Application calls.\n           Consists of Bearer access token and Content Type\n        Args:\n            content_type (str, optional): content type for the request\n        Return:\n            dict: request header values\n        \"\"\"\nrequest_header = {\n\"Authorization\": \"Bearer {}\".format(self._access_token),\n\"Content-Type\": content_type,\n}\nreturn request_header\n# end method definition\ndef request_header_user(self, content_type: str = \"application/json\") -&gt; dict:\n\"\"\"Returns the request header used for user specific calls.\n           Consists of Bearer access token and Content Type\n        Args:\n            content_type (str, optional): content type for the request\n        Return:\n            dict: request header values\n        \"\"\"\nrequest_header = {\n\"Authorization\": \"Bearer {}\".format(self._user_access_token),\n\"Content-Type\": content_type,\n}\nreturn request_header\n# end method definition\ndef parse_request_response(\nself,\nresponse_object: requests.Response,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the request response (JSon) to a Python dict in a safe way\n           that also handles exceptions. It first tries to load the response.text\n           via json.loads() that produces a dict output. Only if response.text is\n           not set or is empty it just converts the response_object to a dict using\n           the vars() built-in method.\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str, optional): use a more specific error message\n                                                      in case of an error\n            show_error (bool): True: write an error to the log file\n                               False: write a warning to the log file\n        Returns:\n            dict: response information or None in case of an error\n        \"\"\"\nif not response_object:\nreturn None\ntry:\nif response_object.text:\ndict_object = json.loads(response_object.text)\nelse:\ndict_object = vars(response_object)\nexcept json.JSONDecodeError as exception:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, exception\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(\nexception\n)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n# end method definition\ndef exist_result_item(\nself, response: dict, key: str, value: str, sub_dict_name: str = \"\"\n) -&gt; bool:\n\"\"\"Check existence of key / value pair in the response properties of an MS Graph API call.\n        Args:\n            response (dict): REST response from an MS Graph REST Call\n            key (str): property name (key)\n            value (str): value to find in the item with the matching key\n            sub_dict_name (str): some MS Graph API calls include nested\n                                 dict structures that can be requested\n                                 with an \"expand\" query parameter. In such\n                                 a case we use the sub_dict_name to access it.\n        Returns:\n            bool: True if the value was found, False otherwise\n        \"\"\"\nif not response:\nreturn False\nif not \"value\" in response:\nreturn False\nvalues = response[\"value\"]\nif not values or not isinstance(values, list):\nreturn False\nif not sub_dict_name:\nfor item in values:\nif value == item[key]:\nreturn True\nelse:\nfor item in values:\nif not sub_dict_name in item:\nreturn False\nif value == item[sub_dict_name][key]:\nreturn True\nreturn False\n# end method definition\ndef get_result_value(\nself, response: dict, key: str, index: int = 0, sub_dict_name: str = \"\"\n) -&gt; str | None:\n\"\"\"Get value of a result property with a given key of an MS Graph API call.\n        Args:\n            response (dict): REST response from an MS Graph REST Call\n            key (str): property name (key)\n            index (int, optional): Index to use (1st element has index 0).\n                                   Defaults to 0.\n            sub_dict_name (str): some MS Graph API calls include nested\n                                 dict structures that can be requested\n                                 with an \"expand\" query parameter. In such\n                                 a case we use the sub_dict_name to access it.\n        Returns:\n            str: value for the key, None otherwise\n        \"\"\"\nif not response:\nreturn None\nif (\nnot \"value\" in response\n):  # If Graph APIs are called with specific IDs (and not name lookups)\n# they may not return a list of dicts calles \"values\" but a single dict directly\nif sub_dict_name and sub_dict_name in response:\nsub_structure = response[sub_dict_name]\n# also the substructure could be a list\nif isinstance(sub_structure, list):\nsub_structure = sub_structure[index]\nreturn sub_structure[key]\nelif key in response:\nreturn response[key]\nelse:\nreturn None\nvalues = response[\"value\"]\nif not values or not isinstance(values, list) or len(values) - 1 &lt; index:\nreturn None\nif not sub_dict_name:\nreturn values[index][key]\nelse:\nsub_structure = values[index][sub_dict_name]\nif isinstance(sub_structure, list):\n# here we assume it is the first element of the\n# substructure. If really required for specific\n# use cases we may introduce a second index in\n# the future.\nsub_structure = sub_structure[0]\nreturn sub_structure[key]\n# end method definition\ndef authenticate(self, revalidate: bool = False) -&gt; str | None:\n\"\"\"Authenticate at M365 Graph API with client ID and client secret.\n        Args:\n            revalidate (bool, optional): determinse if a re-athentication is enforced\n                                         (e.g. if session has timed out with 401 error)\n        Returns:\n            str: Access token. Also stores access token in self._access_token. None in case of error\n        \"\"\"\n# Already authenticated and session still valid?\nif self._access_token and not revalidate:\nreturn self._access_token\nrequest_url = self.config()[\"authenticationUrl\"]\nrequest_header = request_login_headers\nlogger.info(\"Requesting M365 Access Token from -&gt; %s\", request_url)\nauthenticate_post_body = self.credentials()\nauthenticate_response = None\ntry:\nauthenticate_response = requests.post(\nrequest_url,\ndata=authenticate_post_body,\nheaders=request_header,\ntimeout=60,\n)\nexcept requests.exceptions.ConnectionError as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s : %s\",\nself.config()[\"authenticationUrl\"],\nexception,\n)\nreturn None\nif authenticate_response.ok:\nauthenticate_dict = self.parse_request_response(authenticate_response)\nif not authenticate_dict:\nreturn None\nelse:\naccess_token = authenticate_dict[\"access_token\"]\nlogger.debug(\"Access Token -&gt; %s\", access_token)\nelse:\nlogger.error(\n\"Failed to request an M365 Access Token; error -&gt; %s\",\nauthenticate_response.text,\n)\nreturn None\n# Store authentication access_token:\nself._access_token = access_token\nreturn self._access_token\n# end method definition\ndef authenticate_user(self, username: str, password: str) -&gt; str | None:\n\"\"\"Authenticate at M365 Graph API with username and password.\n        Args:\n            username (str): name (emails) of the M365 user\n            password (str): password of the M365 user\n        Returns:\n            str: Access token. Also stores access token in self._access_token\n        \"\"\"\nrequest_url = self.config()[\"authenticationUrl\"]\nrequest_header = request_login_headers\nlogger.info(\n\"Requesting M365 Access Token for user -&gt; %s from -&gt; %s\",\nusername,\nrequest_url,\n)\nauthenticate_post_body = self.credentials_user(username, password)\nauthenticate_response = None\ntry:\nauthenticate_response = requests.post(\nrequest_url,\ndata=authenticate_post_body,\nheaders=request_header,\ntimeout=60,\n)\nexcept requests.exceptions.ConnectionError as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s with username -&gt; %s: %s\",\nself.config()[\"authenticationUrl\"],\nusername,\nexception,\n)\nreturn None\nif authenticate_response.ok:\nauthenticate_dict = self.parse_request_response(authenticate_response)\nif not authenticate_dict:\nreturn None\naccess_token = authenticate_dict[\"access_token\"]\nlogger.debug(\"User Access Token -&gt; %s\", access_token)\nelse:\nlogger.error(\n\"Failed to request an M365 Access Token for user -&gt; %s; error -&gt; %s\",\nusername,\nauthenticate_response.text,\n)\nreturn None\n# Store authentication access_token:\nself._user_access_token = access_token\nreturn self._user_access_token\n# end method definition\ndef get_users(self) -&gt; dict | None:\n\"\"\"Get list all all users in M365 tenant\n        Returns:\n            dict: Dictionary of all users.\n        \"\"\"\nrequest_url = self.config()[\"usersUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Get list of all users; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of users; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_user(self, user_email: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Get a M365 User based on its email\n        Args:\n            user_email (str): M365 user email\n            show_error (bool): whether or not an error should be displayed if the\n                               user is not found.\n        Returns:\n            dict: User information or None if the user couldn't be retrieved (e.g. because it doesn't exist\n                  or if there is a permission problem).\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#users/$entity',\n                'businessPhones': [],\n                'displayName': 'Bob Davis',\n                'givenName': 'Bob',\n                'id': '72c80809-094f-4e6e-98d4-25a736385d10',\n                'jobTitle': None,\n                'mail': 'bdavis@M365x61936377.onmicrosoft.com',\n                'mobilePhone': None,\n                'officeLocation': None,\n                'preferredLanguage': None,\n                'surname': 'Davis',\n                'userPrincipalName': 'bdavis@M365x61936377.onmicrosoft.com'\n            }\n        \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_email\nrequest_header = self.request_header()\nlogger.info(\"Get M365 user -&gt; %s; calling -&gt; %s\", user_email, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_email,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"M365 User -&gt; %s not found.\", user_email)\nreturn None\n# end method definition\ndef add_user(\nself,\nemail: str,\npassword: str,\nfirst_name: str,\nlast_name: str,\nlocation: str = \"US\",\ndepartment: str = \"\",\ncompany_name: str = \"Innovate\",\n) -&gt; dict | None:\n\"\"\"Add a M365 user.\n        Args:\n            email (str): email address of the user. This is also the unique identifier\n            password (str): password of the user\n            first_name (str): first name of the user\n            last_name (str): last name of the user\n            location (str, optional): country ISO 3166-1 alpha-2 format (e.g. US, CA, FR, DE, CN, ...)\n            department (str, optional): department of the user\n            company_name (str): name of the company\n        Returns:\n            dict: User information or None if the user couldn't be created (e.g. because it exisits already\n                  or if a permission problem occurs).\n        \"\"\"\nuser_post_body = {\n\"accountEnabled\": True,\n\"displayName\": first_name + \" \" + last_name,\n\"givenName\": first_name,\n\"surname\": last_name,\n\"mailNickname\": email.split(\"@\")[0],\n\"userPrincipalName\": email,\n\"passwordProfile\": {\n\"forceChangePasswordNextSignIn\": False,\n\"password\": password,\n},\n\"usageLocation\": location,\n}\nif department:\nuser_post_body[\"department\"] = department\nif company_name:\nuser_post_body[\"companyName\"] = company_name\nrequest_url = self.config()[\"usersUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Adding M365 user -&gt; %s; calling -&gt; %s\", email, request_url)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\ndata=json.dumps(user_post_body),\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nemail,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef update_user(self, user_id: str, updated_settings: dict) -&gt; dict | None:\n\"\"\"Update selected properties of an M365 user. Documentation\n           on user properties is here: https://learn.microsoft.com/en-us/graph/api/user-update\n        Returns:\n            dict | None: Response of the M365 Graph API  or None if the call fails.\n        \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id\nrequest_header = self.request_header()\nlogger.info(\n\"Updating M365 user -&gt; %s with -&gt; %s; calling -&gt; %s\",\nuser_id,\nstr(updated_settings),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nrequest_url,\njson=updated_settings,\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update M365 user -&gt; %s with -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nstr(updated_settings),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_user_licenses(self, user_id: str) -&gt; dict | None:\n\"\"\"Get the assigned license SKUs of a user\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        Returns:\n            dict: List of user licenses or None if request fails.\n            Example return data:\n            {\n                '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#users('a5875311-f0a5-486d-a746-bd7372b91115')/licenseDetails\",\n                'value': [\n                    {\n                        'id': '8DRPYHK6IUOra-Nq6L0A7GAn38eBLPdOtXhbU5K1cd8',\n                        'skuId': 'c7df2760-2c81-4ef7-b578-5b5392b571df',\n                        'skuPartNumber': 'ENTERPRISEPREMIUM',\n                        'servicePlans': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n                    }\n                ]\n            }\n        \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/licenseDetails\"\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get M365 licenses of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef assign_license_to_user(self, user_id: str, sku_id: str) -&gt; dict | None:\n\"\"\"Add an M365 license to a user (e.g. to use Office 365)\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            sku_id (str): M365 GUID of the SKU\n                          (e.g. c7df2760-2c81-4ef7-b578-5b5392b571df for E5 and\n                                6fd2c87f-b296-42f0-b197-1e91e994b900 for E3)\n        Returns:\n            dict: response or None if request fails\n        \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/assignLicense\"\nrequest_header = self.request_header()\n# Construct the request body for assigning the E5 license\nlicense_post_body = {\n\"addLicenses\": [\n{\n\"disabledPlans\": [],\n\"skuId\": sku_id,  # \"c42b9cae-ea4f-4a69-9ca5-c53bd8779c42\"\n}\n],\n\"removeLicenses\": [],\n}\nlogger.info(\n\"Assign M365 license -&gt; %s to M365 user -&gt; %s; calling -&gt; %s\",\nsku_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, json=license_post_body, headers=request_header, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 license -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nsku_id,\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_user_photo(self, user_id: str, show_error: bool = True) -&gt; bytes | None:\n\"\"\"Get the photo of a M365 user\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            show_error (bool): whether or not an error should be logged if the user\n                                  does not have a photo in M365\n        Returns:\n            bytes: Image of the user photo or None if the user photo couldn't be retrieved.\n        \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n# Set image as content type:\nrequest_header = self.request_header(\"image/*\")\nlogger.info(\"Get photo of user -&gt; %s; calling -&gt; %s\", user_id, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn response.content  # this is the actual image - not json!\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get photo of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"User -&gt; %s does not yet have a photo.\", user_id)\nreturn None\n# end method definition\ndef update_user_photo(self, user_id: str, photo_path: str) -&gt; dict | None:\n\"\"\"Update the M365 user photo\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            photo_path (str): file system path with the location of the photo\n        Returns:\n            dict: Response of Graph REST API or None if the user photo couldn't be updated.\n        \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n# Set image as content type:\nrequest_header = self.request_header(\"image/*\")\n# Check if the photo file exists\nif not os.path.isfile(photo_path):\nlogger.error(\"Photo file -&gt; %s not found!\", photo_path)\nreturn None\ntry:\n# Read the photo file as binary data\nwith open(photo_path, \"rb\") as image_file:\nphoto_data = image_file.read()\nexcept OSError as exception:\n# Handle any errors that occurred while reading the photo file\nlogger.error(\n\"Error reading photo file -&gt; %s; error -&gt; %s\", photo_path, exception\n)\nreturn None\ndata = photo_data\nlogger.info(\n\"Update M365 user -&gt; %s with photo -&gt; %s; calling -&gt; %s\",\nuser_id,\nphoto_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nrequest_url, headers=request_header, data=data, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user -&gt; %s with photo -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nphoto_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_groups(self, max_number: int = 250) -&gt; dict | None:\n\"\"\"Get list all all groups in M365 tenant\n        Args:\n            max_number (int, optional): maximum result values (limit)\n        Returns:\n            dict: dictionary of all groups or None in case of an error.\n        \"\"\"\nrequest_url = self.config()[\"groupsUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Get list of all M365 groups; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nrequest_url,\nheaders=request_header,\nparams={\"$top\": str(max_number)},\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 groups; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_group(self, group_name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Get a M365 Group based on its name\n        Args:\n            group_name (str): M365 Group name\n            show_error (bool): should an error be logged if group is not found.\n        Returns:\n            dict: Group information or None if the group doesn't exist.\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups',\n                'value': [\n                    {\n                        'id': 'b65f7dba-3ed1-49df-91bf-2bf99affcc8d',\n                        'deletedDateTime': None,\n                        'classification': None,\n                        'createdDateTime': '2023-04-01T13:46:26Z',\n                        'creationOptions': [],\n                        'description': 'Engineering &amp; Construction',\n                        'displayName': 'Engineering &amp; Construction',\n                        'expirationDateTime': None,\n                        'groupTypes': ['Unified'],\n                        'isAssignableToRole': None,\n                        'mail': 'Engineering&amp;Construction@M365x61936377.onmicrosoft.com',\n                        'mailEnabled': True,\n                        'mailNickname': 'Engineering&amp;Construction',\n                        'membershipRule': None,\n                        'membershipRuleProcessingState': None,\n                        'onPremisesDomainName': None,\n                        'onPremisesLastSyncDateTime': None,\n                        'onPremisesNetBiosName': None,\n                        'onPremisesSamAccountName': None,\n                        'onPremisesSecurityIdentifier': None,\n                        'onPremisesSyncEnabled': None,\n                        'preferredDataLocation': None,\n                        'preferredLanguage': None,\n                        'proxyAddresses': ['SPO:SPO_d9deb3e7-c72f-4e8d-80fb-5d9411ca1458@SPO_604f34f0-ba72-4321-ab6b-e36ae8bd00ec', 'SMTP:Engineering&amp;Construction@M365x61936377.onmicrosoft.com'],\n                        'renewedDateTime': '2023-04-01T13:46:26Z',\n                        'resourceBehaviorOptions': [],\n                        'resourceProvisioningOptions': [],\n                        'securityEnabled': False,\n                        'securityIdentifier': 'S-1-12-1-3059711418-1239367377-4180393873-2379022234',\n                        'theme': None,\n                        'visibility': 'Public',\n                        'onPremisesProvisioningErrors': []\n                    },\n                    {\n                        'id': '61359860-302e-4016-b5cc-abff2293dff1',\n                        ...\n                    }\n                ]\n            }\n        \"\"\"\nquery = {\"$filter\": \"displayName eq '\" + group_name + \"'\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"groupsUrl\"] + \"?\" + encoded_query\nrequest_header = self.request_header()\nlogger.info(\"Get M365 group -&gt; %s; calling -&gt; %s\", group_name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\ngroup_name,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"M365 Group -&gt; %s not found.\", group_name)\nreturn None\n# end method definition\ndef add_group(\nself, name: str, security_enabled: bool = False, mail_enabled: bool = True\n) -&gt; dict | None:\n\"\"\"Add a M365 Group.\n        Args:\n            name (str): name of the group\n            security_enabled (bool, optional): whether or not this group is used for permission management\n            mail_enabled (bool, optional): whether or not this group is email enabled\n        Returns:\n            dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups/$entity',\n                'id': '28906460-a69c-439e-84ca-c70becf37655',\n                'deletedDateTime': None,\n                'classification': None,\n                'createdDateTime': '2023-04-01T11:40:13Z',\n                'creationOptions': [],\n                'description': None,\n                'displayName': 'Test',\n                'expirationDateTime': None,\n                'groupTypes': ['Unified'],\n                'isAssignableToRole': None,\n                'mail': 'Diefenbruch@M365x61936377.onmicrosoft.com',\n                'mailEnabled': True,\n                'mailNickname': 'Test',\n                'membershipRule': None,\n                'membershipRuleProcessingState': None,\n                'onPremisesDomainName': None,\n                'onPremisesLastSyncDateTime': None,\n                'onPremisesNetBiosName': None,\n                'onPremisesSamAccountName': None,\n                'onPremisesSecurityIdentifier': None,\n                'onPremisesSyncEnabled': None,\n                'onPremisesProvisioningErrors': [],\n                'preferredDataLocation': None,\n                'preferredLanguage': None,\n                'proxyAddresses': ['SMTP:Test@M365x61936377.onmicrosoft.com'],\n                'renewedDateTime': '2023-04-01T11:40:13Z',\n                'resourceBehaviorOptions': [],\n                'resourceProvisioningOptions': [],\n                'securityEnabled': True,\n                'securityIdentifier': 'S-1-12-1-680551520-1134470812-197642884-1433859052',\n                'theme': None,\n                'visibility': 'Public'\n            }\n        \"\"\"\ngroup_post_body = {\n\"displayName\": name,\n\"mailEnabled\": mail_enabled,\n\"mailNickname\": name.replace(\" \", \"\"),\n\"securityEnabled\": security_enabled,\n\"groupTypes\": [\"Unified\"],\n}\nrequest_url = self.config()[\"groupsUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Adding M365 group -&gt; %s; calling -&gt; %s\", name, request_url)\nlogger.debug(\"M365 group attributes -&gt; %s\", group_post_body)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\ndata=json.dumps(group_post_body),\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_group_members(self, group_name: str) -&gt; dict | None:\n\"\"\"Get members (users and groups) of the specified group.\n        Args:\n            group_name (str): name of the group\n        Returns:\n            dict: Response of Graph REST API or None if the REST call fails.\n        \"\"\"\nresponse = self.get_group(group_name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s does not exist! Cannot retrieve group members.\",\ngroup_name,\n)\nreturn None\nquery = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members?\" + encoded_query\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Get members of M365 group -&gt; %s (%s); calling -&gt; %s\",\ngroup_name,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get members of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ngroup_name,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_group_member(self, group_id: str, member_id: str) -&gt; dict | None:\n\"\"\"Add a member (user or group) to a (parent) group\n        Args:\n            group_id (str): M365 GUID of the group\n            member_id (str): M365 GUID of the new member\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members/$ref\"\nrequest_header = self.request_header()\ngroup_member_post_body = {\n\"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + member_id\n}\nlogger.info(\n\"Adding member -&gt; %s to group -&gt; %s; calling -&gt; %s\",\nmember_id,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\nheaders=request_header,\ndata=json.dumps(group_member_post_body),\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add member -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nmember_id,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef is_member(self, group_id: str, member_id: str, show_error: bool = True) -&gt; bool:\n\"\"\"Checks whether a M365 user is already in a M365 group\n        Args:\n            group_id (str): M365 GUID of the group\n            member_id (str): M365 GUID of the user (member)\n            show_error (bool): whether or not an error should be logged if the user\n                                  is not a member of the group\n        Returns:\n            bool: True if the user is in the group. False otherwise.\n        \"\"\"\n# don't encode this URL - this has not been working!!\nrequest_url = (\nself.config()[\"groupsUrl\"]\n+ f\"/{group_id}/members?$filter=id eq '{member_id}'\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Check if user -&gt; %s is in group -&gt; %s; calling -&gt; %s\",\nmember_id,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nresponse = self.parse_request_response(response)\nif not \"value\" in response or len(response[\"value\"]) == 0:\nreturn False\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\n# MS Graph API returns an error if the member is not in the\n# group. This is typically not what we want. We just return False.\nif show_error:\nlogger.error(\n\"Failed to check if user -&gt; %s is in group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nmember_id,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef get_group_owners(self, group_name: str) -&gt; dict | None:\n\"\"\"Get owners (users) of the specified group.\n        Args:\n            group_name (str): name of the group\n        Returns:\n            dict: Response of Graph REST API or None if the REST call fails.\n        \"\"\"\nresponse = self.get_group(group_name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s does not exist! Cannot retrieve group owners.\",\ngroup_name,\n)\nreturn None\nquery = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners?\" + encoded_query\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Get owners of M365 group -&gt; %s (%s); calling -&gt; %s\",\ngroup_name,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get owners of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ngroup_name,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_group_owner(self, group_id: str, owner_id: str) -&gt; dict | None:\n\"\"\"Add an owner (user) to a group\n        Args:\n            group_id (str): M365 GUID of the group\n            owner_id (str): M365 GUID of the new member\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners/$ref\"\nrequest_header = self.request_header()\ngroup_member_post_body = {\n\"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + owner_id\n}\nlogger.info(\n\"Adding owner -&gt; %s to M365 group -&gt; %s; calling -&gt; %s\",\nowner_id,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\nheaders=request_header,\ndata=json.dumps(group_member_post_body),\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add owner -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nowner_id,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef purge_deleted_items(self):\n\"\"\"Purge all deleted users and groups.\n        Purging users and groups requires administrative rights that typically\n        are not provided in Contoso example org.\n        \"\"\"\nrequest_header = self.request_header()\nrequest_url = (\nself.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.group\"\n)\nresponse = requests.get(request_url, headers=request_header, timeout=60)\ndeleted_groups = self.parse_request_response(response)\nfor group in deleted_groups[\"value\"]:\ngroup_id = group[\"id\"]\nresponse = self.purge_deleted_item(group_id)\nrequest_url = (\nself.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.user\"\n)\nresponse = requests.get(request_url, headers=request_header, timeout=60)\ndeleted_users = self.parse_request_response(response)\nfor user in deleted_users[\"value\"]:\nuser_id = user[\"id\"]\nresponse = self.purge_deleted_item(user_id)\n# end method definition\ndef purge_deleted_item(self, item_id: str) -&gt; dict | None:\n\"\"\"Helper method to purge a single deleted user or group.\n           This requires elevated permissions that are typically\n           not available via Graph API.\n        Args:\n            item_id (str): M365 GUID of the user or group to purge\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nrequest_url = self.config()[\"directoryUrl\"] + \"/deletedItems/\" + item_id\nrequest_header = self.request_header()\nlogger.info(\"Purging deleted item -&gt; %s; calling -&gt; %s\", item_id, request_url)\nretries = 0\nwhile True:\nresponse = requests.delete(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to purge deleted item -&gt; %s; status -&gt; %s; error -&gt; %s\",\nitem_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef has_team(self, group_name: str) -&gt; bool:\n\"\"\"Check if a M365 Group has a M365 Team connected or not\n        Args:\n            group_name (str): name of the M365 group\n        Returns:\n            bool: Returns True if a Team is assigned and False otherwise\n        \"\"\"\nresponse = self.get_group(group_name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s not found. Cannot check if it has a M365 Team.\",\ngroup_name,\n)\nreturn False\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/team\"\nrequest_header = self.request_header()\nlogger.info(\n\"Check if M365 Group -&gt; %s has a M365 Team connected; calling -&gt; %s\",\ngroup_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.status_code == 200:  # Group has a Team assigned!\nlogger.info(\"Group -&gt; %s has a M365 Team connected.\", group_name)\nreturn True\nelif response.status_code == 404:  # Group does not have a Team assigned!\nlogger.info(\"Group -&gt; %s has no M365 Team connected.\", group_name)\nreturn False\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to check if M365 Group -&gt; %s has a M365 Team connected; status -&gt; %s; error -&gt; %s\",\ngroup_name,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef get_team(self, name: str) -&gt; dict | None:\n\"\"\"Get a M365 Team based on its name\n        Args:\n            name (str): name of the M365 Team\n        Returns:\n            dict: teams data structure (dictionary) or None if the request fails.\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#teams',\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '951bd036-c6fc-4da4-bb80-1860f5472a2f',\n                        'createdDateTime': None,\n                        'displayName': 'Procurement',\n                        'description': 'Procurement',\n                        'internalId': None,\n                        'classification': None,\n                        'specialization': None,\n                        'visibility': 'public',\n                        'webUrl': None, ...}]}\n                        'isArchived': None,\n                        'isMembershipLimitedToOwners': None,\n                        'memberSettings': None,\n                        'guestSettings': None,\n                        'messagingSettings': None,\n                        ...\n                    }\n                ]\n            }\n        \"\"\"\n# The M365 Teams API has an issues with ampersand characters in team names (like \"Engineering &amp; Construction\")\n# So we do a work-around here to first get the Team ID via the Group endpoint of the Graph API and\n# then fetch the M365 Team via its ID (which is identical to the underlying M365 Group ID)\nresponse = self.get_group(name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nlogger.error(\n\"Failed to get the ID of the M365 Team -&gt; %s via the M365 Group API\",\nname,\n)\nreturn None\nrequest_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id)\nrequest_header = self.request_header()\nlogger.info(\n\"Lookup Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_team(self, name: str, template_name: str = \"standard\") -&gt; dict | None:\n\"\"\"Add M365 Team based on an existing M365 Group.\n        Args:\n            name (str): name of the team. It is assumed that a group with the same name does already exist!\n            template_name (str, optional): name of the team template. \"standard\" is the default value.\n        Returns:\n            dict: Team information (json - empty text!) or None if the team couldn't be created\n                  (e.g. because it exisits already).\n        \"\"\"\nresponse = self.get_group(name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s not found. It is required for creating a corresponding M365 Team.\",\nname,\n)\nreturn None\nresponse = self.get_group_owners(name)\nif response is None or not \"value\" in response or not response[\"value\"]:\nlogger.warning(\n\"M365 Group -&gt; %s has no owners. This is required for creating a corresponding M365 Team.\",\nname,\n)\nreturn None\nteam_post_body = {\n\"template@odata.bind\": \"{}('{}')\".format(\nself.config()[\"teamsTemplatesUrl\"], template_name\n),\n\"group@odata.bind\": \"{}('{}')\".format(self.config()[\"groupsUrl\"], group_id),\n}\nrequest_url = self.config()[\"teamsUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Adding M365 Team -&gt; %s; calling -&gt; %s\", name, request_url)\nlogger.debug(\"M365 Team attributes -&gt; %s\", team_post_body)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\ndata=json.dumps(team_post_body),\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef delete_team(self, team_id: str) -&gt; dict | None:\n\"\"\"Delete Microsoft 365 Team with a specific ID.\n        Args:\n            team_id (str): ID of the Microsoft 365 Team to delete\n        Returns:\n            dict | None: Response dictionary if the team has been deleted, False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + team_id\nrequest_header = self.request_header()\nlogger.info(\n\"Delete Microsoft 365 Teams with ID -&gt; %s; calling -&gt; %s\",\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\"Failed to delete M365 Team with ID -&gt; %s\", team_id)\nreturn None\n# end method definition\ndef delete_teams(self, name: str) -&gt; bool:\n\"\"\"Delete Microsoft 365 Teams with a specific name. Microsoft 365 allows\n            to have multiple teams with the same name. So this method may delete\n            multiple teams if the have the same name. The Graph API we use here\n            is the M365 Group API as deleting the group also deletes the associated team.\n        Args:\n            name (str): name of the Microsoft 365 Team\n        Returns:\n            bool: True if teams have been deleted, False otherwise.\n        \"\"\"\n# We need a special handling of team names with single quotes:\nescaped_group_name = name.replace(\"'\", \"''\")\nencoded_group_name = quote(escaped_group_name, safe=\"\")\nrequest_url = self.config()[\n\"groupsUrl\"\n] + \"?$filter=displayName eq '{}'\".format(encoded_group_name)\nrequest_header = self.request_header()\nlogger.info(\n\"Delete all Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nexisting_teams = self.parse_request_response(response)\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams to delete; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nexisting_teams = None\nbreak\nif existing_teams:\ndata = existing_teams.get(\"value\")\nif data:\ncounter = 0\nfor team in data:\nteam_id = team.get(\"id\")\nresponse = self.delete_team(team_id)\nif not response:\nlogger.error(\n\"Failed to delete M365 Team -&gt; %s (%s)\", name, team_id\n)\ncontinue\ncounter += 1\nlogger.info(\n\"%s M365 Teams with name -&gt; %s have been deleted.\",\nstr(counter),\nname,\n)\nreturn True\nelse:\nlogger.info(\"No M365 Teams with name -&gt; %s found.\", name)\nreturn False\nelse:\nlogger.error(\"Failed to retrieve M365 Teams with name -&gt; %s\", name)\nreturn False\n# end method definition\ndef delete_all_teams(self, exception_list: list, pattern_list: list) -&gt; bool:\n\"\"\"Delete all teams (groups) that are NOT on the exception list AND\n           that are matching at least one of the patterns in the provided pattern list.\n           This method is used for general cleanup of teams. Be aware that deleted teams\n           are still listed under https://admin.microsoft.com/#/deletedgroups\n        Args:\n            exception_list (list): list of group names that should not be deleted\n            pattern_list (list): list of patterns for group names to be deleted\n                                 (regular expression)\n        Returns:\n            bool: True if teams have been deleted, False otherwise.\n        \"\"\"\n# Get list of all existing M365 groups/teams:\nresponse = self.get_groups(max_number=500)\nif not \"value\" in response or not response[\"value\"]:\nreturn False\ngroups = response[\"value\"]\nlogger.info(\n\"Found -&gt; %s existing M365 groups. Checking which ones should be deleted...\",\nlen(groups),\n)\n# Process all groups and check if the&lt; should be\n# deleted:\nfor group in groups:\ngroup_name = group[\"displayName\"]\n# Check if group is in exception list:\nif group_name in exception_list:\nlogger.info(\n\"M365 Group name -&gt; %s is on the exception list. Skipping...\",\ngroup_name,\n)\ncontinue\n# Check that at least one pattern is found that matches the group:\nfor pattern in pattern_list:\nresult = re.search(pattern, group_name)\nif result:\nlogger.info(\n\"M365 Group name -&gt; %s is matching pattern -&gt; %s. Delete it now...\",\ngroup_name,\npattern,\n)\nself.delete_teams(group_name)\nbreak\nelse:\nlogger.info(\n\"M365 Group name -&gt; %s is not matching any delete pattern. Skipping...\",\ngroup_name,\n)\nreturn True\n# end method definition\ndef get_team_channels(self, name: str) -&gt; dict | None:\n\"\"\"Get channels of a M365 Team based on the team name\n        Args:\n            name (str): name of the team\n        Returns:\n            dict: channel data structure (dictionary) or None if the request fails.\n            Example return data:\n            {\n                '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels\",\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '19:yPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1@thread.tacv2',\n                        'createdDateTime': '2023-08-11T14:11:35.986Z',\n                        'displayName': 'General',\n                        'description': 'Procurement',\n                        'isFavoriteByDefault': None,\n                        'email': None,\n                        'tenantId': '417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                        'webUrl': 'https://teams.microsoft.com/l/channel/19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2/Procurement?groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea&amp;allowXTenantAccess=False',\n                        'membershipType': 'standard'\n                    }\n                ]\n            }\n        \"\"\"\nresponse = self.get_team(name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\nrequest_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id) + \"/channels\"\nrequest_header = self.request_header()\nlogger.info(\n\"Retrieve channels of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get Channels for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_team_channel_tabs(self, team_name: str, channel_name: str) -&gt; dict | None:\n\"\"\"Get tabs of an M365 Team channel based on the team and channel names\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n        Returns:\n            dict: tabs data structure (dictionary) or None if the request fails.\n            Example return data:\n            {\n                '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels('19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2')/tabs\",\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '66f44e9a-0741-49a4-9500-ec82cc120115',\n                        'displayName': 'Procurement',\n                        'webUrl': 'https://teams.microsoft.com/l/entity/2851980b-95dc-4118-a1f5-5ae1894eaaaf/_djb2_msteams_prefix_66f44e9a-0741-49a4-9500-ec82cc120115?webUrl=https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%26showBW%3dtrue%26title%3dProcurement&amp;label=Procurement&amp;context=%7b%0d%0a++%22canvasUrl%22%3a+%22https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%22%2c%0d%0a++%22channelId%22%3a+%2219%3ayPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2%22%2c%0d%0a++%22subEntityId%22%3a+null%0d%0a%7d&amp;groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                        'configuration':\n                        {\n                            'entityId': '13178',\n                            'contentUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed',\n                            'removeUrl': None,\n                            'websiteUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed&amp;showBW=true&amp;title=Procurement',\n                            'dateAdded': '2023-08-12T08:57:35.895Z'\n                        }\n                    }\n                ]\n            }\n        \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn None\nchannel_id = channel[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Retrieve Tabs of Microsoft 365 Teams -&gt; %s and Channel -&gt; %s; calling -&gt; %s\",\nteam_name,\nchannel_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get Tabs for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_teams_apps(self, filter_expression: str = \"\") -&gt; dict | None:\n\"\"\"Get a list of MS Teams apps in catalog that match a given filter criterium\n        Args:\n            filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n            Example return data:\n            {\n                '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps(appDefinitions())',\n                '@odata.count': 1,\n                'value': [\n                    {\n                        'id': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                        'externalId': 'dd4af790-d8ff-47a0-87ad-486318272c7a',\n                        'displayName': 'OpenText Extended ECM',\n                        'distributionMethod': 'organization',\n                        'appDefinitions@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps('2851980b-95dc-4118-a1f5-5ae1894eaaaf')/appDefinitions\",\n                        'appDefinitions': [\n                            {\n                                'id': 'Mjg1MTk4MGItOTVkYy00MTE4LWExZjUtNWFlMTg5NGVhYWFmIyMyMi40IyNQdWJsaXNoZWQ=',\n                                'teamsAppId': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                                'displayName': 'OpenText Extended ECM',\n                                'version': '22.4',\n                                'publishingState': 'published',\n                                'shortDescription': 'Add a tab for an Extended ECM business workspace.',\n                                'description': 'View and interact with OpenText Extended ECM business workspaces',\n                                'lastModifiedDateTime': None,\n                                'createdBy': None,\n                                'authorization': {\n                                    'requiredPermissionSet': {...}\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }\n        \"\"\"\nquery = {\"$expand\": \"AppDefinitions\"}\nif filter_expression:\nquery[\"$filter\"] = filter_expression\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"teamsAppsUrl\"] + \"?\" + encoded_query\nif filter_expression:\nlogger.info(\n\"Get list of MS Teams Apps using filter -&gt; %s; calling -&gt; %s\",\nfilter_expression,\nrequest_url,\n)\nelse:\nlogger.info(\"Get list of all MS Teams Apps; calling -&gt; %s\", request_url)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_teams_app(self, app_id: str) -&gt; dict | None:\n\"\"\"Get a specific MS Teams app in catalog based on the known app ID\n        Args:\n            app_id (str): ID of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nquery = {\"$expand\": \"AppDefinitions\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id + \"?\" + encoded_query\n#        request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\nlogger.info(\n\"Get MS Teams App with ID -&gt; %s; calling -&gt; %s\", app_id, request_url\n)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_teams_apps_of_user(\nself, user_id: str, filter_expression: str = \"\"\n) -&gt; dict | None:\n\"\"\"Get a list of MS Teams apps of a user that match a given filter criterium\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nquery = {\"$expand\": \"teamsAppDefinition\"}\nif filter_expression:\nquery[\"$filter\"] = filter_expression\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"usersUrl\"]\n+ \"/\"\n+ user_id\n+ \"/teamwork/installedApps?\"\n+ encoded_query\n)\nlogger.info(\n\"Get list of M365 Teams Apps for user -&gt; %s using query -&gt; %s; calling -&gt; %s\",\nuser_id,\nquery,\nrequest_url,\n)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams Apps for user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_teams_apps_of_team(\nself, team_id: str, filter_expression: str = \"\"\n) -&gt; dict | None:\n\"\"\"Get a list of MS Teams apps of a M365 team that match a given filter criterium\n        Args:\n            team_id (str): M365 ID of the team\n            filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nquery = {\"$expand\": \"teamsAppDefinition\"}\nif filter_expression:\nquery[\"$filter\"] = filter_expression\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ team_id\n+ \"/installedApps?\"\n+ encoded_query\n)\nlogger.info(\n\"Get list of M365 Teams Apps for M365 Team -&gt; %s using query -&gt; %s; calling -&gt; %s\",\nteam_id,\nquery,\nrequest_url,\n)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams Apps for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nteam_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef extract_version_from_app_manifest(self, app_path: str) -&gt; str | None:\n\"\"\"Extract the version number from the MS Teams app manifest file.\n           This can be used to check if the app package includes a newer\n           app version then the already installed one.\n        Args:\n            app_path (str): file path (with directory) to the app package to extract\n                            the version from\n        Returns:\n            str: version number or None in case of an error\n        \"\"\"\nwith zipfile.ZipFile(app_path, \"r\") as zip_ref:\nmanifest_data = zip_ref.read(\"manifest.json\")\nmanifest_json = json.loads(manifest_data)\nversion = manifest_json.get(\"version\")\nreturn version\n# end method definition\ndef upload_teams_app(\nself, app_path: str, update_existing_app: bool = False, app_catalog_id: str = \"\"\n) -&gt; dict | None:\n\"\"\"Upload a new app package to the catalog of MS Teams apps.\n            This is not possible with client secret credentials\n            but requires a token of a user authenticated with username + password.\n            See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n            (permissions table on that page)\n        Args:\n            app_path (str): file path (with directory) to the app package to upload\n            update_existing_app (bool): whether or not to update an existing app with\n                                        the same name\n            app_catalog_id (str): the unique ID of the app. It is the ID the app has in\n                                  the catalog - which is different from ID an app gets\n                                  after installation (which is tenant specific)\n        Returns:\n            dict: Response of the MS GRAPH API REST call or None if the request fails\n        \"\"\"\nif update_existing_app and not app_catalog_id:\nlogger.error(\n\"To update an existing M365 Teams app in the app catalog you need to provide the existing App catalog ID!\"\n)\nreturn None\nif not os.path.exists(app_path):\nlogger.error(\"M365 Teams app file -&gt; {} does not exist!\")\nreturn None\n# Ensure that the app file is a zip file\nif not app_path.endswith(\".zip\"):\nlogger.error(\"M365 Teams app file -&gt; {} must be a zip file!\")\nreturn None\nrequest_url = self.config()[\"teamsAppsUrl\"]\n# If we want to upgrade an existing app we add the app ID and\n# the specific endpoint:\nif update_existing_app:\nrequest_url += \"/\" + app_catalog_id + \"/appDefinitions\"\n# Here we need the credentials of an authenticated user!\n# (not the application credentials (client_id, client_secret))\nrequest_header = self.request_header_user(\"application/zip\")\n# upload_files = {'file': open(app_path, 'rb')}\nwith open(app_path, \"rb\") as f:\napp_data = f.read()\nwith zipfile.ZipFile(app_path) as z:\n# Ensure that the app file contains a manifest.json file\nif \"manifest.json\" not in z.namelist():\nlogger.error(\n\"M365 Teams app file -&gt; {} does not contain a manifest.json file!\"\n)\nreturn None\nlogger.info(\n\"Upload M365 Teams app -&gt; %s to the MS Teams catalog; calling -&gt; %s\",\napp_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, headers=request_header, data=app_data, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif update_existing_app:\nlogger.warning(\n\"Failed to update existing M365 Teams app -&gt; %s (may be because it is not a new version); status -&gt; %s; error -&gt; %s\",\napp_path,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.error(\n\"Failed to upload new M365 Teams app -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef remove_teams_app(self, app_id: str):\n\"\"\"Remove MS Teams App from the app catalog\n        Args:\n            app_id (str): Microsoft 365 GUID of the MS Teams app\n        \"\"\"\nrequest_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n# Here we need the credentials of an authenticated user!\n# (not the application credentials (client_id, client_secret))\nrequest_header = self.request_header_user()\n# Make the DELETE request to remove the app from the app catalog\nresponse = requests.delete(request_url, headers=request_header, timeout=60)\n# Check the status code of the response\nif response.status_code == 204:\nlogger.info(\n\"The M365 Teams app with ID -&gt; %s has been successfully removed from the app catalog.\",\napp_id,\n)\nelse:\nlogger.error(\n\"An error occurred while removing the M365 Teams app from the M365 app catalog. Status code -&gt; %s. Error message -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\n# end method definition\ndef assign_teams_app_to_user(self, user_id: str, app_name: str) -&gt; dict | None:\n\"\"\"Assigns (adds) a M365 Teams app to a M365 user.\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            app_name (str): exact name of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nresponse = self.get_teams_apps(f\"contains(displayName, '{app_name}')\")\napp_id = self.get_result_value(response, \"id\", 0)\nif not app_id:\nlogger.error(\"M365 Teams App -&gt; %s not found!\", app_name)\nreturn None\nrequest_url = (\nself.config()[\"usersUrl\"] + \"/\" + user_id + \"/teamwork/installedApps\"\n)\nrequest_header = self.request_header()\npost_body = {\n\"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n}\nlogger.info(\n\"Assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; calling -&gt; %s\",\napp_name,\napp_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, json=post_body, headers=request_header, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_name,\napp_id,\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef upgrade_teams_app_of_user(self, user_id: str, app_name: str) -&gt; dict | None:\n\"\"\"Upgrade a MS teams app for a user. The call will fail if the user does not\n            already have the app assigned. So this needs to be checked before\n            calling this method.\n        Args:\n            user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            app_name (str): exact name of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nresponse = self.get_teams_apps_of_user(\nuser_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n)\n# Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\napp_installation_id = self.get_result_value(response, \"id\", 0)\nif not app_installation_id:\nlogger.error(\n\"M365 Teams app -&gt; %s not found for user with ID -&gt; %s. Cannot upgrade app for this user!\",\napp_name,\nuser_id,\n)\nreturn None\nrequest_url = (\nself.config()[\"usersUrl\"]\n+ \"/\"\n+ user_id\n+ \"/teamwork/installedApps/\"\n+ app_installation_id\n+ \"/upgrade\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Upgrade M365 Teams app -&gt; %s (%s) of M365 user with ID -&gt; %s; calling -&gt; %s\",\napp_name,\napp_installation_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upgrade M365 Teams app -&gt; %s (%s) of M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_name,\napp_installation_id,\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef assign_teams_app_to_team(self, team_id: str, app_id: str) -&gt; dict | None:\n\"\"\"Assign (add) a MS Teams app to a M365 team\n           (so that it afterwards can be added as a Tab in a M365 Teams Channel)\n        Args:\n            team_id (str): ID of the Microsoft 365 Team\n            app_id (str): ID of the M365 Team App\n        Returns:\n            dict | None: API response or None if the Graph API call fails.\n        \"\"\"\nrequest_url = self.config()[\"teamsUrl\"] + \"/\" + team_id + \"/installedApps\"\nrequest_header = self.request_header()\npost_body = {\n\"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n}\nlogger.info(\n\"Assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; calling -&gt; %s\",\napp_id,\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, json=post_body, headers=request_header, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_id,\nteam_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef upgrade_teams_app_of_team(self, team_id: str, app_name: str) -&gt; dict | None:\n\"\"\"Upgrade a MS teams app for a specific team. The call will fail if the team does not\n            already have the app assigned. So this needs to be checked before\n            calling this method.\n            THIS IS CURRENTLY NOT WORKING AS EXPECTED.\n        Args:\n            team_id (str): M365 GUID of the user (can also be the M365 email of the user)\n            app_name (str): exact name of the app\n        Returns:\n            dict: response of the MS Graph API call or None if the call fails.\n        \"\"\"\nresponse = self.get_teams_apps_of_team(\nteam_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n)\n# Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\napp_installation_id = self.get_result_value(response, \"id\", 0)\nif not app_installation_id:\nlogger.error(\n\"M365 Teams app -&gt; %s not found for M365 Team with ID -&gt; %s. Cannot upgrade app for this team!\",\napp_name,\nteam_id,\n)\nreturn None\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ team_id\n+ \"/installedApps/\"\n+ app_installation_id\n+ \"/upgrade\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; calling -&gt; %s\",\napp_name,\napp_installation_id,\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_name,\napp_installation_id,\nteam_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_teams_app_to_channel(\nself,\nteam_name: str,\nchannel_name: str,\napp_id: str,\ntab_name: str,\napp_url: str,\ncs_node_id: int,\n) -&gt; dict | None:\n\"\"\"Add tab for Extended ECM app to an M365 Team channel\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n            app_id (str): ID of the MS Teams Application (e.g. the Extended ECM Teams App)\n            tab_name (str): name of the tab\n            app_url (str) web URL of the app\n            cs_node_id (int): node ID of the target workspace or container in Extended ECM\n        Returns:\n            dict: return data structure (dictionary) or None if the request fails.\n            Example return data:\n        \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn None\nchannel_id = channel[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs\"\n)\nrequest_header = self.request_header()\n# Create tab configuration payload:\ntab_config = {\n\"teamsApp@odata.bind\": f\"https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/{app_id}\",\n\"displayName\": tab_name,\n\"configuration\": {\n\"entityId\": cs_node_id,  # Unique identifier for the tab\n\"contentUrl\": app_url,\n\"removeUrl\": \"\",\n\"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n},\n}\nlogger.info(\n\"Add Tab -&gt; %s with App ID -&gt; %s to Channel -&gt; %s of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\ntab_name,\napp_id,\nchannel_name,\nteam_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, headers=request_header, json=tab_config, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add Tab for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s; tab config -&gt; %s\",\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\nstr(tab_config),\n)\nreturn None\n# end method definition\ndef update_teams_app_of_channel(\nself,\nteam_name: str,\nchannel_name: str,\ntab_name: str,\napp_url: str,\ncs_node_id: int,\n) -&gt; dict | None:\n\"\"\"Update an existing tab for Extended ECM app in an M365 Team channel\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n            tab_name (str): name of the tab\n            app_url (str) web URL of the app\n            cs_node_id (int): node ID of the target workspace or container in Extended ECM\n        Returns:\n            dict: return data structure (dictionary) or None if the request fails.\n            Example return data:\n        \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn None\nchannel_id = channel[\"id\"]\n# Get the tabs of the M365 Team channel:\nresponse = self.get_team_channel_tabs(team_name, channel_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the tab by name and then retrieve its ID:\ntab = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == tab_name),\nNone,\n)\nif not tab:\nlogger.erro(\n\"Cannot find Tab -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\ntab_name,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\n)\nreturn None\ntab_id = tab[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs/\"\n+ str(tab_id)\n)\nrequest_header = self.request_header()\n# Create tab configuration payload:\ntab_config = {\n\"configuration\": {\n\"entityId\": cs_node_id,  # Unique identifier for the tab\n\"contentUrl\": app_url,\n\"removeUrl\": \"\",\n\"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n},\n}\nlogger.info(\n\"Update Tab -&gt; %s (%s) of Channel -&gt; %s (%s) for Microsoft 365 Teams -&gt; %s (%s) with configuration -&gt; %s; calling -&gt; %s\",\ntab_name,\ntab_id,\nchannel_name,\nchannel_id,\nteam_name,\nteam_id,\nstr(tab_config),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nrequest_url, headers=request_header, json=tab_config, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ntab_name,\ntab_id,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef delete_teams_app_from_channel(\nself,\nteam_name: str,\nchannel_name: str,\ntab_name: str,\n) -&gt; bool:\n\"\"\"Delete an existing tab for Extended ECM app from an M365 Team channel\n        Args:\n            team_name (str): name of the M365 Team\n            channel_name (str): name of the channel\n            tab_name (str): name of the tab\n        Returns:\n            bool: True = success, False = Error.\n        \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn False\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn False\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn False\nchannel_id = channel[\"id\"]\n# Get the tabs of the M365 Team channel:\nresponse = self.get_team_channel_tabs(team_name, channel_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn False\n# Lookup the tabs by name and then retrieve their IDs (in worst case it can\n# be multiple tabs / apps with same name if former cleanups did not work):\ntab_list = [\nitem for item in response[\"value\"] if item[\"displayName\"] == tab_name\n]\nif not tab_list:\nlogger.erro(\n\"Cannot find Tabs with name -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\ntab_name,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\n)\nreturn False\nfor tab in tab_list:\ntab_id = tab[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs/\"\n+ str(tab_id)\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Delete Tab -&gt; %s (%s) from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s); calling -&gt; %s\",\ntab_name,\ntab_id,\nchannel_name,\nchannel_id,\nteam_name,\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(\nrequest_url, headers=request_header, timeout=60\n)\nif response.ok:\nlogger.info(\n\"Tab -&gt; %s (%s) has been deleted from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s)\",\ntab_name,\ntab_id,\nchannel_name,\nchannel_id,\nteam_name,\nteam_id,\n)\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to delete Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ntab_name,\ntab_id,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n# end method definition\ndef add_sensitivity_label(\nself,\nname: str,\ndisplay_name: str,\ndescription: str = \"\",\ncolor: str = \"red\",\nenabled: bool = True,\nadmin_description: str = \"\",\nuser_description: str = \"\",\nenable_encryption: bool = False,\nenable_marking: bool = False,\n):\n\"\"\"Create a new sensitivity label in M365\n            THIS IS CURRENTLY NOT WORKING!\n        Args:\n            name (str): name of the label\n            display_name (str): display name of the label\n            description (str, optional): Description of the label. Defaults to \"\".\n            color (str, optional): Color of the label. Defaults to \"red\".\n            enabled (bool, optional): Whether this label is enabled. Defaults to True.\n            admin_description (str, optional): Description for administrators. Defaults to \"\".\n            user_description (str, optional): Description for users. Defaults to \"\".\n            enable_encryption (bool, optional): Enable encryption. Defaults to False.\n            enable_marking (bool, optional): _description_. Defaults to False.\n        Returns:\n            Request reponse or None if the request fails.\n        \"\"\"\n# Prepare the request body\npayload = {\n\"displayName\": display_name,\n\"description\": description,\n\"isEnabled\": enabled,\n\"labelColor\": color,\n\"adminDescription\": admin_description,\n\"userDescription\": user_description,\n\"encryptContent\": enable_encryption,\n\"contentMarking\": enable_marking,\n}\nrequest_url = self.config()[\"securityUrl\"] + \"/sensitivityLabels\"\nrequest_header = self.request_header()\nlogger.info(\n\"Create M365 sensitivity label -&gt; %s; calling -&gt; %s\", name, request_url\n)\n# Send the POST request to create the label\nresponse = requests.post(\nrequest_url, headers=request_header, data=json.dumps(payload), timeout=60\n)\n# Check the response status code\nif response.status_code == 201:\nlogger.info(\"Label -&gt; %s has been created successfully!\", name)\nreturn response\nelse:\nlogger.error(\n\"Failed to create the M365 label -&gt; %s! Response status code -&gt; %s\",\nname,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef assign_sensitivity_label_to_user(self, user_email: str, label_name: str):\n\"\"\"Assigns a existing sensitivity label to a user.\n            THIS IS CURRENTLY NOT WORKING!\n        Args:\n            user_email (str): email address of the user (as unique identifier)\n            label_name (str): name of the label (need to exist)\n        Returns:\n            Return the request response or None if the request fails.\n        \"\"\"\n# Set up the request body with the label name\nbody = {\"labelName\": label_name}\nrequest_url = (\nself.config()[\"usersUrl\"] + \"/\" + user_email + \"/assignSensitivityLabels\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Assign label -&gt; %s to user -&gt; %s; calling -&gt; %s\",\nlabel_name,\nuser_email,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, headers=request_header, json=body, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign label -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nlabel_name,\nuser_email,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef upload_outlook_app(\nself,\napp_path: str,\n) -&gt; dict | None:\n\"\"\"Upload the M365 Outlook Add-In as \"Integrated\" App to M365 Admin Center.\n           THIS IS CURRENTLY NOT IMPLEMENTED DUE TO MISSING MS GRAPH API SUPPORT!\n           https://admin.microsoft.com/#/Settings/IntegratedApps\n        Args:\n            app_path (str): path to manifest file in local file system. Needs to be\n                            downloaded before.\n        Returns:\n            dict | None: response of the MS Graph API or None if the request fails.\n        \"\"\"\n#        request_url = self.config()[\"teamsAppsUrl\"]\n#        request_header = self.request_header()\nlogger.info(\"Install Outlook Add-in from %s (NOT IMPLEMENTED)\", app_path)\nresponse = None\nreturn response\n# end method definition\ndef get_app_registration(\nself,\napp_registration_name: str,\n) -&gt; dict:\n\"\"\"Find an Azure App Registration based on its name\n        Args:\n            app_registration_name (str): name of the App Registration\n        Returns:\n            dict: App Registration data or None of the request fails.\n        \"\"\"\nrequest_url = self.config()[\n\"applicationsUrl\"\n] + \"?$filter=displayName eq '{}'\".format(app_registration_name)\nrequest_header = self.request_header()\nlogger.info(\n\"Get Azure App Registration -&gt; %s; calling -&gt; %s\",\napp_registration_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Cannot find Azure App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_registration_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_app_registration(\nself,\napp_registration_name: str,\ndescription: str = \"\",\napi_permissions: list | None = None,\nsupported_account_type: str = \"AzureADMyOrg\",\n) -&gt; dict:\n\"\"\"Add an Azure App Registration\n        Args:\n            app_registration_name (str): name of the App Registration\n            api_permissions (list): API permissions\n            supported_account_type (str): type of account that is supposed to use\n                                          the App Registration\n        Returns:\n            dict: App Registration data or None of the request fails.\n            Example data:\n            {\n                'id': 'd70bee91-3689-4239-a626-30756968e99c',\n                'deletedDateTime': None,\n                'appId': 'd288ba5f-9313-4b38-b4a4-d7edcce089b0',\n                'applicationTemplateId': None,\n                'disabledByMicrosoftStatus': None,\n                'createdDateTime': '2023-09-06T21:06:05Z',\n                'displayName': 'Test 1',\n                'description': None,\n                'groupMembershipClaims': None,\n                'identifierUris': [],\n                'isDeviceOnlyAuthSupported': None,\n                'isFallbackPublicClient': None,\n                'notes': None,\n                'publisherDomain': 'M365x41497014.onmicrosoft.com',\n                'signInAudience': 'AzureADMyOrg',\n                ...\n                'requiredResourceAccess': [\n                    {\n                        'resourceAppId': '00000003-0000-0ff1-ce00-000000000000',\n                        'resourceAccess': [\n                            {\n                                'id': '741f803b-c850-494e-b5df-cde7c675a1ca',\n                                'type': 'Role'\n                            },\n                            {\n                                'id': 'c8e3537c-ec53-43b9-bed3-b2bd3617ae97',\n                                'type': 'Role'\n                            },\n                        ]\n                    },\n                ]\n            }\n        \"\"\"\n# Define the request body to create the App Registration\napp_registration_data = {\n\"displayName\": app_registration_name,\n\"signInAudience\": supported_account_type,\n}\nif api_permissions:\napp_registration_data[\"requiredResourceAccess\"] = api_permissions\nif description:\napp_registration_data[\"description\"] = description\nrequest_url = self.config()[\"applicationsUrl\"]\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\nheaders=request_header,\njson=app_registration_data,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Cannot add App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_registration_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef update_app_registration(\nself,\napp_registration_id: str,\napp_registration_name: str,\napi_permissions: list,\nsupported_account_type: str = \"AzureADMyOrg\",\n) -&gt; dict:\n\"\"\"Update an Azure App Registration\n        Args:\n            app_registration_id (str): ID of the existing App Registration\n            app_registration_name (str): name of the App Registration\n            api_permissions (list): API permissions\n            supported_account_type (str): type of account that is supposed to use\n                                          the App Registration\n        Returns:\n            dict: App Registration data or None of the request fails.\n        \"\"\"\n# Define the request body to create the App Registration\napp_registration_data = {\n\"displayName\": app_registration_name,\n\"requiredResourceAccess\": api_permissions,\n\"signInAudience\": supported_account_type,\n}\nrequest_url = self.config()[\"applicationsUrl\"] + \"/\" + app_registration_id\nrequest_header = self.request_header()\nlogger.info(\n\"Update App Registration -&gt; %s (%s); calling -&gt; %s\",\napp_registration_name,\napp_registration_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nrequest_url,\nheaders=request_header,\njson=app_registration_data,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Cannot update App Registration -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\napp_registration_name,\napp_registration_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.__init__","title":"<code>__init__(tenant_id, client_id, client_secret, domain, sku_id, teams_app_name)</code>","text":"<p>Initialize the M365 object</p> <p>Parameters:</p> Name Type Description Default <code>tenant_id</code> <code>str</code> <p>M365 Tenant ID</p> required <code>client_id</code> <code>str</code> <p>M365 Client ID</p> required <code>client_secret</code> <code>str</code> <p>M365 Client Secret</p> required <code>domain</code> <code>str</code> <p>M365 domain</p> required <code>sku_id</code> <code>str</code> <p>License SKU for M365 users</p> required <code>teams_app_name</code> <code>str</code> <p>name of the Extended ECM app for MS Teams</p> required Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def __init__(\nself,\ntenant_id: str,\nclient_id: str,\nclient_secret: str,\ndomain: str,\nsku_id: str,\nteams_app_name: str,\n):\n\"\"\"Initialize the M365 object\n    Args:\n        tenant_id (str): M365 Tenant ID\n        client_id (str): M365 Client ID\n        client_secret (str): M365 Client Secret\n        domain (str): M365 domain\n        sku_id (str): License SKU for M365 users\n        teams_app_name (str): name of the Extended ECM app for MS Teams\n    \"\"\"\nm365_config = {}\n# Set the authentication endpoints and credentials\nm365_config[\"tenantId\"] = tenant_id\nm365_config[\"clientId\"] = client_id\nm365_config[\"clientSecret\"] = client_secret\nm365_config[\"domain\"] = domain\nm365_config[\"skuId\"] = sku_id\nm365_config[\"teamsAppName\"] = teams_app_name\nm365_config[\n\"authenticationUrl\"\n] = \"https://login.microsoftonline.com/{}/oauth2/v2.0/token\".format(tenant_id)\nm365_config[\"graphUrl\"] = \"https://graph.microsoft.com/v1.0/\"\nm365_config[\"betaUrl\"] = \"https://graph.microsoft.com/beta/\"\nm365_config[\"directoryObjects\"] = m365_config[\"graphUrl\"] + \"directoryObjects\"\n# Set the data for the token request\nm365_config[\"tokenData\"] = {\n\"client_id\": client_id,\n\"scope\": \"https://graph.microsoft.com/.default\",\n\"client_secret\": client_secret,\n\"grant_type\": \"client_credentials\",\n}\nm365_config[\"groupsUrl\"] = m365_config[\"graphUrl\"] + \"groups\"\nm365_config[\"usersUrl\"] = m365_config[\"graphUrl\"] + \"users\"\nm365_config[\"teamsUrl\"] = m365_config[\"graphUrl\"] + \"teams\"\nm365_config[\"teamsTemplatesUrl\"] = m365_config[\"graphUrl\"] + \"teamsTemplates\"\nm365_config[\"teamsAppsUrl\"] = m365_config[\"graphUrl\"] + \"appCatalogs/teamsApps\"\nm365_config[\"directoryUrl\"] = m365_config[\"graphUrl\"] + \"directory\"\nm365_config[\"securityUrl\"] = m365_config[\"betaUrl\"] + \"security\"\nm365_config[\"applicationsUrl\"] = m365_config[\"graphUrl\"] + \"applications\"\nself._config = m365_config\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_app_registration","title":"<code>add_app_registration(app_registration_name, description='', api_permissions=None, supported_account_type='AzureADMyOrg')</code>","text":"<p>Add an Azure App Registration</p> <p>Parameters:</p> Name Type Description Default <code>app_registration_name</code> <code>str</code> <p>name of the App Registration</p> required <code>api_permissions</code> <code>list</code> <p>API permissions</p> <code>None</code> <code>supported_account_type</code> <code>str</code> <p>type of account that is supposed to use                           the App Registration</p> <code>'AzureADMyOrg'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>App Registration data or None of the request fails.</p> <code>dict</code> <p>Example data:</p> <code>dict</code> <p>{ 'id': 'd70bee91-3689-4239-a626-30756968e99c', 'deletedDateTime': None, 'appId': 'd288ba5f-9313-4b38-b4a4-d7edcce089b0', 'applicationTemplateId': None, 'disabledByMicrosoftStatus': None, 'createdDateTime': '2023-09-06T21:06:05Z', 'displayName': 'Test 1', 'description': None, 'groupMembershipClaims': None, 'identifierUris': [], 'isDeviceOnlyAuthSupported': None, 'isFallbackPublicClient': None, 'notes': None, 'publisherDomain': 'M365x41497014.onmicrosoft.com', 'signInAudience': 'AzureADMyOrg', ... 'requiredResourceAccess': [     {         'resourceAppId': '00000003-0000-0ff1-ce00-000000000000',         'resourceAccess': [             {                 'id': '741f803b-c850-494e-b5df-cde7c675a1ca',                 'type': 'Role'             },             {                 'id': 'c8e3537c-ec53-43b9-bed3-b2bd3617ae97',                 'type': 'Role'             },         ]     }, ]</p> <code>dict</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_app_registration(\nself,\napp_registration_name: str,\ndescription: str = \"\",\napi_permissions: list | None = None,\nsupported_account_type: str = \"AzureADMyOrg\",\n) -&gt; dict:\n\"\"\"Add an Azure App Registration\n    Args:\n        app_registration_name (str): name of the App Registration\n        api_permissions (list): API permissions\n        supported_account_type (str): type of account that is supposed to use\n                                      the App Registration\n    Returns:\n        dict: App Registration data or None of the request fails.\n        Example data:\n        {\n            'id': 'd70bee91-3689-4239-a626-30756968e99c',\n            'deletedDateTime': None,\n            'appId': 'd288ba5f-9313-4b38-b4a4-d7edcce089b0',\n            'applicationTemplateId': None,\n            'disabledByMicrosoftStatus': None,\n            'createdDateTime': '2023-09-06T21:06:05Z',\n            'displayName': 'Test 1',\n            'description': None,\n            'groupMembershipClaims': None,\n            'identifierUris': [],\n            'isDeviceOnlyAuthSupported': None,\n            'isFallbackPublicClient': None,\n            'notes': None,\n            'publisherDomain': 'M365x41497014.onmicrosoft.com',\n            'signInAudience': 'AzureADMyOrg',\n            ...\n            'requiredResourceAccess': [\n                {\n                    'resourceAppId': '00000003-0000-0ff1-ce00-000000000000',\n                    'resourceAccess': [\n                        {\n                            'id': '741f803b-c850-494e-b5df-cde7c675a1ca',\n                            'type': 'Role'\n                        },\n                        {\n                            'id': 'c8e3537c-ec53-43b9-bed3-b2bd3617ae97',\n                            'type': 'Role'\n                        },\n                    ]\n                },\n            ]\n        }\n    \"\"\"\n# Define the request body to create the App Registration\napp_registration_data = {\n\"displayName\": app_registration_name,\n\"signInAudience\": supported_account_type,\n}\nif api_permissions:\napp_registration_data[\"requiredResourceAccess\"] = api_permissions\nif description:\napp_registration_data[\"description\"] = description\nrequest_url = self.config()[\"applicationsUrl\"]\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\nheaders=request_header,\njson=app_registration_data,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Cannot add App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_registration_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_group","title":"<code>add_group(name, security_enabled=False, mail_enabled=True)</code>","text":"<p>Add a M365 Group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the group</p> required <code>security_enabled</code> <code>bool</code> <p>whether or not this group is used for permission management</p> <code>False</code> <code>mail_enabled</code> <code>bool</code> <p>whether or not this group is email enabled</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Group information or None if the group couldn't be created (e.g. because it exisits already).</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups/$entity', 'id': '28906460-a69c-439e-84ca-c70becf37655', 'deletedDateTime': None, 'classification': None, 'createdDateTime': '2023-04-01T11:40:13Z', 'creationOptions': [], 'description': None, 'displayName': 'Test', 'expirationDateTime': None, 'groupTypes': ['Unified'], 'isAssignableToRole': None, 'mail': 'Diefenbruch@M365x61936377.onmicrosoft.com', 'mailEnabled': True, 'mailNickname': 'Test', 'membershipRule': None, 'membershipRuleProcessingState': None, 'onPremisesDomainName': None, 'onPremisesLastSyncDateTime': None, 'onPremisesNetBiosName': None, 'onPremisesSamAccountName': None, 'onPremisesSecurityIdentifier': None, 'onPremisesSyncEnabled': None, 'onPremisesProvisioningErrors': [], 'preferredDataLocation': None, 'preferredLanguage': None, 'proxyAddresses': ['SMTP:Test@M365x61936377.onmicrosoft.com'], 'renewedDateTime': '2023-04-01T11:40:13Z', 'resourceBehaviorOptions': [], 'resourceProvisioningOptions': [], 'securityEnabled': True, 'securityIdentifier': 'S-1-12-1-680551520-1134470812-197642884-1433859052', 'theme': None, 'visibility': 'Public'</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_group(\nself, name: str, security_enabled: bool = False, mail_enabled: bool = True\n) -&gt; dict | None:\n\"\"\"Add a M365 Group.\n    Args:\n        name (str): name of the group\n        security_enabled (bool, optional): whether or not this group is used for permission management\n        mail_enabled (bool, optional): whether or not this group is email enabled\n    Returns:\n        dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups/$entity',\n            'id': '28906460-a69c-439e-84ca-c70becf37655',\n            'deletedDateTime': None,\n            'classification': None,\n            'createdDateTime': '2023-04-01T11:40:13Z',\n            'creationOptions': [],\n            'description': None,\n            'displayName': 'Test',\n            'expirationDateTime': None,\n            'groupTypes': ['Unified'],\n            'isAssignableToRole': None,\n            'mail': 'Diefenbruch@M365x61936377.onmicrosoft.com',\n            'mailEnabled': True,\n            'mailNickname': 'Test',\n            'membershipRule': None,\n            'membershipRuleProcessingState': None,\n            'onPremisesDomainName': None,\n            'onPremisesLastSyncDateTime': None,\n            'onPremisesNetBiosName': None,\n            'onPremisesSamAccountName': None,\n            'onPremisesSecurityIdentifier': None,\n            'onPremisesSyncEnabled': None,\n            'onPremisesProvisioningErrors': [],\n            'preferredDataLocation': None,\n            'preferredLanguage': None,\n            'proxyAddresses': ['SMTP:Test@M365x61936377.onmicrosoft.com'],\n            'renewedDateTime': '2023-04-01T11:40:13Z',\n            'resourceBehaviorOptions': [],\n            'resourceProvisioningOptions': [],\n            'securityEnabled': True,\n            'securityIdentifier': 'S-1-12-1-680551520-1134470812-197642884-1433859052',\n            'theme': None,\n            'visibility': 'Public'\n        }\n    \"\"\"\ngroup_post_body = {\n\"displayName\": name,\n\"mailEnabled\": mail_enabled,\n\"mailNickname\": name.replace(\" \", \"\"),\n\"securityEnabled\": security_enabled,\n\"groupTypes\": [\"Unified\"],\n}\nrequest_url = self.config()[\"groupsUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Adding M365 group -&gt; %s; calling -&gt; %s\", name, request_url)\nlogger.debug(\"M365 group attributes -&gt; %s\", group_post_body)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\ndata=json.dumps(group_post_body),\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_group_member","title":"<code>add_group_member(group_id, member_id)</code>","text":"<p>Add a member (user or group) to a (parent) group</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>M365 GUID of the group</p> required <code>member_id</code> <code>str</code> <p>M365 GUID of the new member</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_group_member(self, group_id: str, member_id: str) -&gt; dict | None:\n\"\"\"Add a member (user or group) to a (parent) group\n    Args:\n        group_id (str): M365 GUID of the group\n        member_id (str): M365 GUID of the new member\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members/$ref\"\nrequest_header = self.request_header()\ngroup_member_post_body = {\n\"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + member_id\n}\nlogger.info(\n\"Adding member -&gt; %s to group -&gt; %s; calling -&gt; %s\",\nmember_id,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\nheaders=request_header,\ndata=json.dumps(group_member_post_body),\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add member -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nmember_id,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_group_owner","title":"<code>add_group_owner(group_id, owner_id)</code>","text":"<p>Add an owner (user) to a group</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>M365 GUID of the group</p> required <code>owner_id</code> <code>str</code> <p>M365 GUID of the new member</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_group_owner(self, group_id: str, owner_id: str) -&gt; dict | None:\n\"\"\"Add an owner (user) to a group\n    Args:\n        group_id (str): M365 GUID of the group\n        owner_id (str): M365 GUID of the new member\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners/$ref\"\nrequest_header = self.request_header()\ngroup_member_post_body = {\n\"@odata.id\": self.config()[\"directoryObjects\"] + \"/\" + owner_id\n}\nlogger.info(\n\"Adding owner -&gt; %s to M365 group -&gt; %s; calling -&gt; %s\",\nowner_id,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\nheaders=request_header,\ndata=json.dumps(group_member_post_body),\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add owner -&gt; %s to M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nowner_id,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_sensitivity_label","title":"<code>add_sensitivity_label(name, display_name, description='', color='red', enabled=True, admin_description='', user_description='', enable_encryption=False, enable_marking=False)</code>","text":"<p>Create a new sensitivity label in M365     THIS IS CURRENTLY NOT WORKING!</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the label</p> required <code>display_name</code> <code>str</code> <p>display name of the label</p> required <code>description</code> <code>str</code> <p>Description of the label. Defaults to \"\".</p> <code>''</code> <code>color</code> <code>str</code> <p>Color of the label. Defaults to \"red\".</p> <code>'red'</code> <code>enabled</code> <code>bool</code> <p>Whether this label is enabled. Defaults to True.</p> <code>True</code> <code>admin_description</code> <code>str</code> <p>Description for administrators. Defaults to \"\".</p> <code>''</code> <code>user_description</code> <code>str</code> <p>Description for users. Defaults to \"\".</p> <code>''</code> <code>enable_encryption</code> <code>bool</code> <p>Enable encryption. Defaults to False.</p> <code>False</code> <code>enable_marking</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>Request reponse or None if the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_sensitivity_label(\nself,\nname: str,\ndisplay_name: str,\ndescription: str = \"\",\ncolor: str = \"red\",\nenabled: bool = True,\nadmin_description: str = \"\",\nuser_description: str = \"\",\nenable_encryption: bool = False,\nenable_marking: bool = False,\n):\n\"\"\"Create a new sensitivity label in M365\n        THIS IS CURRENTLY NOT WORKING!\n    Args:\n        name (str): name of the label\n        display_name (str): display name of the label\n        description (str, optional): Description of the label. Defaults to \"\".\n        color (str, optional): Color of the label. Defaults to \"red\".\n        enabled (bool, optional): Whether this label is enabled. Defaults to True.\n        admin_description (str, optional): Description for administrators. Defaults to \"\".\n        user_description (str, optional): Description for users. Defaults to \"\".\n        enable_encryption (bool, optional): Enable encryption. Defaults to False.\n        enable_marking (bool, optional): _description_. Defaults to False.\n    Returns:\n        Request reponse or None if the request fails.\n    \"\"\"\n# Prepare the request body\npayload = {\n\"displayName\": display_name,\n\"description\": description,\n\"isEnabled\": enabled,\n\"labelColor\": color,\n\"adminDescription\": admin_description,\n\"userDescription\": user_description,\n\"encryptContent\": enable_encryption,\n\"contentMarking\": enable_marking,\n}\nrequest_url = self.config()[\"securityUrl\"] + \"/sensitivityLabels\"\nrequest_header = self.request_header()\nlogger.info(\n\"Create M365 sensitivity label -&gt; %s; calling -&gt; %s\", name, request_url\n)\n# Send the POST request to create the label\nresponse = requests.post(\nrequest_url, headers=request_header, data=json.dumps(payload), timeout=60\n)\n# Check the response status code\nif response.status_code == 201:\nlogger.info(\"Label -&gt; %s has been created successfully!\", name)\nreturn response\nelse:\nlogger.error(\n\"Failed to create the M365 label -&gt; %s! Response status code -&gt; %s\",\nname,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_team","title":"<code>add_team(name, template_name='standard')</code>","text":"<p>Add M365 Team based on an existing M365 Group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the team. It is assumed that a group with the same name does already exist!</p> required <code>template_name</code> <code>str</code> <p>name of the team template. \"standard\" is the default value.</p> <code>'standard'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Team information (json - empty text!) or None if the team couldn't be created   (e.g. because it exisits already).</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_team(self, name: str, template_name: str = \"standard\") -&gt; dict | None:\n\"\"\"Add M365 Team based on an existing M365 Group.\n    Args:\n        name (str): name of the team. It is assumed that a group with the same name does already exist!\n        template_name (str, optional): name of the team template. \"standard\" is the default value.\n    Returns:\n        dict: Team information (json - empty text!) or None if the team couldn't be created\n              (e.g. because it exisits already).\n    \"\"\"\nresponse = self.get_group(name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s not found. It is required for creating a corresponding M365 Team.\",\nname,\n)\nreturn None\nresponse = self.get_group_owners(name)\nif response is None or not \"value\" in response or not response[\"value\"]:\nlogger.warning(\n\"M365 Group -&gt; %s has no owners. This is required for creating a corresponding M365 Team.\",\nname,\n)\nreturn None\nteam_post_body = {\n\"template@odata.bind\": \"{}('{}')\".format(\nself.config()[\"teamsTemplatesUrl\"], template_name\n),\n\"group@odata.bind\": \"{}('{}')\".format(self.config()[\"groupsUrl\"], group_id),\n}\nrequest_url = self.config()[\"teamsUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Adding M365 Team -&gt; %s; calling -&gt; %s\", name, request_url)\nlogger.debug(\"M365 Team attributes -&gt; %s\", team_post_body)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\ndata=json.dumps(team_post_body),\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_teams_app_to_channel","title":"<code>add_teams_app_to_channel(team_name, channel_name, app_id, tab_name, app_url, cs_node_id)</code>","text":"<p>Add tab for Extended ECM app to an M365 Team channel</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <code>app_id</code> <code>str</code> <p>ID of the MS Teams Application (e.g. the Extended ECM Teams App)</p> required <code>tab_name</code> <code>str</code> <p>name of the tab</p> required <code>cs_node_id</code> <code>int</code> <p>node ID of the target workspace or container in Extended ECM</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>return data structure (dictionary) or None if the request fails.</p> <code>dict | None</code> <p>Example return data:</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_teams_app_to_channel(\nself,\nteam_name: str,\nchannel_name: str,\napp_id: str,\ntab_name: str,\napp_url: str,\ncs_node_id: int,\n) -&gt; dict | None:\n\"\"\"Add tab for Extended ECM app to an M365 Team channel\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n        app_id (str): ID of the MS Teams Application (e.g. the Extended ECM Teams App)\n        tab_name (str): name of the tab\n        app_url (str) web URL of the app\n        cs_node_id (int): node ID of the target workspace or container in Extended ECM\n    Returns:\n        dict: return data structure (dictionary) or None if the request fails.\n        Example return data:\n    \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn None\nchannel_id = channel[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs\"\n)\nrequest_header = self.request_header()\n# Create tab configuration payload:\ntab_config = {\n\"teamsApp@odata.bind\": f\"https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/{app_id}\",\n\"displayName\": tab_name,\n\"configuration\": {\n\"entityId\": cs_node_id,  # Unique identifier for the tab\n\"contentUrl\": app_url,\n\"removeUrl\": \"\",\n\"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n},\n}\nlogger.info(\n\"Add Tab -&gt; %s with App ID -&gt; %s to Channel -&gt; %s of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\ntab_name,\napp_id,\nchannel_name,\nteam_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, headers=request_header, json=tab_config, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add Tab for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s; tab config -&gt; %s\",\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\nstr(tab_config),\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.add_user","title":"<code>add_user(email, password, first_name, last_name, location='US', department='', company_name='Innovate')</code>","text":"<p>Add a M365 user.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>email address of the user. This is also the unique identifier</p> required <code>password</code> <code>str</code> <p>password of the user</p> required <code>first_name</code> <code>str</code> <p>first name of the user</p> required <code>last_name</code> <code>str</code> <p>last name of the user</p> required <code>location</code> <code>str</code> <p>country ISO 3166-1 alpha-2 format (e.g. US, CA, FR, DE, CN, ...)</p> <code>'US'</code> <code>department</code> <code>str</code> <p>department of the user</p> <code>''</code> <code>company_name</code> <code>str</code> <p>name of the company</p> <code>'Innovate'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user couldn't be created (e.g. because it exisits already   or if a permission problem occurs).</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def add_user(\nself,\nemail: str,\npassword: str,\nfirst_name: str,\nlast_name: str,\nlocation: str = \"US\",\ndepartment: str = \"\",\ncompany_name: str = \"Innovate\",\n) -&gt; dict | None:\n\"\"\"Add a M365 user.\n    Args:\n        email (str): email address of the user. This is also the unique identifier\n        password (str): password of the user\n        first_name (str): first name of the user\n        last_name (str): last name of the user\n        location (str, optional): country ISO 3166-1 alpha-2 format (e.g. US, CA, FR, DE, CN, ...)\n        department (str, optional): department of the user\n        company_name (str): name of the company\n    Returns:\n        dict: User information or None if the user couldn't be created (e.g. because it exisits already\n              or if a permission problem occurs).\n    \"\"\"\nuser_post_body = {\n\"accountEnabled\": True,\n\"displayName\": first_name + \" \" + last_name,\n\"givenName\": first_name,\n\"surname\": last_name,\n\"mailNickname\": email.split(\"@\")[0],\n\"userPrincipalName\": email,\n\"passwordProfile\": {\n\"forceChangePasswordNextSignIn\": False,\n\"password\": password,\n},\n\"usageLocation\": location,\n}\nif department:\nuser_post_body[\"department\"] = department\nif company_name:\nuser_post_body[\"companyName\"] = company_name\nrequest_url = self.config()[\"usersUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Adding M365 user -&gt; %s; calling -&gt; %s\", email, request_url)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url,\ndata=json.dumps(user_post_body),\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nemail,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_license_to_user","title":"<code>assign_license_to_user(user_id, sku_id)</code>","text":"<p>Add an M365 license to a user (e.g. to use Office 365)</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>sku_id</code> <code>str</code> <p>M365 GUID of the SKU           (e.g. c7df2760-2c81-4ef7-b578-5b5392b571df for E5 and                 6fd2c87f-b296-42f0-b197-1e91e994b900 for E3)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response or None if request fails</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_license_to_user(self, user_id: str, sku_id: str) -&gt; dict | None:\n\"\"\"Add an M365 license to a user (e.g. to use Office 365)\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        sku_id (str): M365 GUID of the SKU\n                      (e.g. c7df2760-2c81-4ef7-b578-5b5392b571df for E5 and\n                            6fd2c87f-b296-42f0-b197-1e91e994b900 for E3)\n    Returns:\n        dict: response or None if request fails\n    \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/assignLicense\"\nrequest_header = self.request_header()\n# Construct the request body for assigning the E5 license\nlicense_post_body = {\n\"addLicenses\": [\n{\n\"disabledPlans\": [],\n\"skuId\": sku_id,  # \"c42b9cae-ea4f-4a69-9ca5-c53bd8779c42\"\n}\n],\n\"removeLicenses\": [],\n}\nlogger.info(\n\"Assign M365 license -&gt; %s to M365 user -&gt; %s; calling -&gt; %s\",\nsku_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, json=license_post_body, headers=request_header, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add M365 license -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nsku_id,\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_sensitivity_label_to_user","title":"<code>assign_sensitivity_label_to_user(user_email, label_name)</code>","text":"<p>Assigns a existing sensitivity label to a user.     THIS IS CURRENTLY NOT WORKING!</p> <p>Parameters:</p> Name Type Description Default <code>user_email</code> <code>str</code> <p>email address of the user (as unique identifier)</p> required <code>label_name</code> <code>str</code> <p>name of the label (need to exist)</p> required <p>Returns:</p> Type Description <p>Return the request response or None if the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_sensitivity_label_to_user(self, user_email: str, label_name: str):\n\"\"\"Assigns a existing sensitivity label to a user.\n        THIS IS CURRENTLY NOT WORKING!\n    Args:\n        user_email (str): email address of the user (as unique identifier)\n        label_name (str): name of the label (need to exist)\n    Returns:\n        Return the request response or None if the request fails.\n    \"\"\"\n# Set up the request body with the label name\nbody = {\"labelName\": label_name}\nrequest_url = (\nself.config()[\"usersUrl\"] + \"/\" + user_email + \"/assignSensitivityLabels\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Assign label -&gt; %s to user -&gt; %s; calling -&gt; %s\",\nlabel_name,\nuser_email,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, headers=request_header, json=body, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign label -&gt; %s to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nlabel_name,\nuser_email,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_teams_app_to_team","title":"<code>assign_teams_app_to_team(team_id, app_id)</code>","text":"<p>Assign (add) a MS Teams app to a M365 team    (so that it afterwards can be added as a Tab in a M365 Teams Channel)</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>ID of the Microsoft 365 Team</p> required <code>app_id</code> <code>str</code> <p>ID of the M365 Team App</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: API response or None if the Graph API call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_teams_app_to_team(self, team_id: str, app_id: str) -&gt; dict | None:\n\"\"\"Assign (add) a MS Teams app to a M365 team\n       (so that it afterwards can be added as a Tab in a M365 Teams Channel)\n    Args:\n        team_id (str): ID of the Microsoft 365 Team\n        app_id (str): ID of the M365 Team App\n    Returns:\n        dict | None: API response or None if the Graph API call fails.\n    \"\"\"\nrequest_url = self.config()[\"teamsUrl\"] + \"/\" + team_id + \"/installedApps\"\nrequest_header = self.request_header()\npost_body = {\n\"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n}\nlogger.info(\n\"Assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; calling -&gt; %s\",\napp_id,\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, json=post_body, headers=request_header, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign M365 Teams app -&gt; %s to M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_id,\nteam_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.assign_teams_app_to_user","title":"<code>assign_teams_app_to_user(user_id, app_name)</code>","text":"<p>Assigns (adds) a M365 Teams app to a M365 user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>app_name</code> <code>str</code> <p>exact name of the app</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def assign_teams_app_to_user(self, user_id: str, app_name: str) -&gt; dict | None:\n\"\"\"Assigns (adds) a M365 Teams app to a M365 user.\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        app_name (str): exact name of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nresponse = self.get_teams_apps(f\"contains(displayName, '{app_name}')\")\napp_id = self.get_result_value(response, \"id\", 0)\nif not app_id:\nlogger.error(\"M365 Teams App -&gt; %s not found!\", app_name)\nreturn None\nrequest_url = (\nself.config()[\"usersUrl\"] + \"/\" + user_id + \"/teamwork/installedApps\"\n)\nrequest_header = self.request_header()\npost_body = {\n\"teamsApp@odata.bind\": self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n}\nlogger.info(\n\"Assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; calling -&gt; %s\",\napp_name,\napp_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, json=post_body, headers=request_header, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign M365 Teams app -&gt; %s (%s) to M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_name,\napp_id,\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticate at M365 Graph API with client ID and client secret.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determinse if a re-athentication is enforced                          (e.g. if session has timed out with 401 error)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>Access token. Also stores access token in self._access_token. None in case of error</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; str | None:\n\"\"\"Authenticate at M365 Graph API with client ID and client secret.\n    Args:\n        revalidate (bool, optional): determinse if a re-athentication is enforced\n                                     (e.g. if session has timed out with 401 error)\n    Returns:\n        str: Access token. Also stores access token in self._access_token. None in case of error\n    \"\"\"\n# Already authenticated and session still valid?\nif self._access_token and not revalidate:\nreturn self._access_token\nrequest_url = self.config()[\"authenticationUrl\"]\nrequest_header = request_login_headers\nlogger.info(\"Requesting M365 Access Token from -&gt; %s\", request_url)\nauthenticate_post_body = self.credentials()\nauthenticate_response = None\ntry:\nauthenticate_response = requests.post(\nrequest_url,\ndata=authenticate_post_body,\nheaders=request_header,\ntimeout=60,\n)\nexcept requests.exceptions.ConnectionError as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s : %s\",\nself.config()[\"authenticationUrl\"],\nexception,\n)\nreturn None\nif authenticate_response.ok:\nauthenticate_dict = self.parse_request_response(authenticate_response)\nif not authenticate_dict:\nreturn None\nelse:\naccess_token = authenticate_dict[\"access_token\"]\nlogger.debug(\"Access Token -&gt; %s\", access_token)\nelse:\nlogger.error(\n\"Failed to request an M365 Access Token; error -&gt; %s\",\nauthenticate_response.text,\n)\nreturn None\n# Store authentication access_token:\nself._access_token = access_token\nreturn self._access_token\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.authenticate_user","title":"<code>authenticate_user(username, password)</code>","text":"<p>Authenticate at M365 Graph API with username and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>name (emails) of the M365 user</p> required <code>password</code> <code>str</code> <p>password of the M365 user</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>Access token. Also stores access token in self._access_token</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def authenticate_user(self, username: str, password: str) -&gt; str | None:\n\"\"\"Authenticate at M365 Graph API with username and password.\n    Args:\n        username (str): name (emails) of the M365 user\n        password (str): password of the M365 user\n    Returns:\n        str: Access token. Also stores access token in self._access_token\n    \"\"\"\nrequest_url = self.config()[\"authenticationUrl\"]\nrequest_header = request_login_headers\nlogger.info(\n\"Requesting M365 Access Token for user -&gt; %s from -&gt; %s\",\nusername,\nrequest_url,\n)\nauthenticate_post_body = self.credentials_user(username, password)\nauthenticate_response = None\ntry:\nauthenticate_response = requests.post(\nrequest_url,\ndata=authenticate_post_body,\nheaders=request_header,\ntimeout=60,\n)\nexcept requests.exceptions.ConnectionError as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s with username -&gt; %s: %s\",\nself.config()[\"authenticationUrl\"],\nusername,\nexception,\n)\nreturn None\nif authenticate_response.ok:\nauthenticate_dict = self.parse_request_response(authenticate_response)\nif not authenticate_dict:\nreturn None\naccess_token = authenticate_dict[\"access_token\"]\nlogger.debug(\"User Access Token -&gt; %s\", access_token)\nelse:\nlogger.error(\n\"Failed to request an M365 Access Token for user -&gt; %s; error -&gt; %s\",\nusername,\nauthenticate_response.text,\n)\nreturn None\n# Store authentication access_token:\nself._user_access_token = access_token\nreturn self._user_access_token\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.credentials","title":"<code>credentials()</code>","text":"<p>Return the login credentials</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with login credentials for M365</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def credentials(self) -&gt; dict:\n\"\"\"Return the login credentials\n    Returns:\n        dict: dictionary with login credentials for M365\n    \"\"\"\nreturn self.config()[\"tokenData\"]\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.credentials_user","title":"<code>credentials_user(username, password)</code>","text":"<p>In some cases MS Graph APIs cannot be called via     application permissions (client_id, client_secret)     but requires a token of a user authenticated     with username + password. This is e.g. the case     to upload a MS teams app to the catalog.     See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>username</p> required <code>password</code> <code>str</code> <p>password</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>user credentials for M365</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def credentials_user(self, username: str, password: str) -&gt; dict:\n\"\"\"In some cases MS Graph APIs cannot be called via\n        application permissions (client_id, client_secret)\n        but requires a token of a user authenticated\n        with username + password. This is e.g. the case\n        to upload a MS teams app to the catalog.\n        See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n    Args:\n        username (str): username\n        password (str): password\n    Returns:\n        dict: user credentials for M365\n    \"\"\"\ncredentials = {\n\"client_id\": self.config()[\"clientId\"],\n\"scope\": \"https://graph.microsoft.com/.default\",\n\"client_secret\": self.config()[\"clientSecret\"],\n\"grant_type\": \"password\",\n\"username\": username,\n\"password\": password,\n}\nreturn credentials\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_all_teams","title":"<code>delete_all_teams(exception_list, pattern_list)</code>","text":"<p>Delete all teams (groups) that are NOT on the exception list AND    that are matching at least one of the patterns in the provided pattern list.    This method is used for general cleanup of teams. Be aware that deleted teams    are still listed under https://admin.microsoft.com/#/deletedgroups</p> <p>Parameters:</p> Name Type Description Default <code>exception_list</code> <code>list</code> <p>list of group names that should not be deleted</p> required <code>pattern_list</code> <code>list</code> <p>list of patterns for group names to be deleted                  (regular expression)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if teams have been deleted, False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_all_teams(self, exception_list: list, pattern_list: list) -&gt; bool:\n\"\"\"Delete all teams (groups) that are NOT on the exception list AND\n       that are matching at least one of the patterns in the provided pattern list.\n       This method is used for general cleanup of teams. Be aware that deleted teams\n       are still listed under https://admin.microsoft.com/#/deletedgroups\n    Args:\n        exception_list (list): list of group names that should not be deleted\n        pattern_list (list): list of patterns for group names to be deleted\n                             (regular expression)\n    Returns:\n        bool: True if teams have been deleted, False otherwise.\n    \"\"\"\n# Get list of all existing M365 groups/teams:\nresponse = self.get_groups(max_number=500)\nif not \"value\" in response or not response[\"value\"]:\nreturn False\ngroups = response[\"value\"]\nlogger.info(\n\"Found -&gt; %s existing M365 groups. Checking which ones should be deleted...\",\nlen(groups),\n)\n# Process all groups and check if the&lt; should be\n# deleted:\nfor group in groups:\ngroup_name = group[\"displayName\"]\n# Check if group is in exception list:\nif group_name in exception_list:\nlogger.info(\n\"M365 Group name -&gt; %s is on the exception list. Skipping...\",\ngroup_name,\n)\ncontinue\n# Check that at least one pattern is found that matches the group:\nfor pattern in pattern_list:\nresult = re.search(pattern, group_name)\nif result:\nlogger.info(\n\"M365 Group name -&gt; %s is matching pattern -&gt; %s. Delete it now...\",\ngroup_name,\npattern,\n)\nself.delete_teams(group_name)\nbreak\nelse:\nlogger.info(\n\"M365 Group name -&gt; %s is not matching any delete pattern. Skipping...\",\ngroup_name,\n)\nreturn True\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_team","title":"<code>delete_team(team_id)</code>","text":"<p>Delete Microsoft 365 Team with a specific ID.</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>ID of the Microsoft 365 Team to delete</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Response dictionary if the team has been deleted, False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_team(self, team_id: str) -&gt; dict | None:\n\"\"\"Delete Microsoft 365 Team with a specific ID.\n    Args:\n        team_id (str): ID of the Microsoft 365 Team to delete\n    Returns:\n        dict | None: Response dictionary if the team has been deleted, False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + team_id\nrequest_header = self.request_header()\nlogger.info(\n\"Delete Microsoft 365 Teams with ID -&gt; %s; calling -&gt; %s\",\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\"Failed to delete M365 Team with ID -&gt; %s\", team_id)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_teams","title":"<code>delete_teams(name)</code>","text":"<p>Delete Microsoft 365 Teams with a specific name. Microsoft 365 allows     to have multiple teams with the same name. So this method may delete     multiple teams if the have the same name. The Graph API we use here     is the M365 Group API as deleting the group also deletes the associated team.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Microsoft 365 Team</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if teams have been deleted, False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_teams(self, name: str) -&gt; bool:\n\"\"\"Delete Microsoft 365 Teams with a specific name. Microsoft 365 allows\n        to have multiple teams with the same name. So this method may delete\n        multiple teams if the have the same name. The Graph API we use here\n        is the M365 Group API as deleting the group also deletes the associated team.\n    Args:\n        name (str): name of the Microsoft 365 Team\n    Returns:\n        bool: True if teams have been deleted, False otherwise.\n    \"\"\"\n# We need a special handling of team names with single quotes:\nescaped_group_name = name.replace(\"'\", \"''\")\nencoded_group_name = quote(escaped_group_name, safe=\"\")\nrequest_url = self.config()[\n\"groupsUrl\"\n] + \"?$filter=displayName eq '{}'\".format(encoded_group_name)\nrequest_header = self.request_header()\nlogger.info(\n\"Delete all Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nexisting_teams = self.parse_request_response(response)\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams to delete; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nexisting_teams = None\nbreak\nif existing_teams:\ndata = existing_teams.get(\"value\")\nif data:\ncounter = 0\nfor team in data:\nteam_id = team.get(\"id\")\nresponse = self.delete_team(team_id)\nif not response:\nlogger.error(\n\"Failed to delete M365 Team -&gt; %s (%s)\", name, team_id\n)\ncontinue\ncounter += 1\nlogger.info(\n\"%s M365 Teams with name -&gt; %s have been deleted.\",\nstr(counter),\nname,\n)\nreturn True\nelse:\nlogger.info(\"No M365 Teams with name -&gt; %s found.\", name)\nreturn False\nelse:\nlogger.error(\"Failed to retrieve M365 Teams with name -&gt; %s\", name)\nreturn False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.delete_teams_app_from_channel","title":"<code>delete_teams_app_from_channel(team_name, channel_name, tab_name)</code>","text":"<p>Delete an existing tab for Extended ECM app from an M365 Team channel</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <code>tab_name</code> <code>str</code> <p>name of the tab</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True = success, False = Error.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def delete_teams_app_from_channel(\nself,\nteam_name: str,\nchannel_name: str,\ntab_name: str,\n) -&gt; bool:\n\"\"\"Delete an existing tab for Extended ECM app from an M365 Team channel\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n        tab_name (str): name of the tab\n    Returns:\n        bool: True = success, False = Error.\n    \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn False\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn False\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn False\nchannel_id = channel[\"id\"]\n# Get the tabs of the M365 Team channel:\nresponse = self.get_team_channel_tabs(team_name, channel_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn False\n# Lookup the tabs by name and then retrieve their IDs (in worst case it can\n# be multiple tabs / apps with same name if former cleanups did not work):\ntab_list = [\nitem for item in response[\"value\"] if item[\"displayName\"] == tab_name\n]\nif not tab_list:\nlogger.erro(\n\"Cannot find Tabs with name -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\ntab_name,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\n)\nreturn False\nfor tab in tab_list:\ntab_id = tab[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs/\"\n+ str(tab_id)\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Delete Tab -&gt; %s (%s) from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s); calling -&gt; %s\",\ntab_name,\ntab_id,\nchannel_name,\nchannel_id,\nteam_name,\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(\nrequest_url, headers=request_header, timeout=60\n)\nif response.ok:\nlogger.info(\n\"Tab -&gt; %s (%s) has been deleted from Channel -&gt; %s (%s) of Microsoft 365 Teams -&gt; %s (%s)\",\ntab_name,\ntab_id,\nchannel_name,\nchannel_id,\nteam_name,\nteam_id,\n)\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to delete Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ntab_name,\ntab_id,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.exist_result_item","title":"<code>exist_result_item(response, key, value, sub_dict_name='')</code>","text":"<p>Check existence of key / value pair in the response properties of an MS Graph API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an MS Graph REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>value</code> <code>str</code> <p>value to find in the item with the matching key</p> required <code>sub_dict_name</code> <code>str</code> <p>some MS Graph API calls include nested                  dict structures that can be requested                  with an \"expand\" query parameter. In such                  a case we use the sub_dict_name to access it.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value was found, False otherwise</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def exist_result_item(\nself, response: dict, key: str, value: str, sub_dict_name: str = \"\"\n) -&gt; bool:\n\"\"\"Check existence of key / value pair in the response properties of an MS Graph API call.\n    Args:\n        response (dict): REST response from an MS Graph REST Call\n        key (str): property name (key)\n        value (str): value to find in the item with the matching key\n        sub_dict_name (str): some MS Graph API calls include nested\n                             dict structures that can be requested\n                             with an \"expand\" query parameter. In such\n                             a case we use the sub_dict_name to access it.\n    Returns:\n        bool: True if the value was found, False otherwise\n    \"\"\"\nif not response:\nreturn False\nif not \"value\" in response:\nreturn False\nvalues = response[\"value\"]\nif not values or not isinstance(values, list):\nreturn False\nif not sub_dict_name:\nfor item in values:\nif value == item[key]:\nreturn True\nelse:\nfor item in values:\nif not sub_dict_name in item:\nreturn False\nif value == item[sub_dict_name][key]:\nreturn True\nreturn False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.extract_version_from_app_manifest","title":"<code>extract_version_from_app_manifest(app_path)</code>","text":"<p>Extract the version number from the MS Teams app manifest file.    This can be used to check if the app package includes a newer    app version then the already installed one.</p> <p>Parameters:</p> Name Type Description Default <code>app_path</code> <code>str</code> <p>file path (with directory) to the app package to extract             the version from</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>version number or None in case of an error</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def extract_version_from_app_manifest(self, app_path: str) -&gt; str | None:\n\"\"\"Extract the version number from the MS Teams app manifest file.\n       This can be used to check if the app package includes a newer\n       app version then the already installed one.\n    Args:\n        app_path (str): file path (with directory) to the app package to extract\n                        the version from\n    Returns:\n        str: version number or None in case of an error\n    \"\"\"\nwith zipfile.ZipFile(app_path, \"r\") as zip_ref:\nmanifest_data = zip_ref.read(\"manifest.json\")\nmanifest_json = json.loads(manifest_data)\nversion = manifest_json.get(\"version\")\nreturn version\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_app_registration","title":"<code>get_app_registration(app_registration_name)</code>","text":"<p>Find an Azure App Registration based on its name</p> <p>Parameters:</p> Name Type Description Default <code>app_registration_name</code> <code>str</code> <p>name of the App Registration</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>App Registration data or None of the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_app_registration(\nself,\napp_registration_name: str,\n) -&gt; dict:\n\"\"\"Find an Azure App Registration based on its name\n    Args:\n        app_registration_name (str): name of the App Registration\n    Returns:\n        dict: App Registration data or None of the request fails.\n    \"\"\"\nrequest_url = self.config()[\n\"applicationsUrl\"\n] + \"?$filter=displayName eq '{}'\".format(app_registration_name)\nrequest_header = self.request_header()\nlogger.info(\n\"Get Azure App Registration -&gt; %s; calling -&gt; %s\",\napp_registration_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Cannot find Azure App Registration -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_registration_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_group","title":"<code>get_group(group_name, show_error=False)</code>","text":"<p>Get a M365 Group based on its name</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>M365 Group name</p> required <code>show_error</code> <code>bool</code> <p>should an error be logged if group is not found.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Group information or None if the group doesn't exist.</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups', 'value': [     {         'id': 'b65f7dba-3ed1-49df-91bf-2bf99affcc8d',         'deletedDateTime': None,         'classification': None,         'createdDateTime': '2023-04-01T13:46:26Z',         'creationOptions': [],         'description': 'Engineering &amp; Construction',         'displayName': 'Engineering &amp; Construction',         'expirationDateTime': None,         'groupTypes': ['Unified'],         'isAssignableToRole': None,         'mail': 'Engineering&amp;Construction@M365x61936377.onmicrosoft.com',         'mailEnabled': True,         'mailNickname': 'Engineering&amp;Construction',         'membershipRule': None,         'membershipRuleProcessingState': None,         'onPremisesDomainName': None,         'onPremisesLastSyncDateTime': None,         'onPremisesNetBiosName': None,         'onPremisesSamAccountName': None,         'onPremisesSecurityIdentifier': None,         'onPremisesSyncEnabled': None,         'preferredDataLocation': None,         'preferredLanguage': None,         'proxyAddresses': ['SPO:SPO_d9deb3e7-c72f-4e8d-80fb-5d9411ca1458@SPO_604f34f0-ba72-4321-ab6b-e36ae8bd00ec', 'SMTP:Engineering&amp;Construction@M365x61936377.onmicrosoft.com'],         'renewedDateTime': '2023-04-01T13:46:26Z',         'resourceBehaviorOptions': [],         'resourceProvisioningOptions': [],         'securityEnabled': False,         'securityIdentifier': 'S-1-12-1-3059711418-1239367377-4180393873-2379022234',         'theme': None,         'visibility': 'Public',         'onPremisesProvisioningErrors': []     },     {         'id': '61359860-302e-4016-b5cc-abff2293dff1',         ...     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_group(self, group_name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Get a M365 Group based on its name\n    Args:\n        group_name (str): M365 Group name\n        show_error (bool): should an error be logged if group is not found.\n    Returns:\n        dict: Group information or None if the group doesn't exist.\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#groups',\n            'value': [\n                {\n                    'id': 'b65f7dba-3ed1-49df-91bf-2bf99affcc8d',\n                    'deletedDateTime': None,\n                    'classification': None,\n                    'createdDateTime': '2023-04-01T13:46:26Z',\n                    'creationOptions': [],\n                    'description': 'Engineering &amp; Construction',\n                    'displayName': 'Engineering &amp; Construction',\n                    'expirationDateTime': None,\n                    'groupTypes': ['Unified'],\n                    'isAssignableToRole': None,\n                    'mail': 'Engineering&amp;Construction@M365x61936377.onmicrosoft.com',\n                    'mailEnabled': True,\n                    'mailNickname': 'Engineering&amp;Construction',\n                    'membershipRule': None,\n                    'membershipRuleProcessingState': None,\n                    'onPremisesDomainName': None,\n                    'onPremisesLastSyncDateTime': None,\n                    'onPremisesNetBiosName': None,\n                    'onPremisesSamAccountName': None,\n                    'onPremisesSecurityIdentifier': None,\n                    'onPremisesSyncEnabled': None,\n                    'preferredDataLocation': None,\n                    'preferredLanguage': None,\n                    'proxyAddresses': ['SPO:SPO_d9deb3e7-c72f-4e8d-80fb-5d9411ca1458@SPO_604f34f0-ba72-4321-ab6b-e36ae8bd00ec', 'SMTP:Engineering&amp;Construction@M365x61936377.onmicrosoft.com'],\n                    'renewedDateTime': '2023-04-01T13:46:26Z',\n                    'resourceBehaviorOptions': [],\n                    'resourceProvisioningOptions': [],\n                    'securityEnabled': False,\n                    'securityIdentifier': 'S-1-12-1-3059711418-1239367377-4180393873-2379022234',\n                    'theme': None,\n                    'visibility': 'Public',\n                    'onPremisesProvisioningErrors': []\n                },\n                {\n                    'id': '61359860-302e-4016-b5cc-abff2293dff1',\n                    ...\n                }\n            ]\n        }\n    \"\"\"\nquery = {\"$filter\": \"displayName eq '\" + group_name + \"'\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"groupsUrl\"] + \"?\" + encoded_query\nrequest_header = self.request_header()\nlogger.info(\"Get M365 group -&gt; %s; calling -&gt; %s\", group_name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get M365 group -&gt; %s; status -&gt; %s; error -&gt; %s\",\ngroup_name,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"M365 Group -&gt; %s not found.\", group_name)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_group_members","title":"<code>get_group_members(group_name)</code>","text":"<p>Get members (users and groups) of the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the group</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of Graph REST API or None if the REST call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_group_members(self, group_name: str) -&gt; dict | None:\n\"\"\"Get members (users and groups) of the specified group.\n    Args:\n        group_name (str): name of the group\n    Returns:\n        dict: Response of Graph REST API or None if the REST call fails.\n    \"\"\"\nresponse = self.get_group(group_name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s does not exist! Cannot retrieve group members.\",\ngroup_name,\n)\nreturn None\nquery = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"groupsUrl\"] + \"/\" + group_id + \"/members?\" + encoded_query\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Get members of M365 group -&gt; %s (%s); calling -&gt; %s\",\ngroup_name,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get members of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ngroup_name,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_group_owners","title":"<code>get_group_owners(group_name)</code>","text":"<p>Get owners (users) of the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the group</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of Graph REST API or None if the REST call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_group_owners(self, group_name: str) -&gt; dict | None:\n\"\"\"Get owners (users) of the specified group.\n    Args:\n        group_name (str): name of the group\n    Returns:\n        dict: Response of Graph REST API or None if the REST call fails.\n    \"\"\"\nresponse = self.get_group(group_name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s does not exist! Cannot retrieve group owners.\",\ngroup_name,\n)\nreturn None\nquery = {\"$select\": \"id,displayName,mail,userPrincipalName\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"groupsUrl\"] + \"/\" + group_id + \"/owners?\" + encoded_query\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Get owners of M365 group -&gt; %s (%s); calling -&gt; %s\",\ngroup_name,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get owners of M365 group -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ngroup_name,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_groups","title":"<code>get_groups(max_number=250)</code>","text":"<p>Get list all all groups in M365 tenant</p> <p>Parameters:</p> Name Type Description Default <code>max_number</code> <code>int</code> <p>maximum result values (limit)</p> <code>250</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>dictionary of all groups or None in case of an error.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_groups(self, max_number: int = 250) -&gt; dict | None:\n\"\"\"Get list all all groups in M365 tenant\n    Args:\n        max_number (int, optional): maximum result values (limit)\n    Returns:\n        dict: dictionary of all groups or None in case of an error.\n    \"\"\"\nrequest_url = self.config()[\"groupsUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Get list of all M365 groups; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nrequest_url,\nheaders=request_header,\nparams={\"$top\": str(max_number)},\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 groups; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_result_value","title":"<code>get_result_value(response, key, index=0, sub_dict_name='')</code>","text":"<p>Get value of a result property with a given key of an MS Graph API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an MS Graph REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>index</code> <code>int</code> <p>Index to use (1st element has index 0).                    Defaults to 0.</p> <code>0</code> <code>sub_dict_name</code> <code>str</code> <p>some MS Graph API calls include nested                  dict structures that can be requested                  with an \"expand\" query parameter. In such                  a case we use the sub_dict_name to access it.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>value for the key, None otherwise</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_result_value(\nself, response: dict, key: str, index: int = 0, sub_dict_name: str = \"\"\n) -&gt; str | None:\n\"\"\"Get value of a result property with a given key of an MS Graph API call.\n    Args:\n        response (dict): REST response from an MS Graph REST Call\n        key (str): property name (key)\n        index (int, optional): Index to use (1st element has index 0).\n                               Defaults to 0.\n        sub_dict_name (str): some MS Graph API calls include nested\n                             dict structures that can be requested\n                             with an \"expand\" query parameter. In such\n                             a case we use the sub_dict_name to access it.\n    Returns:\n        str: value for the key, None otherwise\n    \"\"\"\nif not response:\nreturn None\nif (\nnot \"value\" in response\n):  # If Graph APIs are called with specific IDs (and not name lookups)\n# they may not return a list of dicts calles \"values\" but a single dict directly\nif sub_dict_name and sub_dict_name in response:\nsub_structure = response[sub_dict_name]\n# also the substructure could be a list\nif isinstance(sub_structure, list):\nsub_structure = sub_structure[index]\nreturn sub_structure[key]\nelif key in response:\nreturn response[key]\nelse:\nreturn None\nvalues = response[\"value\"]\nif not values or not isinstance(values, list) or len(values) - 1 &lt; index:\nreturn None\nif not sub_dict_name:\nreturn values[index][key]\nelse:\nsub_structure = values[index][sub_dict_name]\nif isinstance(sub_structure, list):\n# here we assume it is the first element of the\n# substructure. If really required for specific\n# use cases we may introduce a second index in\n# the future.\nsub_structure = sub_structure[0]\nreturn sub_structure[key]\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_team","title":"<code>get_team(name)</code>","text":"<p>Get a M365 Team based on its name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the M365 Team</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>teams data structure (dictionary) or None if the request fails.</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#teams', '@odata.count': 1, 'value': [     {         'id': '951bd036-c6fc-4da4-bb80-1860f5472a2f',         'createdDateTime': None,         'displayName': 'Procurement',         'description': 'Procurement',         'internalId': None,         'classification': None,         'specialization': None,         'visibility': 'public',         'webUrl': None, ...}]}         'isArchived': None,         'isMembershipLimitedToOwners': None,         'memberSettings': None,         'guestSettings': None,         'messagingSettings': None,         ...     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_team(self, name: str) -&gt; dict | None:\n\"\"\"Get a M365 Team based on its name\n    Args:\n        name (str): name of the M365 Team\n    Returns:\n        dict: teams data structure (dictionary) or None if the request fails.\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#teams',\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '951bd036-c6fc-4da4-bb80-1860f5472a2f',\n                    'createdDateTime': None,\n                    'displayName': 'Procurement',\n                    'description': 'Procurement',\n                    'internalId': None,\n                    'classification': None,\n                    'specialization': None,\n                    'visibility': 'public',\n                    'webUrl': None, ...}]}\n                    'isArchived': None,\n                    'isMembershipLimitedToOwners': None,\n                    'memberSettings': None,\n                    'guestSettings': None,\n                    'messagingSettings': None,\n                    ...\n                }\n            ]\n        }\n    \"\"\"\n# The M365 Teams API has an issues with ampersand characters in team names (like \"Engineering &amp; Construction\")\n# So we do a work-around here to first get the Team ID via the Group endpoint of the Graph API and\n# then fetch the M365 Team via its ID (which is identical to the underlying M365 Group ID)\nresponse = self.get_group(name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nlogger.error(\n\"Failed to get the ID of the M365 Team -&gt; %s via the M365 Group API\",\nname,\n)\nreturn None\nrequest_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id)\nrequest_header = self.request_header()\nlogger.info(\n\"Lookup Microsoft 365 Teams with name -&gt; %s; calling -&gt; %s\",\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_team_channel_tabs","title":"<code>get_team_channel_tabs(team_name, channel_name)</code>","text":"<p>Get tabs of an M365 Team channel based on the team and channel names</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>tabs data structure (dictionary) or None if the request fails.</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels('19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2')/tabs\", '@odata.count': 1, 'value': [     {         'id': '66f44e9a-0741-49a4-9500-ec82cc120115',         'displayName': 'Procurement',         'webUrl': 'https://teams.microsoft.com/l/entity/2851980b-95dc-4118-a1f5-5ae1894eaaaf/_djb2_msteams_prefix_66f44e9a-0741-49a4-9500-ec82cc120115?webUrl=https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%26showBW%3dtrue%26title%3dProcurement&amp;label=Procurement&amp;context=%7b%0d%0a++%22canvasUrl%22%3a+%22https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%22%2c%0d%0a++%22channelId%22%3a+%2219%3ayPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2%22%2c%0d%0a++%22subEntityId%22%3a+null%0d%0a%7d&amp;groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea',         'configuration':         {             'entityId': '13178',             'contentUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed',             'removeUrl': None,             'websiteUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed&amp;showBW=true&amp;title=Procurement',             'dateAdded': '2023-08-12T08:57:35.895Z'         }     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_team_channel_tabs(self, team_name: str, channel_name: str) -&gt; dict | None:\n\"\"\"Get tabs of an M365 Team channel based on the team and channel names\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n    Returns:\n        dict: tabs data structure (dictionary) or None if the request fails.\n        Example return data:\n        {\n            '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels('19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2')/tabs\",\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '66f44e9a-0741-49a4-9500-ec82cc120115',\n                    'displayName': 'Procurement',\n                    'webUrl': 'https://teams.microsoft.com/l/entity/2851980b-95dc-4118-a1f5-5ae1894eaaaf/_djb2_msteams_prefix_66f44e9a-0741-49a4-9500-ec82cc120115?webUrl=https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%26showBW%3dtrue%26title%3dProcurement&amp;label=Procurement&amp;context=%7b%0d%0a++%22canvasUrl%22%3a+%22https%3a%2f%2fotcs.fqdn.tld.com%2fcssupport%2fxecmoffice%2fteamsapp.html%3fnodeId%3d13178%26type%3dcontainer%26parentId%3d2000%26target%3dcontent%26csurl%3dhttps%3a%2f%2fotcs.fqdn.tld.com%2fcs%2fcs%26appId%3da168b00d-3ad9-46ac-8798-578c1961e1ed%22%2c%0d%0a++%22channelId%22%3a+%2219%3ayPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2%22%2c%0d%0a++%22subEntityId%22%3a+null%0d%0a%7d&amp;groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                    'configuration':\n                    {\n                        'entityId': '13178',\n                        'contentUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed',\n                        'removeUrl': None,\n                        'websiteUrl': 'https://otcs.fqdn.tld.com/cssupport/xecmoffice/teamsapp.html?nodeId=13178&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=https://otcs.fqdn.tld.com/cs/cs&amp;appId=a168b00d-3ad9-46ac-8798-578c1961e1ed&amp;showBW=true&amp;title=Procurement',\n                        'dateAdded': '2023-08-12T08:57:35.895Z'\n                    }\n                }\n            ]\n        }\n    \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s on M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn None\nchannel_id = channel[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Retrieve Tabs of Microsoft 365 Teams -&gt; %s and Channel -&gt; %s; calling -&gt; %s\",\nteam_name,\nchannel_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get Tabs for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_team_channels","title":"<code>get_team_channels(name)</code>","text":"<p>Get channels of a M365 Team based on the team name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the team</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>channel data structure (dictionary) or None if the request fails.</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels\", '@odata.count': 1, 'value': [     {         'id': '19:yPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1@thread.tacv2',         'createdDateTime': '2023-08-11T14:11:35.986Z',         'displayName': 'General',         'description': 'Procurement',         'isFavoriteByDefault': None,         'email': None,         'tenantId': '417e6e3a-82e6-4aa0-9d47-a7734ca3daea',         'webUrl': 'https://teams.microsoft.com/l/channel/19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2/Procurement?groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea&amp;allowXTenantAccess=False',         'membershipType': 'standard'     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_team_channels(self, name: str) -&gt; dict | None:\n\"\"\"Get channels of a M365 Team based on the team name\n    Args:\n        name (str): name of the team\n    Returns:\n        dict: channel data structure (dictionary) or None if the request fails.\n        Example return data:\n        {\n            '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#teams('951bd036-c6fc-4da4-bb80-1860f5472a2f')/channels\",\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '19:yPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1@thread.tacv2',\n                    'createdDateTime': '2023-08-11T14:11:35.986Z',\n                    'displayName': 'General',\n                    'description': 'Procurement',\n                    'isFavoriteByDefault': None,\n                    'email': None,\n                    'tenantId': '417e6e3a-82e6-4aa0-9d47-a7734ca3daea',\n                    'webUrl': 'https://teams.microsoft.com/l/channel/19%3AyPmPnXoFtvs5jmgL7fG-iXNENVMLsB_WSrxYK-zKakY1%40thread.tacv2/Procurement?groupId=951bd036-c6fc-4da4-bb80-1860f5472a2f&amp;tenantId=417e6e3a-82e6-4aa0-9d47-a7734ca3daea&amp;allowXTenantAccess=False',\n                    'membershipType': 'standard'\n                }\n            ]\n        }\n    \"\"\"\nresponse = self.get_team(name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\nrequest_url = self.config()[\"teamsUrl\"] + \"/\" + str(team_id) + \"/channels\"\nrequest_header = self.request_header()\nlogger.info(\n\"Retrieve channels of Microsoft 365 Team -&gt; %s; calling -&gt; %s\",\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get Channels for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_app","title":"<code>get_teams_app(app_id)</code>","text":"<p>Get a specific MS Teams app in catalog based on the known app ID</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>ID of the app</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_app(self, app_id: str) -&gt; dict | None:\n\"\"\"Get a specific MS Teams app in catalog based on the known app ID\n    Args:\n        app_id (str): ID of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nquery = {\"$expand\": \"AppDefinitions\"}\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id + \"?\" + encoded_query\n#        request_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\nlogger.info(\n\"Get MS Teams App with ID -&gt; %s; calling -&gt; %s\", app_id, request_url\n)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_apps","title":"<code>get_teams_apps(filter_expression='')</code>","text":"<p>Get a list of MS Teams apps in catalog that match a given filter criterium</p> <p>Parameters:</p> Name Type Description Default <code>filter_expression</code> <code>str</code> <p>filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps(appDefinitions())', '@odata.count': 1, 'value': [     {         'id': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',         'externalId': 'dd4af790-d8ff-47a0-87ad-486318272c7a',         'displayName': 'OpenText Extended ECM',         'distributionMethod': 'organization',         'appDefinitions@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps('2851980b-95dc-4118-a1f5-5ae1894eaaaf')/appDefinitions\",         'appDefinitions': [             {                 'id': 'Mjg1MTk4MGItOTVkYy00MTE4LWExZjUtNWFlMTg5NGVhYWFmIyMyMi40IyNQdWJsaXNoZWQ=',                 'teamsAppId': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',                 'displayName': 'OpenText Extended ECM',                 'version': '22.4',                 'publishingState': 'published',                 'shortDescription': 'Add a tab for an Extended ECM business workspace.',                 'description': 'View and interact with OpenText Extended ECM business workspaces',                 'lastModifiedDateTime': None,                 'createdBy': None,                 'authorization': {                     'requiredPermissionSet': {...}                 }             }         ]     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_apps(self, filter_expression: str = \"\") -&gt; dict | None:\n\"\"\"Get a list of MS Teams apps in catalog that match a given filter criterium\n    Args:\n        filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps(appDefinitions())',\n            '@odata.count': 1,\n            'value': [\n                {\n                    'id': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                    'externalId': 'dd4af790-d8ff-47a0-87ad-486318272c7a',\n                    'displayName': 'OpenText Extended ECM',\n                    'distributionMethod': 'organization',\n                    'appDefinitions@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#appCatalogs/teamsApps('2851980b-95dc-4118-a1f5-5ae1894eaaaf')/appDefinitions\",\n                    'appDefinitions': [\n                        {\n                            'id': 'Mjg1MTk4MGItOTVkYy00MTE4LWExZjUtNWFlMTg5NGVhYWFmIyMyMi40IyNQdWJsaXNoZWQ=',\n                            'teamsAppId': '2851980b-95dc-4118-a1f5-5ae1894eaaaf',\n                            'displayName': 'OpenText Extended ECM',\n                            'version': '22.4',\n                            'publishingState': 'published',\n                            'shortDescription': 'Add a tab for an Extended ECM business workspace.',\n                            'description': 'View and interact with OpenText Extended ECM business workspaces',\n                            'lastModifiedDateTime': None,\n                            'createdBy': None,\n                            'authorization': {\n                                'requiredPermissionSet': {...}\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    \"\"\"\nquery = {\"$expand\": \"AppDefinitions\"}\nif filter_expression:\nquery[\"$filter\"] = filter_expression\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"teamsAppsUrl\"] + \"?\" + encoded_query\nif filter_expression:\nlogger.info(\n\"Get list of MS Teams Apps using filter -&gt; %s; calling -&gt; %s\",\nfilter_expression,\nrequest_url,\n)\nelse:\nlogger.info(\"Get list of all MS Teams Apps; calling -&gt; %s\", request_url)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams apps; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_apps_of_team","title":"<code>get_teams_apps_of_team(team_id, filter_expression='')</code>","text":"<p>Get a list of MS Teams apps of a M365 team that match a given filter criterium</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>M365 ID of the team</p> required <code>filter_expression</code> <code>str</code> <p>filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_apps_of_team(\nself, team_id: str, filter_expression: str = \"\"\n) -&gt; dict | None:\n\"\"\"Get a list of MS Teams apps of a M365 team that match a given filter criterium\n    Args:\n        team_id (str): M365 ID of the team\n        filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nquery = {\"$expand\": \"teamsAppDefinition\"}\nif filter_expression:\nquery[\"$filter\"] = filter_expression\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ team_id\n+ \"/installedApps?\"\n+ encoded_query\n)\nlogger.info(\n\"Get list of M365 Teams Apps for M365 Team -&gt; %s using query -&gt; %s; calling -&gt; %s\",\nteam_id,\nquery,\nrequest_url,\n)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams Apps for M365 Team -&gt; %s; status -&gt; %s; error -&gt; %s\",\nteam_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_teams_apps_of_user","title":"<code>get_teams_apps_of_user(user_id, filter_expression='')</code>","text":"<p>Get a list of MS Teams apps of a user that match a given filter criterium</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>filter_expression</code> <code>str</code> <p>filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_teams_apps_of_user(\nself, user_id: str, filter_expression: str = \"\"\n) -&gt; dict | None:\n\"\"\"Get a list of MS Teams apps of a user that match a given filter criterium\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        filter_expression (str, optional): filter string see https://learn.microsoft.com/en-us/graph/filter-query-parameter\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nquery = {\"$expand\": \"teamsAppDefinition\"}\nif filter_expression:\nquery[\"$filter\"] = filter_expression\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"usersUrl\"]\n+ \"/\"\n+ user_id\n+ \"/teamwork/installedApps?\"\n+ encoded_query\n)\nlogger.info(\n\"Get list of M365 Teams Apps for user -&gt; %s using query -&gt; %s; calling -&gt; %s\",\nuser_id,\nquery,\nrequest_url,\n)\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of M365 Teams Apps for user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_user","title":"<code>get_user(user_email, show_error=False)</code>","text":"<p>Get a M365 User based on its email</p> <p>Parameters:</p> Name Type Description Default <code>user_email</code> <code>str</code> <p>M365 user email</p> required <code>show_error</code> <code>bool</code> <p>whether or not an error should be displayed if the                user is not found.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user couldn't be retrieved (e.g. because it doesn't exist   or if there is a permission problem).</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#users/$entity', 'businessPhones': [], 'displayName': 'Bob Davis', 'givenName': 'Bob', 'id': '72c80809-094f-4e6e-98d4-25a736385d10', 'jobTitle': None, 'mail': 'bdavis@M365x61936377.onmicrosoft.com', 'mobilePhone': None, 'officeLocation': None, 'preferredLanguage': None, 'surname': 'Davis', 'userPrincipalName': 'bdavis@M365x61936377.onmicrosoft.com'</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_user(self, user_email: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Get a M365 User based on its email\n    Args:\n        user_email (str): M365 user email\n        show_error (bool): whether or not an error should be displayed if the\n                           user is not found.\n    Returns:\n        dict: User information or None if the user couldn't be retrieved (e.g. because it doesn't exist\n              or if there is a permission problem).\n        Example return data:\n        {\n            '@odata.context': 'https://graph.microsoft.com/v1.0/$metadata#users/$entity',\n            'businessPhones': [],\n            'displayName': 'Bob Davis',\n            'givenName': 'Bob',\n            'id': '72c80809-094f-4e6e-98d4-25a736385d10',\n            'jobTitle': None,\n            'mail': 'bdavis@M365x61936377.onmicrosoft.com',\n            'mobilePhone': None,\n            'officeLocation': None,\n            'preferredLanguage': None,\n            'surname': 'Davis',\n            'userPrincipalName': 'bdavis@M365x61936377.onmicrosoft.com'\n        }\n    \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_email\nrequest_header = self.request_header()\nlogger.info(\"Get M365 user -&gt; %s; calling -&gt; %s\", user_email, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_email,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"M365 User -&gt; %s not found.\", user_email)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_user_licenses","title":"<code>get_user_licenses(user_id)</code>","text":"<p>Get the assigned license SKUs of a user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>List of user licenses or None if request fails.</p> <code>dict | None</code> <p>Example return data:</p> <code>dict | None</code> <p>{ '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#users('a5875311-f0a5-486d-a746-bd7372b91115')/licenseDetails\", 'value': [     {         'id': '8DRPYHK6IUOra-Nq6L0A7GAn38eBLPdOtXhbU5K1cd8',         'skuId': 'c7df2760-2c81-4ef7-b578-5b5392b571df',         'skuPartNumber': 'ENTERPRISEPREMIUM',         'servicePlans': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_user_licenses(self, user_id: str) -&gt; dict | None:\n\"\"\"Get the assigned license SKUs of a user\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n    Returns:\n        dict: List of user licenses or None if request fails.\n        Example return data:\n        {\n            '@odata.context': \"https://graph.microsoft.com/v1.0/$metadata#users('a5875311-f0a5-486d-a746-bd7372b91115')/licenseDetails\",\n            'value': [\n                {\n                    'id': '8DRPYHK6IUOra-Nq6L0A7GAn38eBLPdOtXhbU5K1cd8',\n                    'skuId': 'c7df2760-2c81-4ef7-b578-5b5392b571df',\n                    'skuPartNumber': 'ENTERPRISEPREMIUM',\n                    'servicePlans': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n                }\n            ]\n        }\n    \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/licenseDetails\"\nrequest_header = self.request_header()\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get M365 licenses of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_user_photo","title":"<code>get_user_photo(user_id, show_error=True)</code>","text":"<p>Get the photo of a M365 user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>show_error</code> <code>bool</code> <p>whether or not an error should be logged if the user                   does not have a photo in M365</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes | None</code> <p>Image of the user photo or None if the user photo couldn't be retrieved.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_user_photo(self, user_id: str, show_error: bool = True) -&gt; bytes | None:\n\"\"\"Get the photo of a M365 user\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        show_error (bool): whether or not an error should be logged if the user\n                              does not have a photo in M365\n    Returns:\n        bytes: Image of the user photo or None if the user photo couldn't be retrieved.\n    \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n# Set image as content type:\nrequest_header = self.request_header(\"image/*\")\nlogger.info(\"Get photo of user -&gt; %s; calling -&gt; %s\", user_id, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn response.content  # this is the actual image - not json!\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get photo of user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"User -&gt; %s does not yet have a photo.\", user_id)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.get_users","title":"<code>get_users()</code>","text":"<p>Get list all all users in M365 tenant</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Dictionary of all users.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def get_users(self) -&gt; dict | None:\n\"\"\"Get list all all users in M365 tenant\n    Returns:\n        dict: Dictionary of all users.\n    \"\"\"\nrequest_url = self.config()[\"usersUrl\"]\nrequest_header = self.request_header()\nlogger.info(\"Get list of all users; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of users; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.has_team","title":"<code>has_team(group_name)</code>","text":"<p>Check if a M365 Group has a M365 Team connected or not</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the M365 group</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if a Team is assigned and False otherwise</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def has_team(self, group_name: str) -&gt; bool:\n\"\"\"Check if a M365 Group has a M365 Team connected or not\n    Args:\n        group_name (str): name of the M365 group\n    Returns:\n        bool: Returns True if a Team is assigned and False otherwise\n    \"\"\"\nresponse = self.get_group(group_name)\ngroup_id = self.get_result_value(response, \"id\", 0)\nif not group_id:\nlogger.error(\n\"M365 Group -&gt; %s not found. Cannot check if it has a M365 Team.\",\ngroup_name,\n)\nreturn False\nrequest_url = self.config()[\"groupsUrl\"] + \"/\" + group_id + \"/team\"\nrequest_header = self.request_header()\nlogger.info(\n\"Check if M365 Group -&gt; %s has a M365 Team connected; calling -&gt; %s\",\ngroup_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.status_code == 200:  # Group has a Team assigned!\nlogger.info(\"Group -&gt; %s has a M365 Team connected.\", group_name)\nreturn True\nelif response.status_code == 404:  # Group does not have a Team assigned!\nlogger.info(\"Group -&gt; %s has no M365 Team connected.\", group_name)\nreturn False\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to check if M365 Group -&gt; %s has a M365 Team connected; status -&gt; %s; error -&gt; %s\",\ngroup_name,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.is_member","title":"<code>is_member(group_id, member_id, show_error=True)</code>","text":"<p>Checks whether a M365 user is already in a M365 group</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>M365 GUID of the group</p> required <code>member_id</code> <code>str</code> <p>M365 GUID of the user (member)</p> required <code>show_error</code> <code>bool</code> <p>whether or not an error should be logged if the user                   is not a member of the group</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user is in the group. False otherwise.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def is_member(self, group_id: str, member_id: str, show_error: bool = True) -&gt; bool:\n\"\"\"Checks whether a M365 user is already in a M365 group\n    Args:\n        group_id (str): M365 GUID of the group\n        member_id (str): M365 GUID of the user (member)\n        show_error (bool): whether or not an error should be logged if the user\n                              is not a member of the group\n    Returns:\n        bool: True if the user is in the group. False otherwise.\n    \"\"\"\n# don't encode this URL - this has not been working!!\nrequest_url = (\nself.config()[\"groupsUrl\"]\n+ f\"/{group_id}/members?$filter=id eq '{member_id}'\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Check if user -&gt; %s is in group -&gt; %s; calling -&gt; %s\",\nmember_id,\ngroup_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(request_url, headers=request_header, timeout=60)\nif response.ok:\nresponse = self.parse_request_response(response)\nif not \"value\" in response or len(response[\"value\"]) == 0:\nreturn False\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\n# MS Graph API returns an error if the member is not in the\n# group. This is typically not what we want. We just return False.\nif show_error:\nlogger.error(\n\"Failed to check if user -&gt; %s is in group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nmember_id,\ngroup_id,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the request response (JSon) to a Python dict in a safe way    that also handles exceptions. It first tries to load the response.text    via json.loads() that produces a dict output. Only if response.text is    not set or is empty it just converts the response_object to a dict using    the vars() built-in method.</p> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>use a more specific error message                                       in case of an error</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>True: write an error to the log file                False: write a warning to the log file</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response information or None in case of an error</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def parse_request_response(\nself,\nresponse_object: requests.Response,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the request response (JSon) to a Python dict in a safe way\n       that also handles exceptions. It first tries to load the response.text\n       via json.loads() that produces a dict output. Only if response.text is\n       not set or is empty it just converts the response_object to a dict using\n       the vars() built-in method.\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str, optional): use a more specific error message\n                                                  in case of an error\n        show_error (bool): True: write an error to the log file\n                           False: write a warning to the log file\n    Returns:\n        dict: response information or None in case of an error\n    \"\"\"\nif not response_object:\nreturn None\ntry:\nif response_object.text:\ndict_object = json.loads(response_object.text)\nelse:\ndict_object = vars(response_object)\nexcept json.JSONDecodeError as exception:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, exception\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(\nexception\n)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.purge_deleted_item","title":"<code>purge_deleted_item(item_id)</code>","text":"<p>Helper method to purge a single deleted user or group.    This requires elevated permissions that are typically    not available via Graph API.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>str</code> <p>M365 GUID of the user or group to purge</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def purge_deleted_item(self, item_id: str) -&gt; dict | None:\n\"\"\"Helper method to purge a single deleted user or group.\n       This requires elevated permissions that are typically\n       not available via Graph API.\n    Args:\n        item_id (str): M365 GUID of the user or group to purge\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nrequest_url = self.config()[\"directoryUrl\"] + \"/deletedItems/\" + item_id\nrequest_header = self.request_header()\nlogger.info(\"Purging deleted item -&gt; %s; calling -&gt; %s\", item_id, request_url)\nretries = 0\nwhile True:\nresponse = requests.delete(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to purge deleted item -&gt; %s; status -&gt; %s; error -&gt; %s\",\nitem_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.purge_deleted_items","title":"<code>purge_deleted_items()</code>","text":"<p>Purge all deleted users and groups. Purging users and groups requires administrative rights that typically are not provided in Contoso example org.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def purge_deleted_items(self):\n\"\"\"Purge all deleted users and groups.\n    Purging users and groups requires administrative rights that typically\n    are not provided in Contoso example org.\n    \"\"\"\nrequest_header = self.request_header()\nrequest_url = (\nself.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.group\"\n)\nresponse = requests.get(request_url, headers=request_header, timeout=60)\ndeleted_groups = self.parse_request_response(response)\nfor group in deleted_groups[\"value\"]:\ngroup_id = group[\"id\"]\nresponse = self.purge_deleted_item(group_id)\nrequest_url = (\nself.config()[\"directoryUrl\"] + \"/deletedItems/microsoft.graph.user\"\n)\nresponse = requests.get(request_url, headers=request_header, timeout=60)\ndeleted_users = self.parse_request_response(response)\nfor user in deleted_users[\"value\"]:\nuser_id = user[\"id\"]\nresponse = self.purge_deleted_item(user_id)\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.remove_teams_app","title":"<code>remove_teams_app(app_id)</code>","text":"<p>Remove MS Teams App from the app catalog</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>Microsoft 365 GUID of the MS Teams app</p> required Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def remove_teams_app(self, app_id: str):\n\"\"\"Remove MS Teams App from the app catalog\n    Args:\n        app_id (str): Microsoft 365 GUID of the MS Teams app\n    \"\"\"\nrequest_url = self.config()[\"teamsAppsUrl\"] + \"/\" + app_id\n# Here we need the credentials of an authenticated user!\n# (not the application credentials (client_id, client_secret))\nrequest_header = self.request_header_user()\n# Make the DELETE request to remove the app from the app catalog\nresponse = requests.delete(request_url, headers=request_header, timeout=60)\n# Check the status code of the response\nif response.status_code == 204:\nlogger.info(\n\"The M365 Teams app with ID -&gt; %s has been successfully removed from the app catalog.\",\napp_id,\n)\nelse:\nlogger.error(\n\"An error occurred while removing the M365 Teams app from the M365 app catalog. Status code -&gt; %s. Error message -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.request_header","title":"<code>request_header(content_type='application/json')</code>","text":"<p>Returns the request header used for Application calls.    Consists of Bearer access token and Content Type</p> <p>Parameters:</p> Name Type Description Default <code>content_type</code> <code>str</code> <p>content type for the request</p> <code>'application/json'</code> Return <p>dict: request header values</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def request_header(self, content_type: str = \"application/json\") -&gt; dict:\n\"\"\"Returns the request header used for Application calls.\n       Consists of Bearer access token and Content Type\n    Args:\n        content_type (str, optional): content type for the request\n    Return:\n        dict: request header values\n    \"\"\"\nrequest_header = {\n\"Authorization\": \"Bearer {}\".format(self._access_token),\n\"Content-Type\": content_type,\n}\nreturn request_header\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.request_header_user","title":"<code>request_header_user(content_type='application/json')</code>","text":"<p>Returns the request header used for user specific calls.    Consists of Bearer access token and Content Type</p> <p>Parameters:</p> Name Type Description Default <code>content_type</code> <code>str</code> <p>content type for the request</p> <code>'application/json'</code> Return <p>dict: request header values</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def request_header_user(self, content_type: str = \"application/json\") -&gt; dict:\n\"\"\"Returns the request header used for user specific calls.\n       Consists of Bearer access token and Content Type\n    Args:\n        content_type (str, optional): content type for the request\n    Return:\n        dict: request header values\n    \"\"\"\nrequest_header = {\n\"Authorization\": \"Bearer {}\".format(self._user_access_token),\n\"Content-Type\": content_type,\n}\nreturn request_header\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_app_registration","title":"<code>update_app_registration(app_registration_id, app_registration_name, api_permissions, supported_account_type='AzureADMyOrg')</code>","text":"<p>Update an Azure App Registration</p> <p>Parameters:</p> Name Type Description Default <code>app_registration_id</code> <code>str</code> <p>ID of the existing App Registration</p> required <code>app_registration_name</code> <code>str</code> <p>name of the App Registration</p> required <code>api_permissions</code> <code>list</code> <p>API permissions</p> required <code>supported_account_type</code> <code>str</code> <p>type of account that is supposed to use                           the App Registration</p> <code>'AzureADMyOrg'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>App Registration data or None of the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_app_registration(\nself,\napp_registration_id: str,\napp_registration_name: str,\napi_permissions: list,\nsupported_account_type: str = \"AzureADMyOrg\",\n) -&gt; dict:\n\"\"\"Update an Azure App Registration\n    Args:\n        app_registration_id (str): ID of the existing App Registration\n        app_registration_name (str): name of the App Registration\n        api_permissions (list): API permissions\n        supported_account_type (str): type of account that is supposed to use\n                                      the App Registration\n    Returns:\n        dict: App Registration data or None of the request fails.\n    \"\"\"\n# Define the request body to create the App Registration\napp_registration_data = {\n\"displayName\": app_registration_name,\n\"requiredResourceAccess\": api_permissions,\n\"signInAudience\": supported_account_type,\n}\nrequest_url = self.config()[\"applicationsUrl\"] + \"/\" + app_registration_id\nrequest_header = self.request_header()\nlogger.info(\n\"Update App Registration -&gt; %s (%s); calling -&gt; %s\",\napp_registration_name,\napp_registration_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nrequest_url,\nheaders=request_header,\njson=app_registration_data,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Cannot update App Registration -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\napp_registration_name,\napp_registration_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_teams_app_of_channel","title":"<code>update_teams_app_of_channel(team_name, channel_name, tab_name, app_url, cs_node_id)</code>","text":"<p>Update an existing tab for Extended ECM app in an M365 Team channel</p> <p>Parameters:</p> Name Type Description Default <code>team_name</code> <code>str</code> <p>name of the M365 Team</p> required <code>channel_name</code> <code>str</code> <p>name of the channel</p> required <code>tab_name</code> <code>str</code> <p>name of the tab</p> required <code>cs_node_id</code> <code>int</code> <p>node ID of the target workspace or container in Extended ECM</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>return data structure (dictionary) or None if the request fails.</p> <code>dict | None</code> <p>Example return data:</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_teams_app_of_channel(\nself,\nteam_name: str,\nchannel_name: str,\ntab_name: str,\napp_url: str,\ncs_node_id: int,\n) -&gt; dict | None:\n\"\"\"Update an existing tab for Extended ECM app in an M365 Team channel\n    Args:\n        team_name (str): name of the M365 Team\n        channel_name (str): name of the channel\n        tab_name (str): name of the tab\n        app_url (str) web URL of the app\n        cs_node_id (int): node ID of the target workspace or container in Extended ECM\n    Returns:\n        dict: return data structure (dictionary) or None if the request fails.\n        Example return data:\n    \"\"\"\nresponse = self.get_team(team_name)\nteam_id = self.get_result_value(response, \"id\", 0)\nif not team_id:\nreturn None\n# Get the channels of the M365 Team:\nresponse = self.get_team_channels(team_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the channel by name and then retrieve its ID:\nchannel = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == channel_name),\nNone,\n)\nif not channel:\nlogger.erro(\n\"Cannot find Channel -&gt; %s for M365 Team -&gt; %s\", channel_name, team_name\n)\nreturn None\nchannel_id = channel[\"id\"]\n# Get the tabs of the M365 Team channel:\nresponse = self.get_team_channel_tabs(team_name, channel_name)\nif not response or not response[\"value\"] or not response[\"value\"][0]:\nreturn None\n# Look the tab by name and then retrieve its ID:\ntab = next(\n(item for item in response[\"value\"] if item[\"displayName\"] == tab_name),\nNone,\n)\nif not tab:\nlogger.erro(\n\"Cannot find Tab -&gt; %s on M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s)\",\ntab_name,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\n)\nreturn None\ntab_id = tab[\"id\"]\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ str(team_id)\n+ \"/channels/\"\n+ str(channel_id)\n+ \"/tabs/\"\n+ str(tab_id)\n)\nrequest_header = self.request_header()\n# Create tab configuration payload:\ntab_config = {\n\"configuration\": {\n\"entityId\": cs_node_id,  # Unique identifier for the tab\n\"contentUrl\": app_url,\n\"removeUrl\": \"\",\n\"websiteUrl\": app_url + \"&amp;showBW=true&amp;title=\" + tab_name,\n},\n}\nlogger.info(\n\"Update Tab -&gt; %s (%s) of Channel -&gt; %s (%s) for Microsoft 365 Teams -&gt; %s (%s) with configuration -&gt; %s; calling -&gt; %s\",\ntab_name,\ntab_id,\nchannel_name,\nchannel_id,\nteam_name,\nteam_id,\nstr(tab_config),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nrequest_url, headers=request_header, json=tab_config, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update Tab -&gt; %s (%s) for M365 Team -&gt; %s (%s) and Channel -&gt; %s (%s); status -&gt; %s; error -&gt; %s\",\ntab_name,\ntab_id,\nteam_name,\nteam_id,\nchannel_name,\nchannel_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_user","title":"<code>update_user(user_id, updated_settings)</code>","text":"<p>Update selected properties of an M365 user. Documentation    on user properties is here: https://learn.microsoft.com/en-us/graph/api/user-update</p> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Response of the M365 Graph API  or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_user(self, user_id: str, updated_settings: dict) -&gt; dict | None:\n\"\"\"Update selected properties of an M365 user. Documentation\n       on user properties is here: https://learn.microsoft.com/en-us/graph/api/user-update\n    Returns:\n        dict | None: Response of the M365 Graph API  or None if the call fails.\n    \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id\nrequest_header = self.request_header()\nlogger.info(\n\"Updating M365 user -&gt; %s with -&gt; %s; calling -&gt; %s\",\nuser_id,\nstr(updated_settings),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nrequest_url,\njson=updated_settings,\nheaders=request_header,\ntimeout=60,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update M365 user -&gt; %s with -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nstr(updated_settings),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.update_user_photo","title":"<code>update_user_photo(user_id, photo_path)</code>","text":"<p>Update the M365 user photo</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>photo_path</code> <code>str</code> <p>file system path with the location of the photo</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of Graph REST API or None if the user photo couldn't be updated.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def update_user_photo(self, user_id: str, photo_path: str) -&gt; dict | None:\n\"\"\"Update the M365 user photo\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        photo_path (str): file system path with the location of the photo\n    Returns:\n        dict: Response of Graph REST API or None if the user photo couldn't be updated.\n    \"\"\"\nrequest_url = self.config()[\"usersUrl\"] + \"/\" + user_id + \"/photo/$value\"\n# Set image as content type:\nrequest_header = self.request_header(\"image/*\")\n# Check if the photo file exists\nif not os.path.isfile(photo_path):\nlogger.error(\"Photo file -&gt; %s not found!\", photo_path)\nreturn None\ntry:\n# Read the photo file as binary data\nwith open(photo_path, \"rb\") as image_file:\nphoto_data = image_file.read()\nexcept OSError as exception:\n# Handle any errors that occurred while reading the photo file\nlogger.error(\n\"Error reading photo file -&gt; %s; error -&gt; %s\", photo_path, exception\n)\nreturn None\ndata = photo_data\nlogger.info(\n\"Update M365 user -&gt; %s with photo -&gt; %s; calling -&gt; %s\",\nuser_id,\nphoto_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nrequest_url, headers=request_header, data=data, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user -&gt; %s with photo -&gt; %s; status -&gt; %s; error -&gt; %s\",\nuser_id,\nphoto_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upgrade_teams_app_of_team","title":"<code>upgrade_teams_app_of_team(team_id, app_name)</code>","text":"<p>Upgrade a MS teams app for a specific team. The call will fail if the team does not     already have the app assigned. So this needs to be checked before     calling this method.     THIS IS CURRENTLY NOT WORKING AS EXPECTED.</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>app_name</code> <code>str</code> <p>exact name of the app</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upgrade_teams_app_of_team(self, team_id: str, app_name: str) -&gt; dict | None:\n\"\"\"Upgrade a MS teams app for a specific team. The call will fail if the team does not\n        already have the app assigned. So this needs to be checked before\n        calling this method.\n        THIS IS CURRENTLY NOT WORKING AS EXPECTED.\n    Args:\n        team_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        app_name (str): exact name of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nresponse = self.get_teams_apps_of_team(\nteam_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n)\n# Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\napp_installation_id = self.get_result_value(response, \"id\", 0)\nif not app_installation_id:\nlogger.error(\n\"M365 Teams app -&gt; %s not found for M365 Team with ID -&gt; %s. Cannot upgrade app for this team!\",\napp_name,\nteam_id,\n)\nreturn None\nrequest_url = (\nself.config()[\"teamsUrl\"]\n+ \"/\"\n+ team_id\n+ \"/installedApps/\"\n+ app_installation_id\n+ \"/upgrade\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; calling -&gt; %s\",\napp_name,\napp_installation_id,\nteam_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upgrade app -&gt; %s (%s) of M365 team with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_name,\napp_installation_id,\nteam_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upgrade_teams_app_of_user","title":"<code>upgrade_teams_app_of_user(user_id, app_name)</code>","text":"<p>Upgrade a MS teams app for a user. The call will fail if the user does not     already have the app assigned. So this needs to be checked before     calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>M365 GUID of the user (can also be the M365 email of the user)</p> required <code>app_name</code> <code>str</code> <p>exact name of the app</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response of the MS Graph API call or None if the call fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upgrade_teams_app_of_user(self, user_id: str, app_name: str) -&gt; dict | None:\n\"\"\"Upgrade a MS teams app for a user. The call will fail if the user does not\n        already have the app assigned. So this needs to be checked before\n        calling this method.\n    Args:\n        user_id (str): M365 GUID of the user (can also be the M365 email of the user)\n        app_name (str): exact name of the app\n    Returns:\n        dict: response of the MS Graph API call or None if the call fails.\n    \"\"\"\nresponse = self.get_teams_apps_of_user(\nuser_id, \"contains(teamsAppDefinition/displayName, '{}')\".format(app_name)\n)\n# Retrieve the installation specific App ID - this is different from thew App catalalog ID!!\napp_installation_id = self.get_result_value(response, \"id\", 0)\nif not app_installation_id:\nlogger.error(\n\"M365 Teams app -&gt; %s not found for user with ID -&gt; %s. Cannot upgrade app for this user!\",\napp_name,\nuser_id,\n)\nreturn None\nrequest_url = (\nself.config()[\"usersUrl\"]\n+ \"/\"\n+ user_id\n+ \"/teamwork/installedApps/\"\n+ app_installation_id\n+ \"/upgrade\"\n)\nrequest_header = self.request_header()\nlogger.info(\n\"Upgrade M365 Teams app -&gt; %s (%s) of M365 user with ID -&gt; %s; calling -&gt; %s\",\napp_name,\napp_installation_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(request_url, headers=request_header, timeout=60)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upgrade M365 Teams app -&gt; %s (%s) of M365 user -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_name,\napp_installation_id,\nuser_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upload_outlook_app","title":"<code>upload_outlook_app(app_path)</code>","text":"<p>Upload the M365 Outlook Add-In as \"Integrated\" App to M365 Admin Center.    THIS IS CURRENTLY NOT IMPLEMENTED DUE TO MISSING MS GRAPH API SUPPORT!</p> <p>https://admin.microsoft.com/#/Settings/IntegratedApps</p> <p>Parameters:</p> Name Type Description Default <code>app_path</code> <code>str</code> <p>path to manifest file in local file system. Needs to be             downloaded before.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: response of the MS Graph API or None if the request fails.</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upload_outlook_app(\nself,\napp_path: str,\n) -&gt; dict | None:\n\"\"\"Upload the M365 Outlook Add-In as \"Integrated\" App to M365 Admin Center.\n       THIS IS CURRENTLY NOT IMPLEMENTED DUE TO MISSING MS GRAPH API SUPPORT!\n       https://admin.microsoft.com/#/Settings/IntegratedApps\n    Args:\n        app_path (str): path to manifest file in local file system. Needs to be\n                        downloaded before.\n    Returns:\n        dict | None: response of the MS Graph API or None if the request fails.\n    \"\"\"\n#        request_url = self.config()[\"teamsAppsUrl\"]\n#        request_header = self.request_header()\nlogger.info(\"Install Outlook Add-in from %s (NOT IMPLEMENTED)\", app_path)\nresponse = None\nreturn response\n</code></pre>"},{"location":"pyxecm/m365/#pyxecm.customizer.m365.M365.upload_teams_app","title":"<code>upload_teams_app(app_path, update_existing_app=False, app_catalog_id='')</code>","text":"<p>Upload a new app package to the catalog of MS Teams apps.     This is not possible with client secret credentials     but requires a token of a user authenticated with username + password.     See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish     (permissions table on that page)</p> <p>Parameters:</p> Name Type Description Default <code>app_path</code> <code>str</code> <p>file path (with directory) to the app package to upload</p> required <code>update_existing_app</code> <code>bool</code> <p>whether or not to update an existing app with                         the same name</p> <code>False</code> <code>app_catalog_id</code> <code>str</code> <p>the unique ID of the app. It is the ID the app has in                   the catalog - which is different from ID an app gets                   after installation (which is tenant specific)</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of the MS GRAPH API REST call or None if the request fails</p> Source code in <code>pyxecm/customizer/m365.py</code> <pre><code>def upload_teams_app(\nself, app_path: str, update_existing_app: bool = False, app_catalog_id: str = \"\"\n) -&gt; dict | None:\n\"\"\"Upload a new app package to the catalog of MS Teams apps.\n        This is not possible with client secret credentials\n        but requires a token of a user authenticated with username + password.\n        See https://learn.microsoft.com/en-us/graph/api/teamsapp-publish\n        (permissions table on that page)\n    Args:\n        app_path (str): file path (with directory) to the app package to upload\n        update_existing_app (bool): whether or not to update an existing app with\n                                    the same name\n        app_catalog_id (str): the unique ID of the app. It is the ID the app has in\n                              the catalog - which is different from ID an app gets\n                              after installation (which is tenant specific)\n    Returns:\n        dict: Response of the MS GRAPH API REST call or None if the request fails\n    \"\"\"\nif update_existing_app and not app_catalog_id:\nlogger.error(\n\"To update an existing M365 Teams app in the app catalog you need to provide the existing App catalog ID!\"\n)\nreturn None\nif not os.path.exists(app_path):\nlogger.error(\"M365 Teams app file -&gt; {} does not exist!\")\nreturn None\n# Ensure that the app file is a zip file\nif not app_path.endswith(\".zip\"):\nlogger.error(\"M365 Teams app file -&gt; {} must be a zip file!\")\nreturn None\nrequest_url = self.config()[\"teamsAppsUrl\"]\n# If we want to upgrade an existing app we add the app ID and\n# the specific endpoint:\nif update_existing_app:\nrequest_url += \"/\" + app_catalog_id + \"/appDefinitions\"\n# Here we need the credentials of an authenticated user!\n# (not the application credentials (client_id, client_secret))\nrequest_header = self.request_header_user(\"application/zip\")\n# upload_files = {'file': open(app_path, 'rb')}\nwith open(app_path, \"rb\") as f:\napp_data = f.read()\nwith zipfile.ZipFile(app_path) as z:\n# Ensure that the app file contains a manifest.json file\nif \"manifest.json\" not in z.namelist():\nlogger.error(\n\"M365 Teams app file -&gt; {} does not contain a manifest.json file!\"\n)\nreturn None\nlogger.info(\n\"Upload M365 Teams app -&gt; %s to the MS Teams catalog; calling -&gt; %s\",\napp_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nrequest_url, headers=request_header, data=app_data, timeout=60\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nrequest_header = self.request_header()\nretries += 1\nelif response.status_code in [502, 503, 504] and retries &lt; 3:\nlogger.warning(\n\"M365 Graph API delivered server side error -&gt; %s; retrying in %s seconds...\",\nresponse.status_code,\n(retries + 1) * 60,\n)\ntime.sleep((retries + 1) * 60)\nretries += 1\nelse:\nif update_existing_app:\nlogger.warning(\n\"Failed to update existing M365 Teams app -&gt; %s (may be because it is not a new version); status -&gt; %s; error -&gt; %s\",\napp_path,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.error(\n\"Failed to upload new M365 Teams app -&gt; %s; status -&gt; %s; error -&gt; %s\",\napp_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otac/","title":"OTAC","text":"<p>OTAC Module to implement functions to apply Archive Center settings</p> <p>Class: OTAC Methods:</p> <p>init : class initializer config : returns config data set hostname: returns the Archive Center hostname set_hostname: sets the Archive Center hostname exec_command: exec a command on Archive Center put_cert: put Certificate on Archive Center enable_cert: enables Certitificate on Archive Center</p>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC","title":"<code>OTAC</code>","text":"<p>Used to automate stettings in OpenText Archive Center.</p> Source code in <code>pyxecm/otac.py</code> <pre><code>class OTAC:\n\"\"\"Used to automate stettings in OpenText Archive Center.\"\"\"\n_config = None\n_soap_token: str = \"\"\ndef __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\nds_username: str,\nds_password: str,\nadmin_username: str,\nadmin_password: str,\n):\n\"\"\"Initialize the OTAC object\n        Args:\n            protocol (str): Either http or https.\n            hostname (str): The hostname of the Archive Center  to communicate with.\n            port (int): The port number used to talk to the Archive Center .\n            ds_username (str): The admin user name of Archive Center (dsadmin).\n            ds_password (str): The admin password of Archive Center (dsadmin).\n            admin_username (str): The admin user name of Archive Center (otadmin@otds.admin).\n            admin_password (str): The admin password of Archive Center (otadmin@otds.admin).\n        \"\"\"\notac_config = {}\nif hostname:\notac_config[\"hostname\"] = hostname\nelse:\notac_config[\"hostname\"] = \"\"\nif protocol:\notac_config[\"protocol\"] = protocol\nelse:\notac_config[\"protocol\"] = \"http\"\nif port:\notac_config[\"port\"] = port\nelse:\notac_config[\"port\"] = 80\nif ds_username:\notac_config[\"ds_username\"] = ds_username\nelse:\notac_config[\"ds_username\"] = \"dsadmin\"\nif ds_password:\notac_config[\"ds_password\"] = ds_password\nelse:\notac_config[\"ds_password\"] = \"\"\nif admin_username:\notac_config[\"admin_username\"] = admin_username\nelse:\notac_config[\"admin_username\"] = \"admin\"\nif admin_password:\notac_config[\"admin_password\"] = admin_password\nelse:\notac_config[\"admin_password\"] = \"\"\notac_base_url = protocol + \"://\" + otac_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notac_base_url += \":{}\".format(port)\notac_exec_url = otac_base_url + \"/archive/admin/exec\"\notac_config[\"execUrl\"] = otac_exec_url\notac_config[\"baseUrl\"] = otac_base_url\nself._config = otac_config\ndef config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\nreturn self._config\ndef hostname(self) -&gt; str:\n\"\"\"Returns the Archive Center hostname\n        Returns:\n            str: Archive Center hostname\n        \"\"\"\nreturn self.config()[\"hostname\"]\ndef set_hostname(self, hostname: str):\n\"\"\"Sets the Archive Center hostname\n        Args:\n            hostname (str): new Archive Center hostname\n        \"\"\"\nself.config()[\"hostname\"] = hostname\ndef set_credentials(\nself,\nds_username: str = \"\",\nds_password: str = \"\",\nadmin_username: str = \"\",\nadmin_password: str = \"\",\n):\n\"\"\"Set the credentials for Archive Center for the \"ds\" and \"admin\" users.\n        Args:\n            ds_username (str, optional): non-default user name of the \"ds\" user. Defaults to \"\".\n            ds_password (str, optional): non-default password of the \"ds\" user. Defaults to \"\".\n            admin_username (str, optional): non-default user name of the \"admin\" user. Defaults to \"\".\n            admin_password (str, optional): non-default password of the \"admin\" user. Defaults to \"\".\n        \"\"\"\nif ds_username:\nself.config()[\"ds_username\"] = ds_username\nelse:\nself.config()[\"ds_username\"] = \"dsadmin\"\nif ds_password:\nself.config()[\"ds_password\"] = ds_password\nelse:\nself.config()[\"ds_password\"] = \"\"\nif admin_username:\nself.config()[\"admin_username\"] = admin_username\nelse:\nself.config()[\"admin_username\"] = \"admin\"\nif admin_password:\nself.config()[\"admin_password\"] = admin_password\nelse:\nself.config()[\"admin_password\"] = \"\"\ndef base_url(self) -&gt; str:\n\"\"\"Returns the Archive Center base URL\n        Returns:\n            str: Archive Center base URL\n        \"\"\"\nreturn self.config()[\"baseUrl\"]\ndef exec_url(self) -&gt; str:\n\"\"\"Returns the Archive Center URL to execute commandss\n        Returns:\n            str: Archive Center exec URL\n        \"\"\"\nreturn self.config()[\"execUrl\"]\ndef _soap_login(self):\n\"\"\"Authenticate via SOAP with admin User\n        Args:\n            None\n        Returns:\n            string: soap_token\n        \"\"\"\nurl = self.base_url() + \"/archive/services/Authentication?wsdl\"\nclient = Client(url)\nself._soap_token = client.service.Authenticate(\nusername=self.config()[\"admin_username\"],\npassword=self.config()[\"admin_password\"],\n)\nreturn self._soap_token\n# end method definition\ndef exec_command(self, command: str):\n\"\"\"Execute a command on Archive Center\n        Args:\n            command (str): command to execute\n        Returns:\n            _type_: _description_\n        \"\"\"\npayload = {\n\"command\": command,\n\"user\": self.config()[\"ds_username\"],\n\"passwd\": self.config()[\"ds_password\"],\n}\nrequest_url = self.exec_url()\nlogger.info(\n\"Execute command -&gt; %s on Archive Center (user -&gt; %s); calling -&gt; %s\",\ncommand,\npayload[\"user\"],\nrequest_url,\n)\nresponse = requests.post(\nurl=request_url, data=payload, headers=requestHeaders, timeout=None\n)\nif not response.ok:\nlogger.error(\n\"Failed to execute command -&gt; %s on Archive Center; error -&gt; %s\",\ncommand,\nresponse.text.replace(\"\\n\", \" \"),  # avoid multi-line log entries\n)\nreturn response\n# end method definition\ndef put_cert(\nself,\nauth_id: str,\nlogical_archive: str,\ncert_path: str,\npermissions: str = \"rcud\",\n):\n\"\"\"Put Certificate on Archive Center\n        Args:\n            auth_id (str): ID of Certification\n            logical_archive (str): Archive ID\n            cert_path (str): local path to certificate (base64)\n            permissions (str, optional): Permissions of the certificate.\n                                         Defaults to \"rcud\" (read-create-update-delete).\n        Returns:\n            response or None if the request fails\n        \"\"\"\n# Check if the photo file exists\nif not os.path.isfile(cert_path):\nlogger.error(\"Certificate file -&gt; %s not found!\", cert_path)\nreturn None\nwith open(file=cert_path, mode=\"r\", encoding=\"utf-8\") as cert_file:\ncert_content = cert_file.read().strip()\n# Check that we have the pem certificate file - this is what OTAC expects.\n# If the file content is base64 encoded we will decode it\nif \"BEGIN CERTIFICATE\" in cert_content:\nlogger.info(\"Certificate file -&gt; %s is not base64 encoded\", cert_path)\nelif \"BEGIN CERTIFICATE\" in base64.b64decode(\ncert_content, validate=True\n).decode(\"utf-8\"):\nlogger.info(\"Certificate file -&gt; %s is base64 encoded\", cert_path)\ncert_content = base64.b64decode(cert_content, validate=True).decode(\"utf-8\")\nelse:\nlogger.error(\"Certificate file -&gt; %s is not in the right format\", cert_path)\nreturn None\nrequest_url = (\nself.base_url()\n+ \"/archive?putCert&amp;pVersion=0046&amp;authId=\"\n+ auth_id\n+ \"&amp;contRep=\"\n+ logical_archive\n+ \"&amp;permissions=\"\n+ permissions\n)\nlogger.info(\n\"Putting certificate -&gt; %s on Archive -&gt; %s; calling -&gt; %s\",\ncert_path,\nlogical_archive,\nrequest_url,\n)\nresponse = requests.put(\nurl=request_url, data=cert_content, headers=requestHeaders, timeout=None\n)\nif not response.ok:\nmessage = response.text.split(\n'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN'\n)[0]\nlogger.error(\n\"Failed to put certificate -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\ncert_path,\nlogical_archive,\nmessage,\n)\nreturn response\n# end method definition\ndef enable_cert(self, auth_id: str, logical_archive: str, enable: bool = True):\n\"\"\"Enables Certitificate on Archive Center\n        Args:\n            auth_id (str): Client ID\n            logical_archive (str): Archive ID\n            enable (bool, optional): Enable or Disable certificate. Defaults to True.\n        Returns:\n            response or None if request fails.\n        \"\"\"\nif not self._soap_token:\nself._soap_login()\nif enable:\nenabled: int = 1\nelse:\nenabled: int = 0\nurl = self.base_url() + \"/ot-admin/services/ArchiveAdministration?wsdl\"\nclient = Client(url)\ntoken_header = client.factory.create(\"ns0:OTAuthentication\")\ntoken_header.AuthenticationToken = self._soap_token\nclient.set_options(soapheaders=token_header)\ntry:\nresponse = client.service.invokeCommand(\ncommand=\"SetCertificateFlags\",\nparameters=[\n{\"key\": \"CERT_TYPE\", \"data\": \"@{}\".format(logical_archive)},\n{\"key\": \"CERT_NAME\", \"data\": auth_id},\n{\"key\": \"CERT_FLAGS\", \"data\": enabled},\n],\n)\nreturn response\nexcept WebFault as exception:\nlogger.error(\n\"Failed to execute SetCertificateFlags for Client -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\nauth_id,\nlogical_archive,\nexception,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.__init__","title":"<code>__init__(protocol, hostname, port, ds_username, ds_password, admin_username, admin_password)</code>","text":"<p>Initialize the OTAC object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>Either http or https.</p> required <code>hostname</code> <code>str</code> <p>The hostname of the Archive Center  to communicate with.</p> required <code>port</code> <code>int</code> <p>The port number used to talk to the Archive Center .</p> required <code>ds_username</code> <code>str</code> <p>The admin user name of Archive Center (dsadmin).</p> required <code>ds_password</code> <code>str</code> <p>The admin password of Archive Center (dsadmin).</p> required <code>admin_username</code> <code>str</code> <p>The admin user name of Archive Center (otadmin@otds.admin).</p> required <code>admin_password</code> <code>str</code> <p>The admin password of Archive Center (otadmin@otds.admin).</p> required Source code in <code>pyxecm/otac.py</code> <pre><code>def __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\nds_username: str,\nds_password: str,\nadmin_username: str,\nadmin_password: str,\n):\n\"\"\"Initialize the OTAC object\n    Args:\n        protocol (str): Either http or https.\n        hostname (str): The hostname of the Archive Center  to communicate with.\n        port (int): The port number used to talk to the Archive Center .\n        ds_username (str): The admin user name of Archive Center (dsadmin).\n        ds_password (str): The admin password of Archive Center (dsadmin).\n        admin_username (str): The admin user name of Archive Center (otadmin@otds.admin).\n        admin_password (str): The admin password of Archive Center (otadmin@otds.admin).\n    \"\"\"\notac_config = {}\nif hostname:\notac_config[\"hostname\"] = hostname\nelse:\notac_config[\"hostname\"] = \"\"\nif protocol:\notac_config[\"protocol\"] = protocol\nelse:\notac_config[\"protocol\"] = \"http\"\nif port:\notac_config[\"port\"] = port\nelse:\notac_config[\"port\"] = 80\nif ds_username:\notac_config[\"ds_username\"] = ds_username\nelse:\notac_config[\"ds_username\"] = \"dsadmin\"\nif ds_password:\notac_config[\"ds_password\"] = ds_password\nelse:\notac_config[\"ds_password\"] = \"\"\nif admin_username:\notac_config[\"admin_username\"] = admin_username\nelse:\notac_config[\"admin_username\"] = \"admin\"\nif admin_password:\notac_config[\"admin_password\"] = admin_password\nelse:\notac_config[\"admin_password\"] = \"\"\notac_base_url = protocol + \"://\" + otac_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notac_base_url += \":{}\".format(port)\notac_exec_url = otac_base_url + \"/archive/admin/exec\"\notac_config[\"execUrl\"] = otac_exec_url\notac_config[\"baseUrl\"] = otac_base_url\nself._config = otac_config\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.base_url","title":"<code>base_url()</code>","text":"<p>Returns the Archive Center base URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Archive Center base URL</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def base_url(self) -&gt; str:\n\"\"\"Returns the Archive Center base URL\n    Returns:\n        str: Archive Center base URL\n    \"\"\"\nreturn self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.enable_cert","title":"<code>enable_cert(auth_id, logical_archive, enable=True)</code>","text":"<p>Enables Certitificate on Archive Center</p> <p>Parameters:</p> Name Type Description Default <code>auth_id</code> <code>str</code> <p>Client ID</p> required <code>logical_archive</code> <code>str</code> <p>Archive ID</p> required <code>enable</code> <code>bool</code> <p>Enable or Disable certificate. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>response or None if request fails.</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def enable_cert(self, auth_id: str, logical_archive: str, enable: bool = True):\n\"\"\"Enables Certitificate on Archive Center\n    Args:\n        auth_id (str): Client ID\n        logical_archive (str): Archive ID\n        enable (bool, optional): Enable or Disable certificate. Defaults to True.\n    Returns:\n        response or None if request fails.\n    \"\"\"\nif not self._soap_token:\nself._soap_login()\nif enable:\nenabled: int = 1\nelse:\nenabled: int = 0\nurl = self.base_url() + \"/ot-admin/services/ArchiveAdministration?wsdl\"\nclient = Client(url)\ntoken_header = client.factory.create(\"ns0:OTAuthentication\")\ntoken_header.AuthenticationToken = self._soap_token\nclient.set_options(soapheaders=token_header)\ntry:\nresponse = client.service.invokeCommand(\ncommand=\"SetCertificateFlags\",\nparameters=[\n{\"key\": \"CERT_TYPE\", \"data\": \"@{}\".format(logical_archive)},\n{\"key\": \"CERT_NAME\", \"data\": auth_id},\n{\"key\": \"CERT_FLAGS\", \"data\": enabled},\n],\n)\nreturn response\nexcept WebFault as exception:\nlogger.error(\n\"Failed to execute SetCertificateFlags for Client -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\nauth_id,\nlogical_archive,\nexception,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.exec_command","title":"<code>exec_command(command)</code>","text":"<p>Execute a command on Archive Center</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>command to execute</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def exec_command(self, command: str):\n\"\"\"Execute a command on Archive Center\n    Args:\n        command (str): command to execute\n    Returns:\n        _type_: _description_\n    \"\"\"\npayload = {\n\"command\": command,\n\"user\": self.config()[\"ds_username\"],\n\"passwd\": self.config()[\"ds_password\"],\n}\nrequest_url = self.exec_url()\nlogger.info(\n\"Execute command -&gt; %s on Archive Center (user -&gt; %s); calling -&gt; %s\",\ncommand,\npayload[\"user\"],\nrequest_url,\n)\nresponse = requests.post(\nurl=request_url, data=payload, headers=requestHeaders, timeout=None\n)\nif not response.ok:\nlogger.error(\n\"Failed to execute command -&gt; %s on Archive Center; error -&gt; %s\",\ncommand,\nresponse.text.replace(\"\\n\", \" \"),  # avoid multi-line log entries\n)\nreturn response\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.exec_url","title":"<code>exec_url()</code>","text":"<p>Returns the Archive Center URL to execute commandss</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Archive Center exec URL</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def exec_url(self) -&gt; str:\n\"\"\"Returns the Archive Center URL to execute commandss\n    Returns:\n        str: Archive Center exec URL\n    \"\"\"\nreturn self.config()[\"execUrl\"]\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.hostname","title":"<code>hostname()</code>","text":"<p>Returns the Archive Center hostname</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Archive Center hostname</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def hostname(self) -&gt; str:\n\"\"\"Returns the Archive Center hostname\n    Returns:\n        str: Archive Center hostname\n    \"\"\"\nreturn self.config()[\"hostname\"]\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.put_cert","title":"<code>put_cert(auth_id, logical_archive, cert_path, permissions='rcud')</code>","text":"<p>Put Certificate on Archive Center</p> <p>Parameters:</p> Name Type Description Default <code>auth_id</code> <code>str</code> <p>ID of Certification</p> required <code>logical_archive</code> <code>str</code> <p>Archive ID</p> required <code>cert_path</code> <code>str</code> <p>local path to certificate (base64)</p> required <code>permissions</code> <code>str</code> <p>Permissions of the certificate.                          Defaults to \"rcud\" (read-create-update-delete).</p> <code>'rcud'</code> <p>Returns:</p> Type Description <p>response or None if the request fails</p> Source code in <code>pyxecm/otac.py</code> <pre><code>def put_cert(\nself,\nauth_id: str,\nlogical_archive: str,\ncert_path: str,\npermissions: str = \"rcud\",\n):\n\"\"\"Put Certificate on Archive Center\n    Args:\n        auth_id (str): ID of Certification\n        logical_archive (str): Archive ID\n        cert_path (str): local path to certificate (base64)\n        permissions (str, optional): Permissions of the certificate.\n                                     Defaults to \"rcud\" (read-create-update-delete).\n    Returns:\n        response or None if the request fails\n    \"\"\"\n# Check if the photo file exists\nif not os.path.isfile(cert_path):\nlogger.error(\"Certificate file -&gt; %s not found!\", cert_path)\nreturn None\nwith open(file=cert_path, mode=\"r\", encoding=\"utf-8\") as cert_file:\ncert_content = cert_file.read().strip()\n# Check that we have the pem certificate file - this is what OTAC expects.\n# If the file content is base64 encoded we will decode it\nif \"BEGIN CERTIFICATE\" in cert_content:\nlogger.info(\"Certificate file -&gt; %s is not base64 encoded\", cert_path)\nelif \"BEGIN CERTIFICATE\" in base64.b64decode(\ncert_content, validate=True\n).decode(\"utf-8\"):\nlogger.info(\"Certificate file -&gt; %s is base64 encoded\", cert_path)\ncert_content = base64.b64decode(cert_content, validate=True).decode(\"utf-8\")\nelse:\nlogger.error(\"Certificate file -&gt; %s is not in the right format\", cert_path)\nreturn None\nrequest_url = (\nself.base_url()\n+ \"/archive?putCert&amp;pVersion=0046&amp;authId=\"\n+ auth_id\n+ \"&amp;contRep=\"\n+ logical_archive\n+ \"&amp;permissions=\"\n+ permissions\n)\nlogger.info(\n\"Putting certificate -&gt; %s on Archive -&gt; %s; calling -&gt; %s\",\ncert_path,\nlogical_archive,\nrequest_url,\n)\nresponse = requests.put(\nurl=request_url, data=cert_content, headers=requestHeaders, timeout=None\n)\nif not response.ok:\nmessage = response.text.split(\n'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN'\n)[0]\nlogger.error(\n\"Failed to put certificate -&gt; %s on Archive -&gt; %s; error -&gt; %s\",\ncert_path,\nlogical_archive,\nmessage,\n)\nreturn response\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.set_credentials","title":"<code>set_credentials(ds_username='', ds_password='', admin_username='', admin_password='')</code>","text":"<p>Set the credentials for Archive Center for the \"ds\" and \"admin\" users.</p> <p>Parameters:</p> Name Type Description Default <code>ds_username</code> <code>str</code> <p>non-default user name of the \"ds\" user. Defaults to \"\".</p> <code>''</code> <code>ds_password</code> <code>str</code> <p>non-default password of the \"ds\" user. Defaults to \"\".</p> <code>''</code> <code>admin_username</code> <code>str</code> <p>non-default user name of the \"admin\" user. Defaults to \"\".</p> <code>''</code> <code>admin_password</code> <code>str</code> <p>non-default password of the \"admin\" user. Defaults to \"\".</p> <code>''</code> Source code in <code>pyxecm/otac.py</code> <pre><code>def set_credentials(\nself,\nds_username: str = \"\",\nds_password: str = \"\",\nadmin_username: str = \"\",\nadmin_password: str = \"\",\n):\n\"\"\"Set the credentials for Archive Center for the \"ds\" and \"admin\" users.\n    Args:\n        ds_username (str, optional): non-default user name of the \"ds\" user. Defaults to \"\".\n        ds_password (str, optional): non-default password of the \"ds\" user. Defaults to \"\".\n        admin_username (str, optional): non-default user name of the \"admin\" user. Defaults to \"\".\n        admin_password (str, optional): non-default password of the \"admin\" user. Defaults to \"\".\n    \"\"\"\nif ds_username:\nself.config()[\"ds_username\"] = ds_username\nelse:\nself.config()[\"ds_username\"] = \"dsadmin\"\nif ds_password:\nself.config()[\"ds_password\"] = ds_password\nelse:\nself.config()[\"ds_password\"] = \"\"\nif admin_username:\nself.config()[\"admin_username\"] = admin_username\nelse:\nself.config()[\"admin_username\"] = \"admin\"\nif admin_password:\nself.config()[\"admin_password\"] = admin_password\nelse:\nself.config()[\"admin_password\"] = \"\"\n</code></pre>"},{"location":"pyxecm/otac/#pyxecm.otac.OTAC.set_hostname","title":"<code>set_hostname(hostname)</code>","text":"<p>Sets the Archive Center hostname</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>new Archive Center hostname</p> required Source code in <code>pyxecm/otac.py</code> <pre><code>def set_hostname(self, hostname: str):\n\"\"\"Sets the Archive Center hostname\n    Args:\n        hostname (str): new Archive Center hostname\n    \"\"\"\nself.config()[\"hostname\"] = hostname\n</code></pre>"},{"location":"pyxecm/otcs/","title":"OTCS","text":"<p>OTCS Module to implement functions to read / write Content Server objects such as Users, Groups, Nodes, Workspaces, ...</p> <p>Class: OTCS Methods:</p> <p>init : class initializer config : returns config data set cookie : returns cookie information credentials: Get credentials (username and password) set_credentials: Set new credentials hostname: Get the configured OTCS hostname set_hostname: Set the hostname of OTCS base_url : Get OTCS base URL cs_url: Get the Extended ECM (OTCS) URL rest_url : Get OTCS REST base URL</p> <p>request_form_header: Deliver the request header used for the CRUD REST API calls. request_json_header: Deliver the request header for REST calls that require content type application/json.</p> Deliver the request header used for download REST API calls. <p>These calls accept application/octet-stream.</p> Converts the text property of a request response object <p>to a Python dict in a safe way</p> Lookup a property value based on a provided key / value pair in the response <p>properties of an Extended ECM REST API call</p> <p>exist_result_item: Check existence of key / value pair in the response properties of an Extended ECM REST API call.</p> Read an item value from the REST API response. This is considering the most typical structures <p>delivered by V2 REST API of Extended ECM</p> <p>is_configured: returns true if the OTCS pod is ready to serve requests authenticate : Authenticates at Content Server and retrieve OTCS Ticket.</p> <p>get_server_info: return OTCS server information</p> <p>apply_config: Apply Content Server administration settings from XML file</p> <p>get_user: Lookup Content Server user add_user: Add Content Server user search_user: Find a user based on search criteria update_user: Update a defined field for a user get_user_profile: Get the profile (settings) for the current user</p> Update a defined field of the user profile (settings) <p>for the current user.</p> <p>update_user_photo: Update a user with a profile photo (which must be an existing node) is_proxy: Check if a user (login name) is a proxy of the current user get_user_proxies: Get the list of proxy users for the current user add_user_proxy: Add a proxy to the current (authenticated) user add_favorite: Add a favorite for the current (authenticated) user</p> <p>get_group: Lookup Content Server group add_group: Add Content Server group get_group_members: Get Content Server group members add_group_member: Add a user or group to a target group</p> <p>get_node: Get a node based on the node ID get_node_by_parent_and_name: Get a node based on the parent ID and name get_node_by_workspace_and_path: Get a node based on the workspace ID and path (list of folder names) get_node_by_volume_and_path: Get a node based on the volume ID and path get_node_from_nickname: Get a node based on the nickname get_subnodes: get children nodes of a parent node get_node_actions: get possible actions for a node rename_node: Change the name and description of a node get_volumes: Get all Volumes get_volume: Get Volume information based on the volume type ID check_node_name: Check if a a node name in a parent location has a name collision</p> Fetch a file from a URL or local filesystem and upload <p>it to a Extended ECM volume</p> <p>upload_file_to_parent: Upload a document to a parent folder add_document_version: Add a version to an Extended ECM document get_latest_document_version: Get latest version of a document node based on the node ID. get_document_content: get content of a document version download_document: Download a document</p> Download a config file from a given OTCS URL. <p>This is NOT for downloading documents from within the OTCS repository</p> <p>search: search for a search term using Extended ECM search engine</p> <p>get_external_system_connection: Get Extended ECM external system connection add_external_system_connection: Add Extended ECM external system connection</p> <p>create_transport_workbench: Create a Workbench in the Transport Volume unpack_transport_package: Unpack an existing Transport Package into an existing Workbench deploy_workbench: Deploy an existing Workbench</p> Main method to deploy a transport. This uses subfunctions to upload, <p>unpackage and deploy the transport, and creates the required workbench</p> <p>replace_transport_placeholders: Search and replace strings in the XML files of the transport packlage</p> <p>get_workspace_types: Get all workspace types configured in Extended ECM get_business_object_type: Get information for a specific business object type get_workspace_create_form: Get the Workspace create form get_workspace: Get a workspace node get_workspace_instances: Get all instances of a given workspace type  get_workspace_by_type_and_name: Lookup workspace based on workspace type name and workspace name get_workspace_by_business_object: Lookup workspace based by an business object of an external system create_workspace: Create a new business workspace create_workspace_relationship: Create a relationship between two workspaces get_workspace_relationships: get a list of related workspaces get_workspace_roles: Get the Workspace roles add_member_to_workspace: Add member to workspace role. Check that the user is not yet a member remove_member_from_workspace: Remove member from workspace role assign_workspace_permissions: Update workspace permissions for a given role update_workspace_icon: Update a workspace with a with a new icon (which is uploaded)</p> <p>create_item: Create an item in Extended ECM (e.g. folder or URL item) update_item: Update an item in Extended ECM (e.g. folder or URL item) get_document_templates: Get all document templates for a given target location create_document_from_template: Create a document based on a document template</p> <p>get_web_report_parameters: Get parameters of a Web Report run_web_report: Run a Web Report that is identified by its nick name</p> <p>install_cs_application: Install a CS Application (based on WebReports)</p> <p>assign_item_to_user_group: Assign an item (e.g. Workspace or document) to a list of users or groups</p> <p>convert_permission_string_to_permission_value: Convert a list of permission names to a permission value convert_permission_value_to_permission_string: Convert a permission value to a list of permission strings assign_permission: Assign permissions to an item for a defined user or group</p> <p>get_node_categories: Get categories assigned to a node get_node_category: Get a specific category assigned to a node get_node_category_ids: Get list of all category definition IDs that are assign to the node. get_node_category_definition: Get category definition (category id and attribute IDs and types) assign_category: Assign a category to a node set_category_value: Set a value for a specific category attribute to a node</p> <p>assign_classification: Assign a classification to an item assign_rm_classification: Assign a Records management classification to an item</p> <p>register_workspace_template: Register a workspace template for Extended ECM for Engineering</p> <p>get_records_management_rsis: Get the ist of RSIs together with their RSI schedules get_records_management_codes: Get Records Management Codes update_records_management_codes: Update the Records Management Codes create_records_management_rsi: Create a new Records Management RSI item create_records_management_rsi_schedule: Create a schedule for an existing RSI item create_records_management_hold: Create a Records Management Hold get_records_management_holds: Get a list of all Records Management Holds in the system. import_records_management_codes: Import RM codes from a config file import_records_management_rsis: Import RM RSIs from a config file import_records_management_settings: Import Records Management settings from a config file import_physical_objects_codes: Import Physical Objects codes from a config file import_physical_objects_settings: Import Physical Objects settings from a config file import_physical_objects_locators: Import Physical Objects locators from a config file import_security_clearance_codes: Import Securioty Clearance codes from a config file</p> <p>assign_user_security_clearance: Assign a Security Clearance level to a user assign_user_supplemental_markings: Assign a list of Supplemental Markings to a user</p> <p>check_workspace_aviator: Check if Content Aviator is enabled for a workspace update_workspace_aviator: Enable or disable the Content Aviator for a workspace</p>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS","title":"<code>OTCS</code>","text":"<p>Used to automate stettings in OpenText Extended ECM.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>class OTCS:\n\"\"\"Used to automate stettings in OpenText Extended ECM.\"\"\"\n_config: dict\n_cookie = None\n_otcs_ticket = None\n_otds_ticket = None\ndef __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\npublic_url: str,\nusername: str | None = None,\npassword: str | None = None,\nuser_partition: str = \"Content Server Members\",\nresource_name: str = \"cs\",\ndefault_license: str = \"X3\",\notds_ticket: str | None = None,\n):\n\"\"\"Initialize the OTCS object\n        Args:\n            protocol (str): Either http or https.\n            hostname (str): The hostname of Extended ECM server to communicate with.\n            port (int): The port number used to talk to the Extended ECM server.\n            public_url (str): public (external) URL\n            username (str, optional): The admin user name of Extended ECM. Optional if otds_ticket is provided.\n            password (str, optional): The admin password of Extended ECM. Optional if otds_ticket is provided.\n            user_partition (str): Name of the OTDS partition for OTCS users. Default is \"Content Server Members\".\n            resource_name (str, optional): Name of the OTDS resource for OTCS. Dault is \"cs\".\n            default_license (str, optional): name of the default user license. Default is \"X3\".\n            otds_ticket (str, optional): Authentication ticket of OTDS\n        \"\"\"\n# Initialize otcs_config as an empty dictionary\notcs_config = {}\nif hostname:\notcs_config[\"hostname\"] = hostname\nelse:\notcs_config[\"hostname\"] = \"otcs-admin-0\"\nif protocol:\notcs_config[\"protocol\"] = protocol\nelse:\notcs_config[\"protocol\"] = \"http\"\nif port:\notcs_config[\"port\"] = port\nelse:\notcs_config[\"port\"] = 8080\notcs_config[\"publicUrl\"] = public_url\nif username:\notcs_config[\"username\"] = username\nelse:\notcs_config[\"username\"] = \"admin\"\nif password:\notcs_config[\"password\"] = password\nelse:\notcs_config[\"password\"] = \"\"\nif user_partition:\notcs_config[\"partition\"] = user_partition\nelse:\notcs_config[\"partition\"] = \"\"\nif resource_name:\notcs_config[\"resource\"] = resource_name\nelse:\notcs_config[\"resource\"] = \"\"\nif default_license:\notcs_config[\"license\"] = default_license\nelse:\notcs_config[\"license\"] = \"\"\notcs_base_url = protocol + \"://\" + otcs_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notcs_base_url += \":{}\".format(port)\notcs_config[\"baseUrl\"] = otcs_base_url\notcs_support_url = otcs_base_url + \"/cssupport\"\notcs_config[\"supportUrl\"] = otcs_support_url\notcs_public_support_url = public_url + \"/cssupport\"\notcs_config[\"supportPublicUrl\"] = otcs_public_support_url\notcs_config[\"configuredUrl\"] = otcs_support_url + \"/csconfigured\"\notcs_url = otcs_base_url + \"/cs/cs\"\notcs_config[\"csUrl\"] = otcs_url\notcs_public_url = public_url + \"/cs/cs\"\notcs_config[\"csPublicUrl\"] = otcs_public_url\notcs_rest_url = otcs_url + \"/api\"\notcs_config[\"restUrl\"] = otcs_rest_url\notcs_config[\"isReady\"] = otcs_rest_url + \"/v1/ping\"\notcs_config[\"authenticationUrl\"] = otcs_rest_url + \"/v1/auth\"\notcs_config[\"serverInfoUrl\"] = otcs_rest_url + \"/v1/serverinfo\"\notcs_config[\"membersUrl\"] = otcs_rest_url + \"/v1/members\"\notcs_config[\"membersUrlv2\"] = otcs_rest_url + \"/v2/members\"\notcs_config[\"nodesUrl\"] = otcs_rest_url + \"/v1/nodes\"\notcs_config[\"nodesUrlv2\"] = otcs_rest_url + \"/v2/nodes\"\notcs_config[\"doctemplatesUrl\"] = otcs_rest_url + \"/v2/doctemplates\"\notcs_config[\"nicknameUrl\"] = otcs_rest_url + \"/v2/nicknames\"\notcs_config[\"importSettingsUrl\"] = otcs_rest_url + \"/v2/import/settings/admin\"\notcs_config[\"searchUrl\"] = otcs_rest_url + \"/v2/search\"\notcs_config[\"volumeUrl\"] = otcs_rest_url + \"/v2/volumes\"\notcs_config[\"externalSystem\"] = otcs_rest_url + \"/v2/externalsystems\"\notcs_config[\"businessworkspacetypes\"] = (\notcs_rest_url + \"/v2/businessworkspacetypes\"\n)\notcs_config[\"businessworkspacecreateform\"] = (\notcs_rest_url + \"/v2/forms/businessworkspaces/create\"\n)\notcs_config[\"businessworkspaces\"] = otcs_rest_url + \"/v2/businessworkspaces\"\notcs_config[\"favoritesUrl\"] = otcs_rest_url + \"/v2/members/favorites\"\notcs_config[\"webReportsUrl\"] = otcs_rest_url + \"/v1/webreports\"\notcs_config[\"csApplicationsUrl\"] = otcs_rest_url + \"/v2/csapplications\"\notcs_config[\"xEngProjectTemplateUrl\"] = (\notcs_rest_url + \"/v2/xengcrt/projecttemplate\"\n)\notcs_config[\"rsisUrl\"] = otcs_rest_url + \"/v2/rsis\"\notcs_config[\"rsiSchedulesUrl\"] = otcs_rest_url + \"/v2/rsischedules\"\notcs_config[\"recordsManagementUrl\"] = otcs_rest_url + \"/v1/recordsmanagement\"\notcs_config[\"recordsManagementUrlv2\"] = otcs_rest_url + \"/v2/recordsmanagement\"\notcs_config[\"userSecurityUrl\"] = otcs_rest_url + \"/v2/members/usersecurity\"\notcs_config[\"physicalObjectsUrl\"] = otcs_rest_url + \"/v1/physicalobjects\"\notcs_config[\"securityClearancesUrl\"] = otcs_rest_url + \"/v1/securityclearances\"\notcs_config[\"holdsUrl\"] = otcs_rest_url + \"/v1/holds\"\notcs_config[\"holdsUrlv2\"] = otcs_rest_url + \"/v2/holds\"\notcs_config[\"validationUrl\"] = otcs_rest_url + \"/v1/validation/nodes/names\"\notcs_config[\"aiUrl\"] = otcs_rest_url + \"/v2/ai/nodes\"\nself._config = otcs_config\nself._otds_ticket = otds_ticket\ndef config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\nreturn self._config\ndef cookie(self) -&gt; dict:\n\"\"\"Returns the login cookie of Extended ECM.\n           This is set by the authenticate() method\n        Returns:\n            dict: Estended ECM cookie\n        \"\"\"\nreturn self._cookie\ndef credentials(self) -&gt; dict:\n\"\"\"Get credentials (username + password)\n        Returns:\n            dict: dictionary with username and password\n        \"\"\"\nreturn {\n\"username\": self.config()[\"username\"],\n\"password\": self.config()[\"password\"],\n}\ndef set_credentials(self, username: str = \"admin\", password: str = \"\"):\n\"\"\"Set the credentials for Extended ECM for the based on user name and password.\n        Args:\n            username (str, optional): Username. Defaults to \"admin\".\n            password (str, optional): Password of the user. Defaults to \"\".\n        \"\"\"\nself.config()[\"username\"] = username\nself.config()[\"password\"] = password\ndef hostname(self) -&gt; str:\n\"\"\"Returns the hostname of Extended ECM (e.g. \"otcs\")\n        Returns:\n            str: hostname\n        \"\"\"\nreturn self.config()[\"hostname\"]\ndef set_hostname(self, hostname: str):\n\"\"\"Sets the hostname of Extended ECM\n        Args:\n            hostname (str): new hostname\n        \"\"\"\nself.config()[\"hostname\"] = hostname\ndef base_url(self) -&gt; str:\n\"\"\"Returns the base URL of Extended ECM\n        Returns:\n            str: base URL\n        \"\"\"\nreturn self.config()[\"baseUrl\"]\ndef cs_url(self) -&gt; str:\n\"\"\"Returns the Extended ECM URL\n        Returns:\n            str: Extended ECM URL\n        \"\"\"\nreturn self.config()[\"csUrl\"]\ndef cs_public_url(self) -&gt; str:\n\"\"\"Returns the public (external) Extended ECM URL (incl. /cs/cs)\n        Returns:\n            str: Extended ECM Public URL\n        \"\"\"\nreturn self.config()[\"csPublicUrl\"]\ndef cs_support_url(self) -&gt; str:\n\"\"\"Returns the Extended ECM Support URL\n        Returns:\n            str: Extended ECM Support URL\n        \"\"\"\nreturn self.config()[\"supportUrl\"]\ndef cs_support_public_url(self) -&gt; str:\n\"\"\"Returns the Extended ECM Public Support URL\n        Returns:\n            str: Extended ECM Public Support URL\n        \"\"\"\nreturn self.config()[\"supportPublicUrl\"]\ndef rest_url(self) -&gt; str:\n\"\"\"Returns the REST URL of Extended ECM\n        Returns:\n            str: REST URL\n        \"\"\"\nreturn self.config()[\"restUrl\"]\ndef request_form_header(self) -&gt; dict:\n\"\"\"Deliver the request header used for the CRUD REST API calls.\n           Consists of Cookie + Form Headers (see global variable)\n        Args:\n            None.\n        Return:\n            dict: request header values\n        \"\"\"\n# create union of two dicts: cookie and headers\n# (with Python 3.9 this would be easier with the \"|\" operator)\nrequest_header = {}\nrequest_header.update(self.cookie())\nrequest_header.update(REQUEST_FORM_HEADERS)\nreturn request_header\n# end method definition\ndef request_json_header(self) -&gt; dict:\n\"\"\"Deliver the request header for REST calls that require content type application/json.\n           Consists of Cookie + Json Headers (see global variable)\n        Args:\n            None.\n        Return:\n            dict: request header values\n        \"\"\"\n# create union of two dicts: cookie and headers\n# (with Python 3.9 this would be easier with the \"|\" operator)\nrequest_header = {}\nrequest_header.update(self.cookie())\nrequest_header.update(REQUEST_JSON_HEADERS)\nreturn request_header\n# end method definition\ndef request_download_header(self) -&gt; dict:\n\"\"\"Deliver the request header used for the CRUD REST API calls.\n           Consists of Cookie + Form Headers (see global vasriable)\n        Args:\n            None.\n        Return:\n            dict: request header values\n        \"\"\"\n# create union of two dicts: cookie and headers\n# (with Python 3.9 this would be easier with the \"|\" operator)\nrequest_header = {}\nrequest_header.update(self.cookie())\nrequest_header.update(REQUEST_DOWNLOAD_HEADERS)\nreturn request_header\n# end method definition\ndef parse_request_response(\nself,\nresponse_object: object,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the text property of a request response object to a Python dict in a safe way\n            that also handles exceptions.\n            Content Server may produce corrupt response when it gets restarted\n            or hitting resource limits. So we try to avoid a fatal error and bail\n            out more gracefully.\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str): print a custom error message\n            show_error (bool): if True log an error, if False log a warning\n        Returns:\n            dict: response or None in case of an error\n        \"\"\"\nif not response_object:\nreturn None\ntry:\ndict_object = json.loads(response_object.text)\nexcept json.JSONDecodeError as exception:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, exception\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(\nexception\n)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n# end method definition\ndef lookup_result_value(\nself, response: dict, key: str, value: str, return_key: str\n) -&gt; str | None:\n\"\"\"Lookup a property value based on a provided key / value pair in the\n           response properties of an Extended ECM REST API call.\n        Args:\n            response (dict): REST response from an OTCS REST Call\n            key (str): property name (key)\n            value (str): value to find in the item with the matching key\n            return_key (str): determines which value to return based on the name of the dict key\n        Returns:\n            str: value of the property with the key defined in \"return_key\"\n                 or None if the lookup fails\n        \"\"\"\nif not response:\nreturn None\nif not \"results\" in response:\nreturn None\nresults = response[\"results\"]\n# check if results is a list or a dict (both is possible -\n# dependent on the actual REST API):\nif isinstance(results, dict):\n# result is a dict - we don't need index value:\ndata = results[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nelse:\nreturn None\nelif isinstance(data, list):\n# data is a list - this has typically just one item, so we use 0 as index\nfor item in data:\nproperties = item[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nreturn None\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn None\nelif isinstance(results, list):\n# result is a list - we need index value\nfor result in results:\ndata = result[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nelif isinstance(data, list):\n# data is a list we iterate through the list and try to find the key:\nfor item in data:\nproperties = item[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\",\nstr(type(data)),\n)\nreturn None\nreturn None\nelse:\nlogger.error(\n\"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n)\nreturn None\n# end method definition\ndef exist_result_item(\nself, response: dict, key: str, value: str, property_name: str = \"properties\"\n) -&gt; bool:\n\"\"\"Check existence of key / value pair in the response properties of an Extended ECM REST API call.\n        Args:\n            response (dict): REST response from an OTCS REST Call\n            key (str): property name (key)\n            value (str): value to find in the item with the matching key\n            property_name (str, optional): name of the substructure that includes the values\n        Returns:\n            bool: True if the value was found, False otherwise\n        \"\"\"\nif not response:\nreturn False\nif not \"results\" in response:\nreturn False\nresults = response[\"results\"]\n# check if results is a list or a dict (both is possible - dependent on the actual REST API):\nif isinstance(results, dict):\n# result is a dict - we don't need index value:\nif not \"data\" in results:\nreturn False\ndata = results[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nif property_name and not property_name in data:\nlogger.error(\n\"There's no -&gt; %s dictionary in data -&gt; %s\", property_name, data\n)\nreturn False\nproperties = data[property_name]\nif isinstance(properties, dict):\nif key in properties:\nreturn properties[key] == value\nelse:\nreturn False\nelif isinstance(properties, list):\n# properties is a list we iterate through the list and try to find the key:\nfor item in properties:\nif key in item and item[key] == value:\nreturn True\nelse:\nlogger.error(\n\"Properties needs to be a list or dict but it is -&gt; %s\",\nstr(type(properties)),\n)\nreturn False\nelif isinstance(data, list):\n# data is a list\nfor item in data:\nif property_name and not property_name in item:\nlogger.error(\n\"There's no -&gt; %s dictionary in the data list item -&gt; %s\",\nproperty_name,\nitem,\n)\ncontinue\n# if properties if passed as empty string then we assume that\n# the key fields are directly in the item dictionary. This is\n# the case e.g. with the V2 Proxy APIs\nif not property_name:\nproperties = item\nelse:\nproperties = item[property_name]\nif key in properties and properties[key] == value:\nreturn True\nreturn False\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn False\nelif isinstance(results, list):\n# result is a list - we need index value\nfor result in results:\nif not \"data\" in result:\ncontinue\ndata = result[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[property_name]\nif key in properties and properties[key] == value:\nreturn True\nelif isinstance(data, list):\n# data is a list we iterate through the list and try to find the key:\nfor item in data:\nproperties = item[property_name]\nif key in properties and properties[key] == value:\nreturn True\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\",\nstr(type(data)),\n)\nreturn False\nreturn False\nelse:\nlogger.error(\n\"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n)\nreturn False\n# end method definition\ndef get_result_value(\nself,\nresponse: dict,\nkey: str,\nindex: int = 0,\nproperty_name: str = \"properties\",\n) -&gt; str | None:\n\"\"\"Read an item value from the REST API response. This is considering\n           the most typical structures delivered by V2 REST API of Extended ECM.\n           See developer.opentext.com for more details.\n        Args:\n            response (dict): REST API response object\n            key (str): key to find (e.g. \"id\", \"name\", ...)\n            index (int, optional): In case a list of results is delivered the index\n                                   to use (1st element has index  0). Defaults to 0.\n            property_name (str, optional): name of the sub dictionary holding the actual values.\n                                           Default is \"properties\".\n        Returns:\n            str: value of the item with the given key for None if no value is found for the given key.\n        \"\"\"\n# First do some sanity checks:\nif not response:\nlogger.info(\"Empty REST response - returning None\")\nreturn None\nif not \"results\" in response:\nlogger.error(\"No 'results' key in REST response - returning None\")\nreturn None\nresults = response[\"results\"]\nif not results:\nlogger.info(\"No results found!\")\nreturn None\n# check if results is a list or a dict (both is possible - dependent on the actual REST API):\nif isinstance(results, dict):\n# result is a dict - we don't need index value\n# this is a special treatment for the businessworkspaces REST API - it returns\n# for \"Create business workspace\" the ID directly in the results dict (without data substructure)\nif key in results:\nreturn results[key]\ndata = results[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[property_name]\nelif isinstance(data, list):\n# data is a list - this has typically just one item, so we use 0 as index\nproperties = data[0][property_name]\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn None\nlogger.debug(\"Properties of results (dict) -&gt; %s\", str(properties))\n# For nearly all OTCS REST Calls perperties is a dict:\nif isinstance(properties, dict):\nif not key in properties:\nlogger.error(\"Key -&gt; %s is not in result properties!\", key)\nreturn None\nreturn properties[key]\n# but there are some strange ones that have other names for\n# properties and may use a list - see e.g. /v2/holds\nelif isinstance(properties, list):\nif index &gt; len(properties) - 1:\nlogger.error(\n\"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\nstr(index),\nstr(len(properties)),\n)\nreturn None\nreturn properties[index][key]\nelse:\nlogger.error(\n\"Properties needs to be a list or dict but it is -&gt; %s\",\nstr(type(properties)),\n)\nreturn False\nelif isinstance(results, list):\n# result is a list - we need a valid index:\nif index &gt; len(results) - 1:\nlogger.error(\n\"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\nstr(index),\nstr(len(results)),\n)\nreturn None\ndata = results[index][\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[property_name]\nelif isinstance(data, list):\n# data is a list - this has typically just one item, so we use 0 as index\nproperties = data[0][property_name]\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn None\nlogger.debug(\n\"Properties of results (list, index -&gt; %s) -&gt; %s\",\nstr(index),\nproperties,\n)\nif not key in properties:\nlogger.error(\"Key -&gt; %s is not in result properties!\", key)\nreturn None\nreturn properties[key]\nelse:\nlogger.error(\n\"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n)\nreturn None\n# end method definition\ndef is_configured(self) -&gt; bool:\n\"\"\"Checks if the Content Server pod is configured to receive requests.\n        Args:\n            None.\n        Returns:\n            bool: True if pod is ready. False if pod is not yet ready.\n        \"\"\"\nrequest_url = self.config()[\"configuredUrl\"]\nlogger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_JSON_HEADERS,\ntimeout=REQUEST_TIMEOUT,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; warning -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\nlogger.warning(\"OTCS service may not be ready yet.\")\nreturn False\nif not response.ok:\nlogger.warning(\n\"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\nrequest_url,\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n# end method definition\ndef is_ready(self) -&gt; bool:\n\"\"\"Checks if the Content Server pod is ready to receive requests.\n        Args:\n            None.\n        Returns:\n            bool: True if pod is ready. False if pod is not yet ready.\n        \"\"\"\nrequest_url = self.config()[\"isReady\"]\nlogger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_JSON_HEADERS,\ntimeout=2,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; warning -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\nlogger.warning(\"OTCS service may not be ready yet.\")\nreturn False\nif not response.status_code == 200:\nlogger.warning(\n\"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\nrequest_url,\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n# end method definition\ndef authenticate(\nself, revalidate: bool = False, force_user_password_login: bool = False\n) -&gt; dict | None:\n\"\"\"Authenticates at Content Server and retrieve OTCS Ticket.\n        Args:\n            revalidate (bool): determinse if a re-athentication is enforced\n                               (e.g. if session has timed out with 401 error)\n            force_user_password_login (bool): By default we use the OTDS ticket (if exists) for the authentication with OTCS.\n                                              This switch allows the forced usage of username / password for the authentication.\n        Returns:\n            dict: Cookie information of None in case of an error.\n                        Also stores cookie information in self._cookie\n        \"\"\"\n# Already authenticated and session still valid?\nif self._cookie and not revalidate:\nreturn self._cookie\notcs_ticket = None\nlogger.info(\"Wait for OTCS to be ready...\")\nwhile not self.is_ready():\nlogger.warning(\n\"OTCS is not ready to receive requests yet. Waiting 30 seconds...\"\n)\ntime.sleep(30)\nrequest_url = self.config()[\"authenticationUrl\"]\nif self._otds_ticket and not force_user_password_login:\nlogger.info(\n\"Requesting OTCS ticket with OTDS ticket; calling -&gt; %s\",\nrequest_url,\n)\nrequest_header = {\n\"Content-Type\": \"application/x-www-form-urlencoded\",\n\"Accept\": \"application/json\",\n\"OTDSTicket\": self._otds_ticket,\n}\ntry:\nresponse = requests.get(\nurl=request_url, headers=request_header, timeout=10\n)\nif response.ok:\notcs_ticket = response.headers.get(\"OTCSTicket\")\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; error -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\n# Check if previous authentication was successful\nif not otcs_ticket:\nlogger.info(\n\"Requesting OTCS ticket with User/Password; calling -&gt; %s\",\nrequest_url,\n)\nresponse = None\ntry:\nresponse = requests.post(\nurl=request_url,\ndata=self.credentials(),  # this includes username + password\nheaders=REQUEST_FORM_HEADERS,\ntimeout=REQUEST_TIMEOUT,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; error -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\nlogger.warning(\"OTCS service may not be ready yet.\")\nreturn None\nif response.ok:\nauthenticate_dict = self.parse_request_response(\nresponse, \"This can be normal during restart\", False\n)\nif not authenticate_dict:\nreturn None\nelse:\notcs_ticket = authenticate_dict[\"ticket\"]\nlogger.info(\"Ticket -&gt; %s\", otcs_ticket)\nelse:\nlogger.error(\n\"Failed to request an OTCS ticket; error -&gt; %s\", response.text\n)\nreturn None\n# Store authentication ticket:\nself._cookie = {\"otcsticket\": otcs_ticket, \"LLCookie\": otcs_ticket}\nself._otcs_ticket = otcs_ticket\nreturn self._cookie\n# end method definition\ndef get_server_info(self) -&gt; dict | None:\n\"\"\"Get Content Server information (server info)\n        Args:\n            None\n        Returns:\n            dict: server information or None if the call fails\n            Example value:\n            {\n                'mobile': {\n                    'cs_viewer_support': False,\n                    'offline_use': True\n                },\n                'server': {\n                    'advanced_versioning': True,\n                    'character_encoding': 1,\n                    'current_date': '2023-09-05T17:09:41',\n                    'current_locale_suffix': '_en_US',\n                    'domain_access_enabled': False,\n                    'enhanced_advanced_versioning': False,\n                    'force_download_for_mime_types': [...],\n                    'language_code': 'USA',\n                    'languages': [...],\n                    'metadata_languages: [...],\n                    'url': 'https://otcs.dev.idea-te.eimdemo.com/cs/cs'\n                    'version': '23.3'\n                    ...\n                },\n                'sessions': {\n                    'enabled': True,\n                    'expire_after_last_login': False,\n                    'expire_after_last_request': True,\n                    'logout_url': '?func=ll.DoLogout&amp;secureRequestToken=LUAQSY%2BJs4KnlwoVgxLtxQFYrov2XefJQM9ShyhOK93Mzp3ymCxX6IGMTtUgNvTH7AYVt%2BbWLEw%3D',\n                    'session_inactivity': 7020000,\n                    'session_reaction_time': 180000,\n                    'session_timeout': 7200000\n                },\n                'viewer': {\n                    'content_suite': {...}\n                }\n            }\n        \"\"\"\nrequest_url = self.config()[\"serverInfoUrl\"]\nrequest_header = self._cookie\nlogger.info(\n\"Retrieve Extended ECM server information; calling -&gt; %s\", request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve Extended ECM server information; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_server_version(self) -&gt; str | None:\n\"\"\"Get Content Server version\n        Args:\n            None\n        Returns:\n            str: server version number like 23.4\n        \"\"\"\nresponse = self.get_server_info()\nif not response:\nreturn None\nserver_info = response.get(\"server\")\nif not server_info:\nreturn None\nreturn server_info.get(\"version\")\n# end method definition\ndef apply_config(self, xml_file_path: str) -&gt; dict | None:\n\"\"\"Apply Content Server administration settings from XML file\n        Args:\n            xml_file_path (str): name + path of the XML settings file\n        Returns:\n            dict: Import response or None if the import fails.\n                        response[\"results\"][\"data\"][\"restart\"] indicates if the settings\n                        require a restart of the OTCS services.\n        \"\"\"\nfilename = os.path.basename(xml_file_path)\nif not os.path.exists(xml_file_path):\nlogger.error(\n\"The admin settings file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(xml_file_path),\n)\nreturn None\nllconfig_file = {\n\"file\": (filename, open(file=xml_file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nrequest_url = self.config()[\"importSettingsUrl\"]\nrequest_header = self._cookie\nlogger.info(\n\"Applying admin settings from file -&gt; %s; calling -&gt; %s\",\nxml_file_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=llconfig_file,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.debug(\n\"Admin settings in file -&gt; %s have been applied\", xml_file_path\n)\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import settings file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nxml_file_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_user(self, name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Lookup Extended ECM user based on the name.\n        Args:\n            name (str): name of the user\n            show_error (bool): treat as error if user is not found\n        Returns:\n            dict: User information or None if the user is not found.\n            The returned information has a structure like this:\n            {\n                'collection':\n                {\n                    'paging': {...},\n                    'sorting': {...}\n                },\n                'links':\n                {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data':\n                        {\n                            {\n                                'birth_date': None,\n                                'business_email': 'pramos@M365x61936377.onmicrosoft.com',\n                                'business_fax': None,\n                                'business_phone': None,\n                                'cell_phone': None,\n                                'deleted': False,\n                                'display_language': None,\n                                'first_name': 'Peter',\n                                'gender': None,\n                                'group_id': 8006,\n                                'home_address_1': None,\n                                'home_address_2': None,\n                                'home_fax': None,\n                                'home_phone': None,\n                                'id': 8123,\n                                'initials': None,\n                                'last_name': 'Ramos',\n                                'middle_name': None,\n                                'name': 'pramos',\n                                'name_formatted': 'Peter Ramos',\n                                ...\n                                'photo_id': 13981,\n                                'photo_url': 'api/v1/members/8123/photo?v=13981.1'\n                                ...\n                                'type'; 0,\n                                'type_name': 'User'\n                                }\n                        }\n                    }\n                ]\n            }\n            To access the (login) name of the first user found use [\"results\"][0][\"data\"][\"properties\"][\"name\"].\n            It is easier to use the method get_result_value(response, \"name\", 0)\n        \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\n# type = 0 ==&gt; User\nrequest_url = self.config()[\"membersUrlv2\"] + \"?where_type=0&amp;query={}\".format(\nname\n)\nrequest_header = self.request_form_header()\nlogger.info(\"Get user with name -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"User -&gt; %s not found.\", name)\nreturn None\n# end method definition\ndef add_user(\nself,\nname: str,\npassword: str,\nfirst_name: str,\nlast_name: str,\nemail: str,\nbase_group: int,\nprivileges: list | None = None,\n) -&gt; dict | None:\n\"\"\"Add Content Server user.\n        Args:\n            name (str): login name of the user\n            password (str): password of the user\n            first_name (str): first name of the user\n            last_name (str): last name of the user\n            email (str): email address of the user\n            base_group (int): base group id of the user (e.g. department)\n            privileges (list, optional): values are Login, Public Access, Content Manager,\n                                         Modify Users, Modify Groups, User Admin Rights,\n                                         Grant Discovery, System Admin Rights\n        Returns:\n            dict: User information or None if the user couldn't be created (e.g. because it exisits already).\n        \"\"\"\nif privileges is None:\nprivileges = [\"Login\", \"Public Access\"]\nuserPostBody = {\n\"type\": 0,\n\"name\": name,\n\"password\": password,\n\"first_name\": first_name,\n\"last_name\": last_name,\n\"business_email\": email,\n\"group_id\": base_group,\n\"privilege_login\": (\"Login\" in privileges),\n\"privilege_public_access\": (\"Public Access\" in privileges),\n\"privilege_content_manager\": (\"Content Manager\" in privileges),\n\"privilege_modify_users\": (\"Modify Users\" in privileges),\n\"privilege_modify_groups\": (\"Modify Groups\" in privileges),\n\"privilege_user_admin_rights\": (\"User Admin Rights\" in privileges),\n\"privilege_grant_discovery\": (\"Grant Discovery\" in privileges),\n\"privilege_system_admin_rights\": (\"System Admin Rights\" in privileges),\n}\nrequest_url = self.config()[\"membersUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Adding user -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=userPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef search_user(self, value: str, field: str = \"where_name\") -&gt; dict | None:\n\"\"\"Find a user based on search criteria.\n        Args:\n            value (str): field value\n            field (str): user field to search with (where_name, where_first_name, where_last_name)\n        Returns:\n            dict: User information or None if the user couldn't be found (e.g. because it doesn't exist).\n            Example:\n            {\n                'collection': {\n                    'paging': {...},\n                    'sorting': {...}\n                },\n                'links': {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data': {\n                            'properties': {\n                                'birth_date': None,\n                                'business_email': 'dfoxhoven@M365x61936377.onmicrosoft.com',\n                                'business_fax': None,\n                                'business_phone': None,\n                                'cell_phone': None,\n                                'deleted': False,\n                                'display_language': None,\n                                'first_name': 'Deke',\n                                'gender': None,\n                                'group_id': 8005,\n                                'home_address_1': None,\n                                'home_address_2': None,\n                                'home_fax': None,\n                                'home_phone': None,\n                                'id': 8562,\n                                'initials': 'DF',\n                                'last_name': 'Foxhoven',\n                                'middle_name': None,\n                                'name': 'dfoxhoven',\n                                'name_formatted': 'Deke Foxhoven',\n                                ...\n                            }\n                        }\n                    }\n                ]\n            }\n        \"\"\"\nrequest_url = self.config()[\"membersUrlv2\"] + \"?\" + field + \"=\" + value\nrequest_header = self.request_form_header()\nlogger.info(\n\"Searching user by field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\nfield,\nvalue,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Cannot find user with -&gt; %s = %s; status -&gt; %s; error -&gt; %s\",\nfield,\nvalue,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef update_user(self, user_id: int, field: str, value: str) -&gt; dict | None:\n\"\"\"Update a defined field for a user.\n        Args:\n            user_id (int): ID of the user\n            value (str): field value\n            field (str): user field\n        Returns:\n            dict: User information or None if the user couldn't be updated (e.g. because it doesn't exist).\n        \"\"\"\nuserPutBody = {field: value}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/\" + str(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Updating user with ID -&gt; %s, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\nstr(user_id),\nfield,\nvalue,\nrequest_url,\n)\nlogger.debug(\"User Attributes -&gt; %s\", str(userPutBody))\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata=userPutBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_user_profile(self) -&gt; dict | None:\n\"\"\"Update a defined field for a user profile.\n           IMPORTANT: this method needs to be called by the authenticated user\n        Args:\n            field (str): user profile field\n            value (str): new field value\n        Returns:\n            dict: User information or None if the user couldn't be updated\n                  (e.g. because it doesn't exist).\n        \"\"\"\nrequest_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get profile (settings) for current user; calling -&gt; %s\",\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get profile of current user; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef update_user_profile(\nself, field: str, value: str, config_section: str = \"SmartUI\"\n) -&gt; dict | None:\n\"\"\"Update a defined field for a user profile.\n           IMPORTANT: this method needs to be called by the authenticated user\n        Args:\n            field (str): user profile field\n            value (str): new field value\n            config_section (str, optional): name of the config section. Possible config_section values:\n                                            * SmartUI\n                                            * General\n                                            * Colors\n                                            * ContentIntelligence\n                                            * Discussion\n                                            * Follow Up\n                                            * Template Workspaces\n                                            * Workflow\n                                            * XECMGOVSettings\n                                            * CommunitySettings\n                                            * RecMan\n                                            * PhysObj\n        Returns:\n            dict: User information or None if the user couldn't be updated\n                  (e.g. because it doesn't exist).\n        \"\"\"\nuserProfilePutBody = {config_section: {field: value}}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Updating profile for current user, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\nfield,\nvalue,\nrequest_url,\n)\nlogger.debug(\"User Attributes -&gt; %s\", str(userProfilePutBody))\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(userProfilePutBody)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update profile of current user; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef update_user_photo(self, user_id: int, photo_id: int) -&gt; dict | None:\n\"\"\"Update a user with a profile photo (which must be an existing node).\n        Args:\n            user_id (int): ID of the user\n            photo_id (int): Node ID of the photo\n        Returns:\n            dict: Node information or None if photo node is not found.\n        \"\"\"\nupdateUserPutBody = {\"photo_id\": photo_id}\nrequest_url = self.config()[\"membersUrl\"] + \"/\" + str(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Update user ID -&gt; %s with photo ID -&gt; %s; calling -&gt; %s\",\nuser_id,\nphoto_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata=updateUserPutBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef is_proxy(self, user_name: str) -&gt; bool:\n\"\"\"Check if a user is defined as proxy of the current user.\n           This method differentiates between the old (xGov) based\n           implementation and the new Extended ECM platform one\n           that was introduced with version 23.4.\n        Args:\n            user_name (str): user  to test (login name)\n        Returns:\n            bool: True is user is proxy of current user. False if not.\n        \"\"\"\nversion_number = self.get_server_version()\n# Split the version number by dot\nparts = version_number.split(\".\")\n# Take the first two parts and join them back with a dot\nstripped_version = \".\".join(parts[:2])\nversion_number = float(stripped_version)\nif version_number &gt;= 23.4:\nresponse = self.get_user_proxies(use_v2=True)\nif self.exist_result_item(\nresponse=response, key=\"name\", value=user_name, property_name=\"\"\n):\nreturn True\nelse:\nreturn False\nelse:\nresponse = self.get_user_proxies(use_v2=False)\nif not response or not \"proxies\" in response:\nreturn False\nproxies = response[\"proxies\"]\nfor proxy in proxies:\nif proxy[\"name\"] == user_name:\nreturn True\nreturn False\n# end method definition\ndef get_user_proxies(self, use_v2: bool = False) -&gt; dict | None:\n\"\"\"Get list of user proxies.\n           This method needs to be called as the user the proxy is acting for.\n        Args:\n            None\n        Returns:\n            dict: Node information or None if REST call fails.\n        \"\"\"\nif use_v2:\nrequest_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\nelse:\nrequest_url = self.config()[\"membersUrl\"] + \"/proxies\"\nrequest_header = self.request_form_header()\nlogger.info(\"Get proxy users for current user; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get proxy users for current user; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_user_proxy(\nself,\nproxy_user_id: int,\nfrom_date: str = None,\nto_date: str = None,\n) -&gt; dict | None:\n\"\"\"Add a user as a proxy user to the current user.\n           IMPORTANT: This method needs to be called as the user the proxy is acting for.\n           Optional this method can be provided with a time span the proxy should be active.\n           This method differentiates between the old (xGov) based\n           implementation and the new Extended ECM platform one\n           that was introduced with version 23.4.\n           Example payload for proxy user 19340 without time span:\n           {\"id\":2545, \"from_date\": None, \"to_date\": None}\n           Example payload for proxy user 19340 with time span:\n           {\"id\":2545, \"from_date\":\"2023-03-15\", \"to_date\":\"2023-03-31\"}\n        Args:\n            user_id (int): ID of the user\n            from_date (str, optional): start date for proxy (format YYYY-MM-DD)\n            to_date (str, optional): end date for proxy (format YYYY-MM-DD)\n        Returns:\n            dict: Request response or None if call fails.\n        \"\"\"\nversion_number = self.get_server_version()\n# Split the version number by dot\nparts = version_number.split(\".\")\n# Take the first two parts and join them back with a dot\nstripped_version = \".\".join(parts[:2])\nversion_number = float(stripped_version)\n# for versions older than 23.4 we need to use\n# the egacy Extended ECM for Government Proxy\n# implementation:\nif version_number &gt;= 23.4:\npost_dict = {}\npost_dict[\"id\"] = proxy_user_id\npost_dict[\"from_date\"] = from_date\npost_dict[\"to_date\"] = to_date\npost_data = {\"body\": json.dumps(post_dict)}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\nlogger.info(\n\"Assign proxy user with ID -&gt; %s to current user; calling -&gt; %s\",\nproxy_user_id,\nrequest_url,\n)\nelse:\npost_dict = {}\nif from_date and to_date:\npost_dict[\"from_date\"] = from_date\npost_dict[\"to_date\"] = to_date\npost_dict = {str(proxy_user_id): post_dict}\npost_data = {\"add_proxy\": json.dumps(post_dict)}\nrequest_url = self.config()[\"membersUrl\"] + \"/proxies\"\nlogger.info(\n\"Assign proxy user with ID -&gt; %s to current user (legacy xGov); calling -&gt; %s\",\nproxy_user_id,\nrequest_url,\n)\nrequest_header = self.request_form_header()\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.post(\nurl=request_url,\ndata=post_data,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign proxy user with ID -&gt; %s to current user; status -&gt; %s; error -&gt; %s\",\nproxy_user_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_favorite(self, node_id: int) -&gt; dict | None:\n\"\"\"Add a favorite for the current (authenticated) user.\n        Args:\n            node_id (int): ID of the node.\n        Returns:\n            dict: Request response or None if the favorite creation has failed.\n        \"\"\"\nrequest_url = self.config()[\"favoritesUrl\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Adding favorite for node ID -&gt; %s; calling -&gt; %s\", node_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add favorite for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_group(self, name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Lookup Content Server group.\n        Args:\n            name (str): name of the group\n            show_error (bool): if True, treat as error if group is not found\n        Returns:\n            dict: Group information or None if the group is not found.\n            The returned information has a structure like this:\n            \"data\": [\n                {\n                    \"id\": 0,\n                    \"name\": \"string\",\n                    ...\n                }\n            ]\n            To access the id of the first group found use [\"data\"][0][\"id\"]\n        \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\n# type = 1 ==&gt; Group\nrequest_url = self.config()[\"membersUrlv2\"] + \"?where_type=1&amp;query={}\".format(\nname\n)\nrequest_header = self.request_form_header()\nlogger.info(\"Get group with name -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"Group -&gt; %s not found.\", name)\nreturn None\n# end method definition\ndef add_group(self, name: str) -&gt; dict | None:\n\"\"\"Add Content Server group.\n        Args:\n            name (str): name of the group\n        Returns:\n            dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n        \"\"\"\ngroupPostBody = {\"type\": 1, \"name\": name}\nrequest_url = self.config()[\"membersUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Adding group -&gt; %s; calling -&gt; %s\", name, request_url)\nlogger.debug(\"Group Attributes -&gt; %s\", str(groupPostBody))\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=groupPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_group_members(\nself, group: int, member_type: int, limit: int = 100\n) -&gt; dict | None:\n\"\"\"Get Content Server group members.\n        Args:\n            group (int): ID of the group.\n            member_type (int): users = 0, groups = 1\n            limit (int, optional): max number of results (internal default is 25)\n        Returns:\n            dict: Group members or None if the group members couldn't be found.\n        \"\"\"\n# default limit is 25 which may not be enough for groups with many members\n# where_type = 1 makes sure we just get groups and not users\nrequest_url = (\nself.config()[\"membersUrlv2\"]\n+ \"/\"\n+ str(group)\n+ \"/members?where_type=\"\n+ str(member_type)\n+ \"&amp;limit=\"\n+ str(limit)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Getting members of group with ID -&gt; %s; calling -&gt; %s\",\nstr(group),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get members of group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(group),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_group_member(self, member_id: int, group_id: int) -&gt; dict | None:\n\"\"\"Add a user or group to a target group.\n        Args:\n            member_id (int): ID of the user or group to add.\n            group_id (int): ID of the target group.\n        Returns:\n            dict: Response or None if adding a the member fails.\n        \"\"\"\ngroupMemberPostBody = {\"member_id\": member_id}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/\" + str(group_id) + \"/members\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Adding member with ID -&gt; %s to group with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(group_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=groupMemberPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add member with ID -&gt; %s to group with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(member_id),\nstr(group_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_node(self, node_id: int, timeout: int = REQUEST_TIMEOUT) -&gt; dict | None:\n\"\"\"Get a node based on the node ID.\n        Args:\n            node_id (int) is the node Id of the node\n            timeout (int, optional): timeout for the request in seconds\n        Returns:\n            dict: Node information or None if no node with this ID is found.\n            \"results\": [\n                {\n                    \"data\": [\n                        {\n                            \"columns\": [\n                                {\n                                \"data_type\": 0,\n                                \"key\": \"string\",\n                                \"name\": \"string\",\n                                \"sort_key\": \"string\"\n                                }\n                            ],\n                            \"properties\": [\n                                {\n                                    \"advanced_versioning\": true,\n                                    \"container\": true,\n                                    \"container_size\": 0,\n                                    \"create_date\": \"string\",\n                                    \"create_user_id\": 0,\n                                    \"description\": \"string\",\n                                    \"description_multilingual\": {\n                                        \"en\": \"string\",\n                                        \"de\": \"string\"\n                                    },\n                                    \"external_create_date\": \"2019-08-24\",\n                                    \"external_identity\": \"string\",\n                                    \"external_identity_type\": \"string\",\n                                    \"external_modify_date\": \"2019-08-24\",\n                                    \"external_source\": \"string\",\n                                    \"favorite\": true,\n                                    \"guid\": \"string\",\n                                    \"hidden\": true,\n                                    \"icon\": \"string\",\n                                    \"icon_large\": \"string\",\n                                    \"id\": 0,\n                                    \"modify_date\": \"2019-08-24\",\n                                    \"modify_user_id\": 0,\n                                    \"name\": \"string\",\n                                    \"name_multilingual\": {\n                                        \"en\": \"string\",\n                                        \"de\": \"string\"\n                                    },\n                                    \"owner\": \"string\",\n                                    \"owner_group_id\": 0,\n                                    \"owner_user_id\": 0,\n                                    \"parent_id\": 0,\n                                    \"reserved\": true,\n                                    \"reserved_date\": \"string\",\n                                    \"reserved_user_id\": 0,\n                                    \"status\": 0,\n                                    \"type\": 0,\n                                    \"type_name\": \"string\",\n                                    \"versionable\": true,\n                                    \"versions_control_advanced\": true,\n                                    \"volume_id\": 0\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\"Get node with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url)\nretries = 0\nwhile True:\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=timeout,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\nexcept requests.exceptions.Timeout:\nif retries &lt;= REQUEST_MAX_RETRIES:\nlogger.warning(\n\"Request timed out. Retrying in %s seconds...\",\nstr(REQUEST_RETRY_DELAY),\n)\nretries += 1\ntime.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\nelse:\nlogger.error(\n\"Failed to get node with ID -&gt; %s; timeout error\", str(node_id)\n)\n# If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\nlogger.warning(\"Turn timeouts off and wait forever...\")\ntimeout = None\n# end method definition\ndef get_node_by_parent_and_name(\nself,\nparent_id: int,\nname: str,\nfields: str = \"properties\",\nshow_error: bool = False,\n) -&gt; dict | None:\n\"\"\"Get a node based on the parent ID and name. This method does basically\n           a query with \"where_name\" and the \"result\" is a list.\n        Args:\n            parent_id (int) is the node Id of the parent node\n            name (str) is the name of the node to get\n            fields (str): which fields to retrieve. This can have a big impact on performance!\n            show_error (bool, optional): treat as error if node is not found\n        Returns:\n            dict: Node information or None if no node with this name is found in parent.\n                        Access to node ID with: response[\"results\"][0][\"data\"][\"properties\"][\"id\"]\n        \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {\"where_name\": name}\nif fields:\nquery[\"fields\"] = fields\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(parent_id)\n+ \"/nodes?{}\".format(encoded_query)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get node with name -&gt; %s and parent ID -&gt; %s; calling -&gt; %s\",\nname,\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get node with name -&gt; %s and parent ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\n\"Node with name -&gt; %s and parent ID -&gt; %s not found.\",\nname,\nstr(parent_id),\n)\nreturn None\n# end method definition\ndef get_node_by_workspace_and_path(\nself, workspace_id: int, path: list, show_error: bool = False\n) -&gt; dict | None:\n\"\"\"Get a node based on the workspace ID (= node ID) and path (list of folder names).\n        Args:\n            workspace_id (int): node ID of the workspace\n            path (list): list of container items (top down), last item is name of to be retrieved item.\n                         If path is empty the node of the volume is returned.\n            show_error (bool, optional): treat as error if node is not found\n        Returns:\n            dict: Node information or None if no node with this path is found.\n        \"\"\"\ncurrent_item_id = workspace_id\n# in case the path is an empty list\n# we will have the node of the workspace:\nnode = self.get_node(current_item_id)\nfor path_element in path:\nnode = self.get_node_by_parent_and_name(current_item_id, path_element)\ncurrent_item_id = self.get_result_value(node, \"id\")\nif not current_item_id:\nif show_error:\nlogger.error(\"Cannot find path element -&gt; %s!\", path_element)\nelse:\nlogger.info(\"Cannot find path element -&gt; %s.\", path_element)\nreturn None\nlogger.debug(\n\"Traversing path element -&gt; %s (%s)\", path_element, str(current_item_id)\n)\nreturn node\n# end method definition\ndef get_node_by_volume_and_path(\nself, volume_type: int, path: list | None = None\n) -&gt; dict | None:\n\"\"\"Get a node based on the volume and path (list of container items).\n        Args:\n            volume_type (int): Volume type ID (default is 141 = Enterprise Workspace)\n                \"Records Management\"                = 550\n                \"Content Server Document Templates\" = 20541\n                \"O365 Office Online Volume\"         = 1296\n                \"Categories Volume\"                 = 133\n                \"Perspectives\"                      = 908\n                \"Perspective Assets\"                = 954\n                \"Facets Volume\"                     = 901\n                \"Transport Warehouse\"               = 525\n                \"Transport Warehouse Workbench\"     = 528\n                \"Transport Warehouse Package\"       = 531\n                \"Event Action Center Configuration\" = 898\n                \"Classification Volume\"             = 198\n                \"Support Asset Volume\"              = 1309\n                \"Physical Objects Workspace\"        = 413\n                \"Extended ECM\"                      = 882\n                \"Enterprise Workspace\"              = 141\n                \"Personal Workspace\"                = 142\n                \"Business Workspaces\"               = 862\n            path (list): list of container items (top down), last item is name of to be retrieved item.\n                         If path is empty the node of the volume is returned.\n        Returns:\n            dict: Node information or None if no node with this path is found.\n        \"\"\"\n# If path is not given we use empty list to make the for loop below working in this case as well\nif path is None:\npath = []\n# Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\nresponse = self.get_volume(volume_type)\nif not response:\nlogger.error(\"Volume type -&gt; %s not found!\", str(volume_type))\nreturn None\nvolume_id = self.get_result_value(response, \"id\")\nlogger.info(\n\"Volume type -&gt; %s has node ID -&gt; %s\", str(volume_type), str(volume_id)\n)\ncurrent_item_id = volume_id\n# in case the path is an empty list\n# we will have the node of the volume:\nnode = self.get_node(current_item_id)\nfor path_element in path:\nnode = self.get_node_by_parent_and_name(current_item_id, path_element)\npath_item_id = self.get_result_value(node, \"id\")\nif not path_item_id:\nlogger.error(\n\"Cannot find path element -&gt; %s in container with ID -&gt; %s.\",\npath_element,\nstr(current_item_id),\n)\nreturn None\ncurrent_item_id = path_item_id\nlogger.debug(\"Traversing path element with ID -&gt; %s\", str(current_item_id))\nreturn node\n# end method definition\ndef get_node_from_nickname(\nself, nickname: str, show_error: bool = False\n) -&gt; dict | None:\n\"\"\"Get a node based on the nickname.\n        Args:\n            nickname (str): Nickname of the node.\n            show_error (bool): treat as error if node is not found\n        Returns:\n            dict: Node information or None if no node with this nickname is found.\n        \"\"\"\nrequest_url = self.config()[\"nicknameUrl\"] + \"/\" + nickname + \"/nodes\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get node with nickname -&gt; %s; calling -&gt; %s\", nickname, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get node with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnickname,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"Node with nickname -&gt; %s not found.\", nickname)\nreturn None\n# end method definition\ndef get_subnodes(\nself,\nparent_node_id: int,\nfilter_node_types: int = -2,\nfilter_name: str = \"\",\nshow_hidden: bool = False,\nlimit: int = 100,\npage: int = 1,\nfields: str = \"properties\",  # per default we just get the most important information\n) -&gt; dict | None:\n\"\"\"Get a subnodes of a parent node ID.\n        Args:\n            parent_node_id (int) is the node Id of the node\n            filter_node_types (int, optional):\n                -1 get all containers\n                -2 get all searchable objects (default)\n                -3 get all non-containers\n            filter_name (str, optional): filter nodes for specific name (dfault = no filter)\n            show_hidden (bool, optional): list also hidden items (default = False)\n            limit (int, optional): maximum number of results (default = 100)\n            page (int, optional): number of result page (default = 1 = 1st page)\n            fields (str): which fields to retrieve. This can have a big impact on performance!\n        Returns:\n            dict: Subnodes information or None if no node with this parent ID is found.\n        \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {\n\"where_type\": filter_node_types,\n\"limit\": limit,\n}\nif filter_name:\nquery[\"where_name\"] = filter_name\nif show_hidden:\nquery[\"show_hidden\"] = show_hidden\nif page &gt; 1:\nquery[\"page\"] = page\nif fields:\nquery[\"fields\"] = fields\nencodedQuery = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(parent_node_id)\n+ \"/nodes\"\n+ \"?{}\".format(encodedQuery)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get subnodes of parent node with ID -&gt; %s; calling -&gt; %s\",\nstr(parent_node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get subnodes for parent node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nparent_node_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_node_actions(self, node_id: int, filter_actions: list = None) -&gt; dict:\n\"\"\"Get allowed actions for a node.\n        Args:\n            node_id (int): _description_\n            filter_actions (list, optional): _description_\n        Returns:\n            dict: _description_\n        \"\"\"\nactions_post_body = {\"ids\": [node_id], \"actions\": filter_actions}\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/actions\"\n#        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/actions\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get actions for node with ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=actions_post_body,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get actions for node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnode_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef rename_node(\nself,\nnode_id: int,\nname: str,\ndescription: str,\nname_multilingual: dict | None = None,\ndescription_multilingual: dict | None = None,\n) -&gt; dict | None:\n\"\"\"Change the name and description of a node.\n        Args:\n            node_id (int): ID of the node. You can use the get_volume() function below to\n                               to the node id for a volume.\n            name (str): New name of the node.\n            description (str): New description of the node.\n            name_multilingual (dict, optional): multi-lingual node names\n            description_multilingual (dict, optional): multi-lingual description\n        Returns:\n            dict: Request response or None if the renaming fails.\n        \"\"\"\nrenameNodePutBody = {\"name\": name, \"description\": description}\nif name_multilingual:\nrenameNodePutBody[\"name_multilingual\"] = name_multilingual\nif description_multilingual:\nrenameNodePutBody[\"description_multilingual\"] = description_multilingual\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Renaming node with ID -&gt; %s to -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(renameNodePutBody)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to rename node with ID -&gt; %s to -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_volumes(self) -&gt; dict | None:\n\"\"\"Get all Volumes.\n        Args:\n            None\n        Returns:\n            dict: Volume Details or None if an error occured.\n            {\n                'links': {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data': {\n                            'properties': {\n                                'advanced_versioning': None,\n                                'container': True,\n                                'container_size': 16,\n                                'create_date': '2023-05-07T23:18:50Z',\n                                'create_user_id': 1000,\n                                'description': '',\n                                'description_multilingual': {'de': '', 'en': '', 'fr': '', 'it': '', 'ja': ''},\n                                'external_create_date': None,\n                                'external_identity': '',\n                                'external_identity_type': '',\n                                'external_modify_date': None,\n                                'external_source': '',\n                                'favorite': False,\n                                'hidden': False,\n                                ...\n                                'id': 2000,\n                                ...\n                                'name': 'Enterprise',\n                                'name_multilingual': {'de': '', 'en': 'Enterprise', 'fr': '', 'it': '', 'ja': ''},\n                                ...\n                                'parent_id': -1,\n                                'type': 141,\n                                'volume_id': -2000,\n                                ...\n                            }\n                            ...\n                        }\n                    },\n                    ...\n                ]\n            }\n            Example:\n            [\"results\"][0][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n        \"\"\"\nrequest_url = self.config()[\"volumeUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Get volumes; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get volumes; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_volume(\nself, volume_type: int, timeout: int = REQUEST_TIMEOUT\n) -&gt; dict | None:\n\"\"\"Get Volume information based on the volume type ID.\n        Args:\n            volume_type (int): ID of the volume type\n            timeout (int, optional): timeout for the request in seconds\n        Returns:\n            dict: Volume Details or None if volume is not found.\n            [\"results\"][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n        \"\"\"\nrequest_url = self.config()[\"volumeUrl\"] + \"/\" + str(volume_type)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get volume type -&gt; %s; calling -&gt; %s\", str(volume_type), request_url\n)\nretries = 0\nwhile True:\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=timeout,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get volume type -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(volume_type),\nresponse.status_code,\nresponse.text,\n)\nreturn None\nexcept requests.exceptions.Timeout:\nif retries &lt;= REQUEST_MAX_RETRIES:\nlogger.warning(\n\"Request timed out. Retrying in %s seconds...\",\nstr(REQUEST_RETRY_DELAY),\n)\nretries += 1\ntime.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\nelse:\nlogger.error(\n\"Failed to get volume type -&gt; %s; timeout error\",\nstr(volume_type),\n)\n# If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\nlogger.warning(\"Turn timeouts off and wait forever...\")\ntimeout = None\n# end method definition\ndef check_node_name(self, parent_id: int, node_name: str) -&gt; dict | None:\n\"\"\"Get Volume information based on the volume type ID.\n        Args:\n            parent_id (int): ID of the parent location\n            node_name (str): name of the new node\n        Returns:\n        \"\"\"\nrequest_url = self.config()[\"validationUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Check if node with name -&gt; %s can be created in parent with ID -&gt; %s; calling -&gt; %s\",\nnode_name,\nstr(parent_id),\nrequest_url,\n)\ncheckNodeNamePostData = {\"parent_id\": parent_id, \"names\": [node_name]}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata={\"body\": json.dumps(checkNodeNamePostData)},\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to check if node name -&gt; %s can be created in parent with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnode_name,\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef upload_file_to_volume(\nself, package_url: str, file_name: str, mime_type: str, volume_type: int\n) -&gt; dict | None:\n\"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server volume.\n        Args:\n            package_url (str): URL to download file\n            file_name (str): name of the file\n            mime_type (str): mimeType of the file\n            volume_type (int): type (ID) of the volume\n        Returns:\n            dict: Upload response or None if the upload fails.\n        \"\"\"\nif package_url.startswith(\"http\"):\n# Download file from remote location specified by the packageUrl\n# this must be a public place without authentication:\nlogger.info(\"Download transport package from URL -&gt; %s\", package_url)\ntry:\npackage = requests.get(url=package_url, timeout=1200)\npackage.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn None\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn None\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn None\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn None\nlogger.info(\n\"Successfully downloaded package -&gt; %s; status code -&gt; %s\",\npackage_url,\npackage.status_code,\n)\nfile = package.content\nelif os.path.exists(package_url):\nlogger.info(\"Using local package -&gt; %s\", package_url)\nfile = open(file=package_url, mode=\"rb\")\nelse:\nlogger.warning(\"Cannot access -&gt; %s\", package_url)\nreturn None\nuploadPostData = {\"type\": str(volume_type), \"name\": file_name}\nuploadPostFiles = [(\"file\", (f\"{file_name}\", file, mime_type))]\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\nlogger.info(\n\"Uploading package -&gt; %s with mime type -&gt; %s; calling -&gt; %s\",\nfile_name,\nmime_type,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=uploadPostData,\nfiles=uploadPostFiles,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upload file -&gt; %s to volume of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\npackage_url,\nstr(volume_type),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef upload_file_to_parent(\nself, file_url: str, file_name: str, mime_type: str, parent_id: int\n) -&gt; dict | None:\n\"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server parent (folder).\n        Args:\n            file_url (str): URL to download file or local file\n            file_name (str): name of the file\n            mime_type (str): mimeType of the file\n            parent_id (int): parent (ID) of the file to upload\n        Returns:\n            dict: Upload response or None if the upload fails.\n        \"\"\"\nif file_url.startswith(\"http\"):\n# Download file from remote location specified by the fileUrl\n# this must be a public place without authentication:\nlogger.info(\"Download file from URL -&gt; %s\", file_url)\ntry:\nresponse = requests.get(url=file_url, timeout=1200)\nresponse.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn None\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn None\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn None\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn None\nlogger.info(\n\"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\nfile_url,\nresponse.status_code,\n)\nfile_content = response.content\nelif os.path.exists(file_url):\nlogger.info(\"Uploading local file -&gt; %s\", file_url)\nfile_content = open(file=file_url, mode=\"rb\")\nelse:\nlogger.warning(\"Cannot access -&gt; %s\", file_url)\nreturn None\nuploadPostData = {\n\"type\": str(144),\n\"name\": file_name,\n\"parent_id\": str(parent_id),\n}\nuploadPostFiles = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\nlogger.info(\n\"Uploading file -&gt; %s with mime type -&gt; %s to parent with ID -&gt; %s; calling -&gt; %s\",\nfile_name,\nmime_type,\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=uploadPostData,\nfiles=uploadPostFiles,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upload file -&gt; %s to parent -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_url,\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_document_version(\nself,\nnode_id: int,\nfile_url: str,\nfile_name: str,\nmime_type: str = \"text/plain\",\ndescription: str = \"\",\n) -&gt; dict | None:\n\"\"\"Fetch a file from a URL or local filesystem and upload it as a new document version.\n        Args:\n            node_id (int): ID of the document to add add version to\n            file_url (str): URL to download file or local file\n            file_name (str): name of the file\n            mime_type (str, optional): mimeType of the file (default = text/plain)\n            description (str, optional): description of the version (default = no description)\n        Returns:\n            dict: Add version response or None if the upload fails.\n        \"\"\"\nif file_url.startswith(\"http\"):\n# Download file from remote location specified by the fileUrl\n# this must be a public place without authentication:\nlogger.info(\"Download file from URL -&gt; %s\", file_url)\ntry:\nresponse = requests.get(\nurl=file_url,\ntimeout=None,\n)\nresponse.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn None\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn None\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn None\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn None\nlogger.info(\n\"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\nfile_url,\nresponse.status_code,\n)\nfile_content = response.content\nelif os.path.exists(file_url):\nlogger.info(\"Uploading local file -&gt; %s\", file_url)\nfile_content = open(file=file_url, mode=\"rb\")\nelse:\nlogger.warning(\"Cannot access -&gt; %s\", file_url)\nreturn None\nuploadPostData = {\"description\": description}\nuploadPostFiles = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/versions\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\nlogger.info(\n\"Uploading file -&gt; %s with mime type -&gt; %s as new version to document node with ID -&gt; %s; calling -&gt; %s\",\nfile_name,\nmime_type,\nnode_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=uploadPostData,\nfiles=uploadPostFiles,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add file -&gt; %s as new version to document with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_url,\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_latest_document_version(self, node_id: int) -&gt; dict | None:\n\"\"\"Get latest version of a document node based on the node ID.\n        Args:\n            node_id (int) is the node Id of the node\n        Returns:\n            dict: Node information or None if no node with this ID is found.\n        \"\"\"\nrequest_url = (\nself.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/versions/latest\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get latest version of document with node ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get latest version of document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_document_content(self, node_id: int, version_number: str = \"\") -&gt; bytes:\n\"\"\"Get document content from Extended ECM.\n        Args:\n            node_id (int): node ID of the document to download\n            version_number (str): version of the document to download.\n                                     If version = \"\" then download the latest\n                                     version.\n        Returns:\n            bytes: content of the file or None in case of an error.\n        \"\"\"\nif not version_number:\nresponse = self.get_latest_document_version(node_id)\nif not response:\nlogger.error(\n\"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n)\nversion_number = response[\"data\"][\"version_number\"]\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/versions/\"\n+ str(version_number)\n+ \"/content\"\n)\nrequest_header = self.request_download_header()\nlogger.info(\n\"Retrieve document with node ID -&gt; %s and version -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nstr(version_number),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\ncontent = response.content\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\nreturn content\n# end method definition\ndef download_document(\nself, node_id: int, file_path: str, version_number: str = \"\"\n) -&gt; bool:\n\"\"\"Download a document from Extended ECM to local file system.\n        Args:\n            node_id (int): node ID of the document to download\n            file_path (str): local file path (directory)\n            version_number (str): version of the document to download.\n                                     If version = \"\" then download the latest\n                                     version.\n        Returns:\n            bool: True if the document has been download to the specified file.\n                     False otherwise.\n        \"\"\"\ndirectory = os.path.dirname(file_path)\nif not os.path.exists(directory):\nlogger.error(\"Directory -&gt; %s does not exist\", directory)\nreturn False\nif not version_number:\nresponse = self.get_latest_document_version(node_id)\nif not response:\nlogger.error(\n\"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n)\nversion_number = response[\"data\"][\"version_number\"]\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/versions/\"\n+ str(version_number)\n+ \"/content\"\n)\nrequest_header = self.request_download_header()\nlogger.info(\n\"Download document with node ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\ncontent = response.content\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\nlogger.info(\"Writing document content to file -&gt; %s\", file_path)\n# Open file in write binary mode\nwith open(file=file_path, mode=\"wb\") as file:\n# Write the content to the file\nfile.write(content)\nreturn True\n# end method definition\ndef download_config_file(\nself, otcs_url_suffix: str, file_path: str, search: str = \"\", replace: str = \"\"\n) -&gt; bool:\n\"\"\"Download a config file from a given OTCS URL. This is NOT\n            for downloading documents from within the OTCS repository\n            but for configuration files such as app packages for MS Teams.\n        Args:\n            otcs_url_suffix (str): OTCS URL suffix starting typically starting\n                                      with /cs/cs?func=,\n                                      e.g. /cs/cs?func=officegroups.DownloadTeamsPackage\n            file_path (str): local path to save the file (direcotry + filename)\n            search (str, optional): optional string to search for a replacement\n            replace (str, optional): optional replacement\n        Returns:\n            bool: True if the download succeeds, False otherwise\n        \"\"\"\nrequest_url = self.config()[\"baseUrl\"] + otcs_url_suffix\n# request_header = self.cookie()\nrequest_header = self.request_download_header()\nlogger.info(\"Download config file from URL -&gt; %s\", request_url)\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=REQUEST_TIMEOUT,\n)\nresponse.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn False\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn False\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn False\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn False\ncontent = response.content\nif search:\nlogger.info(\n\"Search for all occurances of %s in the config file and replace them with %s\",\nsearch,\nreplace,\n)\ncontent = content.replace(search.encode(\"utf-8\"), replace.encode(\"utf-8\"))\n# Open file in write binary mode\nwith open(file=file_path, mode=\"wb\") as file:\n# Write the content to the file\nfile.write(content)\nlogger.info(\n\"Successfully downloaded config file -&gt; %s to -&gt; %s; status code -&gt; %s\",\nrequest_url,\nfile_path,\nresponse.status_code,\n)\nreturn True\n# end method definition\ndef search(\nself,\nsearch_term: str,\nlook_for: str = \"complexQuery\",\nmodifier: str = \"\",\nslice_id: int = 0,\nquery_id: int = 0,\ntemplate_id: int = 0,\nlimit: int = 100,\npage: int = 1,\n) -&gt; dict | None:\n\"\"\"Search for a search term.\n        Args:\n            search_term (str), e.g. \"test or OTSubType: 189\"\n            look_for (str, optional): 'allwords', 'anywords', 'exactphrase', and 'complexquery'.\n                                      If not specified, it defaults to 'complexQuery'.\n            modifier (str, optional): 'synonymsof', 'relatedto', 'soundslike', 'wordbeginswith',\n                                      and 'wordendswith'.\n                                      If not specified or specify any value other than the available options,\n                                      it will be ignored.\n            slice_id (int, optional): ID of an existing search slice\n            query_id (int, optional): ID of an saved search query\n            template_id (int, optional): ID of an saved search template\n            limit (int, optional): maximum number of results (default = 100)\n            page (int, optional): number of result page (default = 1 = 1st page)\n        Returns:\n            dict: search response or None if the search fails.\n        \"\"\"\nsearchPostBody = {\n\"where\": search_term,\n\"lookfor\": look_for,\n\"page\": page,\n\"limit\": limit,\n}\nif modifier:\nsearchPostBody[\"modifier\"] = modifier\nif slice_id &gt; 0:\nsearchPostBody[\"slice_id\"] = slice_id\nif query_id &gt; 0:\nsearchPostBody[\"query_id\"] = query_id\nif template_id &gt; 0:\nsearchPostBody[\"template_id\"] = template_id\nrequest_url = self.config()[\"searchUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Search for term -&gt; %s; calling -&gt; %s\", search_term, request_url)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=searchPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to search for term -&gt; %s; status -&gt; %s; error -&gt; %s\",\nsearch_term,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_external_system_connection(\nself, connection_name: str, show_error: bool = False\n) -&gt; dict | None:\n\"\"\"Get Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n        Args:\n            connection_name (str): Name of the connection\n            show_error (bool): treat as error if node is not found\n        Returns:\n            dict: External system Details or None if the REST call fails.\n        \"\"\"\nrequest_url = (\nself.config()[\"externalSystem\"] + \"/\" + connection_name + \"/config\"\n)\nrequest_header = self.cookie()\nlogger.info(\n\"Get external system connection -&gt; %s; calling -&gt; %s\",\nconnection_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\nconnection_name,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"External system -&gt; %s not found.\", connection_name)\nreturn None\n# end method definition\ndef add_external_system_connection(\nself,\nconnection_name: str,\nconnection_type: str,\nas_url: str,\nbase_url: str,\nusername: str,\npassword: str,\nauthentication_method: str = \"BASIC\",  # either BASIC or OAUTH\nclient_id: str = None,\nclient_secret: str = None,\n) -&gt; dict | None:\n\"\"\"Add Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n        Args:\n            connection_name (str): Name of the connection\n            connection_type (str): Type of the connection (HTTP, SF, SFInstance)\n            as_url (str): Application URL\n            base_url (str): Base URL\n            username (str): username (used for BASIC authentication)\n            password (str): password (used for BASIC authentication)\n            authentication_method: either BASIC (using username and password) or OAUTH\n            client_id: OAUTH Client ID (only required if authenticationMethod = OAUTH)\n            client_secret: OAUTH Client Secret (only required if authenticationMethod = OAUTH)\n        Returns:\n            dict: External system Details or None if the REST call fails.\n        \"\"\"\nexternalSystemPostBody = {\n\"external_system_name\": connection_name,\n\"conn_type\": connection_type,\n\"asurl\": as_url,\n\"baseurl\": base_url,\n\"username\": username,\n\"password\": password,\n}\nif authentication_method == \"OAUTH\" and client_id and client_secret:\nexternalSystemPostBody[\"authentication_method\"] = str(authentication_method)\nexternalSystemPostBody[\"client_id\"] = str(client_id)\nexternalSystemPostBody[\"client_secret\"] = str(client_secret)\nrequest_url = self.config()[\"externalSystem\"]\nrequest_header = self.cookie()\nlogger.info(\n\"Creating external system connection -&gt; %s of type -&gt; %s with URL -&gt; %s; calling -&gt; %s\",\nconnection_name,\nconnection_type,\nas_url,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=externalSystemPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\nconnection_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_transport_workbench(self, workbench_name: str) -&gt; dict | None:\n\"\"\"Create a Workbench in the Transport Volume.\n        Args:\n            workbench_name (str): name of the workbench to be created\n        Returns:\n            dict: Create response or None if the creation fails.\n        \"\"\"\ncreateWorbenchPostData = {\"type\": \"528\", \"name\": workbench_name}\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create transport workbench -&gt; %s; calling -&gt; %s\",\nworkbench_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=createWorbenchPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create transport workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\nworkbench_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef unpack_transport_package(\nself, package_id: int, workbench_id: int\n) -&gt; dict | None:\n\"\"\"Unpack an existing Transport Package into an existing Workbench.\n        Args:\n            package_id (int): ID of package to be unpacked\n            workbench_id (int): ID of target workbench\n        Returns:\n            dict: Unpack response or None if the unpacking fails.\n        \"\"\"\nunpackPackagePostData = {\"workbench_id\": workbench_id}\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(package_id) + \"/unpack\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Unpack transport package with ID -&gt; %s into workbench with ID -&gt; %s; calling -&gt; %s\",\nstr(package_id),\nstr(workbench_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=unpackPackagePostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to unpack package -&gt; %s; to workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(package_id),\nstr(workbench_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef deploy_workbench(self, workbench_id: int) -&gt; dict | None:\n\"\"\"Deploy an existing Workbench.\n        Args:\n            workbench_d (int): ID of the workbench to be deployed\n        Returns:\n            dict: Deploy response or None if the deployment fails.\n        \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(workbench_id) + \"/deploy\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Deploy workbench with ID -&gt; %s; calling -&gt; %s\",\nstr(workbench_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# As this is a potentially long-running request we put it in try / except:\ntry:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.error(\n\"Error deploying workbench -&gt; %s; error -&gt; %s\",\nstr(workbench_id),\nexception.strerror,\n)\nreturn None\nif response.ok:\nresponse_dict = self.parse_request_response(response)\nif not response_dict:\nlogger.error(\"Error deploying workbench -&gt; %s\", str(workbench_id))\nreturn None\nreturn response_dict\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.warning(\n\"Failed to depoloy workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\nworkbench_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef deploy_transport(\nself,\npackage_url: str,\npackage_name: str,\npackage_description: str = \"\",\nreplacements: list | None = None,\n) -&gt; dict | None:\n\"\"\"Main method to deploy a transport. This uses subfunctions to upload,\n           unpackage and deploy the transport, and creates the required workbench.\n        Args:\n            package_url (str): URL to download the transport package.\n            package_name (str): name of the transport package ZIP file\n            package_description (str): description of the transport package\n            replacements (list of dicts): list of replacement values to be applied\n                                          to all XML files in transport;\n                                          each dict needs to have two values:\n                                          - placeholder: text to replace\n                                          - value: text to replace with\n        Returns:\n            dict: Deploy response or None if the deployment fails.\n        \"\"\"\nif replacements is None:\nreplacements = []\n# Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\nresponse = self.get_volume(525)\ntransport_root_volume_id = self.get_result_value(response, \"id\")\nif not transport_root_volume_id:\nlogger.error(\"Failed to retrieve transport root volume\")\nreturn None\nlogger.info(\"Transport root volume ID -&gt; %s\", str(transport_root_volume_id))\nresponse = self.get_node_by_parent_and_name(\ntransport_root_volume_id, \"Transport Packages\"\n)\ntransport_package_volume_id = self.get_result_value(response, \"id\")\nif not transport_package_volume_id:\nlogger.error(\"Failed to retrieve transport package volume\")\nreturn None\nlogger.info(\n\"Transport package volume ID -&gt; %s\", str(transport_package_volume_id)\n)\n# Step 1: Upload Transport Package\nlogger.info(\"Check if transport package -&gt; %s already exists...\", package_name)\nresponse = self.get_node_by_parent_and_name(\ntransport_package_volume_id, package_name\n)\npackage_id = self.get_result_value(response, \"id\")\nif package_id:\nlogger.info(\n\"Transport package -&gt; %s does already exist; existing package ID -&gt; %s\",\npackage_name,\nstr(package_id),\n)\nelse:\nlogger.info(\n\"Transport package -&gt; %s does not yet exist, loading from -&gt; %s\",\npackage_name,\npackage_url,\n)\n# If we have string replacements configured execute them now:\nif replacements:\nlogger.info(\n\"Transport -&gt; %s has replacements -&gt; %s\",\npackage_name,\nstr(replacements),\n)\nself.replace_transport_placeholders(package_url, replacements)\nelse:\nlogger.info(\"Transport -&gt; %s has no replacements!\", package_name)\n# Upload package to Extended ECM:\nresponse = self.upload_file_to_volume(\npackage_url, package_name, \"application/zip\", 531\n)\npackage_id = self.get_result_value(response, \"id\")\nif not package_id:\nlogger.error(\"Failed to upload transport package -&gt; %s\", package_url)\nreturn None\nlogger.info(\n\"Successfully uploaded transport package -&gt; %s; new package ID -&gt; %s\",\npackage_name,\nstr(package_id),\n)\n# Step 2: Create Transport Workbench (if not yet exist)\nworkbench_name = package_name.split(\".\")[0]\nlogger.info(\"Check if workbench -&gt; %s is already deployed...\", workbench_name)\n# check if the package name has the suffix \"(deployed)\" - this indicates it is alreadey\n# successfully deployed (see renaming at the end of this method)\nresponse = self.get_node_by_parent_and_name(\ntransport_root_volume_id, workbench_name + \" (deployed)\"\n)\nworkbench_id = self.get_result_value(response, \"id\")\nif workbench_id:\nlogger.info(\n\"Workbench -&gt; %s has already been deployed successfully; existing workbench ID -&gt; %s; skipping transport\",\nworkbench_name,\nstr(workbench_id),\n)\n# we return and skip this transport...\nreturn response\nelse:\nlogger.info(\"Check if workbench -&gt; %s already exists...\", workbench_name)\nresponse = self.get_node_by_parent_and_name(\ntransport_root_volume_id, workbench_name\n)\nworkbench_id = self.get_result_value(response, \"id\")\nif workbench_id:\nlogger.info(\n\"Workbench -&gt; %s does already exist but is not successfully deployed; existing workbench ID -&gt; %s\",\nworkbench_name,\nstr(workbench_id),\n)\nelse:\nresponse = self.create_transport_workbench(workbench_name)\nworkbench_id = self.get_result_value(response, \"id\")\nif not workbench_id:\nlogger.error(\"Failed to create workbench -&gt; %s\", workbench_name)\nreturn None\nlogger.info(\n\"Successfully created workbench -&gt; %s; new workbench ID -&gt; %s\",\nworkbench_name,\nstr(workbench_id),\n)\n# Step 3: Unpack Transport Package to Workbench\nlogger.info(\n\"Unpack transport package -&gt; %s (%s) to workbench -&gt; %s (%s)\",\npackage_name,\nstr(package_id),\nworkbench_name,\nstr(workbench_id),\n)\nresponse = self.unpack_transport_package(package_id, workbench_id)\nif not response:\nlogger.error(\"Failed to unpack the transport package -&gt; %s\", package_name)\nreturn None\nlogger.info(\n\"Successfully unpackaged to workbench -&gt; %s (%s)\",\nworkbench_name,\nstr(workbench_id),\n)\n# Step 4: Deploy Workbench\nlogger.info(\"Deploy workbench -&gt; %s (%s)\", workbench_name, str(workbench_id))\nresponse = self.deploy_workbench(workbench_id)\nif not response:\nlogger.error(\"Failed to deploy workbench -&gt; %s\", workbench_name)\nreturn None\nlogger.info(\n\"Successfully deployed workbench -&gt; %s (%s)\",\nworkbench_name,\nstr(workbench_id),\n)\nself.rename_node(\nworkbench_id,\nworkbench_name + \" (deployed)\",\npackage_description,\n)\nreturn response\n# end method definition\ndef replace_transport_placeholders(\nself, zip_file_path: str, replacements: list\n) -&gt; bool:\n\"\"\"Search and replace strings in the XML files of the transport packlage\n        Args:\n            zip_file_path (str): path to transport zip file\n            replacements (list of dicts): list of replacement values; dict needs to have two values:\n                                         * placeholder: text to replace\n                                         * value: text to replace with\n        Returns:\n            Filename to the updated zip file\n        \"\"\"\nif not os.path.isfile(zip_file_path):\nlogger.error(\"Zip file -&gt; %s not found.\", zip_file_path)\nreturn False\n# Extract the zip file to a temporary directory\nzip_file_folder = os.path.splitext(zip_file_path)[0]\nwith zipfile.ZipFile(zip_file_path, \"r\") as zfile:\nzfile.extractall(zip_file_folder)\nmodified = False\n# Replace search pattern with replace string in all XML files in the directory and its subdirectories\nfor replacement in replacements:\nif not \"value\" in replacement:\nlogger.error(\n\"Replacement needs a value but it is not specified. Skipping...\"\n)\ncontinue\nif \"enabled\" in replacement and not replacement[\"enabled\"]:\nlogger.info(\n\"Replacement for transport -&gt; %s is disabled. Skipping...\",\nzip_file_path,\n)\ncontinue\n# there are two types of replacements:\n# 1. XPath - more elegant and powerful\n# 2. Search &amp; Replace - basically treat the XML file like a text file and do a search &amp; replace\nif \"xpath\" in replacement:\nlogger.info(\n\"Using xpath -&gt; %s to narrow down the replacement\",\nreplacement[\"xpath\"],\n)\nif \"setting\" in replacement:\nlogger.info(\n\"Looking up setting -&gt; %s in XML element\",\nreplacement[\"setting\"],\n)\nif \"assoc_elem\" in replacement:\nlogger.info(\n\"Looking up assoc element -&gt; %s in XML element\",\nreplacement[\"assoc_elem\"],\n)\nelse:  # we have a simple \"search &amp; replace\" replacement\nif not \"placeholder\" in replacement:\nlogger.error(\n\"Replacement without an xpath needs a placeholder value but it is not specified. Skipping...\"\n)\ncontinue\nif replacement.get(\"placeholder\") == replacement[\"value\"]:\nlogger.info(\n\"Placeholder and replacement are identical -&gt; %s. Skipping...\",\nreplacement[\"value\"],\n)\ncontinue\nlogger.info(\n\"Replace -&gt; %s with -&gt; %s in Transport package -&gt; %s\",\nreplacement[\"placeholder\"],\nreplacement[\"value\"],\nzip_file_folder,\n)\nfound = XML.replace_in_xml_files(\nzip_file_folder,\nreplacement.get(\"placeholder\"),\nreplacement[\"value\"],\nreplacement.get(\"xpath\"),\nreplacement.get(\"setting\"),\nreplacement.get(\"assoc_elem\"),\n)\nif found:\nlogger.info(\n\"Replacement -&gt; %s has been completed successfully for Transport package -&gt; %s\",\nreplacement,\nzip_file_folder,\n)\nmodified = True\nelse:\nlogger.warning(\n\"Replacement -&gt; %s not found in Transport package -&gt; %s\",\nreplacement,\nzip_file_folder,\n)\nif not modified:\nlogger.warning(\n\"None of the specified replacements have been found in Transport package -&gt; %s. No need to create a new transport package.\",\nzip_file_folder,\n)\nreturn False\n# Create the new zip file and add all files from the directory to it\nnew_zip_file_path = (\nos.path.dirname(zip_file_path) + \"/new_\" + os.path.basename(zip_file_path)\n)\nlogger.info(\n\"Content of transport -&gt; %s has been modified - repacking to new zip file -&gt; %s\",\nzip_file_folder,\nnew_zip_file_path,\n)\nwith zipfile.ZipFile(new_zip_file_path, \"w\", zipfile.ZIP_DEFLATED) as zip_ref:\nfor subdir, _, files in os.walk(\nzip_file_folder\n):  # 2nd parameter is not used, thus using _ instead of dirs\nfor file in files:\nfile_path = os.path.join(subdir, file)\nrel_path = os.path.relpath(file_path, zip_file_folder)\nzip_ref.write(file_path, arcname=rel_path)\n# Close the new zip file and delete the temporary directory\nzip_ref.close()\nold_zip_file_path = (\nos.path.dirname(zip_file_path) + \"/old_\" + os.path.basename(zip_file_path)\n)\nlogger.info(\n\"Rename orginal transport zip file -&gt; %s to -&gt; %s\",\nzip_file_path,\nold_zip_file_path,\n)\nos.rename(zip_file_path, old_zip_file_path)\nlogger.info(\n\"Rename new transport zip file -&gt; %s to -&gt; %s\",\nnew_zip_file_path,\nzip_file_path,\n)\nos.rename(new_zip_file_path, zip_file_path)\n# Return the path to the new zip file\nreturn True\n# end method definition\ndef get_workspace_types(\nself, expand_workspace_info: bool = True, expand_templates: bool = True\n) -&gt; dict | None:\n\"\"\"Get all workspace types configured in Extended ECM.\n        Args:\n            expand_workspace_info (bool, optional): controls if the workspace info\n                                                    is returned as well\n            expand_workspace_info (bool, optional): controls if the list of workspace templates\n                                                    per workspace typ is returned as well\n        Returns:\n            dict: Workspace Types or None if the request fails.\n            Example response:\n            {\n                'links': {\n                    'data': {...}\n                },\n                'results': [\n                    {\n                        'data': {\n                            'properties': {\n                                'rm_enabled': False,\n                                'templates': [\n                                    {\n                                        'id': 14471,\n                                        'name': 'Campaign',\n                                        'subtype': 848\n                                    },\n                                    ...\n                                ],\n                                'wksp_type_id': 35,\n                                'wksp_type_name': 'Campaign'\n                            },\n                            'wksp_info': {\n                                'wksp_type_icon': '/appimg/ot_bws/icons/13147%2Esvg?v=161108_84584'\n                            }\n                        }\n                    }\n                ]\n            }\n        \"\"\"\nrequest_url = self.config()[\"businessworkspacetypes\"]\nif expand_templates:\nrequest_url += \"?expand_templates=true\"\nelse:\nrequest_url += \"?expand_templates=false\"\nif expand_workspace_info:\nrequest_url += \"&amp;expand_wksp_info=true\"\nelse:\nrequest_url += \"&amp;expand_wksp_info=false\"\nrequest_header = self.request_form_header()\nlogger.info(\"Get workspace types; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get workspace types; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_business_object_type(\nself, external_system_id: str, type_name: str\n) -&gt; dict | None:\n\"\"\"Get business object type information.\n        Args:\n            external_system_id (str): external system Id (such as \"TM6\")\n            type_name (str): type name (such as \"SAP Customer\")\n        Returns:\n            dict: Workspace Type information or None if the request fails.\n        \"\"\"\nrequest_url = (\nself.config()[\"externalSystem\"]\n+ \"/\"\n+ str(external_system_id)\n+ \"/botypes/\"\n+ str(type_name)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get business object type -&gt; %s for external system -&gt; %s; calling -&gt; %s\",\ntype_name,\nexternal_system_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get business object type -&gt; %s; status -&gt; %s; error -&gt; %s\",\ntype_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_workspace_create_form(\nself,\ntemplate_id: int,\nexternal_system_id: int = None,\nbo_type: int = None,\nbo_id: int = None,\nparent_id: int = None,\n) -&gt; dict | None:\n\"\"\"Get the Workspace create form.\n        Args:\n            template_id (int): ID of the workspace template\n            external_system_id (str): identifier of the external system (None if no external system)\n            bo_type (str, optional): business object type (None if no external system)\n            bo_id (str, optional): business object identifier / key (None if no external system)\n            parent_id (str, optional): parent ID of the workspaces. Needs only be specified in special\n                                       cases where workspace location cannot be derived from workspace\n                                       type definition, e.g. sub-workspace\n        Returns:\n            dict: Workspace Create Form data or None if the request fails.\n        \"\"\"\nrequest_url = self.config()[\n\"businessworkspacecreateform\"\n] + \"?template_id={}\".format(template_id)\n# Is a parent ID specifified? Then we need to add it to the request URL\nif parent_id is not None:\nrequest_url += \"&amp;parent_id={}\".format(parent_id)\n# Is this workspace connected to a business application / external system?\nif external_system_id and bo_type and bo_id:\nrequest_url += \"&amp;ext_system_id={}\".format(external_system_id)\nrequest_url += \"&amp;bo_type={}\".format(bo_type)\nrequest_url += \"&amp;bo_id={}\".format(bo_id)\nlogger.info(\n\"Use business object connection -&gt; (%s, %s, %s) for workspace template with ID -&gt; %s\",\nstr(external_system_id),\nstr(bo_type),\nstr(bo_id),\nstr(template_id),\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace create form for template with ID -&gt; %s; calling -&gt; %s\",\nstr(template_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get workspace create form for template -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(template_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_workspace(self, node_id: int) -&gt; dict | None:\n\"\"\"Get a workspace based on the node ID.\n        Args:\n            node_id (int) is the node Id of the workspace\n        Returns:\n            dict: Workspace node information or None if no node with this ID is found.\n            Example result:\n            {\n                'links': {\n                    'data': {...}\n                },\n                'meta_data': {\n                    'properties': {...}\n                },\n                'paging': {\n                    'limit': 500,\n                    'page': 1,\n                    'page_total': 1,\n                    'range_max': 1,\n                    'range_min': 1,\n                    'total_count': 1\n                },\n                'results': [\n                    {\n                        'actions': {...},\n                        'data': {\n                            'properties': {\n                                'volume_id': -2000,\n                                'id': 36780,\n                                'parent_id': 13567,\n                                'owner_user_id': 7240,\n                                'name': '4600000044 - C.E.B. New York Inc.',\n                                'type': 848,\n                                'description': '',\n                                'create_date': '2023-09-02T11:07:06',\n                                'create_user_id': 7240,\n                                'create_user_id': 7240,\n                                'modify_date': '2023-09-02T11:07:11',\n                                'modify_user_id': 7240,\n                                'reserved': False,\n                                'reserved_user_id': 0,\n                                'reserved_date': None,\n                                'order': None,\n                                'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                                'hidden': False,\n                                'mime_type': None,\n                                'original_id': 0,\n                                'wnf_wksp_type_id': 16,\n                                'wnf_wksp_template_id': 15615,\n                                'size_formatted': '7 Items',\n                                'type_name': 'Business Workspace',\n                                'container': True,\n                                'size': 7,\n                                ...\n                            }\n                        },\n                        'metadata': {...},\n                        'metadata_order': {...}\n                    }\n                ],\n                'wksp_info': {\n                    'wksp_type_icon': None\n                }\n            }\n        \"\"\"\nrequest_url = self.config()[\"businessworkspaces\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_workspace_instances(\nself, type_name: str = \"\", type_id: int = None, expanded_view: bool = True\n):\n\"\"\"Get all workspace instances of a given type. This is a convenience\n           wrapper method for get_workspace_by_type_and_name()\n        Args:\n            type_name (str, optional): name of the workspace type\n            type_id (int, optional): ID of the workspace_type\n            expanded_view (bool, optional): if 'False' then just search in recently\n                                               accessed business workspace for this name and type\n                                               if 'True' (this is the default) then search in all\n                                               workspaces for this name and type\n        Returns:\n            dict: Workspace information or None if the workspace is not found.\n        \"\"\"\n# Omitting the name lets it return all instances of the type:\nreturn self.get_workspace_by_type_and_name(\ntype_name=type_name, type_id=type_id, name=\"\", expanded_view=expanded_view\n)\n# end method definition\ndef get_workspace_by_type_and_name(\nself,\ntype_name: str = \"\",\ntype_id: int = None,\nname: str = \"\",\nexpanded_view: bool = True,\n) -&gt; dict | None:\n\"\"\"Lookup workspace based on workspace type and workspace name.\n        Args:\n            type_name (str): name of the workspace type\n            type_id (int, optional): ID of the workspace_type\n            name (str, optional): name of the workspace, if \"\" then deliver all instances\n                                  of the given workspace type\n            expanded_view (bool, optional): if 'False' then just search in recently\n                                            accessed business workspace for this name and type\n                                            if 'True' (this is the default) then search in all\n                                            workspaces for this name and type\n        Returns:\n            dict: Workspace information or None if the workspace is not found.\n        \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {\n\"expanded_view\": expanded_view,\n}\nif type_name:\nquery[\"where_workspace_type_name\"] = type_name\nif type_id:\nquery[\"where_workspace_type_id\"] = type_id\nif name:\nquery[\"where_name\"] = name\nencodedQuery = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"businessworkspaces\"] + \"?{}\".format(encodedQuery)\nrequest_header = self.request_form_header()\nif name:\nlogger.info(\n\"Get workspace with name -&gt; %s and type -&gt; %s; calling -&gt; %s\",\nname,\ntype_name,\nrequest_url,\n)\nelse:\nlogger.info(\n\"Get all workspace instances of type -&gt; %s; calling -&gt; %s\",\ntype_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif name:\nlogger.warning(\n\"Failed to get workspace -&gt; %s of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\ntype_name,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.warning(\n\"Failed to get workspace instances of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\ntype_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_workspace_by_business_object(\nself,\nexternal_system_name: str,\nbusiness_object_type: str,\nbusiness_object_id: str,\nreturn_workspace_metadata: bool = False,\nshow_error: bool = False,\n) -&gt; dict | None:\n\"\"\"Get a workspace based on the business object of an external system.\n        Args:\n            external_system_name (str): Name of the connection\n            business_object_type (str): type of the Business object, e.g. KNA1 for SAP customers\n            business_object_id (str): ID of the business object in the external system\n            return_workspace_metadata (bool): Whether or not workspace metadata (categories) should be returned\n            show_error (bool): treat as error if node is not found\n        Returns:\n            dict: Workspace node information or None if no node with this ID is found.\n            Example result:\n            {\n                'links': {\n                    'data': {...}\n                },\n                'meta_data': {\n                    'properties': {...}\n                },\n                'paging': {\n                    'limit': 500,\n                    'page': 1,\n                    'page_total': 1,\n                    'range_max': 1,\n                    'range_min': 1,\n                    'total_count': 1\n                },\n                'results': [\n                    {\n                        'actions': {...},\n                        'data': {\n                            'properties': {\n                                'volume_id': -2000,\n                                'id': 36780,\n                                'parent_id': 13567,\n                                'owner_user_id': 7240,\n                                'name': '4600000044 - C.E.B. New York Inc.',\n                                'type': 848,\n                                'description': '',\n                                'create_date': '2023-09-02T11:07:06',\n                                'create_user_id': 7240,\n                                'create_user_id': 7240,\n                                'modify_date': '2023-09-02T11:07:11',\n                                'modify_user_id': 7240,\n                                'reserved': False,\n                                'reserved_user_id': 0,\n                                'reserved_date': None,\n                                'order': None,\n                                'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                                'hidden': False,\n                                'mime_type': None,\n                                'original_id': 0,\n                                'wnf_wksp_type_id': 16,\n                                'wnf_wksp_template_id': 15615,\n                                'size_formatted': '7 Items',\n                                'type_name': 'Business Workspace',\n                                'container': True,\n                                'size': 7,\n                                ...\n                            }\n                        },\n                        'metadata': {...},\n                        'metadata_order': {...}\n                    }\n                ],\n                'wksp_info': {\n                    'wksp_type_icon': None\n                }\n            }\n        \"\"\"\nrequest_url = (\nself.config()[\"externalSystem\"]\n+ \"/\"\n+ external_system_name\n+ \"/botypes/\"\n+ business_object_type\n+ \"/boids/\"\n+ business_object_id\n)\nif return_workspace_metadata:\nrequest_url += \"?metadata\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); calling -&gt; %s\",\nexternal_system_name,\nbusiness_object_type,\nbusiness_object_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\nexternal_system_name,\nbusiness_object_type,\nbusiness_object_id,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\n\"Cannot fing workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\nexternal_system_name,\nbusiness_object_type,\nbusiness_object_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_workspace(\nself,\nworkspace_template_id: int,\nworkspace_name: str,\nworkspace_description: str,\nworkspace_type: int,\ncategory_data: dict | None = None,\nexternal_system_id: int = None,\nbo_type: int | None = None,\nbo_id: int | None = None,\nparent_id: int | None = None,\n) -&gt; dict | None:\n\"\"\"Create a new business workspace.\n        Args:\n            workspace_template_id (int): ID of the workspace template\n            workspace_name (str): name of the workspace\n            workspace_description (str): description of the workspace\n            workspace_type (int): type ID of the workspace\n            category_data (dict): category and attributes\n            external_system_id (str, optional): identifier of the external system (None if no external system)\n            bo_type (str, optional): business object type (None if no external system)\n            bo_id (str, optional): business object identifier / key (None if no external system)\n            parent_id (str, optional): parent ID of the workspaces. Needs only be specified in special\n                                       cases where workspace location cannot be derived from workspace\n                                       type definition\n        Returns:\n            dict: Workspace Create Form data or None if the request fails.\n        \"\"\"\n# Avoid linter warning W0102\nif category_data is None:\ncategory_data = {}\ncreateWorkspacePostData = {\n\"template_id\": str(workspace_template_id),\n\"name\": workspace_name,\n\"description\": workspace_description,\n\"wksp_type_id\": str(workspace_type),\n\"type\": str(848),\n\"roles\": category_data,\n}\n# Is this workspace connected to a business application / external system?\nif external_system_id and bo_type and bo_id:\ncreateWorkspacePostData[\"ext_system_id\"] = str(external_system_id)\ncreateWorkspacePostData[\"bo_type\"] = str(bo_type)\ncreateWorkspacePostData[\"bo_id\"] = str(bo_id)\nlogger.info(\n\"Use business object connection -&gt; (%s, %s, %s) for workspace -&gt; %s\",\nstr(external_system_id),\nstr(bo_type),\nstr(bo_id),\nworkspace_name,\n)\n# If workspace creation location cannot be derived from the workspace type\n# there may be an optional parent parameter passed to this method. This can\n# also be the case if workspaces are nested into each other:\nif parent_id is not None:\ncreateWorkspacePostData[\"parent_id\"] = parent_id\nlogger.info(\n\"Use specified location -&gt; %s for workspace -&gt; %s\",\nstr(parent_id),\nworkspace_name,\n)\nelse:\nlogger.info(\n\"Determine location of workspace -&gt; %s via workspace type -&gt; %s\",\nworkspace_name,\nstr(workspace_type),\n)\nrequest_url = self.config()[\"businessworkspaces\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create workspace -&gt; %s with type -&gt; %s from template -&gt; %s; calling -&gt; %s\",\nworkspace_name,\nstr(workspace_type),\nstr(workspace_template_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n# See https://developer.opentext.com/apis/14ba85a7-4693-48d3-8c93-9214c663edd2/4403207c-40f1-476a-b794-fdb563e37e1f/07229613-7ef4-4519-8b8a-47eaff639d42#operation/createBusinessWorkspace\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata={\"body\": json.dumps(createWorkspacePostData)},\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create workspace -&gt; %s from template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nworkspace_name,\nstr(workspace_template_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_workspace_relationship(\nself,\nworkspace_id: int,\nrelated_workspace_id: int,\nrelationship_type: str = \"child\",\n) -&gt; dict | None:\n\"\"\"Create a relationship between two workspaces.\n        Args:\n            workspace_id (int): ID of the workspace\n            related_workspace_id (int): ID of the related workspace\n            relationship_type (str, optional): \"parent\" or \"child\" - \"child\" is default if omitted\n        Returns:\n            dict: Workspace Relationship data (json) or None if the request fails.\n        \"\"\"\ncreateWorkspaceRelationshipPostData = {\n\"rel_bw_id\": str(related_workspace_id),\n\"rel_type\": relationship_type,\n}\nrequest_url = self.config()[\"businessworkspaces\"] + \"/{}/relateditems\".format(\nworkspace_id\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create workspace relationship between -&gt; %s and -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nstr(related_workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createWorkspaceRelationshipPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create workspace relationship between -&gt; %s and -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nstr(related_workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_workspace_relationships(self, workspace_id: int) -&gt; dict | None:\n\"\"\"Get the Workspace relationships to other workspaces.\n        Args:\n            workspace_id (int): ID of the workspace template\n        Returns:\n            dict: Workspace relationships or None if the request fails.\n        \"\"\"\nrequest_url = (\nself.config()[\"businessworkspaces\"]\n+ \"/\"\n+ str(workspace_id)\n+ \"/relateditems\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get related workspaces for workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get related workspaces of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_workspace_roles(self, workspace_id: int) -&gt; dict | None:\n\"\"\"Get the Workspace roles.\n        Args:\n            workspace_id (int): ID of the workspace template\n        Returns:\n            dict: Workspace Roles data or None if the request fails.\n        \"\"\"\nrequest_url = (\nself.config()[\"businessworkspaces\"] + \"/\" + str(workspace_id) + \"/roles\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace roles of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get roles of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef add_member_to_workspace(\nself, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n) -&gt; dict | None:\n\"\"\"Add member to a workspace role. Check that the user is not yet a member.\n        Args:\n            workspace_id (int): ID of the workspace\n            role_id (int): ID of the role\n            member_id (int): User or Group Id\n            show_warning (bool, optional): if True shows a warning if member is already in role\n        Returns:\n            dict: Workspace Role Membership or None if the request fails.\n        \"\"\"\naddMemberToWorkspacePostData = {\"id\": str(member_id)}\nrequest_url = self.config()[\n\"businessworkspaces\"\n] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Check if user/group with ID -&gt; %s is already in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\nworkspace_members = self.parse_request_response(response)\nif self.exist_result_item(workspace_members, \"id\", member_id):\nif show_warning:\nlogger.warning(\n\"User/group with ID -&gt; %s is already a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\n)\nreturn workspace_members\nlogger.info(\n\"Add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=addMemberToWorkspacePostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\nelse:\nlogger.error(\n\"Failed to add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef remove_member_from_workspace(\nself, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n) -&gt; dict | None:\n\"\"\"Remove a member from a workspace role. Check that the user is currently a member.\n        Args:\n            workspace_id (int): ID of the workspace\n            role_id (int): ID of the role\n            member_id (int): User or Group Id\n            show_warning (bool, optional): if True shows a warning if member is not in role\n        Returns:\n            dict: Workspace Role Membership or None if the request fails.\n        \"\"\"\nrequest_url = self.config()[\n\"businessworkspaces\"\n] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Check if user/group with ID -&gt; %s is in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nworkspaceMembershipResponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not workspaceMembershipResponse.ok:\nlogger.error(\n\"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\nworkspaceMembershipResponse.status_code,\nworkspaceMembershipResponse.text,\n)\nreturn None\nworkspace_members = self.parse_request_response(workspaceMembershipResponse)\nif not self.exist_result_item(workspace_members, \"id\", member_id):\nif show_warning:\nlogger.warning(\n\"User/group with ID -&gt; %s is not a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\n)\nreturn None\nrequest_url = self.config()[\n\"businessworkspaces\"\n] + \"/{}/roles/{}/members/{}\".format(workspace_id, role_id, member_id)\nlogger.info(\n\"Removing user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nworkspaceMembershipResponse = requests.delete(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif workspaceMembershipResponse.ok:\nreturn self.parse_request_response(workspaceMembershipResponse)\nelse:\nlogger.error(\n\"Failed to remove user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nworkspaceMembershipResponse.status_code,\nworkspaceMembershipResponse.text,\n)\nreturn None\n# end method definition\ndef assign_workspace_permissions(\nself, workspace_id: int, role_id: int, permissions: list, apply_to: int = 2\n) -&gt; dict | None:\n\"\"\"Update permissions of a workspace role\n        Args:\n            workspace_id (int): ID of the workspace\n            role_id (int): ID of the role\n            permissions (list): list of permissions - potential elements:\n                                \"see\"\n                                \"see_contents\"\n                                \"modify\"\n                                \"edit_attributes\"\n                                \"add_items\"\n                                \"reserve\"\n                                \"add_major_version\"\n                                \"delete_versions\"\n                                \"delete\"\n                                \"edit_permissions\"\n            apply_to (int):  0 = this item\n                                 1 = sub-items\n                                 2 = This item and sub-items (default)\n                                 3 = This item and immediate sub-items\n        Returns:\n            dict: Workspace Role Membership or None if the request fails.\n        \"\"\"\nrequest_url = self.config()[\"businessworkspaces\"] + \"/{}/roles/{}\".format(\nworkspace_id, role_id\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Updating Permissions of role with ID -&gt; %s of workspace with ID -&gt; %s with permissions -&gt; %s; calling -&gt; %s\",\nstr(role_id),\nstr(workspace_id),\nstr(permissions),\nrequest_url,\n)\npermissionPostData = {\n\"permissions\": permissions,\n\"apply_to\": apply_to,\n}\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\nheaders=request_header,\ndata={\"body\": json.dumps(permissionPostData)},\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update permissions for role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(role_id),\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef update_workspace_icon(\nself, workspace_id: int, file_path: str, file_mimetype: str = \"image/*\"\n) -&gt; dict | None:\n\"\"\"Update a workspace with a with a new icon (which is uploaded).\n        Args:\n            workspace_id (int): ID of the workspace\n            file_path (str): path + filename of icon file\n            file_mimetype (str, optional): mimetype of the image\n        Returns:\n            dict: Node information or None if REST call fails.\n        \"\"\"\nif not os.path.exists(file_path):\nlogger.error(\"Workspace icon file does not exist -&gt; %s\", file_path)\nreturn None\nupdateWorkspaceIconPostBody = {\n\"file_content_type\": file_mimetype,\n\"file_filename\": os.path.basename(file_path),\n}\nuploadPostFiles = [\n(\n\"file\",\n(\nf\"{os.path.basename(file_path)}\",\nopen(file_path, \"rb\"),\nfile_mimetype,\n),\n)\n]\nrequest_url = (\nself.config()[\"businessworkspaces\"] + \"/\" + str(workspace_id) + \"/icons\"\n)\nrequest_header = self.cookie()\nlogger.info(\n\"Update icon for workspace ID -&gt; %s with icon file -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nfile_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=updateWorkspaceIconPostBody,\nheaders=request_header,\ncookies=self.cookie(),\nfiles=uploadPostFiles,\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update workspace ID -&gt; %s with new icon -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_item(\nself,\nparent_id: int,\nitem_type: str,\nitem_name: str,\nitem_description: str = \"\",\nurl: str = \"\",\noriginal_id: int = 0,\n) -&gt; dict | None:\n\"\"\"Create an Extended ECM item. This REST call is somewhat limited. It cannot set favortie (featured item) or hidden item.\n           It does also not accept owner group information.\n        Args:\n            parent_id (int): node ID of the parent\n            item_type (str): type of the item (e.g. 0 = foler, 140 = URL)\n            item_name (str): name of the item\n            item_description (str, optional): description of the item\n            url (str, optional): address of the URL item (if it is an URL item type)\n            original_id (int, optional): required if a shortcut item is created\n        Returns:\n            dict: Request response of the create item call or None if the REST call has failed.\n        \"\"\"\ncreateItemPostData = {\n\"parent_id\": parent_id,\n\"type\": item_type,\n\"name\": item_name,\n\"description\": item_description,\n}\nif url:\ncreateItemPostData[\"url\"] = url\nif original_id &gt; 0:\ncreateItemPostData[\"original_id\"] = original_id\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create item -&gt; %s (type -&gt; %s) under parent with ID -&gt; %s; calling -&gt; %s\",\nitem_name,\nitem_type,\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.post(\nurl=request_url,\ndata={\"body\": json.dumps(createItemPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create item -&gt; %s; status -&gt; %s; error -&gt; %s\",\nitem_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef update_item(\nself,\nnode_id: int,\nparent_id: int = 0,\nitem_name: str = \"\",\nitem_description: str = \"\",\n) -&gt; dict | None:\n\"\"\"Update an Extended ECM item (parent, name, description). Changing the parent ID is\n           a move operation. If parent ID = 0 the item will not be moved.\n        Args:\n            node_id (int): ID of the node\n            parent_id (int): node ID of the new parent (move operation)\n            item_name (str): new name of the item\n            item_description (str): new description of the item\n        Returns:\n            dict: Response of the update item request or None if the REST call has failed.\n        \"\"\"\nupdateItemPutData = {\n\"name\": item_name,\n\"description\": item_description,\n}\nif parent_id:\n# this is a move operation\nupdateItemPutData[\"parent_id\"] = parent_id\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Update item -&gt; %s with data -&gt; %s; calling -&gt; %s\",\nitem_name,\nstr(updateItemPutData),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(updateItemPutData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update item -&gt; %s; status -&gt; %s; error -&gt; %s\",\nitem_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_document_templates(self, parent_id: int):\n\"\"\"Get all document templates for a given target location.\n        Args:\n            parent_id (int): node ID of target location (e.g. a folder)\n        Returns:\n            dict: response of the REST call (converted to a Python dictionary)\n                        Example output:\n                        'results': [\n                            {\n                                'container': False,\n                                'hasTemplates': False,\n                                'name': 'Document',\n                                'subtype': 144,\n                                'templates': [\n                                    {\n                                        'description_multilingual': {...},\n                                        'id': 16817,\n                                        'isDPWizardAvailable': False,\n                                        'mime_type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                        'name': 'Innovate Procurement Contract Template 2022.docx',\n                                        'name_multilingual': {...},\n                                        'size': 144365,\n                                        'sizeformatted': '141 KB',\n                                        'type': 144\n                                    },\n                                    {\n                                        ...\n                                    }\n                                ]\n                            }\n                        ]\n        \"\"\"\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(parent_id)\n+ \"/doctemplates?subtypes={144}&amp;sidepanel_subtypes={144}\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get document templates for target location -&gt; %s (parent ID); calling -&gt; %s\",\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get document templates for parent folder -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_document_from_template(\nself,\ntemplate_id: int,\nparent_id: int,\nclassification_id: int,\ncategory_data: dict,\ndoc_name: str,\ndoc_desciption: str = \"\",\n) -&gt; dict | None:\n\"\"\"Create a document based on a document template\n        Args:\n            template_id (int): node ID of the document template\n            parent_id (int): node ID of the target location (parent)\n            classification_id (int): node ID of the classification\n            category_data (dict): metadata / category data\n                                    Example: category ID = 12508\n                                    {\n                                        \"12508\": {\n                                            \"12508_2\": \"Draft\",         # Text drop-down\n                                            \"12508_3\": 8559,            # user ID\n                                            \"12508_4\": \"2023-05-10\",    # date\n                                            \"12508_6\": 7357,            # user ID\n                                            \"12508_7\": \"2023-05-11\",    # date\n                                            \"12508_5\": True,            # checkbox / bool\n                                            \"12508_8\": \"EN\",            # text drop-down\n                                            \"12508_9\": \"MS Word\",       # text drop-down\n                                        }\n                                    }\n            doc_name (str): name of the item\n            doc_description (str, optional): description of the item\n        \"\"\"\ncreateDocumentPostData = {\n\"template_id\": template_id,\n\"parent_id\": parent_id,\n\"name\": doc_name,\n\"description\": doc_desciption,\n\"type\": 144,\n\"roles\": {\n\"categories\": category_data,\n\"classifications\": {\"create_id\": [classification_id], \"id\": []},\n},\n}\nrequest_url = self.config()[\"doctemplatesUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create document -&gt; %s from template with ID -&gt; %s in target location -&gt; %s (parent ID) with classification ID -&gt; %s; calling -&gt; %s\",\ndoc_name,\nstr(template_id),\nstr(parent_id),\nstr(classification_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.post(\nurl=request_url,\n# this seems to only work with a \"body\" tag and is different form the documentation\n# on developer.opentext.com\ndata={\"body\": json.dumps(createDocumentPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create document -&gt; %s; status -&gt; %s; error -&gt; %s\",\ndoc_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_web_report_parameters(self, nickname: str):\n\"\"\"Get parameters of a Web Report in Extended ECM. These are defined on the Web Report node\n            (Properties --&gt; Parameters)\n        Args:\n            nickname (str): nickname of the Web Reports node.\n        Returns:\n            Response: list of Web Report parameters. Each list item is a dict describing the parameter.\n            Structure of the list items:\n            {\n                \"type\": \"string\",\n                \"parm_name\": \"string\",\n                \"display_text\": \"string\",\n                \"prompt\": true,\n                \"prompt_order\": 0,\n                \"default_value\": null,\n                \"description\": \"string\",\n                \"mandatory\": true\n            }\n            None if the REST call has failed.\n        \"\"\"\nrequest_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname + \"/parameters\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Retrieving parameters of Web Report with nickname -&gt; %s; calling -&gt; %s\",\nnickname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\n# Return the \"data\" element which is a list of dict items:\nresult_dict = self.parse_request_response(response)\nlogger.debug(\"Web Report parameters result -&gt; %s\", str(result_dict))\nif not result_dict.get(\"data\"):\nreturn None\nreturn result_dict[\"data\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve parameters of Web Report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnickname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef run_web_report(\nself, nickname: str, web_report_parameters: dict | None = None\n) -&gt; dict | None:\n\"\"\"Run a Web Report that is identified by its nick name.\n        Args:\n            nickname (str): nickname of the Web Reports node.\n            web_report_parameters (dict): Parameters of the Web Report (names + value pairs)\n        Returns:\n            dict: Response of the run Web Report request or None if the Web Report execution has failed.\n        \"\"\"\n# Avoid linter warning W0102:\nif web_report_parameters is None:\nweb_report_parameters = {}\nrequest_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname\nrequest_header = self.request_form_header()\nlogger.info(\n\"Running Web Report with nickname -&gt; %s; calling -&gt; %s\",\nnickname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=web_report_parameters,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to run web report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnickname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef install_cs_application(self, application_name: str) -&gt; dict | None:\n\"\"\"Install a CS Application (based on WebReports)\n        Args:\n            application_name (str): name of the application (e.g. OTPOReports, OTRMReports, OTRMSecReports)\n        Returns:\n            dict: Response or None if the installation of the CS Application has failed.\n        \"\"\"\ninstallCSApplicationPostData = {\"appName\": application_name}\nrequest_url = self.config()[\"csApplicationsUrl\"] + \"/install\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Install CS Application -&gt; %s; calling -&gt; %s\", application_name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=installCSApplicationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to install CS Application -&gt; %s; status -&gt; %s; error -&gt; %s\",\napplication_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef assign_item_to_user_group(\nself, node_id: int, subject: str, instruction: str, assignees: list\n) -&gt; dict | None:\n\"\"\"Assign an Extended ECM item to users and groups. This is a function used by\n           Extended ECM for Government.\n        Args:\n            node_id (int): node ID of the Extended ECM item (e.g. a workspace or a document)\n            subject (str): title / subject of the assignment\n            instructions (str): more detailed description or instructions for the assignment\n            assignees (list): list of IDs of users or groups\n        Returns:\n            dict: Response of the request or None if the assignment has failed.\n        \"\"\"\nassignmentPostData = {\n\"subject\": subject,\n\"instruction\": instruction,\n\"assignees\": assignees,\n}\nrequest_url = (\nself.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/xgovassignments\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); calling -&gt; %s\",\nstr(node_id),\nstr(assignees),\nsubject,\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"add_assignment\" tag.\nresponse = requests.post(\nurl=request_url,\ndata={\"add_assignment\": json.dumps(assignmentPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nstr(assignees),\nsubject,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef convert_permission_string_to_permission_value(self, permissions: list) -&gt; int:\n\"\"\"Converts a list of permission names (strongs) to a bit-mask.\n        Args:\n            permissions (list): List of permission names - see conversion variable below.\n        Returns:\n            int: bit-encoded permission value\n        \"\"\"\nconversion = {\n\"see\": 130,  # Bits 2 and 8\n\"see_contents\": 36865,  # Bit 17\n\"modify\": 65536,  # Bit 18\n\"edit_attributes\": 131072,  # Bit 19\n\"add_items\": 4,  # Bit 3\n\"reserve\": 8192,  # Bit 14\n\"add_major_version\": 4194304,  # Bit 23\n\"delete_versions\": 16384,  # Bit 15\n\"delete\": 8,  # Bit 4\n\"edit_permissions\": 16,  # Bit 5\n}\npermission_value = 0\nfor permission in permissions:\nif not conversion.get(permission):\nlogger.error(\"Illegal permission value -&gt; %s\", str(permission))\nreturn 0\npermission_value += conversion[permission]\nreturn permission_value\n# end method definition\ndef convert_permission_value_to_permission_string(\nself, permission_value: int\n) -&gt; list:\n\"\"\"Converts a bit-encoded permission value to a list of permission names (strings).\n        Args:\n            permission_value (int): bit-encoded permission value\n        Returns:\n            list: list of permission names\n        \"\"\"\nconversion = {\n\"see\": 130,  # Bits 2 and 8\n\"see_contents\": 36865,  # Bit 17\n\"modify\": 65536,  # Bit 18\n\"edit_attributes\": 131072,  # Bit 19\n\"add_items\": 4,  # Bit 3\n\"reserve\": 8192,  # Bit 14\n\"add_major_version\": 4194304,  # Bit 23\n\"delete_versions\": 16384,  # Bit 15\n\"delete\": 8,  # Bit 4\n\"edit_permissions\": 16,  # Bit 5\n}\npermissions = []\nfor key, value in conversion.items():\nif permission_value &amp; value:  # binary and\npermissions.append(key)\nreturn permissions\n# end method definition\ndef assign_permission(\nself,\nnode_id: int,\nassignee_type: str,\nassignee: int,\npermissions: list,\napply_to: int = 0,\n) -&gt; dict | None:\n\"\"\"Assign permissions for Extended ECM item to a user or group.\n        Args:\n            node_id (int): node ID of the Extended ECM item\n            assignee_type (str): this can be either \"owner\", \"group\" (for owner group),\n                                    \"public\", or \"custom\" (assigned access)\n            assignee (int): ID of user or group (\"right ID\"). If 0 and assigneeType\n                                is \"owner\" or \"group\" then it is assumed that the owner and\n                                owner group should not be changed.\n            permissions (list): list of permissions - potential elements:\n                                \"see\"\n                                \"see_contents\"\n                                \"modify\"\n                                \"edit_attributes\"\n                                \"add_items\"\n                                \"reserve\"\n                                \"add_major_version\"\n                                \"delete_versions\"\n                                \"delete\"\n                                \"edit_permissions\"\n            apply_to (int, optional): elements to apply permissions to - potential values:\n                                 0 = this item (default)\n                                 1 = sub-items\n                                 2 = This item and sub-items\n                                 3 = This item and immediate sub-items\n        Returns:\n            dict: Response of the request or None if the assignment of permissions has failed.\n        \"\"\"\nif not assignee_type or not assignee_type in [\n\"owner\",\n\"group\",\n\"public\",\n\"custom\",\n]:\nlogger.error(\n\"Missing or wrong assignee type. Needs to be owner, group, public or custom!\"\n)\nreturn None\nif assignee_type == \"custom\" and not assignee:\nlogger.error(\"Missing permission assignee!\")\nreturn None\npermissionPostData = {\n\"permissions\": permissions,\n\"apply_to\": apply_to,\n}\n# Assignees can be specified for owner and group and must be specified for custom:\n#\nif assignee:\npermissionPostData[\"right_id\"] = assignee\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/permissions/\"\n+ assignee_type\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign permissions -&gt; %s to item with ID -&gt; %s; assignee type -&gt; %s; calling -&gt; %s\",\nstr(permissions),\nstr(node_id),\nassignee_type,\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nif assignee_type == \"custom\":\n# Custom also has a REST POST - we prefer this one as to\n# also allows to add a new assigned permission (user or group):\nresponse = requests.post(\nurl=request_url,\ndata={\"body\": json.dumps(permissionPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nelse:\n# Owner, Owner Group and Public require REST PUT:\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(permissionPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign permissions -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(permissions),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_node_categories(self, node_id: int, metadata: bool = True):\n\"\"\"Get categories assigned to a node.\n        Args:\n            node_id (int): ID of the node to get the categories for.\n            metadata (bool, optional): expand the attribute definitions of the category. Default is True\n        Returns:\n            dict: category response or None if the call to the REST API fails.\n        \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\nif metadata:\nrequest_url += \"?metadata\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get categories of node with ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get categories for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_node_category(self, node_id: int, category_id: int, metadata: bool = True):\n\"\"\"Get a specific category assigned to a node.\n        Args:\n            node_id (int): ID of the node to get the categories for.\n            category_id (int): ID of the category definition ID (in category volume)\n            metadata (bool, optional): expand the attribute definitions of the category. Default is True\n        Returns:\n            dict: category response or None if the call to the REST API fails.\n        \"\"\"\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/categories/\"\n+ str(category_id)\n)\nif metadata:\nrequest_url += \"?metadata\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get category with ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\nstr(category_id),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get category with ID -&gt; %s for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_node_category_ids(self, node_id: int) -&gt; list:\n\"\"\"Get list of all category definition IDs that are assign to the node.\n        Args:\n            node_id (int): ID of the node to get the categories for.\n        Returns:\n            list: list of category IDs (all categories assigned to the node)\n        \"\"\"\ncategories = self.get_node_categories(node_id)\nif not categories or not categories[\"results\"]:\nreturn None\ncategory_id_list = []\nfor category in categories[\"results\"]:\ncategory_id_list += [\nint(i) for i in category[\"metadata_order\"][\"categories\"]\n]\nreturn category_id_list\n# end method definition\ndef get_node_category_definition(self, node_id: int, category_name: str):\n\"\"\"Get category definition (category id and attribute IDs and types)\n        Args:\n            node_id (int): node to read the category definition from\n                           (e.g. a workspace template or a document template or a target folder)\n                           This should NOT be the category definition object!\n            category_name (str): name of the category\n        Returns:\n            int: category ID\n            dict: keys are the attribute names. values are sub-dictionaries with the id and type of the attribute.\n                        Example:\n                        {\n                            'Status': {\n                                'id': '12532_2',\n                                'type': 'String'\n                            },\n                            'Legal Approval': {\n                                'id': '12532_3',\n                                'type': 'user'\n                            },\n                            ...\n                        }\n        \"\"\"\nattribute_definitions = {}\ncat_id = -1\nresponse = self.get_node_categories(node_id)\nif response and response[\"results\"]:\nfor categories in response[\"results\"]:\nkeys = categories[\"metadata\"][\"categories\"].keys()\ncat_id = next((key for key in keys if \"_\" not in key), -1)\ncat_name = categories[\"metadata\"][\"categories\"][cat_id][\"name\"]\nif cat_name != category_name:\ncontinue\nfor att_id in categories[\"metadata\"][\"categories\"]:\nif not \"_\" in att_id:\ncontinue\natt_name = categories[\"metadata\"][\"categories\"][att_id][\"name\"]\nif categories[\"metadata\"][\"categories\"][att_id][\"persona\"]:\natt_type = categories[\"metadata\"][\"categories\"][att_id][\n\"persona\"\n]\nelse:\natt_type = categories[\"metadata\"][\"categories\"][att_id][\n\"type_name\"\n]\nattribute_definitions[att_name] = {\"id\": att_id, \"type\": att_type}\nreturn cat_id, attribute_definitions\ndef assign_category(\nself,\nnode_id: int,\ncategory_id: list,\ninheritance: bool = False,\napply_to_sub_items: bool = False,\napply_action: str = \"add_upgrade\",\nadd_version: bool = False,\nclear_existing_categories: bool = False,\n) -&gt; bool:\n\"\"\"Assign a category to a node. Optionally turn on inheritance and apply\n           category to sub-items (if node_id is a container / folder / workspace).\n           If the category is already assigned to the node this method will\n           throw an error.\n        Args:\n            node_id (int): node ID to apply the category to\n            category_id (list): ID of the category definition object\n            inheritance (bool): turn on inheritance for the category\n                                   (this makes only sense if the node is a container like a folder or workspace)\n            apply_to_sub_items (bool, optional): if True the category is applied to\n                                                    the item and all its sub-items\n                                                    if False the category is only applied\n                                                    to the item\n            apply_action (str, optional): supported values are \"add\", \"add_upgrade\", \"upgrade\", \"replace\", \"delete\", \"none\", None\n            add_version (bool, optional): if a document version should be added for the category change (default = False)\n            clear_existing_categories (bool, optional): whether or not existing (other) categories should be removed (default = False)\n        Returns:\n            bool: True = success, False = error\n        \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\nrequest_header = self.request_form_header()\n#\n# 1. Assign Category to Node if not yet assigned:\n#\nexisting_category_ids = self.get_node_category_ids(node_id)\nif not category_id in existing_category_ids:\nlogger.info(\n\"Category with ID -&gt; %s is not yet assigned to node ID -&gt; %s. Assigning it now...\",\nstr(category_id),\nstr(node_id),\n)\ncategoryPostData = {\n\"category_id\": category_id,\n}\nlogger.info(\n\"Assign category with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\nstr(category_id),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=categoryPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign category with ID -&gt; %s to node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\n#\n# 2. Set Inheritance\n#\nrequest_url_inheritance = request_url + \"/\" + str(category_id) + \"/inheritance\"\nretries = 0\nwhile True:\nif inheritance:\n# Enable inheritance\nresponse = requests.post(\nurl=request_url_inheritance,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nelse:\n# Disable inheritance\nresponse = requests.delete(\nurl=request_url_inheritance,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set inheritance for category with ID -&gt; %s on node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\n#\n# 3. Apply to sub-items\n#\nif apply_to_sub_items:\nrequest_url_apply_sub_items = request_url + \"/apply\"\ncategoryPostData = {\n\"categories\": [{\"id\": category_id, \"action\": apply_action}],\n\"add_version\": add_version,\n\"clear_existing_categories\": clear_existing_categories,\n}\nretries = 0\nwhile True:\n# we need to wrap the body of this POST call into a \"body\"\n# tag. This is documented worngly on developer.opentext.com\nresponse = requests.post(\nurl=request_url_apply_sub_items,\ndata={\"body\": json.dumps(categoryPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to apply category with ID -&gt; %s to sub-items of node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n# end method definition\ndef set_category_value(\nself,\nnode_id: int,\nvalue,\ncategory_id: int,\nattribute_id: int,\nset_id: int = 0,\nset_row: int = 1,\n) -&gt; dict | None:\n\"\"\"Set a value to a specific attribute in a category. Categories and have sets (groupings), multi-line sets (matrix),\n           and multi-value attributes (list of values). This method supports all variants.\n        Args:\n            node_id (int): ID of the node\n            value (multi-typed): value to be set - can be string or list of strings (for multi-value attributes)\n            category_id (int):ID of the category object\n            attribute_id (int): ID of the attribute\n            set_id (int, optional): ID of the set. Defaults to 0.\n            set_row (int, optional): Row of . Defaults to 1.\n        Returns:\n            dict: REST API response or None if the call fails\n        \"\"\"\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/categories/\"\n+ str(category_id)\n)\nrequest_header = self.request_form_header()\nif set_id:\nlogger.info(\n\"Assign value -&gt; %s to category with ID -&gt; %s, set ID -&gt; %s, row -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\nstr(value),\nstr(category_id),\nstr(set_id),\nstr(set_row),\nstr(attribute_id),\nstr(node_id),\nrequest_url,\n)\ncategoryPutData = {\n\"category_id\": category_id,\n\"{}_{}_{}_{}\".format(category_id, set_id, set_row, attribute_id): value,\n}\nelse:\nlogger.info(\n\"Assign value -&gt; %s to category ID -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\nstr(value),\nstr(category_id),\nstr(attribute_id),\nstr(node_id),\nrequest_url,\n)\ncategoryPutData = {\n\"category_id\": category_id,\n\"{}_{}\".format(category_id, attribute_id): value,\n}\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata=categoryPutData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set value -&gt; %s for category with ID -&gt; %s, attribute ID -&gt; %s on node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(value),\nstr(category_id),\nstr(attribute_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef assign_classification(\nself, node_id: int, classifications: list, apply_to_sub_items: bool = False\n) -&gt; dict | None:\n\"\"\"Assign one or multiple classifications to an Extended ECM item\n        Args:\n            node_id (int): node ID of the Extended ECM item\n            classifications (list): list of classification item IDs\n            apply_to_sub_items (bool, optional): if True the classification is applied to\n                                                    the item and all its sub-items\n                                                    if False the classification is only applied\n                                                    to the item\n        Returns:\n            dict: Response of the request or None if the assignment of the classification has failed.\n        \"\"\"\n# the REST API expects a list of dict elements with \"id\" and the actual IDs\nclassification_list = []\nfor classification in classifications:\nclassification_list.append({\"id\": classification})\nclassificationPostData = {\n\"class_id\": classification_list,\n\"apply_to_sub_items\": apply_to_sub_items,\n}\nrequest_url = (\nself.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/classifications\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign classifications with IDs -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\nstr(classifications),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=classificationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign classifications with IDs -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(classifications),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef assign_rm_classification(\nself, node_id: int, rm_classification: int, apply_to_sub_items: bool = False\n) -&gt; dict | None:\n\"\"\"Assign a RM classification to an Extended ECM item\n        Args:\n            node_id (int): node ID of the Extended ECM item\n            rm_classification (int): Records Management classification ID\n            apply_to_sub_items (bool, optional): if True the RM classification is applied to\n                                                    the item and all its sub-items\n                                                    if False the RM classification is only applied\n                                                    to the item\n        Returns:\n            dict: Response of the request or None if the assignment of the RM classification has failed.\n        \"\"\"\nrmClassificationPostData = {\n\"class_id\": rm_classification,\n\"apply_to_sub_items\": apply_to_sub_items,\n}\nrequest_url = (\nself.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/rmclassifications\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\nstr(rm_classification),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=rmClassificationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(rm_classification),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef register_workspace_template(self, node_id: int) -&gt; dict | None:\n\"\"\"Register a workspace template as project template for Extended ECM for Engineering\n        Args:\n            node_id (int): node ID of the Extended ECM workspace template\n        Returns:\n            dict: Response of request or None if the registration of the workspace template has failed.\n        \"\"\"\nregistrationPostData = {\"ids\": \"{{ {} }}\".format(node_id)}\nrequest_url = self.config()[\"xEngProjectTemplateUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Register workspace template with ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=registrationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to register Workspace Template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_records_management_rsis(self, limit: int = 100) -&gt; list | None:\n\"\"\"Get all Records management RSIs togther with their RSI Schedules.\n        Args:\n            limit (int, optional): max elements to return (default = 100)\n        Returns:\n            list: list of Records Management RSIs or None if the request fails.\n            Each RSI list element is a dict with this structure:\n            {\n                \"RSIID\": 0,\n                \"RSI\": \"string\",\n                \"Title\": \"string\",\n                \"Subject\": \"string\",\n                \"Description\": \"string\",\n                \"CreateDate\": \"string\",\n                \"RSIStatus\": \"string\",\n                \"StatusDate\": \"string\",\n                \"DiscontFlag\": 0,\n                \"DiscontDate\": \"string\",\n                \"DiscontComment\": \"string\",\n                \"Active\": 0,\n                \"DispControl\": 0,\n                \"RSIScheduleID\": 0,\n                \"RetStage\": \"string\",\n                \"RecordType\": 0,\n                \"EventType\": 0,\n                \"RSIRuleCode\": \"string\",\n                \"DateToUse\": \"string\",\n                \"YearEndMonth\": 0,\n                \"YearEndDay\": 0,\n                \"RetYears\": 0,\n                \"RetMonths\": 0,\n                \"RetDays\": 0,\n                \"RetIntervals\": 0,\n                \"EventRuleDate\": \"string\",\n                \"EventRule\": \"string\",\n                \"EventComment\": \"string\",\n                \"StageAction\": \"string\",\n                \"FixedRet\": 0,\n                \"ActionCode\": \"string\",\n                \"ActionDescription\": \"string\",\n                \"Disposition\": \"string\",\n                \"ApprovalFlag\": 0,\n                \"MaximumRet\": 0,\n                \"ObjectType\": \"LIV\"\n            }\n        \"\"\"\nrequest_url = self.config()[\"rsisUrl\"] + \"?limit=\" + str(limit)\nrequest_header = self.request_form_header()\nlogger.info(\"Get list of Records Management RSIs; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nrsi_dict = self.parse_request_response(response)\nreturn rsi_dict[\"results\"][\"data\"][\"rsis\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of Records Management RSIs; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_records_management_codes(self) -&gt; dict | None:\n\"\"\"Get Records Management Codes. These are the most basic data types of\n           the Records Management configuration and required to create RSIs and\n           other higher-level Records Management configurations\n        Args:\n            None\n        Returns:\n            dict: RM codes or None if the request fails.\n        \"\"\"\nrequest_url = self.config()[\"recordsManagementUrlv2\"] + \"/rmcodes\"\nrequest_header = self.request_form_header()\nlogger.info(\"Get list of Records Management codes; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nrm_codes_dict = self.parse_request_response(response)\nreturn rm_codes_dict[\"results\"][\"data\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of Records Management codes; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\n# This is not yet working. REST API endpoint seems not to be in 22.4. Retest with 23.1\ndef update_records_management_codes(self, rm_codes: dict) -&gt; dict | None:\n\"\"\"Update Records Management Codes. These are the most basic data types of\n           the Records Management configuration and required to create RSIs and\n           other higher-level Records Management configurations\n           THIS METHOD IS CURRENTLY NOT WORKING\n        Args:\n            rm_codes (dict): Codes to be updated\n        Returns:\n            dict: RSI data or None if the request fails.\n        \"\"\"\nupdateRMCodesPostData = {}\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/rmcodes\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Update Records Management codes -&gt; %s; calling -&gt; %s\",\nstr(rm_codes),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=updateRMCodesPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nrm_codes_dict = self.parse_request_response(response)\nreturn rm_codes_dict[\"results\"][\"data\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update Records Management codes; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_records_management_rsi(\nself,\nname: str,\nstatus: str,\nstatus_date: str,\ndescription: str,\nsubject: str,\ntitle: str,\ndispcontrol: bool,\n) -&gt; dict | None:\n\"\"\"Create a new Records Management RSI.\n        Args:\n            name (str): name of the RSI\n            status (str): status of the RSI\n            status_date (str): statusDate of the RSI YYYY-MM-DDTHH:mm:ss\n            description (str): description of the RSI\n            subject (str): status of the RSI\n            title (str): status of the RSI\n            dispcontrol (bool): status of the RSI\n        Returns:\n            dict: RSI data or None if the request fails.\n        \"\"\"\nif statusDate == \"\":\nnow = datetime.now()\nstatusDate = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\ncreateRSIPostData = {\n\"name\": name,\n\"status\": status,\n\"statusDate\": status_date,\n\"description\": description,\n\"subject\": subject,\n\"title\": title,\n\"dispcontrol\": dispcontrol,\n}\nrequest_url = self.config()[\"rsiSchedulesUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create Records Management RSI -&gt; %s; calling -&gt; %s\", name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createRSIPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create Records Management RSI -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_records_management_rsi_schedule(\nself,\nrsi_id: int,\nstage: str,\nevent_type: int = 1,\nobject_type: str = \"LIV\",\nrule_code: str = \"\",\nrule_comment: str = \"\",\ndate_to_use: int = 91,\nretention_years: int = 0,\nretention_months: int = 0,\nretention_days: int = 0,\ncategory_id: int = 0,\nattribute_id: int = 0,\nyear_end_month: int = 12,\nyear_end_day: int = 31,\nretention_intervals: int = 1,\nfixed_retention: bool = True,\nmaximum_retention: bool = True,\nfixed_date: str = \"\",\nevent_condition: str = \"\",\ndisposition: str = \"\",\naction_code: int = 0,\ndescription: str = \"\",\nnew_status: str = \"\",\nmin_num_versions_to_keep: int = 1,\npurge_superseded: bool = False,\npurge_majors: bool = False,\nmark_official_rendition: bool = False,\n) -&gt; dict | None:\n\"\"\"Create a new Records Management RSI Schedule for an existing RSI.\n        Args:\n            rsi_id (int): ID of an existing RSI the schedule should be created for\n            object_type (str): either \"LIV\" - Classified Objects (default) or \"LRM\" - RM Classifications\n            stage (str): retention stage - this is the key parameter to define multiple stages (stages are basically schedules)\n            event_type (int): 1 Calculated Date, 2 Calendar Calculation, 3 Event Based, 4 Fixed Date, 5 Permanent\n            rule_code (str): rule code - this value must be defined upfront\n            rule_comment (str): comment for the rule\n            date_to_use (int): 91 Create Date, 92 Reserved Data, 93 Modification Date, 94 Status Date, 95 Records Date\n            retention_years (int): years to wait before disposition\n            retention_months (int): month to wait before disposition\n            retention_days (int): days to wait before disposition\n            category_id (int): ID of the category\n            attribute_id (int): ID of the category attribute\n            year_end_month (int): month the year ends (normally 12)\n            year_end_day (int): day the year ends (normally 31)\n            retention_intervals (int): retention intervals\n            fixed_retention (bool): fixedRetention\n            maximum_retention (bool): maximumRetention\n            fixed_date(str): fixed date format : YYYY-MM-DDTHH:mm:ss\n            event_condition (str): eventCondition\n            disposition (str): disposition\n            action_code (int): 0 None, 1 Change Status, 7 Close, 8 Finalize Record, 9 Mark Official, 10 Export, 11 Update Storage Provider, 12 Delete Electronic Format, 15 Purge Versions, 16 Make Rendition, 32 Destroy\n            description (str): description\n            new_status (str): new status\n            min_num_versions_to_keep (int): minimum document versions to keep\n            purge_superseded (bool): purge superseded\n            purge_majors (bool): purge majors\n            mark_official_rendition (bool): mark official rendition\n        Returns:\n            dict: RSI Schedule data or None if the request fails.\n        \"\"\"\nif fixedDate == \"\":\nnow = datetime.now()\nfixedDate = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\ncreateRSISchedulePostData = {\n\"objectType\": object_type,\n\"stage\": stage,\n\"eventType\": event_type,\n\"ruleCode\": rule_code,\n\"ruleComment\": rule_comment,\n\"dateToUse\": date_to_use,\n\"retentionYears\": retention_years,\n\"retentionMonths\": retention_months,\n\"retentionDays\": retention_days,\n\"categoryId\": category_id,\n\"attributeId\": attribute_id,\n\"yearEndMonth\": year_end_month,\n\"yearEndDay\": year_end_day,\n\"retentionIntervals\": retention_intervals,\n\"fixedRetention\": fixed_retention,\n\"maximumRetention\": maximum_retention,\n\"fixedDate\": fixed_date,\n\"eventCondition\": event_condition,\n\"disposition\": disposition,\n\"actionCode\": action_code,\n\"description\": description,\n\"newStatus\": new_status,\n\"minNumVersionsToKeep\": min_num_versions_to_keep,\n\"purgeSuperseded\": purge_superseded,\n\"purgeMajors\": purge_majors,\n\"markOfficialRendition\": mark_official_rendition,\n}\nrequest_url = self.config()[\"rsiSchedulesUrl\"] + \"/\" + str(rsi_id) + \"/stages\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create Records Management RSI Schedule -&gt; %s for RSI -&gt; %s; calling -&gt; %s\",\nstage,\nstr(rsi_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createRSISchedulePostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create Records Management RSI Schedule -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstage,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef create_records_management_hold(\nself,\nhold_type: str,\nname: str,\ncomment: str,\nalternate_id: str = \"\",\nparent_id: int = 0,\ndate_applied: str = \"\",\ndate_to_remove: str = \"\",\n) -&gt; dict | None:\n\"\"\"Create a new Records Management Hold.\n        Args:\n            hold_type (str): type of the Hold\n            name (str): name of the RSI\n            comment (str): comment\n            alternate_id (str): alternate hold ID\n            parent_id (int, optional): ID of the parent node. If parent_id is 0 the item will be created right under \"Hold Management\" (top level item)\n            date_applied (str, optional): create date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n            date_to_remove (str, optional): suspend date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n        Returns:\n            dict: Hold data or None if the request fails. The dict structure is this: {'holdID': &lt;ID&gt;}\n        \"\"\"\nif date_applied == \"\":\nnow = datetime.now()\ndate_applied = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\ncreateHoldPostData = {\n\"type\": hold_type,\n\"name\": name,\n\"comment\": comment,\n\"date_applied\": date_applied,\n\"date_to_remove\": date_to_remove,\n\"alternate_id\": alternate_id,\n}\nif parent_id &gt; 0:\ncreateHoldPostData[\"parent_id\"] = parent_id\nrequest_url = self.config()[\"holdsUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create Records Management Hold -&gt; %s; calling -&gt; %s\", name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createHoldPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create Records Management Hold -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef get_records_management_holds(self) -&gt; dict | None:\n\"\"\"Get a list of all Records Management Holds in the system. Even though there are folders\n        in the holds management area in RM these are not real folders - they cannot be retrieved\n        with get_node_by_parent_and_name() thus we need this method to get them all.\n        Args:\n            None\n        Returns:\n            dict: Response with list of holds:\n            \"results\": {\n                \"data\": {\n                    \"holds\": [\n                        {\n                            \"HoldID\": 0,\n                            \"HoldName\": \"string\",\n                            \"ActiveHold\": 0,\n                            \"OBJECT\": 0,\n                            \"ApplyPatron\": \"string\",\n                            \"DateApplied\": \"string\",\n                            \"HoldComment\": \"string\",\n                            \"HoldType\": \"string\",\n                            \"DateToRemove\": \"string\",\n                            \"DateRemoved\": \"string\",\n                            \"RemovalPatron\": \"string\",\n                            \"RemovalComment\": \"string\",\n                            \"EditDate\": \"string\",\n                            \"EditPatron\": \"string\",\n                            \"AlternateHoldID\": 0,\n                            \"ParentID\": 0\n                        }\n                    ]\n                }\n            }\n        \"\"\"\nrequest_url = self.config()[\"holdsUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Get list of Records Management Holds; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of Records Management Holds; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef import_records_management_settings(self, file_path: str) -&gt; bool:\n\"\"\"Import Records Management settings from a file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/importSettings\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Records Management Settings from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Records Management Settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef import_records_management_codes(\nself, file_path: str, update_existing_codes: bool = True\n) -&gt; bool:\n\"\"\"Import RM Codes from a file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of settings file in Python container filesystem\n            update_existing_codes (bool): Flag that controls whether existing table maintenance codes\n                                          should be updated.\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/importCodes\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Records Management Codes from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\"updateExistingCodes\": update_existing_codes}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Records Management Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef import_records_management_rsis(\nself,\nfile_path: str,\nupdate_existing_rsis: bool = True,\ndelete_schedules: bool = False,\n) -&gt; bool:\n\"\"\"Import RM RSIs from a config file that is uploaded from the Python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n            update_existing_rsis (bool, optional): whether or not existing RSIs should be updated (or ignored)\n            delete_schedules (bool, optional): whether RSI Schedules should be deleted\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/importRSIs\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Records Management RSIs from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\n\"updateExistingRSIs\": update_existing_rsis,\n\"deleteSchedules\": delete_schedules,\n}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Records Management RSIs from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef import_physical_objects_settings(self, file_path: str) -&gt; bool:\n\"\"\"Import Physical Objects settings from a config file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"physicalObjectsUrl\"] + \"/importSettings\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Physical Objects Settings from server file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Physical Objects settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef import_physical_objects_codes(\nself, file_path: str, update_existing_codes: bool = True\n) -&gt; bool:\n\"\"\"Import Physical Objects codes from a config file that is uploaded from the Python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n            update_existing_codes (bool): whether or not existing codes should be updated (default = True)\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"physicalObjectsUrl\"] + \"/importCodes\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Physical Objects Codes from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\"updateExistingCodes\": update_existing_codes}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Physical Objects Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef import_physical_objects_locators(self, file_path: str) -&gt; bool:\n\"\"\"Import Physical Objects locators from a config file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"physicalObjectsUrl\"] + \"/importLocators\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Physical Objects Locators from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Physical Objects Locators from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef import_security_clearance_codes(\nself, file_path: str, include_users: bool = False\n) -&gt; bool:\n\"\"\"Import Security Clearance codes from a config file that is uploaded from the python pod\n        Args:\n            file_path (str): path + filename of config file in Python container filesystem\n            include_users (bool): defines if users should be included or not\n        Returns:\n            bool: True if if the REST call succeeds or False otherwise.\n        \"\"\"\nrequest_url = self.config()[\"securityClearancesUrl\"] + \"/importCodes\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Security Clearance Codes from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\"includeusers\": include_users}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Security Clearance Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n# end method definition\ndef assign_user_security_clearance(\nself, user_id: int, security_clearance: int\n) -&gt; dict | None:\n\"\"\"Assign a Security Clearance level to an Extended ECM user\n        Args:\n            user_id (int): ID of the user\n            security_clearance (int): security clearance level to be set\n        Returns:\n            dict: REST response or None if the REST call fails.\n        \"\"\"\nassignUserSecurityClearancePostData = {\n\"securityLevel\": security_clearance,\n}\nrequest_url = self.config()[\n\"userSecurityUrl\"\n] + \"/{}/securityclearancelevel\".format(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign security clearance -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\nstr(security_clearance),\nstr(user_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=assignUserSecurityClearancePostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign security clearance -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(security_clearance),\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef assign_user_supplemental_markings(\nself, user_id: int, supplemental_markings: list\n) -&gt; dict | None:\n\"\"\"Assign a list of Supplemental Markings to a user\n        Args:\n            user_id (int): ID of the user\n            supplemental_markings (list of strings): list of Supplemental Markings to be set\n        Returns:\n            dict: REST response or None if the REST call fails.\n        \"\"\"\nassignUserSupplementalMarkingsPostData = {\n\"suppMarks\": supplemental_markings,\n}\nrequest_url = self.config()[\n\"userSecurityUrl\"\n] + \"/{}/supplementalmarkings\".format(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign supplemental markings -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\nstr(supplemental_markings),\nstr(user_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=assignUserSupplementalMarkingsPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign supplemental markings -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(supplemental_markings),\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef check_workspace_aviator(\nself,\nworkspace_id: int,\n) -&gt; bool:\n\"\"\"Check if Content Aviator is enabled for a workspace\n        Args:\n            workspace_id (int): node ID of the workspace\n        Returns:\n            bool: True if aviator is enabled, False otherwise\n        \"\"\"\nresponse = self.get_node_actions(\nnode_id=workspace_id, filter_actions=[\"disableai\", \"enableai\"]\n)\nresult_data = self.get_result_value(\nresponse=response,\nkey=str(workspace_id),\n)\nif result_data and \"data\" in result_data:\ndata = result_data[\"data\"]\nif \"disableai\" in data:\nlogger.info(\n\"Aviator is enabled for workspace with ID -&gt; %s\", str(workspace_id)\n)\nreturn True\nelif \"enableai\" in data:\nlogger.info(\n\"Aviator is disabled for workspace with ID -&gt; %s\", str(workspace_id)\n)\nreturn False\n# end method definition\ndef update_workspace_aviator(\nself,\nworkspace_id: int,\nstatus: bool,\n) -&gt; dict | None:\n\"\"\"Enable or disable the Content Aviator for a workspace\n        Args:\n            workspace_id (int): node ID of the workspace\n            status (bool): True = enable, False = disable Content Aviator for this workspace\n        Returns:\n            dict: REST response or None if the REST call fails.\n        \"\"\"\naviatorStatusPutData = {\n\"enabled\": status,\n}\nrequest_url = self.config()[\"aiUrl\"] + \"/{}\".format(workspace_id)\nrequest_header = self.request_form_header()\nif status is True:\nlogger.info(\n\"Enable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nelse:\nlogger.info(\n\"Disable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\nheaders=request_header,\ndata=aviatorStatusPutData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to change status for Content Aviator on workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n# end method definition\ndef volume_translator(\nself, current_node_id: int, translator: object, languages: list\n):\n\"\"\"Experimental code to translate the item names and item descriptions in a given hierarchy.\n           The actual translation is done by a tranlator object. This recursive method just\n           traverses the hierarchy and calls the translate() method of the translator object.\n        Args:\n            current_node_id (int): current node ID to translate\n            translator (object): this object needs to be created based on the \"Translator\" class\n                                 and passed to this method\n            languages (list): list of target languages\n        \"\"\"\n# Get current node based on the ID:\ncurrent_node = self.get_node(current_node_id)\ncurrent_node_id = self.get_result_value(current_node, \"id\")\nname = self.get_result_value(current_node, \"name\")\ndescription = self.get_result_value(current_node, \"description\")\nnames_multilingual = self.get_result_value(current_node, \"name_multilingual\")\ndescriptions_multilingual = self.get_result_value(\ncurrent_node, \"description_multilingual\"\n)\nfor language in languages:\nif language == \"en\":\ncontinue\n# Does the language not exist as metadata language or is it already translated?\n# Then we skip this language:\nif (\nlanguage in names_multilingual\nand names_multilingual[\"en\"]\nand not names_multilingual[language]\n):\nnames_multilingual[language] = translator.translate(\n\"en\", language, names_multilingual[\"en\"]\n)\nif (\nlanguage in descriptions_multilingual\nand descriptions_multilingual[\"en\"]\nand not descriptions_multilingual[language]\n):\ndescriptions_multilingual[language] = translator.translate(\n\"en\", language, descriptions_multilingual[\"en\"]\n)\n# Rename node multi-lingual:\nself.rename_node(\ncurrent_node_id,\nname,\ndescription,\nnames_multilingual,\ndescriptions_multilingual,\n)\n# Get children nodes of the current node:\nresults = self.get_subnodes(current_node_id, limit=200)[\"results\"]\n# Recursive call of all subnodes:\nfor result in results:\nself.volume_translator(\nresult[\"data\"][\"properties\"][\"id\"], translator, languages\n)\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.__init__","title":"<code>__init__(protocol, hostname, port, public_url, username=None, password=None, user_partition='Content Server Members', resource_name='cs', default_license='X3', otds_ticket=None)</code>","text":"<p>Initialize the OTCS object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>Either http or https.</p> required <code>hostname</code> <code>str</code> <p>The hostname of Extended ECM server to communicate with.</p> required <code>port</code> <code>int</code> <p>The port number used to talk to the Extended ECM server.</p> required <code>public_url</code> <code>str</code> <p>public (external) URL</p> required <code>username</code> <code>str</code> <p>The admin user name of Extended ECM. Optional if otds_ticket is provided.</p> <code>None</code> <code>password</code> <code>str</code> <p>The admin password of Extended ECM. Optional if otds_ticket is provided.</p> <code>None</code> <code>user_partition</code> <code>str</code> <p>Name of the OTDS partition for OTCS users. Default is \"Content Server Members\".</p> <code>'Content Server Members'</code> <code>resource_name</code> <code>str</code> <p>Name of the OTDS resource for OTCS. Dault is \"cs\".</p> <code>'cs'</code> <code>default_license</code> <code>str</code> <p>name of the default user license. Default is \"X3\".</p> <code>'X3'</code> <code>otds_ticket</code> <code>str</code> <p>Authentication ticket of OTDS</p> <code>None</code> Source code in <code>pyxecm/otcs.py</code> <pre><code>def __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\npublic_url: str,\nusername: str | None = None,\npassword: str | None = None,\nuser_partition: str = \"Content Server Members\",\nresource_name: str = \"cs\",\ndefault_license: str = \"X3\",\notds_ticket: str | None = None,\n):\n\"\"\"Initialize the OTCS object\n    Args:\n        protocol (str): Either http or https.\n        hostname (str): The hostname of Extended ECM server to communicate with.\n        port (int): The port number used to talk to the Extended ECM server.\n        public_url (str): public (external) URL\n        username (str, optional): The admin user name of Extended ECM. Optional if otds_ticket is provided.\n        password (str, optional): The admin password of Extended ECM. Optional if otds_ticket is provided.\n        user_partition (str): Name of the OTDS partition for OTCS users. Default is \"Content Server Members\".\n        resource_name (str, optional): Name of the OTDS resource for OTCS. Dault is \"cs\".\n        default_license (str, optional): name of the default user license. Default is \"X3\".\n        otds_ticket (str, optional): Authentication ticket of OTDS\n    \"\"\"\n# Initialize otcs_config as an empty dictionary\notcs_config = {}\nif hostname:\notcs_config[\"hostname\"] = hostname\nelse:\notcs_config[\"hostname\"] = \"otcs-admin-0\"\nif protocol:\notcs_config[\"protocol\"] = protocol\nelse:\notcs_config[\"protocol\"] = \"http\"\nif port:\notcs_config[\"port\"] = port\nelse:\notcs_config[\"port\"] = 8080\notcs_config[\"publicUrl\"] = public_url\nif username:\notcs_config[\"username\"] = username\nelse:\notcs_config[\"username\"] = \"admin\"\nif password:\notcs_config[\"password\"] = password\nelse:\notcs_config[\"password\"] = \"\"\nif user_partition:\notcs_config[\"partition\"] = user_partition\nelse:\notcs_config[\"partition\"] = \"\"\nif resource_name:\notcs_config[\"resource\"] = resource_name\nelse:\notcs_config[\"resource\"] = \"\"\nif default_license:\notcs_config[\"license\"] = default_license\nelse:\notcs_config[\"license\"] = \"\"\notcs_base_url = protocol + \"://\" + otcs_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notcs_base_url += \":{}\".format(port)\notcs_config[\"baseUrl\"] = otcs_base_url\notcs_support_url = otcs_base_url + \"/cssupport\"\notcs_config[\"supportUrl\"] = otcs_support_url\notcs_public_support_url = public_url + \"/cssupport\"\notcs_config[\"supportPublicUrl\"] = otcs_public_support_url\notcs_config[\"configuredUrl\"] = otcs_support_url + \"/csconfigured\"\notcs_url = otcs_base_url + \"/cs/cs\"\notcs_config[\"csUrl\"] = otcs_url\notcs_public_url = public_url + \"/cs/cs\"\notcs_config[\"csPublicUrl\"] = otcs_public_url\notcs_rest_url = otcs_url + \"/api\"\notcs_config[\"restUrl\"] = otcs_rest_url\notcs_config[\"isReady\"] = otcs_rest_url + \"/v1/ping\"\notcs_config[\"authenticationUrl\"] = otcs_rest_url + \"/v1/auth\"\notcs_config[\"serverInfoUrl\"] = otcs_rest_url + \"/v1/serverinfo\"\notcs_config[\"membersUrl\"] = otcs_rest_url + \"/v1/members\"\notcs_config[\"membersUrlv2\"] = otcs_rest_url + \"/v2/members\"\notcs_config[\"nodesUrl\"] = otcs_rest_url + \"/v1/nodes\"\notcs_config[\"nodesUrlv2\"] = otcs_rest_url + \"/v2/nodes\"\notcs_config[\"doctemplatesUrl\"] = otcs_rest_url + \"/v2/doctemplates\"\notcs_config[\"nicknameUrl\"] = otcs_rest_url + \"/v2/nicknames\"\notcs_config[\"importSettingsUrl\"] = otcs_rest_url + \"/v2/import/settings/admin\"\notcs_config[\"searchUrl\"] = otcs_rest_url + \"/v2/search\"\notcs_config[\"volumeUrl\"] = otcs_rest_url + \"/v2/volumes\"\notcs_config[\"externalSystem\"] = otcs_rest_url + \"/v2/externalsystems\"\notcs_config[\"businessworkspacetypes\"] = (\notcs_rest_url + \"/v2/businessworkspacetypes\"\n)\notcs_config[\"businessworkspacecreateform\"] = (\notcs_rest_url + \"/v2/forms/businessworkspaces/create\"\n)\notcs_config[\"businessworkspaces\"] = otcs_rest_url + \"/v2/businessworkspaces\"\notcs_config[\"favoritesUrl\"] = otcs_rest_url + \"/v2/members/favorites\"\notcs_config[\"webReportsUrl\"] = otcs_rest_url + \"/v1/webreports\"\notcs_config[\"csApplicationsUrl\"] = otcs_rest_url + \"/v2/csapplications\"\notcs_config[\"xEngProjectTemplateUrl\"] = (\notcs_rest_url + \"/v2/xengcrt/projecttemplate\"\n)\notcs_config[\"rsisUrl\"] = otcs_rest_url + \"/v2/rsis\"\notcs_config[\"rsiSchedulesUrl\"] = otcs_rest_url + \"/v2/rsischedules\"\notcs_config[\"recordsManagementUrl\"] = otcs_rest_url + \"/v1/recordsmanagement\"\notcs_config[\"recordsManagementUrlv2\"] = otcs_rest_url + \"/v2/recordsmanagement\"\notcs_config[\"userSecurityUrl\"] = otcs_rest_url + \"/v2/members/usersecurity\"\notcs_config[\"physicalObjectsUrl\"] = otcs_rest_url + \"/v1/physicalobjects\"\notcs_config[\"securityClearancesUrl\"] = otcs_rest_url + \"/v1/securityclearances\"\notcs_config[\"holdsUrl\"] = otcs_rest_url + \"/v1/holds\"\notcs_config[\"holdsUrlv2\"] = otcs_rest_url + \"/v2/holds\"\notcs_config[\"validationUrl\"] = otcs_rest_url + \"/v1/validation/nodes/names\"\notcs_config[\"aiUrl\"] = otcs_rest_url + \"/v2/ai/nodes\"\nself._config = otcs_config\nself._otds_ticket = otds_ticket\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_document_version","title":"<code>add_document_version(node_id, file_url, file_name, mime_type='text/plain', description='')</code>","text":"<p>Fetch a file from a URL or local filesystem and upload it as a new document version.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the document to add add version to</p> required <code>file_url</code> <code>str</code> <p>URL to download file or local file</p> required <code>file_name</code> <code>str</code> <p>name of the file</p> required <code>mime_type</code> <code>str</code> <p>mimeType of the file (default = text/plain)</p> <code>'text/plain'</code> <code>description</code> <code>str</code> <p>description of the version (default = no description)</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Add version response or None if the upload fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_document_version(\nself,\nnode_id: int,\nfile_url: str,\nfile_name: str,\nmime_type: str = \"text/plain\",\ndescription: str = \"\",\n) -&gt; dict | None:\n\"\"\"Fetch a file from a URL or local filesystem and upload it as a new document version.\n    Args:\n        node_id (int): ID of the document to add add version to\n        file_url (str): URL to download file or local file\n        file_name (str): name of the file\n        mime_type (str, optional): mimeType of the file (default = text/plain)\n        description (str, optional): description of the version (default = no description)\n    Returns:\n        dict: Add version response or None if the upload fails.\n    \"\"\"\nif file_url.startswith(\"http\"):\n# Download file from remote location specified by the fileUrl\n# this must be a public place without authentication:\nlogger.info(\"Download file from URL -&gt; %s\", file_url)\ntry:\nresponse = requests.get(\nurl=file_url,\ntimeout=None,\n)\nresponse.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn None\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn None\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn None\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn None\nlogger.info(\n\"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\nfile_url,\nresponse.status_code,\n)\nfile_content = response.content\nelif os.path.exists(file_url):\nlogger.info(\"Uploading local file -&gt; %s\", file_url)\nfile_content = open(file=file_url, mode=\"rb\")\nelse:\nlogger.warning(\"Cannot access -&gt; %s\", file_url)\nreturn None\nuploadPostData = {\"description\": description}\nuploadPostFiles = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/versions\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\nlogger.info(\n\"Uploading file -&gt; %s with mime type -&gt; %s as new version to document node with ID -&gt; %s; calling -&gt; %s\",\nfile_name,\nmime_type,\nnode_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=uploadPostData,\nfiles=uploadPostFiles,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add file -&gt; %s as new version to document with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_url,\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_external_system_connection","title":"<code>add_external_system_connection(connection_name, connection_type, as_url, base_url, username, password, authentication_method='BASIC', client_id=None, client_secret=None)</code>","text":"<p>Add Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).</p> <p>Parameters:</p> Name Type Description Default <code>connection_name</code> <code>str</code> <p>Name of the connection</p> required <code>connection_type</code> <code>str</code> <p>Type of the connection (HTTP, SF, SFInstance)</p> required <code>as_url</code> <code>str</code> <p>Application URL</p> required <code>base_url</code> <code>str</code> <p>Base URL</p> required <code>username</code> <code>str</code> <p>username (used for BASIC authentication)</p> required <code>password</code> <code>str</code> <p>password (used for BASIC authentication)</p> required <code>authentication_method</code> <code>str</code> <p>either BASIC (using username and password) or OAUTH</p> <code>'BASIC'</code> <code>client_id</code> <code>str</code> <p>OAUTH Client ID (only required if authenticationMethod = OAUTH)</p> <code>None</code> <code>client_secret</code> <code>str</code> <p>OAUTH Client Secret (only required if authenticationMethod = OAUTH)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>External system Details or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_external_system_connection(\nself,\nconnection_name: str,\nconnection_type: str,\nas_url: str,\nbase_url: str,\nusername: str,\npassword: str,\nauthentication_method: str = \"BASIC\",  # either BASIC or OAUTH\nclient_id: str = None,\nclient_secret: str = None,\n) -&gt; dict | None:\n\"\"\"Add Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n    Args:\n        connection_name (str): Name of the connection\n        connection_type (str): Type of the connection (HTTP, SF, SFInstance)\n        as_url (str): Application URL\n        base_url (str): Base URL\n        username (str): username (used for BASIC authentication)\n        password (str): password (used for BASIC authentication)\n        authentication_method: either BASIC (using username and password) or OAUTH\n        client_id: OAUTH Client ID (only required if authenticationMethod = OAUTH)\n        client_secret: OAUTH Client Secret (only required if authenticationMethod = OAUTH)\n    Returns:\n        dict: External system Details or None if the REST call fails.\n    \"\"\"\nexternalSystemPostBody = {\n\"external_system_name\": connection_name,\n\"conn_type\": connection_type,\n\"asurl\": as_url,\n\"baseurl\": base_url,\n\"username\": username,\n\"password\": password,\n}\nif authentication_method == \"OAUTH\" and client_id and client_secret:\nexternalSystemPostBody[\"authentication_method\"] = str(authentication_method)\nexternalSystemPostBody[\"client_id\"] = str(client_id)\nexternalSystemPostBody[\"client_secret\"] = str(client_secret)\nrequest_url = self.config()[\"externalSystem\"]\nrequest_header = self.cookie()\nlogger.info(\n\"Creating external system connection -&gt; %s of type -&gt; %s with URL -&gt; %s; calling -&gt; %s\",\nconnection_name,\nconnection_type,\nas_url,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=externalSystemPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\nconnection_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_favorite","title":"<code>add_favorite(node_id)</code>","text":"<p>Add a favorite for the current (authenticated) user.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the favorite creation has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_favorite(self, node_id: int) -&gt; dict | None:\n\"\"\"Add a favorite for the current (authenticated) user.\n    Args:\n        node_id (int): ID of the node.\n    Returns:\n        dict: Request response or None if the favorite creation has failed.\n    \"\"\"\nrequest_url = self.config()[\"favoritesUrl\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Adding favorite for node ID -&gt; %s; calling -&gt; %s\", node_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add favorite for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_group","title":"<code>add_group(name)</code>","text":"<p>Add Content Server group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the group</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Group information or None if the group couldn't be created (e.g. because it exisits already).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_group(self, name: str) -&gt; dict | None:\n\"\"\"Add Content Server group.\n    Args:\n        name (str): name of the group\n    Returns:\n        dict: Group information or None if the group couldn't be created (e.g. because it exisits already).\n    \"\"\"\ngroupPostBody = {\"type\": 1, \"name\": name}\nrequest_url = self.config()[\"membersUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Adding group -&gt; %s; calling -&gt; %s\", name, request_url)\nlogger.debug(\"Group Attributes -&gt; %s\", str(groupPostBody))\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=groupPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_group_member","title":"<code>add_group_member(member_id, group_id)</code>","text":"<p>Add a user or group to a target group.</p> <p>Parameters:</p> Name Type Description Default <code>member_id</code> <code>int</code> <p>ID of the user or group to add.</p> required <code>group_id</code> <code>int</code> <p>ID of the target group.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response or None if adding a the member fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_group_member(self, member_id: int, group_id: int) -&gt; dict | None:\n\"\"\"Add a user or group to a target group.\n    Args:\n        member_id (int): ID of the user or group to add.\n        group_id (int): ID of the target group.\n    Returns:\n        dict: Response or None if adding a the member fails.\n    \"\"\"\ngroupMemberPostBody = {\"member_id\": member_id}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/\" + str(group_id) + \"/members\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Adding member with ID -&gt; %s to group with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(group_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=groupMemberPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add member with ID -&gt; %s to group with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(member_id),\nstr(group_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_member_to_workspace","title":"<code>add_member_to_workspace(workspace_id, role_id, member_id, show_warning=True)</code>","text":"<p>Add member to a workspace role. Check that the user is not yet a member.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>role_id</code> <code>int</code> <p>ID of the role</p> required <code>member_id</code> <code>int</code> <p>User or Group Id</p> required <code>show_warning</code> <code>bool</code> <p>if True shows a warning if member is already in role</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Role Membership or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_member_to_workspace(\nself, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n) -&gt; dict | None:\n\"\"\"Add member to a workspace role. Check that the user is not yet a member.\n    Args:\n        workspace_id (int): ID of the workspace\n        role_id (int): ID of the role\n        member_id (int): User or Group Id\n        show_warning (bool, optional): if True shows a warning if member is already in role\n    Returns:\n        dict: Workspace Role Membership or None if the request fails.\n    \"\"\"\naddMemberToWorkspacePostData = {\"id\": str(member_id)}\nrequest_url = self.config()[\n\"businessworkspaces\"\n] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Check if user/group with ID -&gt; %s is already in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\nworkspace_members = self.parse_request_response(response)\nif self.exist_result_item(workspace_members, \"id\", member_id):\nif show_warning:\nlogger.warning(\n\"User/group with ID -&gt; %s is already a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\n)\nreturn workspace_members\nlogger.info(\n\"Add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=addMemberToWorkspacePostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\nelse:\nlogger.error(\n\"Failed to add user/group with ID -&gt; %s to role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_user","title":"<code>add_user(name, password, first_name, last_name, email, base_group, privileges=None)</code>","text":"<p>Add Content Server user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>login name of the user</p> required <code>password</code> <code>str</code> <p>password of the user</p> required <code>first_name</code> <code>str</code> <p>first name of the user</p> required <code>last_name</code> <code>str</code> <p>last name of the user</p> required <code>email</code> <code>str</code> <p>email address of the user</p> required <code>base_group</code> <code>int</code> <p>base group id of the user (e.g. department)</p> required <code>privileges</code> <code>list</code> <p>values are Login, Public Access, Content Manager,                          Modify Users, Modify Groups, User Admin Rights,                          Grant Discovery, System Admin Rights</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user couldn't be created (e.g. because it exisits already).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_user(\nself,\nname: str,\npassword: str,\nfirst_name: str,\nlast_name: str,\nemail: str,\nbase_group: int,\nprivileges: list | None = None,\n) -&gt; dict | None:\n\"\"\"Add Content Server user.\n    Args:\n        name (str): login name of the user\n        password (str): password of the user\n        first_name (str): first name of the user\n        last_name (str): last name of the user\n        email (str): email address of the user\n        base_group (int): base group id of the user (e.g. department)\n        privileges (list, optional): values are Login, Public Access, Content Manager,\n                                     Modify Users, Modify Groups, User Admin Rights,\n                                     Grant Discovery, System Admin Rights\n    Returns:\n        dict: User information or None if the user couldn't be created (e.g. because it exisits already).\n    \"\"\"\nif privileges is None:\nprivileges = [\"Login\", \"Public Access\"]\nuserPostBody = {\n\"type\": 0,\n\"name\": name,\n\"password\": password,\n\"first_name\": first_name,\n\"last_name\": last_name,\n\"business_email\": email,\n\"group_id\": base_group,\n\"privilege_login\": (\"Login\" in privileges),\n\"privilege_public_access\": (\"Public Access\" in privileges),\n\"privilege_content_manager\": (\"Content Manager\" in privileges),\n\"privilege_modify_users\": (\"Modify Users\" in privileges),\n\"privilege_modify_groups\": (\"Modify Groups\" in privileges),\n\"privilege_user_admin_rights\": (\"User Admin Rights\" in privileges),\n\"privilege_grant_discovery\": (\"Grant Discovery\" in privileges),\n\"privilege_system_admin_rights\": (\"System Admin Rights\" in privileges),\n}\nrequest_url = self.config()[\"membersUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Adding user -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=userPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.add_user_proxy","title":"<code>add_user_proxy(proxy_user_id, from_date=None, to_date=None)</code>","text":"<p>Add a user as a proxy user to the current user.    IMPORTANT: This method needs to be called as the user the proxy is acting for.    Optional this method can be provided with a time span the proxy should be active.    This method differentiates between the old (xGov) based    implementation and the new Extended ECM platform one    that was introduced with version 23.4.</p> <p>Example payload for proxy user 19340 without time span:    {\"id\":2545, \"from_date\": None, \"to_date\": None}</p> <p>Example payload for proxy user 19340 with time span:    {\"id\":2545, \"from_date\":\"2023-03-15\", \"to_date\":\"2023-03-31\"}</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>from_date</code> <code>str</code> <p>start date for proxy (format YYYY-MM-DD)</p> <code>None</code> <code>to_date</code> <code>str</code> <p>end date for proxy (format YYYY-MM-DD)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def add_user_proxy(\nself,\nproxy_user_id: int,\nfrom_date: str = None,\nto_date: str = None,\n) -&gt; dict | None:\n\"\"\"Add a user as a proxy user to the current user.\n       IMPORTANT: This method needs to be called as the user the proxy is acting for.\n       Optional this method can be provided with a time span the proxy should be active.\n       This method differentiates between the old (xGov) based\n       implementation and the new Extended ECM platform one\n       that was introduced with version 23.4.\n       Example payload for proxy user 19340 without time span:\n       {\"id\":2545, \"from_date\": None, \"to_date\": None}\n       Example payload for proxy user 19340 with time span:\n       {\"id\":2545, \"from_date\":\"2023-03-15\", \"to_date\":\"2023-03-31\"}\n    Args:\n        user_id (int): ID of the user\n        from_date (str, optional): start date for proxy (format YYYY-MM-DD)\n        to_date (str, optional): end date for proxy (format YYYY-MM-DD)\n    Returns:\n        dict: Request response or None if call fails.\n    \"\"\"\nversion_number = self.get_server_version()\n# Split the version number by dot\nparts = version_number.split(\".\")\n# Take the first two parts and join them back with a dot\nstripped_version = \".\".join(parts[:2])\nversion_number = float(stripped_version)\n# for versions older than 23.4 we need to use\n# the egacy Extended ECM for Government Proxy\n# implementation:\nif version_number &gt;= 23.4:\npost_dict = {}\npost_dict[\"id\"] = proxy_user_id\npost_dict[\"from_date\"] = from_date\npost_dict[\"to_date\"] = to_date\npost_data = {\"body\": json.dumps(post_dict)}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\nlogger.info(\n\"Assign proxy user with ID -&gt; %s to current user; calling -&gt; %s\",\nproxy_user_id,\nrequest_url,\n)\nelse:\npost_dict = {}\nif from_date and to_date:\npost_dict[\"from_date\"] = from_date\npost_dict[\"to_date\"] = to_date\npost_dict = {str(proxy_user_id): post_dict}\npost_data = {\"add_proxy\": json.dumps(post_dict)}\nrequest_url = self.config()[\"membersUrl\"] + \"/proxies\"\nlogger.info(\n\"Assign proxy user with ID -&gt; %s to current user (legacy xGov); calling -&gt; %s\",\nproxy_user_id,\nrequest_url,\n)\nrequest_header = self.request_form_header()\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.post(\nurl=request_url,\ndata=post_data,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign proxy user with ID -&gt; %s to current user; status -&gt; %s; error -&gt; %s\",\nproxy_user_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.apply_config","title":"<code>apply_config(xml_file_path)</code>","text":"<p>Apply Content Server administration settings from XML file</p> <p>Parameters:</p> Name Type Description Default <code>xml_file_path</code> <code>str</code> <p>name + path of the XML settings file</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Import response or None if the import fails.         response\"results\"[\"restart\"] indicates if the settings         require a restart of the OTCS services.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def apply_config(self, xml_file_path: str) -&gt; dict | None:\n\"\"\"Apply Content Server administration settings from XML file\n    Args:\n        xml_file_path (str): name + path of the XML settings file\n    Returns:\n        dict: Import response or None if the import fails.\n                    response[\"results\"][\"data\"][\"restart\"] indicates if the settings\n                    require a restart of the OTCS services.\n    \"\"\"\nfilename = os.path.basename(xml_file_path)\nif not os.path.exists(xml_file_path):\nlogger.error(\n\"The admin settings file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(xml_file_path),\n)\nreturn None\nllconfig_file = {\n\"file\": (filename, open(file=xml_file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nrequest_url = self.config()[\"importSettingsUrl\"]\nrequest_header = self._cookie\nlogger.info(\n\"Applying admin settings from file -&gt; %s; calling -&gt; %s\",\nxml_file_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=llconfig_file,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.debug(\n\"Admin settings in file -&gt; %s have been applied\", xml_file_path\n)\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import settings file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nxml_file_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_category","title":"<code>assign_category(node_id, category_id, inheritance=False, apply_to_sub_items=False, apply_action='add_upgrade', add_version=False, clear_existing_categories=False)</code>","text":"<p>Assign a category to a node. Optionally turn on inheritance and apply    category to sub-items (if node_id is a container / folder / workspace).    If the category is already assigned to the node this method will    throw an error.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID to apply the category to</p> required <code>category_id</code> <code>list</code> <p>ID of the category definition object</p> required <code>inheritance</code> <code>bool</code> <p>turn on inheritance for the category                    (this makes only sense if the node is a container like a folder or workspace)</p> <code>False</code> <code>apply_to_sub_items</code> <code>bool</code> <p>if True the category is applied to                                     the item and all its sub-items                                     if False the category is only applied                                     to the item</p> <code>False</code> <code>apply_action</code> <code>str</code> <p>supported values are \"add\", \"add_upgrade\", \"upgrade\", \"replace\", \"delete\", \"none\", None</p> <code>'add_upgrade'</code> <code>add_version</code> <code>bool</code> <p>if a document version should be added for the category change (default = False)</p> <code>False</code> <code>clear_existing_categories</code> <code>bool</code> <p>whether or not existing (other) categories should be removed (default = False)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True = success, False = error</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_category(\nself,\nnode_id: int,\ncategory_id: list,\ninheritance: bool = False,\napply_to_sub_items: bool = False,\napply_action: str = \"add_upgrade\",\nadd_version: bool = False,\nclear_existing_categories: bool = False,\n) -&gt; bool:\n\"\"\"Assign a category to a node. Optionally turn on inheritance and apply\n       category to sub-items (if node_id is a container / folder / workspace).\n       If the category is already assigned to the node this method will\n       throw an error.\n    Args:\n        node_id (int): node ID to apply the category to\n        category_id (list): ID of the category definition object\n        inheritance (bool): turn on inheritance for the category\n                               (this makes only sense if the node is a container like a folder or workspace)\n        apply_to_sub_items (bool, optional): if True the category is applied to\n                                                the item and all its sub-items\n                                                if False the category is only applied\n                                                to the item\n        apply_action (str, optional): supported values are \"add\", \"add_upgrade\", \"upgrade\", \"replace\", \"delete\", \"none\", None\n        add_version (bool, optional): if a document version should be added for the category change (default = False)\n        clear_existing_categories (bool, optional): whether or not existing (other) categories should be removed (default = False)\n    Returns:\n        bool: True = success, False = error\n    \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\nrequest_header = self.request_form_header()\n#\n# 1. Assign Category to Node if not yet assigned:\n#\nexisting_category_ids = self.get_node_category_ids(node_id)\nif not category_id in existing_category_ids:\nlogger.info(\n\"Category with ID -&gt; %s is not yet assigned to node ID -&gt; %s. Assigning it now...\",\nstr(category_id),\nstr(node_id),\n)\ncategoryPostData = {\n\"category_id\": category_id,\n}\nlogger.info(\n\"Assign category with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\nstr(category_id),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=categoryPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign category with ID -&gt; %s to node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\n#\n# 2. Set Inheritance\n#\nrequest_url_inheritance = request_url + \"/\" + str(category_id) + \"/inheritance\"\nretries = 0\nwhile True:\nif inheritance:\n# Enable inheritance\nresponse = requests.post(\nurl=request_url_inheritance,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nelse:\n# Disable inheritance\nresponse = requests.delete(\nurl=request_url_inheritance,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set inheritance for category with ID -&gt; %s on node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\n#\n# 3. Apply to sub-items\n#\nif apply_to_sub_items:\nrequest_url_apply_sub_items = request_url + \"/apply\"\ncategoryPostData = {\n\"categories\": [{\"id\": category_id, \"action\": apply_action}],\n\"add_version\": add_version,\n\"clear_existing_categories\": clear_existing_categories,\n}\nretries = 0\nwhile True:\n# we need to wrap the body of this POST call into a \"body\"\n# tag. This is documented worngly on developer.opentext.com\nresponse = requests.post(\nurl=request_url_apply_sub_items,\ndata={\"body\": json.dumps(categoryPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to apply category with ID -&gt; %s to sub-items of node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_classification","title":"<code>assign_classification(node_id, classifications, apply_to_sub_items=False)</code>","text":"<p>Assign one or multiple classifications to an Extended ECM item</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the Extended ECM item</p> required <code>classifications</code> <code>list</code> <p>list of classification item IDs</p> required <code>apply_to_sub_items</code> <code>bool</code> <p>if True the classification is applied to                                     the item and all its sub-items                                     if False the classification is only applied                                     to the item</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of the request or None if the assignment of the classification has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_classification(\nself, node_id: int, classifications: list, apply_to_sub_items: bool = False\n) -&gt; dict | None:\n\"\"\"Assign one or multiple classifications to an Extended ECM item\n    Args:\n        node_id (int): node ID of the Extended ECM item\n        classifications (list): list of classification item IDs\n        apply_to_sub_items (bool, optional): if True the classification is applied to\n                                                the item and all its sub-items\n                                                if False the classification is only applied\n                                                to the item\n    Returns:\n        dict: Response of the request or None if the assignment of the classification has failed.\n    \"\"\"\n# the REST API expects a list of dict elements with \"id\" and the actual IDs\nclassification_list = []\nfor classification in classifications:\nclassification_list.append({\"id\": classification})\nclassificationPostData = {\n\"class_id\": classification_list,\n\"apply_to_sub_items\": apply_to_sub_items,\n}\nrequest_url = (\nself.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/classifications\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign classifications with IDs -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\nstr(classifications),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=classificationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign classifications with IDs -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(classifications),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_item_to_user_group","title":"<code>assign_item_to_user_group(node_id, subject, instruction, assignees)</code>","text":"<p>Assign an Extended ECM item to users and groups. This is a function used by    Extended ECM for Government.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the Extended ECM item (e.g. a workspace or a document)</p> required <code>subject</code> <code>str</code> <p>title / subject of the assignment</p> required <code>instructions</code> <code>str</code> <p>more detailed description or instructions for the assignment</p> required <code>assignees</code> <code>list</code> <p>list of IDs of users or groups</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of the request or None if the assignment has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_item_to_user_group(\nself, node_id: int, subject: str, instruction: str, assignees: list\n) -&gt; dict | None:\n\"\"\"Assign an Extended ECM item to users and groups. This is a function used by\n       Extended ECM for Government.\n    Args:\n        node_id (int): node ID of the Extended ECM item (e.g. a workspace or a document)\n        subject (str): title / subject of the assignment\n        instructions (str): more detailed description or instructions for the assignment\n        assignees (list): list of IDs of users or groups\n    Returns:\n        dict: Response of the request or None if the assignment has failed.\n    \"\"\"\nassignmentPostData = {\n\"subject\": subject,\n\"instruction\": instruction,\n\"assignees\": assignees,\n}\nrequest_url = (\nself.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/xgovassignments\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); calling -&gt; %s\",\nstr(node_id),\nstr(assignees),\nsubject,\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"add_assignment\" tag.\nresponse = requests.post(\nurl=request_url,\ndata={\"add_assignment\": json.dumps(assignmentPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign item with ID -&gt; %s to assignees -&gt; %s (subject -&gt; %s); status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nstr(assignees),\nsubject,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_permission","title":"<code>assign_permission(node_id, assignee_type, assignee, permissions, apply_to=0)</code>","text":"<p>Assign permissions for Extended ECM item to a user or group.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the Extended ECM item</p> required <code>assignee_type</code> <code>str</code> <p>this can be either \"owner\", \"group\" (for owner group),                     \"public\", or \"custom\" (assigned access)</p> required <code>assignee</code> <code>int</code> <p>ID of user or group (\"right ID\"). If 0 and assigneeType                 is \"owner\" or \"group\" then it is assumed that the owner and                 owner group should not be changed.</p> required <code>permissions</code> <code>list</code> <p>list of permissions - potential elements:                 \"see\"                 \"see_contents\"                 \"modify\"                 \"edit_attributes\"                 \"add_items\"                 \"reserve\"                 \"add_major_version\"                 \"delete_versions\"                 \"delete\"                 \"edit_permissions\"</p> required <code>apply_to</code> <code>int</code> <p>elements to apply permissions to - potential values:                  0 = this item (default)                  1 = sub-items                  2 = This item and sub-items                  3 = This item and immediate sub-items</p> <code>0</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of the request or None if the assignment of permissions has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_permission(\nself,\nnode_id: int,\nassignee_type: str,\nassignee: int,\npermissions: list,\napply_to: int = 0,\n) -&gt; dict | None:\n\"\"\"Assign permissions for Extended ECM item to a user or group.\n    Args:\n        node_id (int): node ID of the Extended ECM item\n        assignee_type (str): this can be either \"owner\", \"group\" (for owner group),\n                                \"public\", or \"custom\" (assigned access)\n        assignee (int): ID of user or group (\"right ID\"). If 0 and assigneeType\n                            is \"owner\" or \"group\" then it is assumed that the owner and\n                            owner group should not be changed.\n        permissions (list): list of permissions - potential elements:\n                            \"see\"\n                            \"see_contents\"\n                            \"modify\"\n                            \"edit_attributes\"\n                            \"add_items\"\n                            \"reserve\"\n                            \"add_major_version\"\n                            \"delete_versions\"\n                            \"delete\"\n                            \"edit_permissions\"\n        apply_to (int, optional): elements to apply permissions to - potential values:\n                             0 = this item (default)\n                             1 = sub-items\n                             2 = This item and sub-items\n                             3 = This item and immediate sub-items\n    Returns:\n        dict: Response of the request or None if the assignment of permissions has failed.\n    \"\"\"\nif not assignee_type or not assignee_type in [\n\"owner\",\n\"group\",\n\"public\",\n\"custom\",\n]:\nlogger.error(\n\"Missing or wrong assignee type. Needs to be owner, group, public or custom!\"\n)\nreturn None\nif assignee_type == \"custom\" and not assignee:\nlogger.error(\"Missing permission assignee!\")\nreturn None\npermissionPostData = {\n\"permissions\": permissions,\n\"apply_to\": apply_to,\n}\n# Assignees can be specified for owner and group and must be specified for custom:\n#\nif assignee:\npermissionPostData[\"right_id\"] = assignee\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/permissions/\"\n+ assignee_type\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign permissions -&gt; %s to item with ID -&gt; %s; assignee type -&gt; %s; calling -&gt; %s\",\nstr(permissions),\nstr(node_id),\nassignee_type,\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nif assignee_type == \"custom\":\n# Custom also has a REST POST - we prefer this one as to\n# also allows to add a new assigned permission (user or group):\nresponse = requests.post(\nurl=request_url,\ndata={\"body\": json.dumps(permissionPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nelse:\n# Owner, Owner Group and Public require REST PUT:\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(permissionPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign permissions -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(permissions),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_rm_classification","title":"<code>assign_rm_classification(node_id, rm_classification, apply_to_sub_items=False)</code>","text":"<p>Assign a RM classification to an Extended ECM item</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the Extended ECM item</p> required <code>rm_classification</code> <code>int</code> <p>Records Management classification ID</p> required <code>apply_to_sub_items</code> <code>bool</code> <p>if True the RM classification is applied to                                     the item and all its sub-items                                     if False the RM classification is only applied                                     to the item</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of the request or None if the assignment of the RM classification has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_rm_classification(\nself, node_id: int, rm_classification: int, apply_to_sub_items: bool = False\n) -&gt; dict | None:\n\"\"\"Assign a RM classification to an Extended ECM item\n    Args:\n        node_id (int): node ID of the Extended ECM item\n        rm_classification (int): Records Management classification ID\n        apply_to_sub_items (bool, optional): if True the RM classification is applied to\n                                                the item and all its sub-items\n                                                if False the RM classification is only applied\n                                                to the item\n    Returns:\n        dict: Response of the request or None if the assignment of the RM classification has failed.\n    \"\"\"\nrmClassificationPostData = {\n\"class_id\": rm_classification,\n\"apply_to_sub_items\": apply_to_sub_items,\n}\nrequest_url = (\nself.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/rmclassifications\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; calling -&gt; %s\",\nstr(rm_classification),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=rmClassificationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign RM classifications with ID -&gt; %s to item with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(rm_classification),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_user_security_clearance","title":"<code>assign_user_security_clearance(user_id, security_clearance)</code>","text":"<p>Assign a Security Clearance level to an Extended ECM user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>security_clearance</code> <code>int</code> <p>security clearance level to be set</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>REST response or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_user_security_clearance(\nself, user_id: int, security_clearance: int\n) -&gt; dict | None:\n\"\"\"Assign a Security Clearance level to an Extended ECM user\n    Args:\n        user_id (int): ID of the user\n        security_clearance (int): security clearance level to be set\n    Returns:\n        dict: REST response or None if the REST call fails.\n    \"\"\"\nassignUserSecurityClearancePostData = {\n\"securityLevel\": security_clearance,\n}\nrequest_url = self.config()[\n\"userSecurityUrl\"\n] + \"/{}/securityclearancelevel\".format(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign security clearance -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\nstr(security_clearance),\nstr(user_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=assignUserSecurityClearancePostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign security clearance -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(security_clearance),\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_user_supplemental_markings","title":"<code>assign_user_supplemental_markings(user_id, supplemental_markings)</code>","text":"<p>Assign a list of Supplemental Markings to a user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>supplemental_markings</code> <code>list of strings</code> <p>list of Supplemental Markings to be set</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>REST response or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_user_supplemental_markings(\nself, user_id: int, supplemental_markings: list\n) -&gt; dict | None:\n\"\"\"Assign a list of Supplemental Markings to a user\n    Args:\n        user_id (int): ID of the user\n        supplemental_markings (list of strings): list of Supplemental Markings to be set\n    Returns:\n        dict: REST response or None if the REST call fails.\n    \"\"\"\nassignUserSupplementalMarkingsPostData = {\n\"suppMarks\": supplemental_markings,\n}\nrequest_url = self.config()[\n\"userSecurityUrl\"\n] + \"/{}/supplementalmarkings\".format(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Assign supplemental markings -&gt; %s to user with ID -&gt; %s; calling -&gt; %s\",\nstr(supplemental_markings),\nstr(user_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=assignUserSupplementalMarkingsPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to assign supplemental markings -&gt; %s to user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(supplemental_markings),\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.assign_workspace_permissions","title":"<code>assign_workspace_permissions(workspace_id, role_id, permissions, apply_to=2)</code>","text":"<p>Update permissions of a workspace role</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>role_id</code> <code>int</code> <p>ID of the role</p> required <code>permissions</code> <code>list</code> <p>list of permissions - potential elements:                 \"see\"                 \"see_contents\"                 \"modify\"                 \"edit_attributes\"                 \"add_items\"                 \"reserve\"                 \"add_major_version\"                 \"delete_versions\"                 \"delete\"                 \"edit_permissions\"</p> required <code>apply_to</code> <code>int</code> <p>0 = this item                  1 = sub-items                  2 = This item and sub-items (default)                  3 = This item and immediate sub-items</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Role Membership or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def assign_workspace_permissions(\nself, workspace_id: int, role_id: int, permissions: list, apply_to: int = 2\n) -&gt; dict | None:\n\"\"\"Update permissions of a workspace role\n    Args:\n        workspace_id (int): ID of the workspace\n        role_id (int): ID of the role\n        permissions (list): list of permissions - potential elements:\n                            \"see\"\n                            \"see_contents\"\n                            \"modify\"\n                            \"edit_attributes\"\n                            \"add_items\"\n                            \"reserve\"\n                            \"add_major_version\"\n                            \"delete_versions\"\n                            \"delete\"\n                            \"edit_permissions\"\n        apply_to (int):  0 = this item\n                             1 = sub-items\n                             2 = This item and sub-items (default)\n                             3 = This item and immediate sub-items\n    Returns:\n        dict: Workspace Role Membership or None if the request fails.\n    \"\"\"\nrequest_url = self.config()[\"businessworkspaces\"] + \"/{}/roles/{}\".format(\nworkspace_id, role_id\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Updating Permissions of role with ID -&gt; %s of workspace with ID -&gt; %s with permissions -&gt; %s; calling -&gt; %s\",\nstr(role_id),\nstr(workspace_id),\nstr(permissions),\nrequest_url,\n)\npermissionPostData = {\n\"permissions\": permissions,\n\"apply_to\": apply_to,\n}\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\nheaders=request_header,\ndata={\"body\": json.dumps(permissionPostData)},\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update permissions for role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(role_id),\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.authenticate","title":"<code>authenticate(revalidate=False, force_user_password_login=False)</code>","text":"<p>Authenticates at Content Server and retrieve OTCS Ticket.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determinse if a re-athentication is enforced                (e.g. if session has timed out with 401 error)</p> <code>False</code> <code>force_user_password_login</code> <code>bool</code> <p>By default we use the OTDS ticket (if exists) for the authentication with OTCS.                               This switch allows the forced usage of username / password for the authentication.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Cookie information of None in case of an error.         Also stores cookie information in self._cookie</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def authenticate(\nself, revalidate: bool = False, force_user_password_login: bool = False\n) -&gt; dict | None:\n\"\"\"Authenticates at Content Server and retrieve OTCS Ticket.\n    Args:\n        revalidate (bool): determinse if a re-athentication is enforced\n                           (e.g. if session has timed out with 401 error)\n        force_user_password_login (bool): By default we use the OTDS ticket (if exists) for the authentication with OTCS.\n                                          This switch allows the forced usage of username / password for the authentication.\n    Returns:\n        dict: Cookie information of None in case of an error.\n                    Also stores cookie information in self._cookie\n    \"\"\"\n# Already authenticated and session still valid?\nif self._cookie and not revalidate:\nreturn self._cookie\notcs_ticket = None\nlogger.info(\"Wait for OTCS to be ready...\")\nwhile not self.is_ready():\nlogger.warning(\n\"OTCS is not ready to receive requests yet. Waiting 30 seconds...\"\n)\ntime.sleep(30)\nrequest_url = self.config()[\"authenticationUrl\"]\nif self._otds_ticket and not force_user_password_login:\nlogger.info(\n\"Requesting OTCS ticket with OTDS ticket; calling -&gt; %s\",\nrequest_url,\n)\nrequest_header = {\n\"Content-Type\": \"application/x-www-form-urlencoded\",\n\"Accept\": \"application/json\",\n\"OTDSTicket\": self._otds_ticket,\n}\ntry:\nresponse = requests.get(\nurl=request_url, headers=request_header, timeout=10\n)\nif response.ok:\notcs_ticket = response.headers.get(\"OTCSTicket\")\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; error -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\n# Check if previous authentication was successful\nif not otcs_ticket:\nlogger.info(\n\"Requesting OTCS ticket with User/Password; calling -&gt; %s\",\nrequest_url,\n)\nresponse = None\ntry:\nresponse = requests.post(\nurl=request_url,\ndata=self.credentials(),  # this includes username + password\nheaders=REQUEST_FORM_HEADERS,\ntimeout=REQUEST_TIMEOUT,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; error -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\nlogger.warning(\"OTCS service may not be ready yet.\")\nreturn None\nif response.ok:\nauthenticate_dict = self.parse_request_response(\nresponse, \"This can be normal during restart\", False\n)\nif not authenticate_dict:\nreturn None\nelse:\notcs_ticket = authenticate_dict[\"ticket\"]\nlogger.info(\"Ticket -&gt; %s\", otcs_ticket)\nelse:\nlogger.error(\n\"Failed to request an OTCS ticket; error -&gt; %s\", response.text\n)\nreturn None\n# Store authentication ticket:\nself._cookie = {\"otcsticket\": otcs_ticket, \"LLCookie\": otcs_ticket}\nself._otcs_ticket = otcs_ticket\nreturn self._cookie\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.base_url","title":"<code>base_url()</code>","text":"<p>Returns the base URL of Extended ECM</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>base URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def base_url(self) -&gt; str:\n\"\"\"Returns the base URL of Extended ECM\n    Returns:\n        str: base URL\n    \"\"\"\nreturn self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.check_node_name","title":"<code>check_node_name(parent_id, node_name)</code>","text":"<p>Get Volume information based on the volume type ID.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>int</code> <p>ID of the parent location</p> required <code>node_name</code> <code>str</code> <p>name of the new node</p> required Source code in <code>pyxecm/otcs.py</code> <pre><code>def check_node_name(self, parent_id: int, node_name: str) -&gt; dict | None:\n\"\"\"Get Volume information based on the volume type ID.\n    Args:\n        parent_id (int): ID of the parent location\n        node_name (str): name of the new node\n    Returns:\n    \"\"\"\nrequest_url = self.config()[\"validationUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Check if node with name -&gt; %s can be created in parent with ID -&gt; %s; calling -&gt; %s\",\nnode_name,\nstr(parent_id),\nrequest_url,\n)\ncheckNodeNamePostData = {\"parent_id\": parent_id, \"names\": [node_name]}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata={\"body\": json.dumps(checkNodeNamePostData)},\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to check if node name -&gt; %s can be created in parent with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnode_name,\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.check_workspace_aviator","title":"<code>check_workspace_aviator(workspace_id)</code>","text":"<p>Check if Content Aviator is enabled for a workspace</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>node ID of the workspace</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if aviator is enabled, False otherwise</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def check_workspace_aviator(\nself,\nworkspace_id: int,\n) -&gt; bool:\n\"\"\"Check if Content Aviator is enabled for a workspace\n    Args:\n        workspace_id (int): node ID of the workspace\n    Returns:\n        bool: True if aviator is enabled, False otherwise\n    \"\"\"\nresponse = self.get_node_actions(\nnode_id=workspace_id, filter_actions=[\"disableai\", \"enableai\"]\n)\nresult_data = self.get_result_value(\nresponse=response,\nkey=str(workspace_id),\n)\nif result_data and \"data\" in result_data:\ndata = result_data[\"data\"]\nif \"disableai\" in data:\nlogger.info(\n\"Aviator is enabled for workspace with ID -&gt; %s\", str(workspace_id)\n)\nreturn True\nelif \"enableai\" in data:\nlogger.info(\n\"Aviator is disabled for workspace with ID -&gt; %s\", str(workspace_id)\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.convert_permission_string_to_permission_value","title":"<code>convert_permission_string_to_permission_value(permissions)</code>","text":"<p>Converts a list of permission names (strongs) to a bit-mask.</p> <p>Parameters:</p> Name Type Description Default <code>permissions</code> <code>list</code> <p>List of permission names - see conversion variable below.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>bit-encoded permission value</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def convert_permission_string_to_permission_value(self, permissions: list) -&gt; int:\n\"\"\"Converts a list of permission names (strongs) to a bit-mask.\n    Args:\n        permissions (list): List of permission names - see conversion variable below.\n    Returns:\n        int: bit-encoded permission value\n    \"\"\"\nconversion = {\n\"see\": 130,  # Bits 2 and 8\n\"see_contents\": 36865,  # Bit 17\n\"modify\": 65536,  # Bit 18\n\"edit_attributes\": 131072,  # Bit 19\n\"add_items\": 4,  # Bit 3\n\"reserve\": 8192,  # Bit 14\n\"add_major_version\": 4194304,  # Bit 23\n\"delete_versions\": 16384,  # Bit 15\n\"delete\": 8,  # Bit 4\n\"edit_permissions\": 16,  # Bit 5\n}\npermission_value = 0\nfor permission in permissions:\nif not conversion.get(permission):\nlogger.error(\"Illegal permission value -&gt; %s\", str(permission))\nreturn 0\npermission_value += conversion[permission]\nreturn permission_value\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.convert_permission_value_to_permission_string","title":"<code>convert_permission_value_to_permission_string(permission_value)</code>","text":"<p>Converts a bit-encoded permission value to a list of permission names (strings).</p> <p>Parameters:</p> Name Type Description Default <code>permission_value</code> <code>int</code> <p>bit-encoded permission value</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of permission names</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def convert_permission_value_to_permission_string(\nself, permission_value: int\n) -&gt; list:\n\"\"\"Converts a bit-encoded permission value to a list of permission names (strings).\n    Args:\n        permission_value (int): bit-encoded permission value\n    Returns:\n        list: list of permission names\n    \"\"\"\nconversion = {\n\"see\": 130,  # Bits 2 and 8\n\"see_contents\": 36865,  # Bit 17\n\"modify\": 65536,  # Bit 18\n\"edit_attributes\": 131072,  # Bit 19\n\"add_items\": 4,  # Bit 3\n\"reserve\": 8192,  # Bit 14\n\"add_major_version\": 4194304,  # Bit 23\n\"delete_versions\": 16384,  # Bit 15\n\"delete\": 8,  # Bit 4\n\"edit_permissions\": 16,  # Bit 5\n}\npermissions = []\nfor key, value in conversion.items():\nif permission_value &amp; value:  # binary and\npermissions.append(key)\nreturn permissions\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cookie","title":"<code>cookie()</code>","text":"<p>Returns the login cookie of Extended ECM.    This is set by the authenticate() method</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Estended ECM cookie</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cookie(self) -&gt; dict:\n\"\"\"Returns the login cookie of Extended ECM.\n       This is set by the authenticate() method\n    Returns:\n        dict: Estended ECM cookie\n    \"\"\"\nreturn self._cookie\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_document_from_template","title":"<code>create_document_from_template(template_id, parent_id, classification_id, category_data, doc_name, doc_desciption='')</code>","text":"<p>Create a document based on a document template</p> <p>Parameters:</p> Name Type Description Default <code>template_id</code> <code>int</code> <p>node ID of the document template</p> required <code>parent_id</code> <code>int</code> <p>node ID of the target location (parent)</p> required <code>classification_id</code> <code>int</code> <p>node ID of the classification</p> required <code>category_data</code> <code>dict</code> <p>metadata / category data                     Example: category ID = 12508                     {                         \"12508\": {                             \"12508_2\": \"Draft\",         # Text drop-down                             \"12508_3\": 8559,            # user ID                             \"12508_4\": \"2023-05-10\",    # date                             \"12508_6\": 7357,            # user ID                             \"12508_7\": \"2023-05-11\",    # date                             \"12508_5\": True,            # checkbox / bool                             \"12508_8\": \"EN\",            # text drop-down                             \"12508_9\": \"MS Word\",       # text drop-down                         }                     }</p> required <code>doc_name</code> <code>str</code> <p>name of the item</p> required <code>doc_description</code> <code>str</code> <p>description of the item</p> required Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_document_from_template(\nself,\ntemplate_id: int,\nparent_id: int,\nclassification_id: int,\ncategory_data: dict,\ndoc_name: str,\ndoc_desciption: str = \"\",\n) -&gt; dict | None:\n\"\"\"Create a document based on a document template\n    Args:\n        template_id (int): node ID of the document template\n        parent_id (int): node ID of the target location (parent)\n        classification_id (int): node ID of the classification\n        category_data (dict): metadata / category data\n                                Example: category ID = 12508\n                                {\n                                    \"12508\": {\n                                        \"12508_2\": \"Draft\",         # Text drop-down\n                                        \"12508_3\": 8559,            # user ID\n                                        \"12508_4\": \"2023-05-10\",    # date\n                                        \"12508_6\": 7357,            # user ID\n                                        \"12508_7\": \"2023-05-11\",    # date\n                                        \"12508_5\": True,            # checkbox / bool\n                                        \"12508_8\": \"EN\",            # text drop-down\n                                        \"12508_9\": \"MS Word\",       # text drop-down\n                                    }\n                                }\n        doc_name (str): name of the item\n        doc_description (str, optional): description of the item\n    \"\"\"\ncreateDocumentPostData = {\n\"template_id\": template_id,\n\"parent_id\": parent_id,\n\"name\": doc_name,\n\"description\": doc_desciption,\n\"type\": 144,\n\"roles\": {\n\"categories\": category_data,\n\"classifications\": {\"create_id\": [classification_id], \"id\": []},\n},\n}\nrequest_url = self.config()[\"doctemplatesUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create document -&gt; %s from template with ID -&gt; %s in target location -&gt; %s (parent ID) with classification ID -&gt; %s; calling -&gt; %s\",\ndoc_name,\nstr(template_id),\nstr(parent_id),\nstr(classification_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.post(\nurl=request_url,\n# this seems to only work with a \"body\" tag and is different form the documentation\n# on developer.opentext.com\ndata={\"body\": json.dumps(createDocumentPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create document -&gt; %s; status -&gt; %s; error -&gt; %s\",\ndoc_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_item","title":"<code>create_item(parent_id, item_type, item_name, item_description='', url='', original_id=0)</code>","text":"<p>Create an Extended ECM item. This REST call is somewhat limited. It cannot set favortie (featured item) or hidden item.    It does also not accept owner group information.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>int</code> <p>node ID of the parent</p> required <code>item_type</code> <code>str</code> <p>type of the item (e.g. 0 = foler, 140 = URL)</p> required <code>item_name</code> <code>str</code> <p>name of the item</p> required <code>item_description</code> <code>str</code> <p>description of the item</p> <code>''</code> <code>url</code> <code>str</code> <p>address of the URL item (if it is an URL item type)</p> <code>''</code> <code>original_id</code> <code>int</code> <p>required if a shortcut item is created</p> <code>0</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response of the create item call or None if the REST call has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_item(\nself,\nparent_id: int,\nitem_type: str,\nitem_name: str,\nitem_description: str = \"\",\nurl: str = \"\",\noriginal_id: int = 0,\n) -&gt; dict | None:\n\"\"\"Create an Extended ECM item. This REST call is somewhat limited. It cannot set favortie (featured item) or hidden item.\n       It does also not accept owner group information.\n    Args:\n        parent_id (int): node ID of the parent\n        item_type (str): type of the item (e.g. 0 = foler, 140 = URL)\n        item_name (str): name of the item\n        item_description (str, optional): description of the item\n        url (str, optional): address of the URL item (if it is an URL item type)\n        original_id (int, optional): required if a shortcut item is created\n    Returns:\n        dict: Request response of the create item call or None if the REST call has failed.\n    \"\"\"\ncreateItemPostData = {\n\"parent_id\": parent_id,\n\"type\": item_type,\n\"name\": item_name,\n\"description\": item_description,\n}\nif url:\ncreateItemPostData[\"url\"] = url\nif original_id &gt; 0:\ncreateItemPostData[\"original_id\"] = original_id\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create item -&gt; %s (type -&gt; %s) under parent with ID -&gt; %s; calling -&gt; %s\",\nitem_name,\nitem_type,\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.post(\nurl=request_url,\ndata={\"body\": json.dumps(createItemPostData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create item -&gt; %s; status -&gt; %s; error -&gt; %s\",\nitem_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_records_management_hold","title":"<code>create_records_management_hold(hold_type, name, comment, alternate_id='', parent_id=0, date_applied='', date_to_remove='')</code>","text":"<p>Create a new Records Management Hold.</p> <p>Parameters:</p> Name Type Description Default <code>hold_type</code> <code>str</code> <p>type of the Hold</p> required <code>name</code> <code>str</code> <p>name of the RSI</p> required <code>comment</code> <code>str</code> <p>comment</p> required <code>alternate_id</code> <code>str</code> <p>alternate hold ID</p> <code>''</code> <code>parent_id</code> <code>int</code> <p>ID of the parent node. If parent_id is 0 the item will be created right under \"Hold Management\" (top level item)</p> <code>0</code> <code>date_applied</code> <code>str</code> <p>create date of the Hold in this format: YYYY-MM-DDTHH:mm:ss</p> <code>''</code> <code>date_to_remove</code> <code>str</code> <p>suspend date of the Hold in this format: YYYY-MM-DDTHH:mm:ss</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Hold data or None if the request fails. The dict structure is this: {'holdID': } Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_records_management_hold(\nself,\nhold_type: str,\nname: str,\ncomment: str,\nalternate_id: str = \"\",\nparent_id: int = 0,\ndate_applied: str = \"\",\ndate_to_remove: str = \"\",\n) -&gt; dict | None:\n\"\"\"Create a new Records Management Hold.\n    Args:\n        hold_type (str): type of the Hold\n        name (str): name of the RSI\n        comment (str): comment\n        alternate_id (str): alternate hold ID\n        parent_id (int, optional): ID of the parent node. If parent_id is 0 the item will be created right under \"Hold Management\" (top level item)\n        date_applied (str, optional): create date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n        date_to_remove (str, optional): suspend date of the Hold in this format: YYYY-MM-DDTHH:mm:ss\n    Returns:\n        dict: Hold data or None if the request fails. The dict structure is this: {'holdID': &lt;ID&gt;}\n    \"\"\"\nif date_applied == \"\":\nnow = datetime.now()\ndate_applied = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\ncreateHoldPostData = {\n\"type\": hold_type,\n\"name\": name,\n\"comment\": comment,\n\"date_applied\": date_applied,\n\"date_to_remove\": date_to_remove,\n\"alternate_id\": alternate_id,\n}\nif parent_id &gt; 0:\ncreateHoldPostData[\"parent_id\"] = parent_id\nrequest_url = self.config()[\"holdsUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create Records Management Hold -&gt; %s; calling -&gt; %s\", name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createHoldPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create Records Management Hold -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_records_management_rsi","title":"<code>create_records_management_rsi(name, status, status_date, description, subject, title, dispcontrol)</code>","text":"<p>Create a new Records Management RSI.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the RSI</p> required <code>status</code> <code>str</code> <p>status of the RSI</p> required <code>status_date</code> <code>str</code> <p>statusDate of the RSI YYYY-MM-DDTHH:mm:ss</p> required <code>description</code> <code>str</code> <p>description of the RSI</p> required <code>subject</code> <code>str</code> <p>status of the RSI</p> required <code>title</code> <code>str</code> <p>status of the RSI</p> required <code>dispcontrol</code> <code>bool</code> <p>status of the RSI</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>RSI data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_records_management_rsi(\nself,\nname: str,\nstatus: str,\nstatus_date: str,\ndescription: str,\nsubject: str,\ntitle: str,\ndispcontrol: bool,\n) -&gt; dict | None:\n\"\"\"Create a new Records Management RSI.\n    Args:\n        name (str): name of the RSI\n        status (str): status of the RSI\n        status_date (str): statusDate of the RSI YYYY-MM-DDTHH:mm:ss\n        description (str): description of the RSI\n        subject (str): status of the RSI\n        title (str): status of the RSI\n        dispcontrol (bool): status of the RSI\n    Returns:\n        dict: RSI data or None if the request fails.\n    \"\"\"\nif statusDate == \"\":\nnow = datetime.now()\nstatusDate = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\ncreateRSIPostData = {\n\"name\": name,\n\"status\": status,\n\"statusDate\": status_date,\n\"description\": description,\n\"subject\": subject,\n\"title\": title,\n\"dispcontrol\": dispcontrol,\n}\nrequest_url = self.config()[\"rsiSchedulesUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create Records Management RSI -&gt; %s; calling -&gt; %s\", name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createRSIPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create Records Management RSI -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_records_management_rsi_schedule","title":"<code>create_records_management_rsi_schedule(rsi_id, stage, event_type=1, object_type='LIV', rule_code='', rule_comment='', date_to_use=91, retention_years=0, retention_months=0, retention_days=0, category_id=0, attribute_id=0, year_end_month=12, year_end_day=31, retention_intervals=1, fixed_retention=True, maximum_retention=True, fixed_date='', event_condition='', disposition='', action_code=0, description='', new_status='', min_num_versions_to_keep=1, purge_superseded=False, purge_majors=False, mark_official_rendition=False)</code>","text":"<p>Create a new Records Management RSI Schedule for an existing RSI.</p> <p>Parameters:</p> Name Type Description Default <code>rsi_id</code> <code>int</code> <p>ID of an existing RSI the schedule should be created for</p> required <code>object_type</code> <code>str</code> <p>either \"LIV\" - Classified Objects (default) or \"LRM\" - RM Classifications</p> <code>'LIV'</code> <code>stage</code> <code>str</code> <p>retention stage - this is the key parameter to define multiple stages (stages are basically schedules)</p> required <code>event_type</code> <code>int</code> <p>1 Calculated Date, 2 Calendar Calculation, 3 Event Based, 4 Fixed Date, 5 Permanent</p> <code>1</code> <code>rule_code</code> <code>str</code> <p>rule code - this value must be defined upfront</p> <code>''</code> <code>rule_comment</code> <code>str</code> <p>comment for the rule</p> <code>''</code> <code>date_to_use</code> <code>int</code> <p>91 Create Date, 92 Reserved Data, 93 Modification Date, 94 Status Date, 95 Records Date</p> <code>91</code> <code>retention_years</code> <code>int</code> <p>years to wait before disposition</p> <code>0</code> <code>retention_months</code> <code>int</code> <p>month to wait before disposition</p> <code>0</code> <code>retention_days</code> <code>int</code> <p>days to wait before disposition</p> <code>0</code> <code>category_id</code> <code>int</code> <p>ID of the category</p> <code>0</code> <code>attribute_id</code> <code>int</code> <p>ID of the category attribute</p> <code>0</code> <code>year_end_month</code> <code>int</code> <p>month the year ends (normally 12)</p> <code>12</code> <code>year_end_day</code> <code>int</code> <p>day the year ends (normally 31)</p> <code>31</code> <code>retention_intervals</code> <code>int</code> <p>retention intervals</p> <code>1</code> <code>fixed_retention</code> <code>bool</code> <p>fixedRetention</p> <code>True</code> <code>maximum_retention</code> <code>bool</code> <p>maximumRetention</p> <code>True</code> <code>fixed_date(str)</code> <p>fixed date format : YYYY-MM-DDTHH:mm:ss</p> required <code>event_condition</code> <code>str</code> <p>eventCondition</p> <code>''</code> <code>disposition</code> <code>str</code> <p>disposition</p> <code>''</code> <code>action_code</code> <code>int</code> <p>0 None, 1 Change Status, 7 Close, 8 Finalize Record, 9 Mark Official, 10 Export, 11 Update Storage Provider, 12 Delete Electronic Format, 15 Purge Versions, 16 Make Rendition, 32 Destroy</p> <code>0</code> <code>description</code> <code>str</code> <p>description</p> <code>''</code> <code>new_status</code> <code>str</code> <p>new status</p> <code>''</code> <code>min_num_versions_to_keep</code> <code>int</code> <p>minimum document versions to keep</p> <code>1</code> <code>purge_superseded</code> <code>bool</code> <p>purge superseded</p> <code>False</code> <code>purge_majors</code> <code>bool</code> <p>purge majors</p> <code>False</code> <code>mark_official_rendition</code> <code>bool</code> <p>mark official rendition</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>RSI Schedule data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_records_management_rsi_schedule(\nself,\nrsi_id: int,\nstage: str,\nevent_type: int = 1,\nobject_type: str = \"LIV\",\nrule_code: str = \"\",\nrule_comment: str = \"\",\ndate_to_use: int = 91,\nretention_years: int = 0,\nretention_months: int = 0,\nretention_days: int = 0,\ncategory_id: int = 0,\nattribute_id: int = 0,\nyear_end_month: int = 12,\nyear_end_day: int = 31,\nretention_intervals: int = 1,\nfixed_retention: bool = True,\nmaximum_retention: bool = True,\nfixed_date: str = \"\",\nevent_condition: str = \"\",\ndisposition: str = \"\",\naction_code: int = 0,\ndescription: str = \"\",\nnew_status: str = \"\",\nmin_num_versions_to_keep: int = 1,\npurge_superseded: bool = False,\npurge_majors: bool = False,\nmark_official_rendition: bool = False,\n) -&gt; dict | None:\n\"\"\"Create a new Records Management RSI Schedule for an existing RSI.\n    Args:\n        rsi_id (int): ID of an existing RSI the schedule should be created for\n        object_type (str): either \"LIV\" - Classified Objects (default) or \"LRM\" - RM Classifications\n        stage (str): retention stage - this is the key parameter to define multiple stages (stages are basically schedules)\n        event_type (int): 1 Calculated Date, 2 Calendar Calculation, 3 Event Based, 4 Fixed Date, 5 Permanent\n        rule_code (str): rule code - this value must be defined upfront\n        rule_comment (str): comment for the rule\n        date_to_use (int): 91 Create Date, 92 Reserved Data, 93 Modification Date, 94 Status Date, 95 Records Date\n        retention_years (int): years to wait before disposition\n        retention_months (int): month to wait before disposition\n        retention_days (int): days to wait before disposition\n        category_id (int): ID of the category\n        attribute_id (int): ID of the category attribute\n        year_end_month (int): month the year ends (normally 12)\n        year_end_day (int): day the year ends (normally 31)\n        retention_intervals (int): retention intervals\n        fixed_retention (bool): fixedRetention\n        maximum_retention (bool): maximumRetention\n        fixed_date(str): fixed date format : YYYY-MM-DDTHH:mm:ss\n        event_condition (str): eventCondition\n        disposition (str): disposition\n        action_code (int): 0 None, 1 Change Status, 7 Close, 8 Finalize Record, 9 Mark Official, 10 Export, 11 Update Storage Provider, 12 Delete Electronic Format, 15 Purge Versions, 16 Make Rendition, 32 Destroy\n        description (str): description\n        new_status (str): new status\n        min_num_versions_to_keep (int): minimum document versions to keep\n        purge_superseded (bool): purge superseded\n        purge_majors (bool): purge majors\n        mark_official_rendition (bool): mark official rendition\n    Returns:\n        dict: RSI Schedule data or None if the request fails.\n    \"\"\"\nif fixedDate == \"\":\nnow = datetime.now()\nfixedDate = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\ncreateRSISchedulePostData = {\n\"objectType\": object_type,\n\"stage\": stage,\n\"eventType\": event_type,\n\"ruleCode\": rule_code,\n\"ruleComment\": rule_comment,\n\"dateToUse\": date_to_use,\n\"retentionYears\": retention_years,\n\"retentionMonths\": retention_months,\n\"retentionDays\": retention_days,\n\"categoryId\": category_id,\n\"attributeId\": attribute_id,\n\"yearEndMonth\": year_end_month,\n\"yearEndDay\": year_end_day,\n\"retentionIntervals\": retention_intervals,\n\"fixedRetention\": fixed_retention,\n\"maximumRetention\": maximum_retention,\n\"fixedDate\": fixed_date,\n\"eventCondition\": event_condition,\n\"disposition\": disposition,\n\"actionCode\": action_code,\n\"description\": description,\n\"newStatus\": new_status,\n\"minNumVersionsToKeep\": min_num_versions_to_keep,\n\"purgeSuperseded\": purge_superseded,\n\"purgeMajors\": purge_majors,\n\"markOfficialRendition\": mark_official_rendition,\n}\nrequest_url = self.config()[\"rsiSchedulesUrl\"] + \"/\" + str(rsi_id) + \"/stages\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create Records Management RSI Schedule -&gt; %s for RSI -&gt; %s; calling -&gt; %s\",\nstage,\nstr(rsi_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createRSISchedulePostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create Records Management RSI Schedule -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstage,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_transport_workbench","title":"<code>create_transport_workbench(workbench_name)</code>","text":"<p>Create a Workbench in the Transport Volume.</p> <p>Parameters:</p> Name Type Description Default <code>workbench_name</code> <code>str</code> <p>name of the workbench to be created</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Create response or None if the creation fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_transport_workbench(self, workbench_name: str) -&gt; dict | None:\n\"\"\"Create a Workbench in the Transport Volume.\n    Args:\n        workbench_name (str): name of the workbench to be created\n    Returns:\n        dict: Create response or None if the creation fails.\n    \"\"\"\ncreateWorbenchPostData = {\"type\": \"528\", \"name\": workbench_name}\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create transport workbench -&gt; %s; calling -&gt; %s\",\nworkbench_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=createWorbenchPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create transport workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\nworkbench_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_workspace","title":"<code>create_workspace(workspace_template_id, workspace_name, workspace_description, workspace_type, category_data=None, external_system_id=None, bo_type=None, bo_id=None, parent_id=None)</code>","text":"<p>Create a new business workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_template_id</code> <code>int</code> <p>ID of the workspace template</p> required <code>workspace_name</code> <code>str</code> <p>name of the workspace</p> required <code>workspace_description</code> <code>str</code> <p>description of the workspace</p> required <code>workspace_type</code> <code>int</code> <p>type ID of the workspace</p> required <code>category_data</code> <code>dict</code> <p>category and attributes</p> <code>None</code> <code>external_system_id</code> <code>str</code> <p>identifier of the external system (None if no external system)</p> <code>None</code> <code>bo_type</code> <code>str</code> <p>business object type (None if no external system)</p> <code>None</code> <code>bo_id</code> <code>str</code> <p>business object identifier / key (None if no external system)</p> <code>None</code> <code>parent_id</code> <code>str</code> <p>parent ID of the workspaces. Needs only be specified in special                        cases where workspace location cannot be derived from workspace                        type definition</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Create Form data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_workspace(\nself,\nworkspace_template_id: int,\nworkspace_name: str,\nworkspace_description: str,\nworkspace_type: int,\ncategory_data: dict | None = None,\nexternal_system_id: int = None,\nbo_type: int | None = None,\nbo_id: int | None = None,\nparent_id: int | None = None,\n) -&gt; dict | None:\n\"\"\"Create a new business workspace.\n    Args:\n        workspace_template_id (int): ID of the workspace template\n        workspace_name (str): name of the workspace\n        workspace_description (str): description of the workspace\n        workspace_type (int): type ID of the workspace\n        category_data (dict): category and attributes\n        external_system_id (str, optional): identifier of the external system (None if no external system)\n        bo_type (str, optional): business object type (None if no external system)\n        bo_id (str, optional): business object identifier / key (None if no external system)\n        parent_id (str, optional): parent ID of the workspaces. Needs only be specified in special\n                                   cases where workspace location cannot be derived from workspace\n                                   type definition\n    Returns:\n        dict: Workspace Create Form data or None if the request fails.\n    \"\"\"\n# Avoid linter warning W0102\nif category_data is None:\ncategory_data = {}\ncreateWorkspacePostData = {\n\"template_id\": str(workspace_template_id),\n\"name\": workspace_name,\n\"description\": workspace_description,\n\"wksp_type_id\": str(workspace_type),\n\"type\": str(848),\n\"roles\": category_data,\n}\n# Is this workspace connected to a business application / external system?\nif external_system_id and bo_type and bo_id:\ncreateWorkspacePostData[\"ext_system_id\"] = str(external_system_id)\ncreateWorkspacePostData[\"bo_type\"] = str(bo_type)\ncreateWorkspacePostData[\"bo_id\"] = str(bo_id)\nlogger.info(\n\"Use business object connection -&gt; (%s, %s, %s) for workspace -&gt; %s\",\nstr(external_system_id),\nstr(bo_type),\nstr(bo_id),\nworkspace_name,\n)\n# If workspace creation location cannot be derived from the workspace type\n# there may be an optional parent parameter passed to this method. This can\n# also be the case if workspaces are nested into each other:\nif parent_id is not None:\ncreateWorkspacePostData[\"parent_id\"] = parent_id\nlogger.info(\n\"Use specified location -&gt; %s for workspace -&gt; %s\",\nstr(parent_id),\nworkspace_name,\n)\nelse:\nlogger.info(\n\"Determine location of workspace -&gt; %s via workspace type -&gt; %s\",\nworkspace_name,\nstr(workspace_type),\n)\nrequest_url = self.config()[\"businessworkspaces\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create workspace -&gt; %s with type -&gt; %s from template -&gt; %s; calling -&gt; %s\",\nworkspace_name,\nstr(workspace_type),\nstr(workspace_template_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\n# See https://developer.opentext.com/apis/14ba85a7-4693-48d3-8c93-9214c663edd2/4403207c-40f1-476a-b794-fdb563e37e1f/07229613-7ef4-4519-8b8a-47eaff639d42#operation/createBusinessWorkspace\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata={\"body\": json.dumps(createWorkspacePostData)},\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create workspace -&gt; %s from template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nworkspace_name,\nstr(workspace_template_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.create_workspace_relationship","title":"<code>create_workspace_relationship(workspace_id, related_workspace_id, relationship_type='child')</code>","text":"<p>Create a relationship between two workspaces.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>related_workspace_id</code> <code>int</code> <p>ID of the related workspace</p> required <code>relationship_type</code> <code>str</code> <p>\"parent\" or \"child\" - \"child\" is default if omitted</p> <code>'child'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Relationship data (json) or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def create_workspace_relationship(\nself,\nworkspace_id: int,\nrelated_workspace_id: int,\nrelationship_type: str = \"child\",\n) -&gt; dict | None:\n\"\"\"Create a relationship between two workspaces.\n    Args:\n        workspace_id (int): ID of the workspace\n        related_workspace_id (int): ID of the related workspace\n        relationship_type (str, optional): \"parent\" or \"child\" - \"child\" is default if omitted\n    Returns:\n        dict: Workspace Relationship data (json) or None if the request fails.\n    \"\"\"\ncreateWorkspaceRelationshipPostData = {\n\"rel_bw_id\": str(related_workspace_id),\n\"rel_type\": relationship_type,\n}\nrequest_url = self.config()[\"businessworkspaces\"] + \"/{}/relateditems\".format(\nworkspace_id\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Create workspace relationship between -&gt; %s and -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nstr(related_workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=createWorkspaceRelationshipPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to create workspace relationship between -&gt; %s and -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nstr(related_workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.credentials","title":"<code>credentials()</code>","text":"<p>Get credentials (username + password)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with username and password</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def credentials(self) -&gt; dict:\n\"\"\"Get credentials (username + password)\n    Returns:\n        dict: dictionary with username and password\n    \"\"\"\nreturn {\n\"username\": self.config()[\"username\"],\n\"password\": self.config()[\"password\"],\n}\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_public_url","title":"<code>cs_public_url()</code>","text":"<p>Returns the public (external) Extended ECM URL (incl. /cs/cs)</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM Public URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_public_url(self) -&gt; str:\n\"\"\"Returns the public (external) Extended ECM URL (incl. /cs/cs)\n    Returns:\n        str: Extended ECM Public URL\n    \"\"\"\nreturn self.config()[\"csPublicUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_support_public_url","title":"<code>cs_support_public_url()</code>","text":"<p>Returns the Extended ECM Public Support URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM Public Support URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_support_public_url(self) -&gt; str:\n\"\"\"Returns the Extended ECM Public Support URL\n    Returns:\n        str: Extended ECM Public Support URL\n    \"\"\"\nreturn self.config()[\"supportPublicUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_support_url","title":"<code>cs_support_url()</code>","text":"<p>Returns the Extended ECM Support URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM Support URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_support_url(self) -&gt; str:\n\"\"\"Returns the Extended ECM Support URL\n    Returns:\n        str: Extended ECM Support URL\n    \"\"\"\nreturn self.config()[\"supportUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.cs_url","title":"<code>cs_url()</code>","text":"<p>Returns the Extended ECM URL</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extended ECM URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def cs_url(self) -&gt; str:\n\"\"\"Returns the Extended ECM URL\n    Returns:\n        str: Extended ECM URL\n    \"\"\"\nreturn self.config()[\"csUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.deploy_transport","title":"<code>deploy_transport(package_url, package_name, package_description='', replacements=None)</code>","text":"<p>Main method to deploy a transport. This uses subfunctions to upload,    unpackage and deploy the transport, and creates the required workbench.</p> <p>Parameters:</p> Name Type Description Default <code>package_url</code> <code>str</code> <p>URL to download the transport package.</p> required <code>package_name</code> <code>str</code> <p>name of the transport package ZIP file</p> required <code>package_description</code> <code>str</code> <p>description of the transport package</p> <code>''</code> <code>replacements</code> <code>list of dicts</code> <p>list of replacement values to be applied                           to all XML files in transport;                           each dict needs to have two values:                           - placeholder: text to replace                           - value: text to replace with</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Deploy response or None if the deployment fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def deploy_transport(\nself,\npackage_url: str,\npackage_name: str,\npackage_description: str = \"\",\nreplacements: list | None = None,\n) -&gt; dict | None:\n\"\"\"Main method to deploy a transport. This uses subfunctions to upload,\n       unpackage and deploy the transport, and creates the required workbench.\n    Args:\n        package_url (str): URL to download the transport package.\n        package_name (str): name of the transport package ZIP file\n        package_description (str): description of the transport package\n        replacements (list of dicts): list of replacement values to be applied\n                                      to all XML files in transport;\n                                      each dict needs to have two values:\n                                      - placeholder: text to replace\n                                      - value: text to replace with\n    Returns:\n        dict: Deploy response or None if the deployment fails.\n    \"\"\"\nif replacements is None:\nreplacements = []\n# Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\nresponse = self.get_volume(525)\ntransport_root_volume_id = self.get_result_value(response, \"id\")\nif not transport_root_volume_id:\nlogger.error(\"Failed to retrieve transport root volume\")\nreturn None\nlogger.info(\"Transport root volume ID -&gt; %s\", str(transport_root_volume_id))\nresponse = self.get_node_by_parent_and_name(\ntransport_root_volume_id, \"Transport Packages\"\n)\ntransport_package_volume_id = self.get_result_value(response, \"id\")\nif not transport_package_volume_id:\nlogger.error(\"Failed to retrieve transport package volume\")\nreturn None\nlogger.info(\n\"Transport package volume ID -&gt; %s\", str(transport_package_volume_id)\n)\n# Step 1: Upload Transport Package\nlogger.info(\"Check if transport package -&gt; %s already exists...\", package_name)\nresponse = self.get_node_by_parent_and_name(\ntransport_package_volume_id, package_name\n)\npackage_id = self.get_result_value(response, \"id\")\nif package_id:\nlogger.info(\n\"Transport package -&gt; %s does already exist; existing package ID -&gt; %s\",\npackage_name,\nstr(package_id),\n)\nelse:\nlogger.info(\n\"Transport package -&gt; %s does not yet exist, loading from -&gt; %s\",\npackage_name,\npackage_url,\n)\n# If we have string replacements configured execute them now:\nif replacements:\nlogger.info(\n\"Transport -&gt; %s has replacements -&gt; %s\",\npackage_name,\nstr(replacements),\n)\nself.replace_transport_placeholders(package_url, replacements)\nelse:\nlogger.info(\"Transport -&gt; %s has no replacements!\", package_name)\n# Upload package to Extended ECM:\nresponse = self.upload_file_to_volume(\npackage_url, package_name, \"application/zip\", 531\n)\npackage_id = self.get_result_value(response, \"id\")\nif not package_id:\nlogger.error(\"Failed to upload transport package -&gt; %s\", package_url)\nreturn None\nlogger.info(\n\"Successfully uploaded transport package -&gt; %s; new package ID -&gt; %s\",\npackage_name,\nstr(package_id),\n)\n# Step 2: Create Transport Workbench (if not yet exist)\nworkbench_name = package_name.split(\".\")[0]\nlogger.info(\"Check if workbench -&gt; %s is already deployed...\", workbench_name)\n# check if the package name has the suffix \"(deployed)\" - this indicates it is alreadey\n# successfully deployed (see renaming at the end of this method)\nresponse = self.get_node_by_parent_and_name(\ntransport_root_volume_id, workbench_name + \" (deployed)\"\n)\nworkbench_id = self.get_result_value(response, \"id\")\nif workbench_id:\nlogger.info(\n\"Workbench -&gt; %s has already been deployed successfully; existing workbench ID -&gt; %s; skipping transport\",\nworkbench_name,\nstr(workbench_id),\n)\n# we return and skip this transport...\nreturn response\nelse:\nlogger.info(\"Check if workbench -&gt; %s already exists...\", workbench_name)\nresponse = self.get_node_by_parent_and_name(\ntransport_root_volume_id, workbench_name\n)\nworkbench_id = self.get_result_value(response, \"id\")\nif workbench_id:\nlogger.info(\n\"Workbench -&gt; %s does already exist but is not successfully deployed; existing workbench ID -&gt; %s\",\nworkbench_name,\nstr(workbench_id),\n)\nelse:\nresponse = self.create_transport_workbench(workbench_name)\nworkbench_id = self.get_result_value(response, \"id\")\nif not workbench_id:\nlogger.error(\"Failed to create workbench -&gt; %s\", workbench_name)\nreturn None\nlogger.info(\n\"Successfully created workbench -&gt; %s; new workbench ID -&gt; %s\",\nworkbench_name,\nstr(workbench_id),\n)\n# Step 3: Unpack Transport Package to Workbench\nlogger.info(\n\"Unpack transport package -&gt; %s (%s) to workbench -&gt; %s (%s)\",\npackage_name,\nstr(package_id),\nworkbench_name,\nstr(workbench_id),\n)\nresponse = self.unpack_transport_package(package_id, workbench_id)\nif not response:\nlogger.error(\"Failed to unpack the transport package -&gt; %s\", package_name)\nreturn None\nlogger.info(\n\"Successfully unpackaged to workbench -&gt; %s (%s)\",\nworkbench_name,\nstr(workbench_id),\n)\n# Step 4: Deploy Workbench\nlogger.info(\"Deploy workbench -&gt; %s (%s)\", workbench_name, str(workbench_id))\nresponse = self.deploy_workbench(workbench_id)\nif not response:\nlogger.error(\"Failed to deploy workbench -&gt; %s\", workbench_name)\nreturn None\nlogger.info(\n\"Successfully deployed workbench -&gt; %s (%s)\",\nworkbench_name,\nstr(workbench_id),\n)\nself.rename_node(\nworkbench_id,\nworkbench_name + \" (deployed)\",\npackage_description,\n)\nreturn response\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.deploy_workbench","title":"<code>deploy_workbench(workbench_id)</code>","text":"<p>Deploy an existing Workbench.</p> <p>Parameters:</p> Name Type Description Default <code>workbench_d</code> <code>int</code> <p>ID of the workbench to be deployed</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Deploy response or None if the deployment fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def deploy_workbench(self, workbench_id: int) -&gt; dict | None:\n\"\"\"Deploy an existing Workbench.\n    Args:\n        workbench_d (int): ID of the workbench to be deployed\n    Returns:\n        dict: Deploy response or None if the deployment fails.\n    \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(workbench_id) + \"/deploy\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Deploy workbench with ID -&gt; %s; calling -&gt; %s\",\nstr(workbench_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# As this is a potentially long-running request we put it in try / except:\ntry:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.error(\n\"Error deploying workbench -&gt; %s; error -&gt; %s\",\nstr(workbench_id),\nexception.strerror,\n)\nreturn None\nif response.ok:\nresponse_dict = self.parse_request_response(response)\nif not response_dict:\nlogger.error(\"Error deploying workbench -&gt; %s\", str(workbench_id))\nreturn None\nreturn response_dict\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.warning(\n\"Failed to depoloy workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\nworkbench_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.download_config_file","title":"<code>download_config_file(otcs_url_suffix, file_path, search='', replace='')</code>","text":"<p>Download a config file from a given OTCS URL. This is NOT     for downloading documents from within the OTCS repository     but for configuration files such as app packages for MS Teams.</p> <p>Parameters:</p> Name Type Description Default <code>otcs_url_suffix</code> <code>str</code> <p>OTCS URL suffix starting typically starting                       with /cs/cs?func=,                       e.g. /cs/cs?func=officegroups.DownloadTeamsPackage</p> required <code>file_path</code> <code>str</code> <p>local path to save the file (direcotry + filename)</p> required <code>search</code> <code>str</code> <p>optional string to search for a replacement</p> <code>''</code> <code>replace</code> <code>str</code> <p>optional replacement</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the download succeeds, False otherwise</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def download_config_file(\nself, otcs_url_suffix: str, file_path: str, search: str = \"\", replace: str = \"\"\n) -&gt; bool:\n\"\"\"Download a config file from a given OTCS URL. This is NOT\n        for downloading documents from within the OTCS repository\n        but for configuration files such as app packages for MS Teams.\n    Args:\n        otcs_url_suffix (str): OTCS URL suffix starting typically starting\n                                  with /cs/cs?func=,\n                                  e.g. /cs/cs?func=officegroups.DownloadTeamsPackage\n        file_path (str): local path to save the file (direcotry + filename)\n        search (str, optional): optional string to search for a replacement\n        replace (str, optional): optional replacement\n    Returns:\n        bool: True if the download succeeds, False otherwise\n    \"\"\"\nrequest_url = self.config()[\"baseUrl\"] + otcs_url_suffix\n# request_header = self.cookie()\nrequest_header = self.request_download_header()\nlogger.info(\"Download config file from URL -&gt; %s\", request_url)\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=REQUEST_TIMEOUT,\n)\nresponse.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn False\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn False\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn False\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn False\ncontent = response.content\nif search:\nlogger.info(\n\"Search for all occurances of %s in the config file and replace them with %s\",\nsearch,\nreplace,\n)\ncontent = content.replace(search.encode(\"utf-8\"), replace.encode(\"utf-8\"))\n# Open file in write binary mode\nwith open(file=file_path, mode=\"wb\") as file:\n# Write the content to the file\nfile.write(content)\nlogger.info(\n\"Successfully downloaded config file -&gt; %s to -&gt; %s; status code -&gt; %s\",\nrequest_url,\nfile_path,\nresponse.status_code,\n)\nreturn True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.download_document","title":"<code>download_document(node_id, file_path, version_number='')</code>","text":"<p>Download a document from Extended ECM to local file system.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the document to download</p> required <code>file_path</code> <code>str</code> <p>local file path (directory)</p> required <code>version_number</code> <code>str</code> <p>version of the document to download.                      If version = \"\" then download the latest                      version.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the document has been download to the specified file.      False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def download_document(\nself, node_id: int, file_path: str, version_number: str = \"\"\n) -&gt; bool:\n\"\"\"Download a document from Extended ECM to local file system.\n    Args:\n        node_id (int): node ID of the document to download\n        file_path (str): local file path (directory)\n        version_number (str): version of the document to download.\n                                 If version = \"\" then download the latest\n                                 version.\n    Returns:\n        bool: True if the document has been download to the specified file.\n                 False otherwise.\n    \"\"\"\ndirectory = os.path.dirname(file_path)\nif not os.path.exists(directory):\nlogger.error(\"Directory -&gt; %s does not exist\", directory)\nreturn False\nif not version_number:\nresponse = self.get_latest_document_version(node_id)\nif not response:\nlogger.error(\n\"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n)\nversion_number = response[\"data\"][\"version_number\"]\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/versions/\"\n+ str(version_number)\n+ \"/content\"\n)\nrequest_header = self.request_download_header()\nlogger.info(\n\"Download document with node ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\ncontent = response.content\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn False\nlogger.info(\"Writing document content to file -&gt; %s\", file_path)\n# Open file in write binary mode\nwith open(file=file_path, mode=\"wb\") as file:\n# Write the content to the file\nfile.write(content)\nreturn True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.exist_result_item","title":"<code>exist_result_item(response, key, value, property_name='properties')</code>","text":"<p>Check existence of key / value pair in the response properties of an Extended ECM REST API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an OTCS REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>value</code> <code>str</code> <p>value to find in the item with the matching key</p> required <code>property_name</code> <code>str</code> <p>name of the substructure that includes the values</p> <code>'properties'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value was found, False otherwise</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def exist_result_item(\nself, response: dict, key: str, value: str, property_name: str = \"properties\"\n) -&gt; bool:\n\"\"\"Check existence of key / value pair in the response properties of an Extended ECM REST API call.\n    Args:\n        response (dict): REST response from an OTCS REST Call\n        key (str): property name (key)\n        value (str): value to find in the item with the matching key\n        property_name (str, optional): name of the substructure that includes the values\n    Returns:\n        bool: True if the value was found, False otherwise\n    \"\"\"\nif not response:\nreturn False\nif not \"results\" in response:\nreturn False\nresults = response[\"results\"]\n# check if results is a list or a dict (both is possible - dependent on the actual REST API):\nif isinstance(results, dict):\n# result is a dict - we don't need index value:\nif not \"data\" in results:\nreturn False\ndata = results[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nif property_name and not property_name in data:\nlogger.error(\n\"There's no -&gt; %s dictionary in data -&gt; %s\", property_name, data\n)\nreturn False\nproperties = data[property_name]\nif isinstance(properties, dict):\nif key in properties:\nreturn properties[key] == value\nelse:\nreturn False\nelif isinstance(properties, list):\n# properties is a list we iterate through the list and try to find the key:\nfor item in properties:\nif key in item and item[key] == value:\nreturn True\nelse:\nlogger.error(\n\"Properties needs to be a list or dict but it is -&gt; %s\",\nstr(type(properties)),\n)\nreturn False\nelif isinstance(data, list):\n# data is a list\nfor item in data:\nif property_name and not property_name in item:\nlogger.error(\n\"There's no -&gt; %s dictionary in the data list item -&gt; %s\",\nproperty_name,\nitem,\n)\ncontinue\n# if properties if passed as empty string then we assume that\n# the key fields are directly in the item dictionary. This is\n# the case e.g. with the V2 Proxy APIs\nif not property_name:\nproperties = item\nelse:\nproperties = item[property_name]\nif key in properties and properties[key] == value:\nreturn True\nreturn False\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn False\nelif isinstance(results, list):\n# result is a list - we need index value\nfor result in results:\nif not \"data\" in result:\ncontinue\ndata = result[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[property_name]\nif key in properties and properties[key] == value:\nreturn True\nelif isinstance(data, list):\n# data is a list we iterate through the list and try to find the key:\nfor item in data:\nproperties = item[property_name]\nif key in properties and properties[key] == value:\nreturn True\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\",\nstr(type(data)),\n)\nreturn False\nreturn False\nelse:\nlogger.error(\n\"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_business_object_type","title":"<code>get_business_object_type(external_system_id, type_name)</code>","text":"<p>Get business object type information.</p> <p>Parameters:</p> Name Type Description Default <code>external_system_id</code> <code>str</code> <p>external system Id (such as \"TM6\")</p> required <code>type_name</code> <code>str</code> <p>type name (such as \"SAP Customer\")</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Type information or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_business_object_type(\nself, external_system_id: str, type_name: str\n) -&gt; dict | None:\n\"\"\"Get business object type information.\n    Args:\n        external_system_id (str): external system Id (such as \"TM6\")\n        type_name (str): type name (such as \"SAP Customer\")\n    Returns:\n        dict: Workspace Type information or None if the request fails.\n    \"\"\"\nrequest_url = (\nself.config()[\"externalSystem\"]\n+ \"/\"\n+ str(external_system_id)\n+ \"/botypes/\"\n+ str(type_name)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get business object type -&gt; %s for external system -&gt; %s; calling -&gt; %s\",\ntype_name,\nexternal_system_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get business object type -&gt; %s; status -&gt; %s; error -&gt; %s\",\ntype_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_document_content","title":"<code>get_document_content(node_id, version_number='')</code>","text":"<p>Get document content from Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the document to download</p> required <code>version_number</code> <code>str</code> <p>version of the document to download.                      If version = \"\" then download the latest                      version.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>content of the file or None in case of an error.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_document_content(self, node_id: int, version_number: str = \"\") -&gt; bytes:\n\"\"\"Get document content from Extended ECM.\n    Args:\n        node_id (int): node ID of the document to download\n        version_number (str): version of the document to download.\n                                 If version = \"\" then download the latest\n                                 version.\n    Returns:\n        bytes: content of the file or None in case of an error.\n    \"\"\"\nif not version_number:\nresponse = self.get_latest_document_version(node_id)\nif not response:\nlogger.error(\n\"Cannot get latest version of document with ID -&gt; %s\", str(node_id)\n)\nversion_number = response[\"data\"][\"version_number\"]\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/versions/\"\n+ str(version_number)\n+ \"/content\"\n)\nrequest_header = self.request_download_header()\nlogger.info(\n\"Retrieve document with node ID -&gt; %s and version -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nstr(version_number),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\ncontent = response.content\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to download document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\nreturn content\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_document_templates","title":"<code>get_document_templates(parent_id)</code>","text":"<p>Get all document templates for a given target location.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>int</code> <p>node ID of target location (e.g. a folder)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>response of the REST call (converted to a Python dictionary)         Example output:         'results': [             {                 'container': False,                 'hasTemplates': False,                 'name': 'Document',                 'subtype': 144,                 'templates': [                     {                         'description_multilingual': {...},                         'id': 16817,                         'isDPWizardAvailable': False,                         'mime_type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',                         'name': 'Innovate Procurement Contract Template 2022.docx',                         'name_multilingual': {...},                         'size': 144365,                         'sizeformatted': '141 KB',                         'type': 144                     },                     {                         ...                     }                 ]             }         ]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_document_templates(self, parent_id: int):\n\"\"\"Get all document templates for a given target location.\n    Args:\n        parent_id (int): node ID of target location (e.g. a folder)\n    Returns:\n        dict: response of the REST call (converted to a Python dictionary)\n                    Example output:\n                    'results': [\n                        {\n                            'container': False,\n                            'hasTemplates': False,\n                            'name': 'Document',\n                            'subtype': 144,\n                            'templates': [\n                                {\n                                    'description_multilingual': {...},\n                                    'id': 16817,\n                                    'isDPWizardAvailable': False,\n                                    'mime_type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                    'name': 'Innovate Procurement Contract Template 2022.docx',\n                                    'name_multilingual': {...},\n                                    'size': 144365,\n                                    'sizeformatted': '141 KB',\n                                    'type': 144\n                                },\n                                {\n                                    ...\n                                }\n                            ]\n                        }\n                    ]\n    \"\"\"\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(parent_id)\n+ \"/doctemplates?subtypes={144}&amp;sidepanel_subtypes={144}\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get document templates for target location -&gt; %s (parent ID); calling -&gt; %s\",\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get document templates for parent folder -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_external_system_connection","title":"<code>get_external_system_connection(connection_name, show_error=False)</code>","text":"<p>Get Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).</p> <p>Parameters:</p> Name Type Description Default <code>connection_name</code> <code>str</code> <p>Name of the connection</p> required <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>External system Details or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_external_system_connection(\nself, connection_name: str, show_error: bool = False\n) -&gt; dict | None:\n\"\"\"Get Extended ECM external system connection (e.g. SAP, Salesforce, SuccessFactors).\n    Args:\n        connection_name (str): Name of the connection\n        show_error (bool): treat as error if node is not found\n    Returns:\n        dict: External system Details or None if the REST call fails.\n    \"\"\"\nrequest_url = (\nself.config()[\"externalSystem\"] + \"/\" + connection_name + \"/config\"\n)\nrequest_header = self.cookie()\nlogger.info(\n\"Get external system connection -&gt; %s; calling -&gt; %s\",\nconnection_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get external system connection -&gt; %s; status -&gt; %s; error -&gt; %s\",\nconnection_name,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"External system -&gt; %s not found.\", connection_name)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_group","title":"<code>get_group(name, show_error=False)</code>","text":"<p>Lookup Content Server group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the group</p> required <code>show_error</code> <code>bool</code> <p>if True, treat as error if group is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Group information or None if the group is not found.</p> <code>dict | None</code> <p>The returned information has a structure like this:</p> <code>dict | None</code> <p>\"data\": [ {     \"id\": 0,     \"name\": \"string\",     ... }</p> <code>dict | None</code> <p>]</p> <code>dict | None</code> <p>To access the id of the first group found use \"data\"[\"id\"]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_group(self, name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Lookup Content Server group.\n    Args:\n        name (str): name of the group\n        show_error (bool): if True, treat as error if group is not found\n    Returns:\n        dict: Group information or None if the group is not found.\n        The returned information has a structure like this:\n        \"data\": [\n            {\n                \"id\": 0,\n                \"name\": \"string\",\n                ...\n            }\n        ]\n        To access the id of the first group found use [\"data\"][0][\"id\"]\n    \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\n# type = 1 ==&gt; Group\nrequest_url = self.config()[\"membersUrlv2\"] + \"?where_type=1&amp;query={}\".format(\nname\n)\nrequest_header = self.request_form_header()\nlogger.info(\"Get group with name -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"Group -&gt; %s not found.\", name)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_group_members","title":"<code>get_group_members(group, member_type, limit=100)</code>","text":"<p>Get Content Server group members.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>int</code> <p>ID of the group.</p> required <code>member_type</code> <code>int</code> <p>users = 0, groups = 1</p> required <code>limit</code> <code>int</code> <p>max number of results (internal default is 25)</p> <code>100</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Group members or None if the group members couldn't be found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_group_members(\nself, group: int, member_type: int, limit: int = 100\n) -&gt; dict | None:\n\"\"\"Get Content Server group members.\n    Args:\n        group (int): ID of the group.\n        member_type (int): users = 0, groups = 1\n        limit (int, optional): max number of results (internal default is 25)\n    Returns:\n        dict: Group members or None if the group members couldn't be found.\n    \"\"\"\n# default limit is 25 which may not be enough for groups with many members\n# where_type = 1 makes sure we just get groups and not users\nrequest_url = (\nself.config()[\"membersUrlv2\"]\n+ \"/\"\n+ str(group)\n+ \"/members?where_type=\"\n+ str(member_type)\n+ \"&amp;limit=\"\n+ str(limit)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Getting members of group with ID -&gt; %s; calling -&gt; %s\",\nstr(group),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get members of group -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(group),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_latest_document_version","title":"<code>get_latest_document_version(node_id)</code>","text":"<p>Get latest version of a document node based on the node ID.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if no node with this ID is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_latest_document_version(self, node_id: int) -&gt; dict | None:\n\"\"\"Get latest version of a document node based on the node ID.\n    Args:\n        node_id (int) is the node Id of the node\n    Returns:\n        dict: Node information or None if no node with this ID is found.\n    \"\"\"\nrequest_url = (\nself.config()[\"nodesUrl\"] + \"/\" + str(node_id) + \"/versions/latest\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get latest version of document with node ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get latest version of document with node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node","title":"<code>get_node(node_id, timeout=REQUEST_TIMEOUT)</code>","text":"<p>Get a node based on the node ID.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>timeout for the request in seconds</p> <code>REQUEST_TIMEOUT</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if no node with this ID is found.</p> <code>dict | None</code> <p>\"results\": [ {     \"data\": [         {             \"columns\": [                 {                 \"data_type\": 0,                 \"key\": \"string\",                 \"name\": \"string\",                 \"sort_key\": \"string\"                 }             ],             \"properties\": [                 {                     \"advanced_versioning\": true,                     \"container\": true,                     \"container_size\": 0,                     \"create_date\": \"string\",                     \"create_user_id\": 0,                     \"description\": \"string\",                     \"description_multilingual\": {                         \"en\": \"string\",                         \"de\": \"string\"                     },                     \"external_create_date\": \"2019-08-24\",                     \"external_identity\": \"string\",                     \"external_identity_type\": \"string\",                     \"external_modify_date\": \"2019-08-24\",                     \"external_source\": \"string\",                     \"favorite\": true,                     \"guid\": \"string\",                     \"hidden\": true,                     \"icon\": \"string\",                     \"icon_large\": \"string\",                     \"id\": 0,                     \"modify_date\": \"2019-08-24\",                     \"modify_user_id\": 0,                     \"name\": \"string\",                     \"name_multilingual\": {                         \"en\": \"string\",                         \"de\": \"string\"                     },                     \"owner\": \"string\",                     \"owner_group_id\": 0,                     \"owner_user_id\": 0,                     \"parent_id\": 0,                     \"reserved\": true,                     \"reserved_date\": \"string\",                     \"reserved_user_id\": 0,                     \"status\": 0,                     \"type\": 0,                     \"type_name\": \"string\",                     \"versionable\": true,                     \"versions_control_advanced\": true,                     \"volume_id\": 0                 }             ]         }     ] }</p> <code>dict | None</code> <p>]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node(self, node_id: int, timeout: int = REQUEST_TIMEOUT) -&gt; dict | None:\n\"\"\"Get a node based on the node ID.\n    Args:\n        node_id (int) is the node Id of the node\n        timeout (int, optional): timeout for the request in seconds\n    Returns:\n        dict: Node information or None if no node with this ID is found.\n        \"results\": [\n            {\n                \"data\": [\n                    {\n                        \"columns\": [\n                            {\n                            \"data_type\": 0,\n                            \"key\": \"string\",\n                            \"name\": \"string\",\n                            \"sort_key\": \"string\"\n                            }\n                        ],\n                        \"properties\": [\n                            {\n                                \"advanced_versioning\": true,\n                                \"container\": true,\n                                \"container_size\": 0,\n                                \"create_date\": \"string\",\n                                \"create_user_id\": 0,\n                                \"description\": \"string\",\n                                \"description_multilingual\": {\n                                    \"en\": \"string\",\n                                    \"de\": \"string\"\n                                },\n                                \"external_create_date\": \"2019-08-24\",\n                                \"external_identity\": \"string\",\n                                \"external_identity_type\": \"string\",\n                                \"external_modify_date\": \"2019-08-24\",\n                                \"external_source\": \"string\",\n                                \"favorite\": true,\n                                \"guid\": \"string\",\n                                \"hidden\": true,\n                                \"icon\": \"string\",\n                                \"icon_large\": \"string\",\n                                \"id\": 0,\n                                \"modify_date\": \"2019-08-24\",\n                                \"modify_user_id\": 0,\n                                \"name\": \"string\",\n                                \"name_multilingual\": {\n                                    \"en\": \"string\",\n                                    \"de\": \"string\"\n                                },\n                                \"owner\": \"string\",\n                                \"owner_group_id\": 0,\n                                \"owner_user_id\": 0,\n                                \"parent_id\": 0,\n                                \"reserved\": true,\n                                \"reserved_date\": \"string\",\n                                \"reserved_user_id\": 0,\n                                \"status\": 0,\n                                \"type\": 0,\n                                \"type_name\": \"string\",\n                                \"versionable\": true,\n                                \"versions_control_advanced\": true,\n                                \"volume_id\": 0\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\"Get node with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url)\nretries = 0\nwhile True:\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=timeout,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\nexcept requests.exceptions.Timeout:\nif retries &lt;= REQUEST_MAX_RETRIES:\nlogger.warning(\n\"Request timed out. Retrying in %s seconds...\",\nstr(REQUEST_RETRY_DELAY),\n)\nretries += 1\ntime.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\nelse:\nlogger.error(\n\"Failed to get node with ID -&gt; %s; timeout error\", str(node_id)\n)\n# If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\nlogger.warning(\"Turn timeouts off and wait forever...\")\ntimeout = None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_actions","title":"<code>get_node_actions(node_id, filter_actions=None)</code>","text":"<p>Get allowed actions for a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>description</p> required <code>filter_actions</code> <code>list</code> <p>description</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>description</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_actions(self, node_id: int, filter_actions: list = None) -&gt; dict:\n\"\"\"Get allowed actions for a node.\n    Args:\n        node_id (int): _description_\n        filter_actions (list, optional): _description_\n    Returns:\n        dict: _description_\n    \"\"\"\nactions_post_body = {\"ids\": [node_id], \"actions\": filter_actions}\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/actions\"\n#        request_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/actions\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get actions for node with ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=actions_post_body,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get actions for node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnode_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_by_parent_and_name","title":"<code>get_node_by_parent_and_name(parent_id, name, fields='properties', show_error=False)</code>","text":"<p>Get a node based on the parent ID and name. This method does basically    a query with \"where_name\" and the \"result\" is a list.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>str</code> <p>which fields to retrieve. This can have a big impact on performance!</p> <code>'properties'</code> <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if no node with this name is found in parent.         Access to node ID with: response\"results\"\"data\"[\"id\"]</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_by_parent_and_name(\nself,\nparent_id: int,\nname: str,\nfields: str = \"properties\",\nshow_error: bool = False,\n) -&gt; dict | None:\n\"\"\"Get a node based on the parent ID and name. This method does basically\n       a query with \"where_name\" and the \"result\" is a list.\n    Args:\n        parent_id (int) is the node Id of the parent node\n        name (str) is the name of the node to get\n        fields (str): which fields to retrieve. This can have a big impact on performance!\n        show_error (bool, optional): treat as error if node is not found\n    Returns:\n        dict: Node information or None if no node with this name is found in parent.\n                    Access to node ID with: response[\"results\"][0][\"data\"][\"properties\"][\"id\"]\n    \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {\"where_name\": name}\nif fields:\nquery[\"fields\"] = fields\nencoded_query = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(parent_id)\n+ \"/nodes?{}\".format(encoded_query)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get node with name -&gt; %s and parent ID -&gt; %s; calling -&gt; %s\",\nname,\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get node with name -&gt; %s and parent ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\n\"Node with name -&gt; %s and parent ID -&gt; %s not found.\",\nname,\nstr(parent_id),\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_by_volume_and_path","title":"<code>get_node_by_volume_and_path(volume_type, path=None)</code>","text":"<p>Get a node based on the volume and path (list of container items).</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>int</code> <p>Volume type ID (default is 141 = Enterprise Workspace) \"Records Management\"                = 550 \"Content Server Document Templates\" = 20541 \"O365 Office Online Volume\"         = 1296 \"Categories Volume\"                 = 133 \"Perspectives\"                      = 908 \"Perspective Assets\"                = 954 \"Facets Volume\"                     = 901 \"Transport Warehouse\"               = 525 \"Transport Warehouse Workbench\"     = 528 \"Transport Warehouse Package\"       = 531 \"Event Action Center Configuration\" = 898 \"Classification Volume\"             = 198 \"Support Asset Volume\"              = 1309 \"Physical Objects Workspace\"        = 413 \"Extended ECM\"                      = 882 \"Enterprise Workspace\"              = 141 \"Personal Workspace\"                = 142 \"Business Workspaces\"               = 862</p> required <code>path</code> <code>list</code> <p>list of container items (top down), last item is name of to be retrieved item.          If path is empty the node of the volume is returned.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if no node with this path is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_by_volume_and_path(\nself, volume_type: int, path: list | None = None\n) -&gt; dict | None:\n\"\"\"Get a node based on the volume and path (list of container items).\n    Args:\n        volume_type (int): Volume type ID (default is 141 = Enterprise Workspace)\n            \"Records Management\"                = 550\n            \"Content Server Document Templates\" = 20541\n            \"O365 Office Online Volume\"         = 1296\n            \"Categories Volume\"                 = 133\n            \"Perspectives\"                      = 908\n            \"Perspective Assets\"                = 954\n            \"Facets Volume\"                     = 901\n            \"Transport Warehouse\"               = 525\n            \"Transport Warehouse Workbench\"     = 528\n            \"Transport Warehouse Package\"       = 531\n            \"Event Action Center Configuration\" = 898\n            \"Classification Volume\"             = 198\n            \"Support Asset Volume\"              = 1309\n            \"Physical Objects Workspace\"        = 413\n            \"Extended ECM\"                      = 882\n            \"Enterprise Workspace\"              = 141\n            \"Personal Workspace\"                = 142\n            \"Business Workspaces\"               = 862\n        path (list): list of container items (top down), last item is name of to be retrieved item.\n                     If path is empty the node of the volume is returned.\n    Returns:\n        dict: Node information or None if no node with this path is found.\n    \"\"\"\n# If path is not given we use empty list to make the for loop below working in this case as well\nif path is None:\npath = []\n# Preparation: get volume IDs for Transport Warehouse (root volume and Transport Packages)\nresponse = self.get_volume(volume_type)\nif not response:\nlogger.error(\"Volume type -&gt; %s not found!\", str(volume_type))\nreturn None\nvolume_id = self.get_result_value(response, \"id\")\nlogger.info(\n\"Volume type -&gt; %s has node ID -&gt; %s\", str(volume_type), str(volume_id)\n)\ncurrent_item_id = volume_id\n# in case the path is an empty list\n# we will have the node of the volume:\nnode = self.get_node(current_item_id)\nfor path_element in path:\nnode = self.get_node_by_parent_and_name(current_item_id, path_element)\npath_item_id = self.get_result_value(node, \"id\")\nif not path_item_id:\nlogger.error(\n\"Cannot find path element -&gt; %s in container with ID -&gt; %s.\",\npath_element,\nstr(current_item_id),\n)\nreturn None\ncurrent_item_id = path_item_id\nlogger.debug(\"Traversing path element with ID -&gt; %s\", str(current_item_id))\nreturn node\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_by_workspace_and_path","title":"<code>get_node_by_workspace_and_path(workspace_id, path, show_error=False)</code>","text":"<p>Get a node based on the workspace ID (= node ID) and path (list of folder names).</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>node ID of the workspace</p> required <code>path</code> <code>list</code> <p>list of container items (top down), last item is name of to be retrieved item.          If path is empty the node of the volume is returned.</p> required <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if no node with this path is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_by_workspace_and_path(\nself, workspace_id: int, path: list, show_error: bool = False\n) -&gt; dict | None:\n\"\"\"Get a node based on the workspace ID (= node ID) and path (list of folder names).\n    Args:\n        workspace_id (int): node ID of the workspace\n        path (list): list of container items (top down), last item is name of to be retrieved item.\n                     If path is empty the node of the volume is returned.\n        show_error (bool, optional): treat as error if node is not found\n    Returns:\n        dict: Node information or None if no node with this path is found.\n    \"\"\"\ncurrent_item_id = workspace_id\n# in case the path is an empty list\n# we will have the node of the workspace:\nnode = self.get_node(current_item_id)\nfor path_element in path:\nnode = self.get_node_by_parent_and_name(current_item_id, path_element)\ncurrent_item_id = self.get_result_value(node, \"id\")\nif not current_item_id:\nif show_error:\nlogger.error(\"Cannot find path element -&gt; %s!\", path_element)\nelse:\nlogger.info(\"Cannot find path element -&gt; %s.\", path_element)\nreturn None\nlogger.debug(\n\"Traversing path element -&gt; %s (%s)\", path_element, str(current_item_id)\n)\nreturn node\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_categories","title":"<code>get_node_categories(node_id, metadata=True)</code>","text":"<p>Get categories assigned to a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node to get the categories for.</p> required <code>metadata</code> <code>bool</code> <p>expand the attribute definitions of the category. Default is True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>category response or None if the call to the REST API fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_categories(self, node_id: int, metadata: bool = True):\n\"\"\"Get categories assigned to a node.\n    Args:\n        node_id (int): ID of the node to get the categories for.\n        metadata (bool, optional): expand the attribute definitions of the category. Default is True\n    Returns:\n        dict: category response or None if the call to the REST API fails.\n    \"\"\"\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id) + \"/categories\"\nif metadata:\nrequest_url += \"?metadata\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get categories of node with ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get categories for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_category","title":"<code>get_node_category(node_id, category_id, metadata=True)</code>","text":"<p>Get a specific category assigned to a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node to get the categories for.</p> required <code>category_id</code> <code>int</code> <p>ID of the category definition ID (in category volume)</p> required <code>metadata</code> <code>bool</code> <p>expand the attribute definitions of the category. Default is True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>category response or None if the call to the REST API fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_category(self, node_id: int, category_id: int, metadata: bool = True):\n\"\"\"Get a specific category assigned to a node.\n    Args:\n        node_id (int): ID of the node to get the categories for.\n        category_id (int): ID of the category definition ID (in category volume)\n        metadata (bool, optional): expand the attribute definitions of the category. Default is True\n    Returns:\n        dict: category response or None if the call to the REST API fails.\n    \"\"\"\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/categories/\"\n+ str(category_id)\n)\nif metadata:\nrequest_url += \"?metadata\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get category with ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\nstr(category_id),\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get category with ID -&gt; %s for node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(category_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_category_definition","title":"<code>get_node_category_definition(node_id, category_name)</code>","text":"<p>Get category definition (category id and attribute IDs and types)</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node to read the category definition from            (e.g. a workspace template or a document template or a target folder)            This should NOT be the category definition object!</p> required <code>category_name</code> <code>str</code> <p>name of the category</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>category ID</p> <code>dict</code> <p>keys are the attribute names. values are sub-dictionaries with the id and type of the attribute.         Example:         {             'Status': {                 'id': '12532_2',                 'type': 'String'             },             'Legal Approval': {                 'id': '12532_3',                 'type': 'user'             },             ...         }</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_category_definition(self, node_id: int, category_name: str):\n\"\"\"Get category definition (category id and attribute IDs and types)\n    Args:\n        node_id (int): node to read the category definition from\n                       (e.g. a workspace template or a document template or a target folder)\n                       This should NOT be the category definition object!\n        category_name (str): name of the category\n    Returns:\n        int: category ID\n        dict: keys are the attribute names. values are sub-dictionaries with the id and type of the attribute.\n                    Example:\n                    {\n                        'Status': {\n                            'id': '12532_2',\n                            'type': 'String'\n                        },\n                        'Legal Approval': {\n                            'id': '12532_3',\n                            'type': 'user'\n                        },\n                        ...\n                    }\n    \"\"\"\nattribute_definitions = {}\ncat_id = -1\nresponse = self.get_node_categories(node_id)\nif response and response[\"results\"]:\nfor categories in response[\"results\"]:\nkeys = categories[\"metadata\"][\"categories\"].keys()\ncat_id = next((key for key in keys if \"_\" not in key), -1)\ncat_name = categories[\"metadata\"][\"categories\"][cat_id][\"name\"]\nif cat_name != category_name:\ncontinue\nfor att_id in categories[\"metadata\"][\"categories\"]:\nif not \"_\" in att_id:\ncontinue\natt_name = categories[\"metadata\"][\"categories\"][att_id][\"name\"]\nif categories[\"metadata\"][\"categories\"][att_id][\"persona\"]:\natt_type = categories[\"metadata\"][\"categories\"][att_id][\n\"persona\"\n]\nelse:\natt_type = categories[\"metadata\"][\"categories\"][att_id][\n\"type_name\"\n]\nattribute_definitions[att_name] = {\"id\": att_id, \"type\": att_type}\nreturn cat_id, attribute_definitions\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_category_ids","title":"<code>get_node_category_ids(node_id)</code>","text":"<p>Get list of all category definition IDs that are assign to the node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node to get the categories for.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of category IDs (all categories assigned to the node)</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_category_ids(self, node_id: int) -&gt; list:\n\"\"\"Get list of all category definition IDs that are assign to the node.\n    Args:\n        node_id (int): ID of the node to get the categories for.\n    Returns:\n        list: list of category IDs (all categories assigned to the node)\n    \"\"\"\ncategories = self.get_node_categories(node_id)\nif not categories or not categories[\"results\"]:\nreturn None\ncategory_id_list = []\nfor category in categories[\"results\"]:\ncategory_id_list += [\nint(i) for i in category[\"metadata_order\"][\"categories\"]\n]\nreturn category_id_list\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_node_from_nickname","title":"<code>get_node_from_nickname(nickname, show_error=False)</code>","text":"<p>Get a node based on the nickname.</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>str</code> <p>Nickname of the node.</p> required <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if no node with this nickname is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_node_from_nickname(\nself, nickname: str, show_error: bool = False\n) -&gt; dict | None:\n\"\"\"Get a node based on the nickname.\n    Args:\n        nickname (str): Nickname of the node.\n        show_error (bool): treat as error if node is not found\n    Returns:\n        dict: Node information or None if no node with this nickname is found.\n    \"\"\"\nrequest_url = self.config()[\"nicknameUrl\"] + \"/\" + nickname + \"/nodes\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get node with nickname -&gt; %s; calling -&gt; %s\", nickname, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get node with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnickname,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"Node with nickname -&gt; %s not found.\", nickname)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_records_management_codes","title":"<code>get_records_management_codes()</code>","text":"<p>Get Records Management Codes. These are the most basic data types of    the Records Management configuration and required to create RSIs and    other higher-level Records Management configurations</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>RM codes or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_records_management_codes(self) -&gt; dict | None:\n\"\"\"Get Records Management Codes. These are the most basic data types of\n       the Records Management configuration and required to create RSIs and\n       other higher-level Records Management configurations\n    Args:\n        None\n    Returns:\n        dict: RM codes or None if the request fails.\n    \"\"\"\nrequest_url = self.config()[\"recordsManagementUrlv2\"] + \"/rmcodes\"\nrequest_header = self.request_form_header()\nlogger.info(\"Get list of Records Management codes; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nrm_codes_dict = self.parse_request_response(response)\nreturn rm_codes_dict[\"results\"][\"data\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of Records Management codes; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_records_management_holds","title":"<code>get_records_management_holds()</code>","text":"<p>Get a list of all Records Management Holds in the system. Even though there are folders in the holds management area in RM these are not real folders - they cannot be retrieved with get_node_by_parent_and_name() thus we need this method to get them all.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response with list of holds:</p> <code>dict | None</code> <p>\"results\": { \"data\": {     \"holds\": [         {             \"HoldID\": 0,             \"HoldName\": \"string\",             \"ActiveHold\": 0,             \"OBJECT\": 0,             \"ApplyPatron\": \"string\",             \"DateApplied\": \"string\",             \"HoldComment\": \"string\",             \"HoldType\": \"string\",             \"DateToRemove\": \"string\",             \"DateRemoved\": \"string\",             \"RemovalPatron\": \"string\",             \"RemovalComment\": \"string\",             \"EditDate\": \"string\",             \"EditPatron\": \"string\",             \"AlternateHoldID\": 0,             \"ParentID\": 0         }     ] }</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_records_management_holds(self) -&gt; dict | None:\n\"\"\"Get a list of all Records Management Holds in the system. Even though there are folders\n    in the holds management area in RM these are not real folders - they cannot be retrieved\n    with get_node_by_parent_and_name() thus we need this method to get them all.\n    Args:\n        None\n    Returns:\n        dict: Response with list of holds:\n        \"results\": {\n            \"data\": {\n                \"holds\": [\n                    {\n                        \"HoldID\": 0,\n                        \"HoldName\": \"string\",\n                        \"ActiveHold\": 0,\n                        \"OBJECT\": 0,\n                        \"ApplyPatron\": \"string\",\n                        \"DateApplied\": \"string\",\n                        \"HoldComment\": \"string\",\n                        \"HoldType\": \"string\",\n                        \"DateToRemove\": \"string\",\n                        \"DateRemoved\": \"string\",\n                        \"RemovalPatron\": \"string\",\n                        \"RemovalComment\": \"string\",\n                        \"EditDate\": \"string\",\n                        \"EditPatron\": \"string\",\n                        \"AlternateHoldID\": 0,\n                        \"ParentID\": 0\n                    }\n                ]\n            }\n        }\n    \"\"\"\nrequest_url = self.config()[\"holdsUrlv2\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Get list of Records Management Holds; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of Records Management Holds; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_records_management_rsis","title":"<code>get_records_management_rsis(limit=100)</code>","text":"<p>Get all Records management RSIs togther with their RSI Schedules.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>max elements to return (default = 100)</p> <code>100</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list | None</code> <p>list of Records Management RSIs or None if the request fails.</p> <code>list | None</code> <p>Each RSI list element is a dict with this structure:</p> <code>list | None</code> <p>{ \"RSIID\": 0, \"RSI\": \"string\", \"Title\": \"string\", \"Subject\": \"string\", \"Description\": \"string\", \"CreateDate\": \"string\", \"RSIStatus\": \"string\", \"StatusDate\": \"string\", \"DiscontFlag\": 0, \"DiscontDate\": \"string\", \"DiscontComment\": \"string\", \"Active\": 0, \"DispControl\": 0, \"RSIScheduleID\": 0, \"RetStage\": \"string\", \"RecordType\": 0, \"EventType\": 0, \"RSIRuleCode\": \"string\", \"DateToUse\": \"string\", \"YearEndMonth\": 0, \"YearEndDay\": 0, \"RetYears\": 0, \"RetMonths\": 0, \"RetDays\": 0, \"RetIntervals\": 0, \"EventRuleDate\": \"string\", \"EventRule\": \"string\", \"EventComment\": \"string\", \"StageAction\": \"string\", \"FixedRet\": 0, \"ActionCode\": \"string\", \"ActionDescription\": \"string\", \"Disposition\": \"string\", \"ApprovalFlag\": 0, \"MaximumRet\": 0, \"ObjectType\": \"LIV\"</p> <code>list | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_records_management_rsis(self, limit: int = 100) -&gt; list | None:\n\"\"\"Get all Records management RSIs togther with their RSI Schedules.\n    Args:\n        limit (int, optional): max elements to return (default = 100)\n    Returns:\n        list: list of Records Management RSIs or None if the request fails.\n        Each RSI list element is a dict with this structure:\n        {\n            \"RSIID\": 0,\n            \"RSI\": \"string\",\n            \"Title\": \"string\",\n            \"Subject\": \"string\",\n            \"Description\": \"string\",\n            \"CreateDate\": \"string\",\n            \"RSIStatus\": \"string\",\n            \"StatusDate\": \"string\",\n            \"DiscontFlag\": 0,\n            \"DiscontDate\": \"string\",\n            \"DiscontComment\": \"string\",\n            \"Active\": 0,\n            \"DispControl\": 0,\n            \"RSIScheduleID\": 0,\n            \"RetStage\": \"string\",\n            \"RecordType\": 0,\n            \"EventType\": 0,\n            \"RSIRuleCode\": \"string\",\n            \"DateToUse\": \"string\",\n            \"YearEndMonth\": 0,\n            \"YearEndDay\": 0,\n            \"RetYears\": 0,\n            \"RetMonths\": 0,\n            \"RetDays\": 0,\n            \"RetIntervals\": 0,\n            \"EventRuleDate\": \"string\",\n            \"EventRule\": \"string\",\n            \"EventComment\": \"string\",\n            \"StageAction\": \"string\",\n            \"FixedRet\": 0,\n            \"ActionCode\": \"string\",\n            \"ActionDescription\": \"string\",\n            \"Disposition\": \"string\",\n            \"ApprovalFlag\": 0,\n            \"MaximumRet\": 0,\n            \"ObjectType\": \"LIV\"\n        }\n    \"\"\"\nrequest_url = self.config()[\"rsisUrl\"] + \"?limit=\" + str(limit)\nrequest_header = self.request_form_header()\nlogger.info(\"Get list of Records Management RSIs; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nrsi_dict = self.parse_request_response(response)\nreturn rsi_dict[\"results\"][\"data\"][\"rsis\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get list of Records Management RSIs; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_result_value","title":"<code>get_result_value(response, key, index=0, property_name='properties')</code>","text":"<p>Read an item value from the REST API response. This is considering    the most typical structures delivered by V2 REST API of Extended ECM.    See developer.opentext.com for more details.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST API response object</p> required <code>key</code> <code>str</code> <p>key to find (e.g. \"id\", \"name\", ...)</p> required <code>index</code> <code>int</code> <p>In case a list of results is delivered the index                    to use (1st element has index  0). Defaults to 0.</p> <code>0</code> <code>property_name</code> <code>str</code> <p>name of the sub dictionary holding the actual values.                            Default is \"properties\".</p> <code>'properties'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>value of the item with the given key for None if no value is found for the given key.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_result_value(\nself,\nresponse: dict,\nkey: str,\nindex: int = 0,\nproperty_name: str = \"properties\",\n) -&gt; str | None:\n\"\"\"Read an item value from the REST API response. This is considering\n       the most typical structures delivered by V2 REST API of Extended ECM.\n       See developer.opentext.com for more details.\n    Args:\n        response (dict): REST API response object\n        key (str): key to find (e.g. \"id\", \"name\", ...)\n        index (int, optional): In case a list of results is delivered the index\n                               to use (1st element has index  0). Defaults to 0.\n        property_name (str, optional): name of the sub dictionary holding the actual values.\n                                       Default is \"properties\".\n    Returns:\n        str: value of the item with the given key for None if no value is found for the given key.\n    \"\"\"\n# First do some sanity checks:\nif not response:\nlogger.info(\"Empty REST response - returning None\")\nreturn None\nif not \"results\" in response:\nlogger.error(\"No 'results' key in REST response - returning None\")\nreturn None\nresults = response[\"results\"]\nif not results:\nlogger.info(\"No results found!\")\nreturn None\n# check if results is a list or a dict (both is possible - dependent on the actual REST API):\nif isinstance(results, dict):\n# result is a dict - we don't need index value\n# this is a special treatment for the businessworkspaces REST API - it returns\n# for \"Create business workspace\" the ID directly in the results dict (without data substructure)\nif key in results:\nreturn results[key]\ndata = results[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[property_name]\nelif isinstance(data, list):\n# data is a list - this has typically just one item, so we use 0 as index\nproperties = data[0][property_name]\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn None\nlogger.debug(\"Properties of results (dict) -&gt; %s\", str(properties))\n# For nearly all OTCS REST Calls perperties is a dict:\nif isinstance(properties, dict):\nif not key in properties:\nlogger.error(\"Key -&gt; %s is not in result properties!\", key)\nreturn None\nreturn properties[key]\n# but there are some strange ones that have other names for\n# properties and may use a list - see e.g. /v2/holds\nelif isinstance(properties, list):\nif index &gt; len(properties) - 1:\nlogger.error(\n\"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\nstr(index),\nstr(len(properties)),\n)\nreturn None\nreturn properties[index][key]\nelse:\nlogger.error(\n\"Properties needs to be a list or dict but it is -&gt; %s\",\nstr(type(properties)),\n)\nreturn False\nelif isinstance(results, list):\n# result is a list - we need a valid index:\nif index &gt; len(results) - 1:\nlogger.error(\n\"Illegal Index -&gt; %s given. List has only -&gt; %s elements!\",\nstr(index),\nstr(len(results)),\n)\nreturn None\ndata = results[index][\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[property_name]\nelif isinstance(data, list):\n# data is a list - this has typically just one item, so we use 0 as index\nproperties = data[0][property_name]\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn None\nlogger.debug(\n\"Properties of results (list, index -&gt; %s) -&gt; %s\",\nstr(index),\nproperties,\n)\nif not key in properties:\nlogger.error(\"Key -&gt; %s is not in result properties!\", key)\nreturn None\nreturn properties[key]\nelse:\nlogger.error(\n\"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_server_info","title":"<code>get_server_info()</code>","text":"<p>Get Content Server information (server info)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>server information or None if the call fails</p> <code>dict | None</code> <p>Example value:</p> <code>dict | None</code> <p>{ 'mobile': {     'cs_viewer_support': False,     'offline_use': True }, 'server': {     'advanced_versioning': True,     'character_encoding': 1,     'current_date': '2023-09-05T17:09:41',     'current_locale_suffix': '_en_US',     'domain_access_enabled': False,     'enhanced_advanced_versioning': False,     'force_download_for_mime_types': [...],     'language_code': 'USA',     'languages': [...],     'metadata_languages: [...],     'url': 'https://otcs.dev.idea-te.eimdemo.com/cs/cs'     'version': '23.3'     ... }, 'sessions': {     'enabled': True,     'expire_after_last_login': False,     'expire_after_last_request': True,     'logout_url': '?func=ll.DoLogout&amp;secureRequestToken=LUAQSY%2BJs4KnlwoVgxLtxQFYrov2XefJQM9ShyhOK93Mzp3ymCxX6IGMTtUgNvTH7AYVt%2BbWLEw%3D',     'session_inactivity': 7020000,     'session_reaction_time': 180000,     'session_timeout': 7200000 }, 'viewer': {     'content_suite': {...} }</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_server_info(self) -&gt; dict | None:\n\"\"\"Get Content Server information (server info)\n    Args:\n        None\n    Returns:\n        dict: server information or None if the call fails\n        Example value:\n        {\n            'mobile': {\n                'cs_viewer_support': False,\n                'offline_use': True\n            },\n            'server': {\n                'advanced_versioning': True,\n                'character_encoding': 1,\n                'current_date': '2023-09-05T17:09:41',\n                'current_locale_suffix': '_en_US',\n                'domain_access_enabled': False,\n                'enhanced_advanced_versioning': False,\n                'force_download_for_mime_types': [...],\n                'language_code': 'USA',\n                'languages': [...],\n                'metadata_languages: [...],\n                'url': 'https://otcs.dev.idea-te.eimdemo.com/cs/cs'\n                'version': '23.3'\n                ...\n            },\n            'sessions': {\n                'enabled': True,\n                'expire_after_last_login': False,\n                'expire_after_last_request': True,\n                'logout_url': '?func=ll.DoLogout&amp;secureRequestToken=LUAQSY%2BJs4KnlwoVgxLtxQFYrov2XefJQM9ShyhOK93Mzp3ymCxX6IGMTtUgNvTH7AYVt%2BbWLEw%3D',\n                'session_inactivity': 7020000,\n                'session_reaction_time': 180000,\n                'session_timeout': 7200000\n            },\n            'viewer': {\n                'content_suite': {...}\n            }\n        }\n    \"\"\"\nrequest_url = self.config()[\"serverInfoUrl\"]\nrequest_header = self._cookie\nlogger.info(\n\"Retrieve Extended ECM server information; calling -&gt; %s\", request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve Extended ECM server information; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_server_version","title":"<code>get_server_version()</code>","text":"<p>Get Content Server version</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>server version number like 23.4</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_server_version(self) -&gt; str | None:\n\"\"\"Get Content Server version\n    Args:\n        None\n    Returns:\n        str: server version number like 23.4\n    \"\"\"\nresponse = self.get_server_info()\nif not response:\nreturn None\nserver_info = response.get(\"server\")\nif not server_info:\nreturn None\nreturn server_info.get(\"version\")\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_subnodes","title":"<code>get_subnodes(parent_node_id, filter_node_types=-2, filter_name='', show_hidden=False, limit=100, page=1, fields='properties')</code>","text":"<p>Get a subnodes of a parent node ID.</p> <p>Parameters:</p> Name Type Description Default <code>filter_node_types</code> <code>int</code> <p>-1 get all containers -2 get all searchable objects (default) -3 get all non-containers</p> <code>-2</code> <code>filter_name</code> <code>str</code> <p>filter nodes for specific name (dfault = no filter)</p> <code>''</code> <code>show_hidden</code> <code>bool</code> <p>list also hidden items (default = False)</p> <code>False</code> <code>limit</code> <code>int</code> <p>maximum number of results (default = 100)</p> <code>100</code> <code>page</code> <code>int</code> <p>number of result page (default = 1 = 1st page)</p> <code>1</code> <code>fields</code> <code>str</code> <p>which fields to retrieve. This can have a big impact on performance!</p> <code>'properties'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Subnodes information or None if no node with this parent ID is found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_subnodes(\nself,\nparent_node_id: int,\nfilter_node_types: int = -2,\nfilter_name: str = \"\",\nshow_hidden: bool = False,\nlimit: int = 100,\npage: int = 1,\nfields: str = \"properties\",  # per default we just get the most important information\n) -&gt; dict | None:\n\"\"\"Get a subnodes of a parent node ID.\n    Args:\n        parent_node_id (int) is the node Id of the node\n        filter_node_types (int, optional):\n            -1 get all containers\n            -2 get all searchable objects (default)\n            -3 get all non-containers\n        filter_name (str, optional): filter nodes for specific name (dfault = no filter)\n        show_hidden (bool, optional): list also hidden items (default = False)\n        limit (int, optional): maximum number of results (default = 100)\n        page (int, optional): number of result page (default = 1 = 1st page)\n        fields (str): which fields to retrieve. This can have a big impact on performance!\n    Returns:\n        dict: Subnodes information or None if no node with this parent ID is found.\n    \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {\n\"where_type\": filter_node_types,\n\"limit\": limit,\n}\nif filter_name:\nquery[\"where_name\"] = filter_name\nif show_hidden:\nquery[\"show_hidden\"] = show_hidden\nif page &gt; 1:\nquery[\"page\"] = page\nif fields:\nquery[\"fields\"] = fields\nencodedQuery = urllib.parse.urlencode(query, doseq=True)\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(parent_node_id)\n+ \"/nodes\"\n+ \"?{}\".format(encodedQuery)\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get subnodes of parent node with ID -&gt; %s; calling -&gt; %s\",\nstr(parent_node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get subnodes for parent node with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nparent_node_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_user","title":"<code>get_user(name, show_error=False)</code>","text":"<p>Lookup Extended ECM user based on the name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the user</p> required <code>show_error</code> <code>bool</code> <p>treat as error if user is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user is not found.</p> <code>dict | None</code> <p>The returned information has a structure like this:</p> <code>dict | None</code> <p>{ 'collection': {     'paging': {...},     'sorting': {...} }, 'links': {     'data': {...} }, 'results': [     {         'data':         {             {                 'birth_date': None,                 'business_email': 'pramos@M365x61936377.onmicrosoft.com',                 'business_fax': None,                 'business_phone': None,                 'cell_phone': None,                 'deleted': False,                 'display_language': None,                 'first_name': 'Peter',                 'gender': None,                 'group_id': 8006,                 'home_address_1': None,                 'home_address_2': None,                 'home_fax': None,                 'home_phone': None,                 'id': 8123,                 'initials': None,                 'last_name': 'Ramos',                 'middle_name': None,                 'name': 'pramos',                 'name_formatted': 'Peter Ramos',                 ...                 'photo_id': 13981,                 'photo_url': 'api/v1/members/8123/photo?v=13981.1'                 ...                 'type'; 0,                 'type_name': 'User'                 }         }     } ]</p> <code>dict | None</code> <p>}</p> <code>dict | None</code> <p>To access the (login) name of the first user found use \"results\"\"data\"[\"name\"].</p> <code>dict | None</code> <p>It is easier to use the method get_result_value(response, \"name\", 0)</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_user(self, name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Lookup Extended ECM user based on the name.\n    Args:\n        name (str): name of the user\n        show_error (bool): treat as error if user is not found\n    Returns:\n        dict: User information or None if the user is not found.\n        The returned information has a structure like this:\n        {\n            'collection':\n            {\n                'paging': {...},\n                'sorting': {...}\n            },\n            'links':\n            {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data':\n                    {\n                        {\n                            'birth_date': None,\n                            'business_email': 'pramos@M365x61936377.onmicrosoft.com',\n                            'business_fax': None,\n                            'business_phone': None,\n                            'cell_phone': None,\n                            'deleted': False,\n                            'display_language': None,\n                            'first_name': 'Peter',\n                            'gender': None,\n                            'group_id': 8006,\n                            'home_address_1': None,\n                            'home_address_2': None,\n                            'home_fax': None,\n                            'home_phone': None,\n                            'id': 8123,\n                            'initials': None,\n                            'last_name': 'Ramos',\n                            'middle_name': None,\n                            'name': 'pramos',\n                            'name_formatted': 'Peter Ramos',\n                            ...\n                            'photo_id': 13981,\n                            'photo_url': 'api/v1/members/8123/photo?v=13981.1'\n                            ...\n                            'type'; 0,\n                            'type_name': 'User'\n                            }\n                    }\n                }\n            ]\n        }\n        To access the (login) name of the first user found use [\"results\"][0][\"data\"][\"properties\"][\"name\"].\n        It is easier to use the method get_result_value(response, \"name\", 0)\n    \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\n# type = 0 ==&gt; User\nrequest_url = self.config()[\"membersUrlv2\"] + \"?where_type=0&amp;query={}\".format(\nname\n)\nrequest_header = self.request_form_header()\nlogger.info(\"Get user with name -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get user -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\"User -&gt; %s not found.\", name)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_user_profile","title":"<code>get_user_profile()</code>","text":"<p>Update a defined field for a user profile.    IMPORTANT: this method needs to be called by the authenticated user</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>user profile field</p> required <code>value</code> <code>str</code> <p>new field value</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user couldn't be updated   (e.g. because it doesn't exist).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_user_profile(self) -&gt; dict | None:\n\"\"\"Update a defined field for a user profile.\n       IMPORTANT: this method needs to be called by the authenticated user\n    Args:\n        field (str): user profile field\n        value (str): new field value\n    Returns:\n        dict: User information or None if the user couldn't be updated\n              (e.g. because it doesn't exist).\n    \"\"\"\nrequest_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get profile (settings) for current user; calling -&gt; %s\",\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get profile of current user; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_user_proxies","title":"<code>get_user_proxies(use_v2=False)</code>","text":"<p>Get list of user proxies.    This method needs to be called as the user the proxy is acting for.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_user_proxies(self, use_v2: bool = False) -&gt; dict | None:\n\"\"\"Get list of user proxies.\n       This method needs to be called as the user the proxy is acting for.\n    Args:\n        None\n    Returns:\n        dict: Node information or None if REST call fails.\n    \"\"\"\nif use_v2:\nrequest_url = self.config()[\"membersUrlv2\"] + \"/proxies\"\nelse:\nrequest_url = self.config()[\"membersUrl\"] + \"/proxies\"\nrequest_header = self.request_form_header()\nlogger.info(\"Get proxy users for current user; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get proxy users for current user; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_volume","title":"<code>get_volume(volume_type, timeout=REQUEST_TIMEOUT)</code>","text":"<p>Get Volume information based on the volume type ID.</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>int</code> <p>ID of the volume type</p> required <code>timeout</code> <code>int</code> <p>timeout for the request in seconds</p> <code>REQUEST_TIMEOUT</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Volume Details or None if volume is not found.</p> <code>dict | None</code> <p>\"results\"\"properties\" is the node ID of the volume.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_volume(\nself, volume_type: int, timeout: int = REQUEST_TIMEOUT\n) -&gt; dict | None:\n\"\"\"Get Volume information based on the volume type ID.\n    Args:\n        volume_type (int): ID of the volume type\n        timeout (int, optional): timeout for the request in seconds\n    Returns:\n        dict: Volume Details or None if volume is not found.\n        [\"results\"][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n    \"\"\"\nrequest_url = self.config()[\"volumeUrl\"] + \"/\" + str(volume_type)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get volume type -&gt; %s; calling -&gt; %s\", str(volume_type), request_url\n)\nretries = 0\nwhile True:\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=timeout,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get volume type -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(volume_type),\nresponse.status_code,\nresponse.text,\n)\nreturn None\nexcept requests.exceptions.Timeout:\nif retries &lt;= REQUEST_MAX_RETRIES:\nlogger.warning(\n\"Request timed out. Retrying in %s seconds...\",\nstr(REQUEST_RETRY_DELAY),\n)\nretries += 1\ntime.sleep(REQUEST_RETRY_DELAY)  # Add a delay before retrying\nelse:\nlogger.error(\n\"Failed to get volume type -&gt; %s; timeout error\",\nstr(volume_type),\n)\n# If it fails after REQUEST_MAX_RETRIES retries we let it wait forever\nlogger.warning(\"Turn timeouts off and wait forever...\")\ntimeout = None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_volumes","title":"<code>get_volumes()</code>","text":"<p>Get all Volumes.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Volume Details or None if an error occured.</p> <code>dict | None</code> <p>{ 'links': {     'data': {...} }, 'results': [     {         'data': {             'properties': {                 'advanced_versioning': None,                 'container': True,                 'container_size': 16,                 'create_date': '2023-05-07T23:18:50Z',                 'create_user_id': 1000,                 'description': '',                 'description_multilingual': {'de': '', 'en': '', 'fr': '', 'it': '', 'ja': ''},                 'external_create_date': None,                 'external_identity': '',                 'external_identity_type': '',                 'external_modify_date': None,                 'external_source': '',                 'favorite': False,                 'hidden': False,                 ...                 'id': 2000,                 ...                 'name': 'Enterprise',                 'name_multilingual': {'de': '', 'en': 'Enterprise', 'fr': '', 'it': '', 'ja': ''},                 ...                 'parent_id': -1,                 'type': 141,                 'volume_id': -2000,                 ...             }             ...         }     },     ... ]</p> <code>dict | None</code> <p>}</p> <code>Example</code> <code>dict | None</code> <code>dict | None</code> <p>\"results\"\"data\"[\"id\"] is the node ID of the volume.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_volumes(self) -&gt; dict | None:\n\"\"\"Get all Volumes.\n    Args:\n        None\n    Returns:\n        dict: Volume Details or None if an error occured.\n        {\n            'links': {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data': {\n                        'properties': {\n                            'advanced_versioning': None,\n                            'container': True,\n                            'container_size': 16,\n                            'create_date': '2023-05-07T23:18:50Z',\n                            'create_user_id': 1000,\n                            'description': '',\n                            'description_multilingual': {'de': '', 'en': '', 'fr': '', 'it': '', 'ja': ''},\n                            'external_create_date': None,\n                            'external_identity': '',\n                            'external_identity_type': '',\n                            'external_modify_date': None,\n                            'external_source': '',\n                            'favorite': False,\n                            'hidden': False,\n                            ...\n                            'id': 2000,\n                            ...\n                            'name': 'Enterprise',\n                            'name_multilingual': {'de': '', 'en': 'Enterprise', 'fr': '', 'it': '', 'ja': ''},\n                            ...\n                            'parent_id': -1,\n                            'type': 141,\n                            'volume_id': -2000,\n                            ...\n                        }\n                        ...\n                    }\n                },\n                ...\n            ]\n        }\n        Example:\n        [\"results\"][0][\"data\"][\"properties\"][\"id\"] is the node ID of the volume.\n    \"\"\"\nrequest_url = self.config()[\"volumeUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Get volumes; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get volumes; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_web_report_parameters","title":"<code>get_web_report_parameters(nickname)</code>","text":"<p>Get parameters of a Web Report in Extended ECM. These are defined on the Web Report node     (Properties --&gt; Parameters)</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>str</code> <p>nickname of the Web Reports node.</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>list of Web Report parameters. Each list item is a dict describing the parameter.</p> <p>Structure of the list items:</p> <p>{ \"type\": \"string\", \"parm_name\": \"string\", \"display_text\": \"string\", \"prompt\": true, \"prompt_order\": 0, \"default_value\": null, \"description\": \"string\", \"mandatory\": true</p> <p>}</p> <p>None if the REST call has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_web_report_parameters(self, nickname: str):\n\"\"\"Get parameters of a Web Report in Extended ECM. These are defined on the Web Report node\n        (Properties --&gt; Parameters)\n    Args:\n        nickname (str): nickname of the Web Reports node.\n    Returns:\n        Response: list of Web Report parameters. Each list item is a dict describing the parameter.\n        Structure of the list items:\n        {\n            \"type\": \"string\",\n            \"parm_name\": \"string\",\n            \"display_text\": \"string\",\n            \"prompt\": true,\n            \"prompt_order\": 0,\n            \"default_value\": null,\n            \"description\": \"string\",\n            \"mandatory\": true\n        }\n        None if the REST call has failed.\n    \"\"\"\nrequest_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname + \"/parameters\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Retrieving parameters of Web Report with nickname -&gt; %s; calling -&gt; %s\",\nnickname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\n# Return the \"data\" element which is a list of dict items:\nresult_dict = self.parse_request_response(response)\nlogger.debug(\"Web Report parameters result -&gt; %s\", str(result_dict))\nif not result_dict.get(\"data\"):\nreturn None\nreturn result_dict[\"data\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve parameters of Web Report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnickname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace","title":"<code>get_workspace(node_id)</code>","text":"<p>Get a workspace based on the node ID.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace node information or None if no node with this ID is found.</p> <code>dict | None</code> <p>Example result:</p> <code>dict | None</code> <p>{ 'links': {     'data': {...} }, 'meta_data': {     'properties': {...} }, 'paging': {     'limit': 500,     'page': 1,     'page_total': 1,     'range_max': 1,     'range_min': 1,     'total_count': 1 }, 'results': [     {         'actions': {...},         'data': {             'properties': {                 'volume_id': -2000,                 'id': 36780,                 'parent_id': 13567,                 'owner_user_id': 7240,                 'name': '4600000044 - C.E.B. New York Inc.',                 'type': 848,                 'description': '',                 'create_date': '2023-09-02T11:07:06',                 'create_user_id': 7240,                 'create_user_id': 7240,                 'modify_date': '2023-09-02T11:07:11',                 'modify_user_id': 7240,                 'reserved': False,                 'reserved_user_id': 0,                 'reserved_date': None,                 'order': None,                 'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',                 'hidden': False,                 'mime_type': None,                 'original_id': 0,                 'wnf_wksp_type_id': 16,                 'wnf_wksp_template_id': 15615,                 'size_formatted': '7 Items',                 'type_name': 'Business Workspace',                 'container': True,                 'size': 7,                 ...             }         },         'metadata': {...},         'metadata_order': {...}     } ], 'wksp_info': {     'wksp_type_icon': None }</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace(self, node_id: int) -&gt; dict | None:\n\"\"\"Get a workspace based on the node ID.\n    Args:\n        node_id (int) is the node Id of the workspace\n    Returns:\n        dict: Workspace node information or None if no node with this ID is found.\n        Example result:\n        {\n            'links': {\n                'data': {...}\n            },\n            'meta_data': {\n                'properties': {...}\n            },\n            'paging': {\n                'limit': 500,\n                'page': 1,\n                'page_total': 1,\n                'range_max': 1,\n                'range_min': 1,\n                'total_count': 1\n            },\n            'results': [\n                {\n                    'actions': {...},\n                    'data': {\n                        'properties': {\n                            'volume_id': -2000,\n                            'id': 36780,\n                            'parent_id': 13567,\n                            'owner_user_id': 7240,\n                            'name': '4600000044 - C.E.B. New York Inc.',\n                            'type': 848,\n                            'description': '',\n                            'create_date': '2023-09-02T11:07:06',\n                            'create_user_id': 7240,\n                            'create_user_id': 7240,\n                            'modify_date': '2023-09-02T11:07:11',\n                            'modify_user_id': 7240,\n                            'reserved': False,\n                            'reserved_user_id': 0,\n                            'reserved_date': None,\n                            'order': None,\n                            'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                            'hidden': False,\n                            'mime_type': None,\n                            'original_id': 0,\n                            'wnf_wksp_type_id': 16,\n                            'wnf_wksp_template_id': 15615,\n                            'size_formatted': '7 Items',\n                            'type_name': 'Business Workspace',\n                            'container': True,\n                            'size': 7,\n                            ...\n                        }\n                    },\n                    'metadata': {...},\n                    'metadata_order': {...}\n                }\n            ],\n            'wksp_info': {\n                'wksp_type_icon': None\n            }\n        }\n    \"\"\"\nrequest_url = self.config()[\"businessworkspaces\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace with ID -&gt; %s; calling -&gt; %s\", str(node_id), request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_by_business_object","title":"<code>get_workspace_by_business_object(external_system_name, business_object_type, business_object_id, return_workspace_metadata=False, show_error=False)</code>","text":"<p>Get a workspace based on the business object of an external system.</p> <p>Parameters:</p> Name Type Description Default <code>external_system_name</code> <code>str</code> <p>Name of the connection</p> required <code>business_object_type</code> <code>str</code> <p>type of the Business object, e.g. KNA1 for SAP customers</p> required <code>business_object_id</code> <code>str</code> <p>ID of the business object in the external system</p> required <code>return_workspace_metadata</code> <code>bool</code> <p>Whether or not workspace metadata (categories) should be returned</p> <code>False</code> <code>show_error</code> <code>bool</code> <p>treat as error if node is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace node information or None if no node with this ID is found.</p> <code>dict | None</code> <p>Example result:</p> <code>dict | None</code> <p>{ 'links': {     'data': {...} }, 'meta_data': {     'properties': {...} }, 'paging': {     'limit': 500,     'page': 1,     'page_total': 1,     'range_max': 1,     'range_min': 1,     'total_count': 1 }, 'results': [     {         'actions': {...},         'data': {             'properties': {                 'volume_id': -2000,                 'id': 36780,                 'parent_id': 13567,                 'owner_user_id': 7240,                 'name': '4600000044 - C.E.B. New York Inc.',                 'type': 848,                 'description': '',                 'create_date': '2023-09-02T11:07:06',                 'create_user_id': 7240,                 'create_user_id': 7240,                 'modify_date': '2023-09-02T11:07:11',                 'modify_user_id': 7240,                 'reserved': False,                 'reserved_user_id': 0,                 'reserved_date': None,                 'order': None,                 'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',                 'hidden': False,                 'mime_type': None,                 'original_id': 0,                 'wnf_wksp_type_id': 16,                 'wnf_wksp_template_id': 15615,                 'size_formatted': '7 Items',                 'type_name': 'Business Workspace',                 'container': True,                 'size': 7,                 ...             }         },         'metadata': {...},         'metadata_order': {...}     } ], 'wksp_info': {     'wksp_type_icon': None }</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_by_business_object(\nself,\nexternal_system_name: str,\nbusiness_object_type: str,\nbusiness_object_id: str,\nreturn_workspace_metadata: bool = False,\nshow_error: bool = False,\n) -&gt; dict | None:\n\"\"\"Get a workspace based on the business object of an external system.\n    Args:\n        external_system_name (str): Name of the connection\n        business_object_type (str): type of the Business object, e.g. KNA1 for SAP customers\n        business_object_id (str): ID of the business object in the external system\n        return_workspace_metadata (bool): Whether or not workspace metadata (categories) should be returned\n        show_error (bool): treat as error if node is not found\n    Returns:\n        dict: Workspace node information or None if no node with this ID is found.\n        Example result:\n        {\n            'links': {\n                'data': {...}\n            },\n            'meta_data': {\n                'properties': {...}\n            },\n            'paging': {\n                'limit': 500,\n                'page': 1,\n                'page_total': 1,\n                'range_max': 1,\n                'range_min': 1,\n                'total_count': 1\n            },\n            'results': [\n                {\n                    'actions': {...},\n                    'data': {\n                        'properties': {\n                            'volume_id': -2000,\n                            'id': 36780,\n                            'parent_id': 13567,\n                            'owner_user_id': 7240,\n                            'name': '4600000044 - C.E.B. New York Inc.',\n                            'type': 848,\n                            'description': '',\n                            'create_date': '2023-09-02T11:07:06',\n                            'create_user_id': 7240,\n                            'create_user_id': 7240,\n                            'modify_date': '2023-09-02T11:07:11',\n                            'modify_user_id': 7240,\n                            'reserved': False,\n                            'reserved_user_id': 0,\n                            'reserved_date': None,\n                            'order': None,\n                            'icon': '/cssupport/otsapxecm/wksp_contract_vendor.png',\n                            'hidden': False,\n                            'mime_type': None,\n                            'original_id': 0,\n                            'wnf_wksp_type_id': 16,\n                            'wnf_wksp_template_id': 15615,\n                            'size_formatted': '7 Items',\n                            'type_name': 'Business Workspace',\n                            'container': True,\n                            'size': 7,\n                            ...\n                        }\n                    },\n                    'metadata': {...},\n                    'metadata_order': {...}\n                }\n            ],\n            'wksp_info': {\n                'wksp_type_icon': None\n            }\n        }\n    \"\"\"\nrequest_url = (\nself.config()[\"externalSystem\"]\n+ \"/\"\n+ external_system_name\n+ \"/botypes/\"\n+ business_object_type\n+ \"/boids/\"\n+ business_object_id\n)\nif return_workspace_metadata:\nrequest_url += \"?metadata\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); calling -&gt; %s\",\nexternal_system_name,\nbusiness_object_type,\nbusiness_object_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\nexternal_system_name,\nbusiness_object_type,\nbusiness_object_id,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.info(\n\"Cannot fing workspace via external system -&gt; %s (Business Object Type -&gt; %s; Business Object ID -&gt; %s); status -&gt; %s; error -&gt; %s\",\nexternal_system_name,\nbusiness_object_type,\nbusiness_object_id,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_by_type_and_name","title":"<code>get_workspace_by_type_and_name(type_name='', type_id=None, name='', expanded_view=True)</code>","text":"<p>Lookup workspace based on workspace type and workspace name.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>name of the workspace type</p> <code>''</code> <code>type_id</code> <code>int</code> <p>ID of the workspace_type</p> <code>None</code> <code>name</code> <code>str</code> <p>name of the workspace, if \"\" then deliver all instances                   of the given workspace type</p> <code>''</code> <code>expanded_view</code> <code>bool</code> <p>if 'False' then just search in recently                             accessed business workspace for this name and type                             if 'True' (this is the default) then search in all                             workspaces for this name and type</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace information or None if the workspace is not found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_by_type_and_name(\nself,\ntype_name: str = \"\",\ntype_id: int = None,\nname: str = \"\",\nexpanded_view: bool = True,\n) -&gt; dict | None:\n\"\"\"Lookup workspace based on workspace type and workspace name.\n    Args:\n        type_name (str): name of the workspace type\n        type_id (int, optional): ID of the workspace_type\n        name (str, optional): name of the workspace, if \"\" then deliver all instances\n                              of the given workspace type\n        expanded_view (bool, optional): if 'False' then just search in recently\n                                        accessed business workspace for this name and type\n                                        if 'True' (this is the default) then search in all\n                                        workspaces for this name and type\n    Returns:\n        dict: Workspace information or None if the workspace is not found.\n    \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {\n\"expanded_view\": expanded_view,\n}\nif type_name:\nquery[\"where_workspace_type_name\"] = type_name\nif type_id:\nquery[\"where_workspace_type_id\"] = type_id\nif name:\nquery[\"where_name\"] = name\nencodedQuery = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.config()[\"businessworkspaces\"] + \"?{}\".format(encodedQuery)\nrequest_header = self.request_form_header()\nif name:\nlogger.info(\n\"Get workspace with name -&gt; %s and type -&gt; %s; calling -&gt; %s\",\nname,\ntype_name,\nrequest_url,\n)\nelse:\nlogger.info(\n\"Get all workspace instances of type -&gt; %s; calling -&gt; %s\",\ntype_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif name:\nlogger.warning(\n\"Failed to get workspace -&gt; %s of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\nname,\ntype_name,\nresponse.status_code,\nresponse.text,\n)\nelse:\nlogger.warning(\n\"Failed to get workspace instances of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\ntype_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_create_form","title":"<code>get_workspace_create_form(template_id, external_system_id=None, bo_type=None, bo_id=None, parent_id=None)</code>","text":"<p>Get the Workspace create form.</p> <p>Parameters:</p> Name Type Description Default <code>template_id</code> <code>int</code> <p>ID of the workspace template</p> required <code>external_system_id</code> <code>str</code> <p>identifier of the external system (None if no external system)</p> <code>None</code> <code>bo_type</code> <code>str</code> <p>business object type (None if no external system)</p> <code>None</code> <code>bo_id</code> <code>str</code> <p>business object identifier / key (None if no external system)</p> <code>None</code> <code>parent_id</code> <code>str</code> <p>parent ID of the workspaces. Needs only be specified in special                        cases where workspace location cannot be derived from workspace                        type definition, e.g. sub-workspace</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Create Form data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_create_form(\nself,\ntemplate_id: int,\nexternal_system_id: int = None,\nbo_type: int = None,\nbo_id: int = None,\nparent_id: int = None,\n) -&gt; dict | None:\n\"\"\"Get the Workspace create form.\n    Args:\n        template_id (int): ID of the workspace template\n        external_system_id (str): identifier of the external system (None if no external system)\n        bo_type (str, optional): business object type (None if no external system)\n        bo_id (str, optional): business object identifier / key (None if no external system)\n        parent_id (str, optional): parent ID of the workspaces. Needs only be specified in special\n                                   cases where workspace location cannot be derived from workspace\n                                   type definition, e.g. sub-workspace\n    Returns:\n        dict: Workspace Create Form data or None if the request fails.\n    \"\"\"\nrequest_url = self.config()[\n\"businessworkspacecreateform\"\n] + \"?template_id={}\".format(template_id)\n# Is a parent ID specifified? Then we need to add it to the request URL\nif parent_id is not None:\nrequest_url += \"&amp;parent_id={}\".format(parent_id)\n# Is this workspace connected to a business application / external system?\nif external_system_id and bo_type and bo_id:\nrequest_url += \"&amp;ext_system_id={}\".format(external_system_id)\nrequest_url += \"&amp;bo_type={}\".format(bo_type)\nrequest_url += \"&amp;bo_id={}\".format(bo_id)\nlogger.info(\n\"Use business object connection -&gt; (%s, %s, %s) for workspace template with ID -&gt; %s\",\nstr(external_system_id),\nstr(bo_type),\nstr(bo_id),\nstr(template_id),\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace create form for template with ID -&gt; %s; calling -&gt; %s\",\nstr(template_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get workspace create form for template -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(template_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_instances","title":"<code>get_workspace_instances(type_name='', type_id=None, expanded_view=True)</code>","text":"<p>Get all workspace instances of a given type. This is a convenience    wrapper method for get_workspace_by_type_and_name()</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>name of the workspace type</p> <code>''</code> <code>type_id</code> <code>int</code> <p>ID of the workspace_type</p> <code>None</code> <code>expanded_view</code> <code>bool</code> <p>if 'False' then just search in recently                                accessed business workspace for this name and type                                if 'True' (this is the default) then search in all                                workspaces for this name and type</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Workspace information or None if the workspace is not found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_instances(\nself, type_name: str = \"\", type_id: int = None, expanded_view: bool = True\n):\n\"\"\"Get all workspace instances of a given type. This is a convenience\n       wrapper method for get_workspace_by_type_and_name()\n    Args:\n        type_name (str, optional): name of the workspace type\n        type_id (int, optional): ID of the workspace_type\n        expanded_view (bool, optional): if 'False' then just search in recently\n                                           accessed business workspace for this name and type\n                                           if 'True' (this is the default) then search in all\n                                           workspaces for this name and type\n    Returns:\n        dict: Workspace information or None if the workspace is not found.\n    \"\"\"\n# Omitting the name lets it return all instances of the type:\nreturn self.get_workspace_by_type_and_name(\ntype_name=type_name, type_id=type_id, name=\"\", expanded_view=expanded_view\n)\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_relationships","title":"<code>get_workspace_relationships(workspace_id)</code>","text":"<p>Get the Workspace relationships to other workspaces.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace template</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace relationships or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_relationships(self, workspace_id: int) -&gt; dict | None:\n\"\"\"Get the Workspace relationships to other workspaces.\n    Args:\n        workspace_id (int): ID of the workspace template\n    Returns:\n        dict: Workspace relationships or None if the request fails.\n    \"\"\"\nrequest_url = (\nself.config()[\"businessworkspaces\"]\n+ \"/\"\n+ str(workspace_id)\n+ \"/relateditems\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get related workspaces for workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get related workspaces of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_roles","title":"<code>get_workspace_roles(workspace_id)</code>","text":"<p>Get the Workspace roles.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace template</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Roles data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_roles(self, workspace_id: int) -&gt; dict | None:\n\"\"\"Get the Workspace roles.\n    Args:\n        workspace_id (int): ID of the workspace template\n    Returns:\n        dict: Workspace Roles data or None if the request fails.\n    \"\"\"\nrequest_url = (\nself.config()[\"businessworkspaces\"] + \"/\" + str(workspace_id) + \"/roles\"\n)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Get workspace roles of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get roles of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.get_workspace_types","title":"<code>get_workspace_types(expand_workspace_info=True, expand_templates=True)</code>","text":"<p>Get all workspace types configured in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>expand_workspace_info</code> <code>bool</code> <p>controls if the workspace info                                     is returned as well</p> <code>True</code> <code>expand_workspace_info</code> <code>bool</code> <p>controls if the list of workspace templates                                     per workspace typ is returned as well</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Types or None if the request fails.</p> <code>dict | None</code> <p>Example response:</p> <code>dict | None</code> <p>{ 'links': {     'data': {...} }, 'results': [     {         'data': {             'properties': {                 'rm_enabled': False,                 'templates': [                     {                         'id': 14471,                         'name': 'Campaign',                         'subtype': 848                     },                     ...                 ],                 'wksp_type_id': 35,                 'wksp_type_name': 'Campaign'             },             'wksp_info': {                 'wksp_type_icon': '/appimg/ot_bws/icons/13147%2Esvg?v=161108_84584'             }         }     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def get_workspace_types(\nself, expand_workspace_info: bool = True, expand_templates: bool = True\n) -&gt; dict | None:\n\"\"\"Get all workspace types configured in Extended ECM.\n    Args:\n        expand_workspace_info (bool, optional): controls if the workspace info\n                                                is returned as well\n        expand_workspace_info (bool, optional): controls if the list of workspace templates\n                                                per workspace typ is returned as well\n    Returns:\n        dict: Workspace Types or None if the request fails.\n        Example response:\n        {\n            'links': {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data': {\n                        'properties': {\n                            'rm_enabled': False,\n                            'templates': [\n                                {\n                                    'id': 14471,\n                                    'name': 'Campaign',\n                                    'subtype': 848\n                                },\n                                ...\n                            ],\n                            'wksp_type_id': 35,\n                            'wksp_type_name': 'Campaign'\n                        },\n                        'wksp_info': {\n                            'wksp_type_icon': '/appimg/ot_bws/icons/13147%2Esvg?v=161108_84584'\n                        }\n                    }\n                }\n            ]\n        }\n    \"\"\"\nrequest_url = self.config()[\"businessworkspacetypes\"]\nif expand_templates:\nrequest_url += \"?expand_templates=true\"\nelse:\nrequest_url += \"?expand_templates=false\"\nif expand_workspace_info:\nrequest_url += \"&amp;expand_wksp_info=true\"\nelse:\nrequest_url += \"&amp;expand_wksp_info=false\"\nrequest_header = self.request_form_header()\nlogger.info(\"Get workspace types; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get workspace types; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.hostname","title":"<code>hostname()</code>","text":"<p>Returns the hostname of Extended ECM (e.g. \"otcs\")</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>hostname</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def hostname(self) -&gt; str:\n\"\"\"Returns the hostname of Extended ECM (e.g. \"otcs\")\n    Returns:\n        str: hostname\n    \"\"\"\nreturn self.config()[\"hostname\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_physical_objects_codes","title":"<code>import_physical_objects_codes(file_path, update_existing_codes=True)</code>","text":"<p>Import Physical Objects codes from a config file that is uploaded from the Python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of config file in Python container filesystem</p> required <code>update_existing_codes</code> <code>bool</code> <p>whether or not existing codes should be updated (default = True)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_physical_objects_codes(\nself, file_path: str, update_existing_codes: bool = True\n) -&gt; bool:\n\"\"\"Import Physical Objects codes from a config file that is uploaded from the Python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n        update_existing_codes (bool): whether or not existing codes should be updated (default = True)\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"physicalObjectsUrl\"] + \"/importCodes\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Physical Objects Codes from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\"updateExistingCodes\": update_existing_codes}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Physical Objects Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_physical_objects_locators","title":"<code>import_physical_objects_locators(file_path)</code>","text":"<p>Import Physical Objects locators from a config file that is uploaded from the python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of config file in Python container filesystem</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_physical_objects_locators(self, file_path: str) -&gt; bool:\n\"\"\"Import Physical Objects locators from a config file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"physicalObjectsUrl\"] + \"/importLocators\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Physical Objects Locators from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Physical Objects Locators from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_physical_objects_settings","title":"<code>import_physical_objects_settings(file_path)</code>","text":"<p>Import Physical Objects settings from a config file that is uploaded from the python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of config file in Python container filesystem</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_physical_objects_settings(self, file_path: str) -&gt; bool:\n\"\"\"Import Physical Objects settings from a config file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"physicalObjectsUrl\"] + \"/importSettings\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Physical Objects Settings from server file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Physical Objects settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_records_management_codes","title":"<code>import_records_management_codes(file_path, update_existing_codes=True)</code>","text":"<p>Import RM Codes from a file that is uploaded from the python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of settings file in Python container filesystem</p> required <code>update_existing_codes</code> <code>bool</code> <p>Flag that controls whether existing table maintenance codes                           should be updated.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_records_management_codes(\nself, file_path: str, update_existing_codes: bool = True\n) -&gt; bool:\n\"\"\"Import RM Codes from a file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of settings file in Python container filesystem\n        update_existing_codes (bool): Flag that controls whether existing table maintenance codes\n                                      should be updated.\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/importCodes\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Records Management Codes from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\"updateExistingCodes\": update_existing_codes}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Records Management Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_records_management_rsis","title":"<code>import_records_management_rsis(file_path, update_existing_rsis=True, delete_schedules=False)</code>","text":"<p>Import RM RSIs from a config file that is uploaded from the Python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of config file in Python container filesystem</p> required <code>update_existing_rsis</code> <code>bool</code> <p>whether or not existing RSIs should be updated (or ignored)</p> <code>True</code> <code>delete_schedules</code> <code>bool</code> <p>whether RSI Schedules should be deleted</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_records_management_rsis(\nself,\nfile_path: str,\nupdate_existing_rsis: bool = True,\ndelete_schedules: bool = False,\n) -&gt; bool:\n\"\"\"Import RM RSIs from a config file that is uploaded from the Python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n        update_existing_rsis (bool, optional): whether or not existing RSIs should be updated (or ignored)\n        delete_schedules (bool, optional): whether RSI Schedules should be deleted\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/importRSIs\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Records Management RSIs from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\n\"updateExistingRSIs\": update_existing_rsis,\n\"deleteSchedules\": delete_schedules,\n}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Records Management RSIs from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_records_management_settings","title":"<code>import_records_management_settings(file_path)</code>","text":"<p>Import Records Management settings from a file that is uploaded from the python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of config file in Python container filesystem</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_records_management_settings(self, file_path: str) -&gt; bool:\n\"\"\"Import Records Management settings from a file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/importSettings\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Records Management Settings from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Records Management Settings from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.import_security_clearance_codes","title":"<code>import_security_clearance_codes(file_path, include_users=False)</code>","text":"<p>Import Security Clearance codes from a config file that is uploaded from the python pod</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path + filename of config file in Python container filesystem</p> required <code>include_users</code> <code>bool</code> <p>defines if users should be included or not</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if if the REST call succeeds or False otherwise.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def import_security_clearance_codes(\nself, file_path: str, include_users: bool = False\n) -&gt; bool:\n\"\"\"Import Security Clearance codes from a config file that is uploaded from the python pod\n    Args:\n        file_path (str): path + filename of config file in Python container filesystem\n        include_users (bool): defines if users should be included or not\n    Returns:\n        bool: True if if the REST call succeeds or False otherwise.\n    \"\"\"\nrequest_url = self.config()[\"securityClearancesUrl\"] + \"/importCodes\"\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 400 response\nlogger.info(\n\"Importing Security Clearance Codes from file -&gt; %s; calling -&gt; %s\",\nfile_path,\nrequest_url,\n)\nsettingsPostData = {\"includeusers\": include_users}\nfilename = os.path.basename(file_path)\nif not os.path.exists(file_path):\nlogger.error(\n\"The file -&gt; %s does not exist in path -&gt; %s!\",\nfilename,\nos.path.dirname(file_path),\n)\nreturn False\nsettingsPostFile = {\n\"file\": (filename, open(file=file_path, encoding=\"utf-8\"), \"text/xml\")\n}\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=settingsPostData,\nfiles=settingsPostFile,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to import Security Clearance Codes from file -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.install_cs_application","title":"<code>install_cs_application(application_name)</code>","text":"<p>Install a CS Application (based on WebReports)</p> <p>Parameters:</p> Name Type Description Default <code>application_name</code> <code>str</code> <p>name of the application (e.g. OTPOReports, OTRMReports, OTRMSecReports)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response or None if the installation of the CS Application has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def install_cs_application(self, application_name: str) -&gt; dict | None:\n\"\"\"Install a CS Application (based on WebReports)\n    Args:\n        application_name (str): name of the application (e.g. OTPOReports, OTRMReports, OTRMSecReports)\n    Returns:\n        dict: Response or None if the installation of the CS Application has failed.\n    \"\"\"\ninstallCSApplicationPostData = {\"appName\": application_name}\nrequest_url = self.config()[\"csApplicationsUrl\"] + \"/install\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Install CS Application -&gt; %s; calling -&gt; %s\", application_name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=installCSApplicationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to install CS Application -&gt; %s; status -&gt; %s; error -&gt; %s\",\napplication_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.is_configured","title":"<code>is_configured()</code>","text":"<p>Checks if the Content Server pod is configured to receive requests.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if pod is ready. False if pod is not yet ready.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def is_configured(self) -&gt; bool:\n\"\"\"Checks if the Content Server pod is configured to receive requests.\n    Args:\n        None.\n    Returns:\n        bool: True if pod is ready. False if pod is not yet ready.\n    \"\"\"\nrequest_url = self.config()[\"configuredUrl\"]\nlogger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_JSON_HEADERS,\ntimeout=REQUEST_TIMEOUT,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; warning -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\nlogger.warning(\"OTCS service may not be ready yet.\")\nreturn False\nif not response.ok:\nlogger.warning(\n\"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\nrequest_url,\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.is_proxy","title":"<code>is_proxy(user_name)</code>","text":"<p>Check if a user is defined as proxy of the current user.    This method differentiates between the old (xGov) based    implementation and the new Extended ECM platform one    that was introduced with version 23.4.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> <p>user  to test (login name)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True is user is proxy of current user. False if not.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def is_proxy(self, user_name: str) -&gt; bool:\n\"\"\"Check if a user is defined as proxy of the current user.\n       This method differentiates between the old (xGov) based\n       implementation and the new Extended ECM platform one\n       that was introduced with version 23.4.\n    Args:\n        user_name (str): user  to test (login name)\n    Returns:\n        bool: True is user is proxy of current user. False if not.\n    \"\"\"\nversion_number = self.get_server_version()\n# Split the version number by dot\nparts = version_number.split(\".\")\n# Take the first two parts and join them back with a dot\nstripped_version = \".\".join(parts[:2])\nversion_number = float(stripped_version)\nif version_number &gt;= 23.4:\nresponse = self.get_user_proxies(use_v2=True)\nif self.exist_result_item(\nresponse=response, key=\"name\", value=user_name, property_name=\"\"\n):\nreturn True\nelse:\nreturn False\nelse:\nresponse = self.get_user_proxies(use_v2=False)\nif not response or not \"proxies\" in response:\nreturn False\nproxies = response[\"proxies\"]\nfor proxy in proxies:\nif proxy[\"name\"] == user_name:\nreturn True\nreturn False\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.is_ready","title":"<code>is_ready()</code>","text":"<p>Checks if the Content Server pod is ready to receive requests.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if pod is ready. False if pod is not yet ready.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def is_ready(self) -&gt; bool:\n\"\"\"Checks if the Content Server pod is ready to receive requests.\n    Args:\n        None.\n    Returns:\n        bool: True if pod is ready. False if pod is not yet ready.\n    \"\"\"\nrequest_url = self.config()[\"isReady\"]\nlogger.info(\"Trying to retrieve OTCS URL -&gt; %s\", request_url)\ntry:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_JSON_HEADERS,\ntimeout=2,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; warning -&gt; %s\",\nrequest_url,\nexception.strerror,\n)\nlogger.warning(\"OTCS service may not be ready yet.\")\nreturn False\nif not response.status_code == 200:\nlogger.warning(\n\"Unable to connect to -&gt; %s; status -&gt; %s; warning -&gt; %s\",\nrequest_url,\nresponse.status_code,\nresponse.text,\n)\nreturn False\nreturn True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.lookup_result_value","title":"<code>lookup_result_value(response, key, value, return_key)</code>","text":"<p>Lookup a property value based on a provided key / value pair in the    response properties of an Extended ECM REST API call.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>REST response from an OTCS REST Call</p> required <code>key</code> <code>str</code> <p>property name (key)</p> required <code>value</code> <code>str</code> <p>value to find in the item with the matching key</p> required <code>return_key</code> <code>str</code> <p>determines which value to return based on the name of the dict key</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>value of the property with the key defined in \"return_key\"  or None if the lookup fails</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def lookup_result_value(\nself, response: dict, key: str, value: str, return_key: str\n) -&gt; str | None:\n\"\"\"Lookup a property value based on a provided key / value pair in the\n       response properties of an Extended ECM REST API call.\n    Args:\n        response (dict): REST response from an OTCS REST Call\n        key (str): property name (key)\n        value (str): value to find in the item with the matching key\n        return_key (str): determines which value to return based on the name of the dict key\n    Returns:\n        str: value of the property with the key defined in \"return_key\"\n             or None if the lookup fails\n    \"\"\"\nif not response:\nreturn None\nif not \"results\" in response:\nreturn None\nresults = response[\"results\"]\n# check if results is a list or a dict (both is possible -\n# dependent on the actual REST API):\nif isinstance(results, dict):\n# result is a dict - we don't need index value:\ndata = results[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nelse:\nreturn None\nelif isinstance(data, list):\n# data is a list - this has typically just one item, so we use 0 as index\nfor item in data:\nproperties = item[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nreturn None\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\", str(type(data))\n)\nreturn None\nelif isinstance(results, list):\n# result is a list - we need index value\nfor result in results:\ndata = result[\"data\"]\nif isinstance(data, dict):\n# data is a dict - we don't need index value:\nproperties = data[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nelif isinstance(data, list):\n# data is a list we iterate through the list and try to find the key:\nfor item in data:\nproperties = item[\"properties\"]\nif (\nkey in properties\nand properties[key] == value\nand return_key in properties\n):\nreturn properties[return_key]\nelse:\nlogger.error(\n\"Data needs to be a list or dict but it is -&gt; %s\",\nstr(type(data)),\n)\nreturn None\nreturn None\nelse:\nlogger.error(\n\"Result needs to be a list or dict but it is -&gt; %s\", str(type(results))\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the text property of a request response object to a Python dict in a safe way     that also handles exceptions.</p> <pre><code>Content Server may produce corrupt response when it gets restarted\nor hitting resource limits. So we try to avoid a fatal error and bail\nout more gracefully.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>print a custom error message</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>if True log an error, if False log a warning</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response or None in case of an error</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def parse_request_response(\nself,\nresponse_object: object,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the text property of a request response object to a Python dict in a safe way\n        that also handles exceptions.\n        Content Server may produce corrupt response when it gets restarted\n        or hitting resource limits. So we try to avoid a fatal error and bail\n        out more gracefully.\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str): print a custom error message\n        show_error (bool): if True log an error, if False log a warning\n    Returns:\n        dict: response or None in case of an error\n    \"\"\"\nif not response_object:\nreturn None\ntry:\ndict_object = json.loads(response_object.text)\nexcept json.JSONDecodeError as exception:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, exception\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(\nexception\n)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.register_workspace_template","title":"<code>register_workspace_template(node_id)</code>","text":"<p>Register a workspace template as project template for Extended ECM for Engineering</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>node ID of the Extended ECM workspace template</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of request or None if the registration of the workspace template has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def register_workspace_template(self, node_id: int) -&gt; dict | None:\n\"\"\"Register a workspace template as project template for Extended ECM for Engineering\n    Args:\n        node_id (int): node ID of the Extended ECM workspace template\n    Returns:\n        dict: Response of request or None if the registration of the workspace template has failed.\n    \"\"\"\nregistrationPostData = {\"ids\": \"{{ {} }}\".format(node_id)}\nrequest_url = self.config()[\"xEngProjectTemplateUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\n\"Register workspace template with ID -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=registrationPostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to register Workspace Template with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.remove_member_from_workspace","title":"<code>remove_member_from_workspace(workspace_id, role_id, member_id, show_warning=True)</code>","text":"<p>Remove a member from a workspace role. Check that the user is currently a member.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>role_id</code> <code>int</code> <p>ID of the role</p> required <code>member_id</code> <code>int</code> <p>User or Group Id</p> required <code>show_warning</code> <code>bool</code> <p>if True shows a warning if member is not in role</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Workspace Role Membership or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def remove_member_from_workspace(\nself, workspace_id: int, role_id: int, member_id: int, show_warning: bool = True\n) -&gt; dict | None:\n\"\"\"Remove a member from a workspace role. Check that the user is currently a member.\n    Args:\n        workspace_id (int): ID of the workspace\n        role_id (int): ID of the role\n        member_id (int): User or Group Id\n        show_warning (bool, optional): if True shows a warning if member is not in role\n    Returns:\n        dict: Workspace Role Membership or None if the request fails.\n    \"\"\"\nrequest_url = self.config()[\n\"businessworkspaces\"\n] + \"/{}/roles/{}/members\".format(workspace_id, role_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Check if user/group with ID -&gt; %s is in role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nworkspaceMembershipResponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not workspaceMembershipResponse.ok:\nlogger.error(\n\"Failed to get workspace members; status -&gt; %s; error -&gt; %s\",\nworkspaceMembershipResponse.status_code,\nworkspaceMembershipResponse.text,\n)\nreturn None\nworkspace_members = self.parse_request_response(workspaceMembershipResponse)\nif not self.exist_result_item(workspace_members, \"id\", member_id):\nif show_warning:\nlogger.warning(\n\"User/group with ID -&gt; %s is not a member of role with ID -&gt; %s of workspace with ID -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\n)\nreturn None\nrequest_url = self.config()[\n\"businessworkspaces\"\n] + \"/{}/roles/{}/members/{}\".format(workspace_id, role_id, member_id)\nlogger.info(\n\"Removing user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nrequest_url,\n)\nworkspaceMembershipResponse = requests.delete(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif workspaceMembershipResponse.ok:\nreturn self.parse_request_response(workspaceMembershipResponse)\nelse:\nlogger.error(\n\"Failed to remove user/group with ID -&gt; %s from role with ID -&gt; %s of workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(member_id),\nstr(role_id),\nstr(workspace_id),\nworkspaceMembershipResponse.status_code,\nworkspaceMembershipResponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.rename_node","title":"<code>rename_node(node_id, name, description, name_multilingual=None, description_multilingual=None)</code>","text":"<p>Change the name and description of a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node. You can use the get_volume() function below to                to the node id for a volume.</p> required <code>name</code> <code>str</code> <p>New name of the node.</p> required <code>description</code> <code>str</code> <p>New description of the node.</p> required <code>name_multilingual</code> <code>dict</code> <p>multi-lingual node names</p> <code>None</code> <code>description_multilingual</code> <code>dict</code> <p>multi-lingual description</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the renaming fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def rename_node(\nself,\nnode_id: int,\nname: str,\ndescription: str,\nname_multilingual: dict | None = None,\ndescription_multilingual: dict | None = None,\n) -&gt; dict | None:\n\"\"\"Change the name and description of a node.\n    Args:\n        node_id (int): ID of the node. You can use the get_volume() function below to\n                           to the node id for a volume.\n        name (str): New name of the node.\n        description (str): New description of the node.\n        name_multilingual (dict, optional): multi-lingual node names\n        description_multilingual (dict, optional): multi-lingual description\n    Returns:\n        dict: Request response or None if the renaming fails.\n    \"\"\"\nrenameNodePutBody = {\"name\": name, \"description\": description}\nif name_multilingual:\nrenameNodePutBody[\"name_multilingual\"] = name_multilingual\nif description_multilingual:\nrenameNodePutBody[\"description_multilingual\"] = description_multilingual\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Renaming node with ID -&gt; %s to -&gt; %s; calling -&gt; %s\",\nstr(node_id),\nname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(renameNodePutBody)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to rename node with ID -&gt; %s to -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(node_id),\nname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.replace_transport_placeholders","title":"<code>replace_transport_placeholders(zip_file_path, replacements)</code>","text":"<p>Search and replace strings in the XML files of the transport packlage</p> <p>Parameters:</p> Name Type Description Default <code>zip_file_path</code> <code>str</code> <p>path to transport zip file</p> required <code>replacements</code> <code>list of dicts</code> <p>list of replacement values; dict needs to have two values:                          * placeholder: text to replace                          * value: text to replace with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Filename to the updated zip file</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def replace_transport_placeholders(\nself, zip_file_path: str, replacements: list\n) -&gt; bool:\n\"\"\"Search and replace strings in the XML files of the transport packlage\n    Args:\n        zip_file_path (str): path to transport zip file\n        replacements (list of dicts): list of replacement values; dict needs to have two values:\n                                     * placeholder: text to replace\n                                     * value: text to replace with\n    Returns:\n        Filename to the updated zip file\n    \"\"\"\nif not os.path.isfile(zip_file_path):\nlogger.error(\"Zip file -&gt; %s not found.\", zip_file_path)\nreturn False\n# Extract the zip file to a temporary directory\nzip_file_folder = os.path.splitext(zip_file_path)[0]\nwith zipfile.ZipFile(zip_file_path, \"r\") as zfile:\nzfile.extractall(zip_file_folder)\nmodified = False\n# Replace search pattern with replace string in all XML files in the directory and its subdirectories\nfor replacement in replacements:\nif not \"value\" in replacement:\nlogger.error(\n\"Replacement needs a value but it is not specified. Skipping...\"\n)\ncontinue\nif \"enabled\" in replacement and not replacement[\"enabled\"]:\nlogger.info(\n\"Replacement for transport -&gt; %s is disabled. Skipping...\",\nzip_file_path,\n)\ncontinue\n# there are two types of replacements:\n# 1. XPath - more elegant and powerful\n# 2. Search &amp; Replace - basically treat the XML file like a text file and do a search &amp; replace\nif \"xpath\" in replacement:\nlogger.info(\n\"Using xpath -&gt; %s to narrow down the replacement\",\nreplacement[\"xpath\"],\n)\nif \"setting\" in replacement:\nlogger.info(\n\"Looking up setting -&gt; %s in XML element\",\nreplacement[\"setting\"],\n)\nif \"assoc_elem\" in replacement:\nlogger.info(\n\"Looking up assoc element -&gt; %s in XML element\",\nreplacement[\"assoc_elem\"],\n)\nelse:  # we have a simple \"search &amp; replace\" replacement\nif not \"placeholder\" in replacement:\nlogger.error(\n\"Replacement without an xpath needs a placeholder value but it is not specified. Skipping...\"\n)\ncontinue\nif replacement.get(\"placeholder\") == replacement[\"value\"]:\nlogger.info(\n\"Placeholder and replacement are identical -&gt; %s. Skipping...\",\nreplacement[\"value\"],\n)\ncontinue\nlogger.info(\n\"Replace -&gt; %s with -&gt; %s in Transport package -&gt; %s\",\nreplacement[\"placeholder\"],\nreplacement[\"value\"],\nzip_file_folder,\n)\nfound = XML.replace_in_xml_files(\nzip_file_folder,\nreplacement.get(\"placeholder\"),\nreplacement[\"value\"],\nreplacement.get(\"xpath\"),\nreplacement.get(\"setting\"),\nreplacement.get(\"assoc_elem\"),\n)\nif found:\nlogger.info(\n\"Replacement -&gt; %s has been completed successfully for Transport package -&gt; %s\",\nreplacement,\nzip_file_folder,\n)\nmodified = True\nelse:\nlogger.warning(\n\"Replacement -&gt; %s not found in Transport package -&gt; %s\",\nreplacement,\nzip_file_folder,\n)\nif not modified:\nlogger.warning(\n\"None of the specified replacements have been found in Transport package -&gt; %s. No need to create a new transport package.\",\nzip_file_folder,\n)\nreturn False\n# Create the new zip file and add all files from the directory to it\nnew_zip_file_path = (\nos.path.dirname(zip_file_path) + \"/new_\" + os.path.basename(zip_file_path)\n)\nlogger.info(\n\"Content of transport -&gt; %s has been modified - repacking to new zip file -&gt; %s\",\nzip_file_folder,\nnew_zip_file_path,\n)\nwith zipfile.ZipFile(new_zip_file_path, \"w\", zipfile.ZIP_DEFLATED) as zip_ref:\nfor subdir, _, files in os.walk(\nzip_file_folder\n):  # 2nd parameter is not used, thus using _ instead of dirs\nfor file in files:\nfile_path = os.path.join(subdir, file)\nrel_path = os.path.relpath(file_path, zip_file_folder)\nzip_ref.write(file_path, arcname=rel_path)\n# Close the new zip file and delete the temporary directory\nzip_ref.close()\nold_zip_file_path = (\nos.path.dirname(zip_file_path) + \"/old_\" + os.path.basename(zip_file_path)\n)\nlogger.info(\n\"Rename orginal transport zip file -&gt; %s to -&gt; %s\",\nzip_file_path,\nold_zip_file_path,\n)\nos.rename(zip_file_path, old_zip_file_path)\nlogger.info(\n\"Rename new transport zip file -&gt; %s to -&gt; %s\",\nnew_zip_file_path,\nzip_file_path,\n)\nos.rename(new_zip_file_path, zip_file_path)\n# Return the path to the new zip file\nreturn True\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.request_download_header","title":"<code>request_download_header()</code>","text":"<p>Deliver the request header used for the CRUD REST API calls.    Consists of Cookie + Form Headers (see global vasriable)</p> Return <p>dict: request header values</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def request_download_header(self) -&gt; dict:\n\"\"\"Deliver the request header used for the CRUD REST API calls.\n       Consists of Cookie + Form Headers (see global vasriable)\n    Args:\n        None.\n    Return:\n        dict: request header values\n    \"\"\"\n# create union of two dicts: cookie and headers\n# (with Python 3.9 this would be easier with the \"|\" operator)\nrequest_header = {}\nrequest_header.update(self.cookie())\nrequest_header.update(REQUEST_DOWNLOAD_HEADERS)\nreturn request_header\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.request_form_header","title":"<code>request_form_header()</code>","text":"<p>Deliver the request header used for the CRUD REST API calls.    Consists of Cookie + Form Headers (see global variable)</p> Return <p>dict: request header values</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def request_form_header(self) -&gt; dict:\n\"\"\"Deliver the request header used for the CRUD REST API calls.\n       Consists of Cookie + Form Headers (see global variable)\n    Args:\n        None.\n    Return:\n        dict: request header values\n    \"\"\"\n# create union of two dicts: cookie and headers\n# (with Python 3.9 this would be easier with the \"|\" operator)\nrequest_header = {}\nrequest_header.update(self.cookie())\nrequest_header.update(REQUEST_FORM_HEADERS)\nreturn request_header\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.request_json_header","title":"<code>request_json_header()</code>","text":"<p>Deliver the request header for REST calls that require content type application/json.    Consists of Cookie + Json Headers (see global variable)</p> Return <p>dict: request header values</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def request_json_header(self) -&gt; dict:\n\"\"\"Deliver the request header for REST calls that require content type application/json.\n       Consists of Cookie + Json Headers (see global variable)\n    Args:\n        None.\n    Return:\n        dict: request header values\n    \"\"\"\n# create union of two dicts: cookie and headers\n# (with Python 3.9 this would be easier with the \"|\" operator)\nrequest_header = {}\nrequest_header.update(self.cookie())\nrequest_header.update(REQUEST_JSON_HEADERS)\nreturn request_header\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.rest_url","title":"<code>rest_url()</code>","text":"<p>Returns the REST URL of Extended ECM</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>REST URL</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def rest_url(self) -&gt; str:\n\"\"\"Returns the REST URL of Extended ECM\n    Returns:\n        str: REST URL\n    \"\"\"\nreturn self.config()[\"restUrl\"]\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.run_web_report","title":"<code>run_web_report(nickname, web_report_parameters=None)</code>","text":"<p>Run a Web Report that is identified by its nick name.</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>str</code> <p>nickname of the Web Reports node.</p> required <code>web_report_parameters</code> <code>dict</code> <p>Parameters of the Web Report (names + value pairs)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of the run Web Report request or None if the Web Report execution has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def run_web_report(\nself, nickname: str, web_report_parameters: dict | None = None\n) -&gt; dict | None:\n\"\"\"Run a Web Report that is identified by its nick name.\n    Args:\n        nickname (str): nickname of the Web Reports node.\n        web_report_parameters (dict): Parameters of the Web Report (names + value pairs)\n    Returns:\n        dict: Response of the run Web Report request or None if the Web Report execution has failed.\n    \"\"\"\n# Avoid linter warning W0102:\nif web_report_parameters is None:\nweb_report_parameters = {}\nrequest_url = self.config()[\"webReportsUrl\"] + \"/\" + nickname\nrequest_header = self.request_form_header()\nlogger.info(\n\"Running Web Report with nickname -&gt; %s; calling -&gt; %s\",\nnickname,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=web_report_parameters,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to run web report with nickname -&gt; %s; status -&gt; %s; error -&gt; %s\",\nnickname,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.search","title":"<code>search(search_term, look_for='complexQuery', modifier='', slice_id=0, query_id=0, template_id=0, limit=100, page=1)</code>","text":"<p>Search for a search term.</p> <p>Parameters:</p> Name Type Description Default <code>search_term</code> <code>str), e.g. \"test or OTSubType</code> <p>189\"</p> required <code>look_for</code> <code>str</code> <p>'allwords', 'anywords', 'exactphrase', and 'complexquery'.                       If not specified, it defaults to 'complexQuery'.</p> <code>'complexQuery'</code> <code>modifier</code> <code>str</code> <p>'synonymsof', 'relatedto', 'soundslike', 'wordbeginswith',                       and 'wordendswith'.                       If not specified or specify any value other than the available options,                       it will be ignored.</p> <code>''</code> <code>slice_id</code> <code>int</code> <p>ID of an existing search slice</p> <code>0</code> <code>query_id</code> <code>int</code> <p>ID of an saved search query</p> <code>0</code> <code>template_id</code> <code>int</code> <p>ID of an saved search template</p> <code>0</code> <code>limit</code> <code>int</code> <p>maximum number of results (default = 100)</p> <code>100</code> <code>page</code> <code>int</code> <p>number of result page (default = 1 = 1st page)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>search response or None if the search fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def search(\nself,\nsearch_term: str,\nlook_for: str = \"complexQuery\",\nmodifier: str = \"\",\nslice_id: int = 0,\nquery_id: int = 0,\ntemplate_id: int = 0,\nlimit: int = 100,\npage: int = 1,\n) -&gt; dict | None:\n\"\"\"Search for a search term.\n    Args:\n        search_term (str), e.g. \"test or OTSubType: 189\"\n        look_for (str, optional): 'allwords', 'anywords', 'exactphrase', and 'complexquery'.\n                                  If not specified, it defaults to 'complexQuery'.\n        modifier (str, optional): 'synonymsof', 'relatedto', 'soundslike', 'wordbeginswith',\n                                  and 'wordendswith'.\n                                  If not specified or specify any value other than the available options,\n                                  it will be ignored.\n        slice_id (int, optional): ID of an existing search slice\n        query_id (int, optional): ID of an saved search query\n        template_id (int, optional): ID of an saved search template\n        limit (int, optional): maximum number of results (default = 100)\n        page (int, optional): number of result page (default = 1 = 1st page)\n    Returns:\n        dict: search response or None if the search fails.\n    \"\"\"\nsearchPostBody = {\n\"where\": search_term,\n\"lookfor\": look_for,\n\"page\": page,\n\"limit\": limit,\n}\nif modifier:\nsearchPostBody[\"modifier\"] = modifier\nif slice_id &gt; 0:\nsearchPostBody[\"slice_id\"] = slice_id\nif query_id &gt; 0:\nsearchPostBody[\"query_id\"] = query_id\nif template_id &gt; 0:\nsearchPostBody[\"template_id\"] = template_id\nrequest_url = self.config()[\"searchUrl\"]\nrequest_header = self.request_form_header()\nlogger.info(\"Search for term -&gt; %s; calling -&gt; %s\", search_term, request_url)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=searchPostBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to search for term -&gt; %s; status -&gt; %s; error -&gt; %s\",\nsearch_term,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.search_user","title":"<code>search_user(value, field='where_name')</code>","text":"<p>Find a user based on search criteria.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>field value</p> required <code>field</code> <code>str</code> <p>user field to search with (where_name, where_first_name, where_last_name)</p> <code>'where_name'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user couldn't be found (e.g. because it doesn't exist).</p> <code>Example</code> <code>dict | None</code> <code>dict | None</code> <p>{ 'collection': {     'paging': {...},     'sorting': {...} }, 'links': {     'data': {...} }, 'results': [     {         'data': {             'properties': {                 'birth_date': None,                 'business_email': 'dfoxhoven@M365x61936377.onmicrosoft.com',                 'business_fax': None,                 'business_phone': None,                 'cell_phone': None,                 'deleted': False,                 'display_language': None,                 'first_name': 'Deke',                 'gender': None,                 'group_id': 8005,                 'home_address_1': None,                 'home_address_2': None,                 'home_fax': None,                 'home_phone': None,                 'id': 8562,                 'initials': 'DF',                 'last_name': 'Foxhoven',                 'middle_name': None,                 'name': 'dfoxhoven',                 'name_formatted': 'Deke Foxhoven',                 ...             }         }     } ]</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def search_user(self, value: str, field: str = \"where_name\") -&gt; dict | None:\n\"\"\"Find a user based on search criteria.\n    Args:\n        value (str): field value\n        field (str): user field to search with (where_name, where_first_name, where_last_name)\n    Returns:\n        dict: User information or None if the user couldn't be found (e.g. because it doesn't exist).\n        Example:\n        {\n            'collection': {\n                'paging': {...},\n                'sorting': {...}\n            },\n            'links': {\n                'data': {...}\n            },\n            'results': [\n                {\n                    'data': {\n                        'properties': {\n                            'birth_date': None,\n                            'business_email': 'dfoxhoven@M365x61936377.onmicrosoft.com',\n                            'business_fax': None,\n                            'business_phone': None,\n                            'cell_phone': None,\n                            'deleted': False,\n                            'display_language': None,\n                            'first_name': 'Deke',\n                            'gender': None,\n                            'group_id': 8005,\n                            'home_address_1': None,\n                            'home_address_2': None,\n                            'home_fax': None,\n                            'home_phone': None,\n                            'id': 8562,\n                            'initials': 'DF',\n                            'last_name': 'Foxhoven',\n                            'middle_name': None,\n                            'name': 'dfoxhoven',\n                            'name_formatted': 'Deke Foxhoven',\n                            ...\n                        }\n                    }\n                }\n            ]\n        }\n    \"\"\"\nrequest_url = self.config()[\"membersUrlv2\"] + \"?\" + field + \"=\" + value\nrequest_header = self.request_form_header()\nlogger.info(\n\"Searching user by field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\nfield,\nvalue,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Cannot find user with -&gt; %s = %s; status -&gt; %s; error -&gt; %s\",\nfield,\nvalue,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.set_category_value","title":"<code>set_category_value(node_id, value, category_id, attribute_id, set_id=0, set_row=1)</code>","text":"<p>Set a value to a specific attribute in a category. Categories and have sets (groupings), multi-line sets (matrix),    and multi-value attributes (list of values). This method supports all variants.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node</p> required <code>value</code> <code>multi-typed</code> <p>value to be set - can be string or list of strings (for multi-value attributes)</p> required <code>category_id</code> <code>int</code> <p>ID of the category object</p> required <code>attribute_id</code> <code>int</code> <p>ID of the attribute</p> required <code>set_id</code> <code>int</code> <p>ID of the set. Defaults to 0.</p> <code>0</code> <code>set_row</code> <code>int</code> <p>Row of . Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>REST API response or None if the call fails</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def set_category_value(\nself,\nnode_id: int,\nvalue,\ncategory_id: int,\nattribute_id: int,\nset_id: int = 0,\nset_row: int = 1,\n) -&gt; dict | None:\n\"\"\"Set a value to a specific attribute in a category. Categories and have sets (groupings), multi-line sets (matrix),\n       and multi-value attributes (list of values). This method supports all variants.\n    Args:\n        node_id (int): ID of the node\n        value (multi-typed): value to be set - can be string or list of strings (for multi-value attributes)\n        category_id (int):ID of the category object\n        attribute_id (int): ID of the attribute\n        set_id (int, optional): ID of the set. Defaults to 0.\n        set_row (int, optional): Row of . Defaults to 1.\n    Returns:\n        dict: REST API response or None if the call fails\n    \"\"\"\nrequest_url = (\nself.config()[\"nodesUrlv2\"]\n+ \"/\"\n+ str(node_id)\n+ \"/categories/\"\n+ str(category_id)\n)\nrequest_header = self.request_form_header()\nif set_id:\nlogger.info(\n\"Assign value -&gt; %s to category with ID -&gt; %s, set ID -&gt; %s, row -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\nstr(value),\nstr(category_id),\nstr(set_id),\nstr(set_row),\nstr(attribute_id),\nstr(node_id),\nrequest_url,\n)\ncategoryPutData = {\n\"category_id\": category_id,\n\"{}_{}_{}_{}\".format(category_id, set_id, set_row, attribute_id): value,\n}\nelse:\nlogger.info(\n\"Assign value -&gt; %s to category ID -&gt; %s, attribute ID -&gt; %s on node with ID -&gt; %s; calling -&gt; %s\",\nstr(value),\nstr(category_id),\nstr(attribute_id),\nstr(node_id),\nrequest_url,\n)\ncategoryPutData = {\n\"category_id\": category_id,\n\"{}_{}\".format(category_id, attribute_id): value,\n}\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata=categoryPutData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set value -&gt; %s for category with ID -&gt; %s, attribute ID -&gt; %s on node ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(value),\nstr(category_id),\nstr(attribute_id),\nstr(node_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.set_credentials","title":"<code>set_credentials(username='admin', password='')</code>","text":"<p>Set the credentials for Extended ECM for the based on user name and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username. Defaults to \"admin\".</p> <code>'admin'</code> <code>password</code> <code>str</code> <p>Password of the user. Defaults to \"\".</p> <code>''</code> Source code in <code>pyxecm/otcs.py</code> <pre><code>def set_credentials(self, username: str = \"admin\", password: str = \"\"):\n\"\"\"Set the credentials for Extended ECM for the based on user name and password.\n    Args:\n        username (str, optional): Username. Defaults to \"admin\".\n        password (str, optional): Password of the user. Defaults to \"\".\n    \"\"\"\nself.config()[\"username\"] = username\nself.config()[\"password\"] = password\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.set_hostname","title":"<code>set_hostname(hostname)</code>","text":"<p>Sets the hostname of Extended ECM</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>new hostname</p> required Source code in <code>pyxecm/otcs.py</code> <pre><code>def set_hostname(self, hostname: str):\n\"\"\"Sets the hostname of Extended ECM\n    Args:\n        hostname (str): new hostname\n    \"\"\"\nself.config()[\"hostname\"] = hostname\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.unpack_transport_package","title":"<code>unpack_transport_package(package_id, workbench_id)</code>","text":"<p>Unpack an existing Transport Package into an existing Workbench.</p> <p>Parameters:</p> Name Type Description Default <code>package_id</code> <code>int</code> <p>ID of package to be unpacked</p> required <code>workbench_id</code> <code>int</code> <p>ID of target workbench</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Unpack response or None if the unpacking fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def unpack_transport_package(\nself, package_id: int, workbench_id: int\n) -&gt; dict | None:\n\"\"\"Unpack an existing Transport Package into an existing Workbench.\n    Args:\n        package_id (int): ID of package to be unpacked\n        workbench_id (int): ID of target workbench\n    Returns:\n        dict: Unpack response or None if the unpacking fails.\n    \"\"\"\nunpackPackagePostData = {\"workbench_id\": workbench_id}\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(package_id) + \"/unpack\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Unpack transport package with ID -&gt; %s into workbench with ID -&gt; %s; calling -&gt; %s\",\nstr(package_id),\nstr(workbench_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=unpackPackagePostData,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to unpack package -&gt; %s; to workbench -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(package_id),\nstr(workbench_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_item","title":"<code>update_item(node_id, parent_id=0, item_name='', item_description='')</code>","text":"<p>Update an Extended ECM item (parent, name, description). Changing the parent ID is    a move operation. If parent ID = 0 the item will not be moved.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node</p> required <code>parent_id</code> <code>int</code> <p>node ID of the new parent (move operation)</p> <code>0</code> <code>item_name</code> <code>str</code> <p>new name of the item</p> <code>''</code> <code>item_description</code> <code>str</code> <p>new description of the item</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Response of the update item request or None if the REST call has failed.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_item(\nself,\nnode_id: int,\nparent_id: int = 0,\nitem_name: str = \"\",\nitem_description: str = \"\",\n) -&gt; dict | None:\n\"\"\"Update an Extended ECM item (parent, name, description). Changing the parent ID is\n       a move operation. If parent ID = 0 the item will not be moved.\n    Args:\n        node_id (int): ID of the node\n        parent_id (int): node ID of the new parent (move operation)\n        item_name (str): new name of the item\n        item_description (str): new description of the item\n    Returns:\n        dict: Response of the update item request or None if the REST call has failed.\n    \"\"\"\nupdateItemPutData = {\n\"name\": item_name,\n\"description\": item_description,\n}\nif parent_id:\n# this is a move operation\nupdateItemPutData[\"parent_id\"] = parent_id\nrequest_url = self.config()[\"nodesUrlv2\"] + \"/\" + str(node_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Update item -&gt; %s with data -&gt; %s; calling -&gt; %s\",\nitem_name,\nstr(updateItemPutData),\nrequest_url,\n)\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(updateItemPutData)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update item -&gt; %s; status -&gt; %s; error -&gt; %s\",\nitem_name,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_records_management_codes","title":"<code>update_records_management_codes(rm_codes)</code>","text":"<p>Update Records Management Codes. These are the most basic data types of    the Records Management configuration and required to create RSIs and    other higher-level Records Management configurations    THIS METHOD IS CURRENTLY NOT WORKING</p> <p>Parameters:</p> Name Type Description Default <code>rm_codes</code> <code>dict</code> <p>Codes to be updated</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>RSI data or None if the request fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_records_management_codes(self, rm_codes: dict) -&gt; dict | None:\n\"\"\"Update Records Management Codes. These are the most basic data types of\n       the Records Management configuration and required to create RSIs and\n       other higher-level Records Management configurations\n       THIS METHOD IS CURRENTLY NOT WORKING\n    Args:\n        rm_codes (dict): Codes to be updated\n    Returns:\n        dict: RSI data or None if the request fails.\n    \"\"\"\nupdateRMCodesPostData = {}\nrequest_url = self.config()[\"recordsManagementUrl\"] + \"/rmcodes\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Update Records Management codes -&gt; %s; calling -&gt; %s\",\nstr(rm_codes),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\nheaders=request_header,\ndata=updateRMCodesPostData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nrm_codes_dict = self.parse_request_response(response)\nreturn rm_codes_dict[\"results\"][\"data\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update Records Management codes; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_user","title":"<code>update_user(user_id, field, value)</code>","text":"<p>Update a defined field for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>value</code> <code>str</code> <p>field value</p> required <code>field</code> <code>str</code> <p>user field</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user couldn't be updated (e.g. because it doesn't exist).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_user(self, user_id: int, field: str, value: str) -&gt; dict | None:\n\"\"\"Update a defined field for a user.\n    Args:\n        user_id (int): ID of the user\n        value (str): field value\n        field (str): user field\n    Returns:\n        dict: User information or None if the user couldn't be updated (e.g. because it doesn't exist).\n    \"\"\"\nuserPutBody = {field: value}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/\" + str(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Updating user with ID -&gt; %s, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\nstr(user_id),\nfield,\nvalue,\nrequest_url,\n)\nlogger.debug(\"User Attributes -&gt; %s\", str(userPutBody))\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata=userPutBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_user_photo","title":"<code>update_user_photo(user_id, photo_id)</code>","text":"<p>Update a user with a profile photo (which must be an existing node).</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID of the user</p> required <code>photo_id</code> <code>int</code> <p>Node ID of the photo</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if photo node is not found.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_user_photo(self, user_id: int, photo_id: int) -&gt; dict | None:\n\"\"\"Update a user with a profile photo (which must be an existing node).\n    Args:\n        user_id (int): ID of the user\n        photo_id (int): Node ID of the photo\n    Returns:\n        dict: Node information or None if photo node is not found.\n    \"\"\"\nupdateUserPutBody = {\"photo_id\": photo_id}\nrequest_url = self.config()[\"membersUrl\"] + \"/\" + str(user_id)\nrequest_header = self.request_form_header()\nlogger.info(\n\"Update user ID -&gt; %s with photo ID -&gt; %s; calling -&gt; %s\",\nuser_id,\nphoto_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\ndata=updateUserPutBody,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(user_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_user_profile","title":"<code>update_user_profile(field, value, config_section='SmartUI')</code>","text":"<p>Update a defined field for a user profile.    IMPORTANT: this method needs to be called by the authenticated user</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>user profile field</p> required <code>value</code> <code>str</code> <p>new field value</p> required <code>config_section</code> <code>str</code> <p>name of the config section. Possible config_section values:                             * SmartUI                             * General                             * Colors                             * ContentIntelligence                             * Discussion                             * Follow Up                             * Template Workspaces                             * Workflow                             * XECMGOVSettings                             * CommunitySettings                             * RecMan                             * PhysObj</p> <code>'SmartUI'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>User information or None if the user couldn't be updated   (e.g. because it doesn't exist).</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_user_profile(\nself, field: str, value: str, config_section: str = \"SmartUI\"\n) -&gt; dict | None:\n\"\"\"Update a defined field for a user profile.\n       IMPORTANT: this method needs to be called by the authenticated user\n    Args:\n        field (str): user profile field\n        value (str): new field value\n        config_section (str, optional): name of the config section. Possible config_section values:\n                                        * SmartUI\n                                        * General\n                                        * Colors\n                                        * ContentIntelligence\n                                        * Discussion\n                                        * Follow Up\n                                        * Template Workspaces\n                                        * Workflow\n                                        * XECMGOVSettings\n                                        * CommunitySettings\n                                        * RecMan\n                                        * PhysObj\n    Returns:\n        dict: User information or None if the user couldn't be updated\n              (e.g. because it doesn't exist).\n    \"\"\"\nuserProfilePutBody = {config_section: {field: value}}\nrequest_url = self.config()[\"membersUrlv2\"] + \"/preferences\"\nrequest_header = self.request_form_header()\nlogger.info(\n\"Updating profile for current user, field -&gt; %s, value -&gt; %s; calling -&gt; %s\",\nfield,\nvalue,\nrequest_url,\n)\nlogger.debug(\"User Attributes -&gt; %s\", str(userProfilePutBody))\nretries = 0\nwhile True:\n# This REST API needs a special treatment: we encapsulate the payload as JSON into a \"body\" tag.\nresponse = requests.put(\nurl=request_url,\ndata={\"body\": json.dumps(userProfilePutBody)},\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update profile of current user; status -&gt; %s; error -&gt; %s\",\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_workspace_aviator","title":"<code>update_workspace_aviator(workspace_id, status)</code>","text":"<p>Enable or disable the Content Aviator for a workspace</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>node ID of the workspace</p> required <code>status</code> <code>bool</code> <p>True = enable, False = disable Content Aviator for this workspace</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>REST response or None if the REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_workspace_aviator(\nself,\nworkspace_id: int,\nstatus: bool,\n) -&gt; dict | None:\n\"\"\"Enable or disable the Content Aviator for a workspace\n    Args:\n        workspace_id (int): node ID of the workspace\n        status (bool): True = enable, False = disable Content Aviator for this workspace\n    Returns:\n        dict: REST response or None if the REST call fails.\n    \"\"\"\naviatorStatusPutData = {\n\"enabled\": status,\n}\nrequest_url = self.config()[\"aiUrl\"] + \"/{}\".format(workspace_id)\nrequest_header = self.request_form_header()\nif status is True:\nlogger.info(\n\"Enable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nelse:\nlogger.info(\n\"Disable Content Aviator for workspace with ID -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\nheaders=request_header,\ndata=aviatorStatusPutData,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to change status for Content Aviator on workspace with ID -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.update_workspace_icon","title":"<code>update_workspace_icon(workspace_id, file_path, file_mimetype='image/*')</code>","text":"<p>Update a workspace with a with a new icon (which is uploaded).</p> <p>Parameters:</p> Name Type Description Default <code>workspace_id</code> <code>int</code> <p>ID of the workspace</p> required <code>file_path</code> <code>str</code> <p>path + filename of icon file</p> required <code>file_mimetype</code> <code>str</code> <p>mimetype of the image</p> <code>'image/*'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Node information or None if REST call fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def update_workspace_icon(\nself, workspace_id: int, file_path: str, file_mimetype: str = \"image/*\"\n) -&gt; dict | None:\n\"\"\"Update a workspace with a with a new icon (which is uploaded).\n    Args:\n        workspace_id (int): ID of the workspace\n        file_path (str): path + filename of icon file\n        file_mimetype (str, optional): mimetype of the image\n    Returns:\n        dict: Node information or None if REST call fails.\n    \"\"\"\nif not os.path.exists(file_path):\nlogger.error(\"Workspace icon file does not exist -&gt; %s\", file_path)\nreturn None\nupdateWorkspaceIconPostBody = {\n\"file_content_type\": file_mimetype,\n\"file_filename\": os.path.basename(file_path),\n}\nuploadPostFiles = [\n(\n\"file\",\n(\nf\"{os.path.basename(file_path)}\",\nopen(file_path, \"rb\"),\nfile_mimetype,\n),\n)\n]\nrequest_url = (\nself.config()[\"businessworkspaces\"] + \"/\" + str(workspace_id) + \"/icons\"\n)\nrequest_header = self.cookie()\nlogger.info(\n\"Update icon for workspace ID -&gt; %s with icon file -&gt; %s; calling -&gt; %s\",\nstr(workspace_id),\nfile_path,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=updateWorkspaceIconPostBody,\nheaders=request_header,\ncookies=self.cookie(),\nfiles=uploadPostFiles,\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update workspace ID -&gt; %s with new icon -&gt; %s; status -&gt; %s; error -&gt; %s\",\nstr(workspace_id),\nfile_path,\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.upload_file_to_parent","title":"<code>upload_file_to_parent(file_url, file_name, mime_type, parent_id)</code>","text":"<p>Fetch a file from a URL or local filesystem and upload it to a Content Server parent (folder).</p> <p>Parameters:</p> Name Type Description Default <code>file_url</code> <code>str</code> <p>URL to download file or local file</p> required <code>file_name</code> <code>str</code> <p>name of the file</p> required <code>mime_type</code> <code>str</code> <p>mimeType of the file</p> required <code>parent_id</code> <code>int</code> <p>parent (ID) of the file to upload</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Upload response or None if the upload fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def upload_file_to_parent(\nself, file_url: str, file_name: str, mime_type: str, parent_id: int\n) -&gt; dict | None:\n\"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server parent (folder).\n    Args:\n        file_url (str): URL to download file or local file\n        file_name (str): name of the file\n        mime_type (str): mimeType of the file\n        parent_id (int): parent (ID) of the file to upload\n    Returns:\n        dict: Upload response or None if the upload fails.\n    \"\"\"\nif file_url.startswith(\"http\"):\n# Download file from remote location specified by the fileUrl\n# this must be a public place without authentication:\nlogger.info(\"Download file from URL -&gt; %s\", file_url)\ntry:\nresponse = requests.get(url=file_url, timeout=1200)\nresponse.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn None\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn None\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn None\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn None\nlogger.info(\n\"Successfully downloaded file -&gt; %s; status code -&gt; %s\",\nfile_url,\nresponse.status_code,\n)\nfile_content = response.content\nelif os.path.exists(file_url):\nlogger.info(\"Uploading local file -&gt; %s\", file_url)\nfile_content = open(file=file_url, mode=\"rb\")\nelse:\nlogger.warning(\"Cannot access -&gt; %s\", file_url)\nreturn None\nuploadPostData = {\n\"type\": str(144),\n\"name\": file_name,\n\"parent_id\": str(parent_id),\n}\nuploadPostFiles = [(\"file\", (f\"{file_name}\", file_content, mime_type))]\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\nlogger.info(\n\"Uploading file -&gt; %s with mime type -&gt; %s to parent with ID -&gt; %s; calling -&gt; %s\",\nfile_name,\nmime_type,\nstr(parent_id),\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=uploadPostData,\nfiles=uploadPostFiles,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upload file -&gt; %s to parent -&gt; %s; status -&gt; %s; error -&gt; %s\",\nfile_url,\nstr(parent_id),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.upload_file_to_volume","title":"<code>upload_file_to_volume(package_url, file_name, mime_type, volume_type)</code>","text":"<p>Fetch a file from a URL or local filesystem and upload it to a Content Server volume.</p> <p>Parameters:</p> Name Type Description Default <code>package_url</code> <code>str</code> <p>URL to download file</p> required <code>file_name</code> <code>str</code> <p>name of the file</p> required <code>mime_type</code> <code>str</code> <p>mimeType of the file</p> required <code>volume_type</code> <code>int</code> <p>type (ID) of the volume</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Upload response or None if the upload fails.</p> Source code in <code>pyxecm/otcs.py</code> <pre><code>def upload_file_to_volume(\nself, package_url: str, file_name: str, mime_type: str, volume_type: int\n) -&gt; dict | None:\n\"\"\"Fetch a file from a URL or local filesystem and upload it to a Content Server volume.\n    Args:\n        package_url (str): URL to download file\n        file_name (str): name of the file\n        mime_type (str): mimeType of the file\n        volume_type (int): type (ID) of the volume\n    Returns:\n        dict: Upload response or None if the upload fails.\n    \"\"\"\nif package_url.startswith(\"http\"):\n# Download file from remote location specified by the packageUrl\n# this must be a public place without authentication:\nlogger.info(\"Download transport package from URL -&gt; %s\", package_url)\ntry:\npackage = requests.get(url=package_url, timeout=1200)\npackage.raise_for_status()\nexcept requests.exceptions.HTTPError as errh:\nlogger.error(\"Http Error -&gt; %s\", errh.strerror)\nreturn None\nexcept requests.exceptions.ConnectionError as errc:\nlogger.error(\"Error Connecting -&gt; %s\", errc.strerror)\nreturn None\nexcept requests.exceptions.Timeout as errt:\nlogger.error(\"Timeout Error -&gt; %s\", errt.strerror)\nreturn None\nexcept requests.exceptions.RequestException as err:\nlogger.error(\"Request error -&gt; %s\", err.strerror)\nreturn None\nlogger.info(\n\"Successfully downloaded package -&gt; %s; status code -&gt; %s\",\npackage_url,\npackage.status_code,\n)\nfile = package.content\nelif os.path.exists(package_url):\nlogger.info(\"Using local package -&gt; %s\", package_url)\nfile = open(file=package_url, mode=\"rb\")\nelse:\nlogger.warning(\"Cannot access -&gt; %s\", package_url)\nreturn None\nuploadPostData = {\"type\": str(volume_type), \"name\": file_name}\nuploadPostFiles = [(\"file\", (f\"{file_name}\", file, mime_type))]\nrequest_url = self.config()[\"nodesUrlv2\"]\nrequest_header = (\nself.cookie()\n)  # for some reason we have to omit the other header parts here - otherwise we get a 500 response\nlogger.info(\n\"Uploading package -&gt; %s with mime type -&gt; %s; calling -&gt; %s\",\nfile_name,\nmime_type,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\ndata=uploadPostData,\nfiles=uploadPostFiles,\nheaders=request_header,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to upload file -&gt; %s to volume of type -&gt; %s; status -&gt; %s; error -&gt; %s\",\npackage_url,\nstr(volume_type),\nresponse.status_code,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otcs/#pyxecm.otcs.OTCS.volume_translator","title":"<code>volume_translator(current_node_id, translator, languages)</code>","text":"<p>Experimental code to translate the item names and item descriptions in a given hierarchy.    The actual translation is done by a tranlator object. This recursive method just    traverses the hierarchy and calls the translate() method of the translator object.</p> <p>Parameters:</p> Name Type Description Default <code>current_node_id</code> <code>int</code> <p>current node ID to translate</p> required <code>translator</code> <code>object</code> <p>this object needs to be created based on the \"Translator\" class                  and passed to this method</p> required <code>languages</code> <code>list</code> <p>list of target languages</p> required Source code in <code>pyxecm/otcs.py</code> <pre><code>def volume_translator(\nself, current_node_id: int, translator: object, languages: list\n):\n\"\"\"Experimental code to translate the item names and item descriptions in a given hierarchy.\n       The actual translation is done by a tranlator object. This recursive method just\n       traverses the hierarchy and calls the translate() method of the translator object.\n    Args:\n        current_node_id (int): current node ID to translate\n        translator (object): this object needs to be created based on the \"Translator\" class\n                             and passed to this method\n        languages (list): list of target languages\n    \"\"\"\n# Get current node based on the ID:\ncurrent_node = self.get_node(current_node_id)\ncurrent_node_id = self.get_result_value(current_node, \"id\")\nname = self.get_result_value(current_node, \"name\")\ndescription = self.get_result_value(current_node, \"description\")\nnames_multilingual = self.get_result_value(current_node, \"name_multilingual\")\ndescriptions_multilingual = self.get_result_value(\ncurrent_node, \"description_multilingual\"\n)\nfor language in languages:\nif language == \"en\":\ncontinue\n# Does the language not exist as metadata language or is it already translated?\n# Then we skip this language:\nif (\nlanguage in names_multilingual\nand names_multilingual[\"en\"]\nand not names_multilingual[language]\n):\nnames_multilingual[language] = translator.translate(\n\"en\", language, names_multilingual[\"en\"]\n)\nif (\nlanguage in descriptions_multilingual\nand descriptions_multilingual[\"en\"]\nand not descriptions_multilingual[language]\n):\ndescriptions_multilingual[language] = translator.translate(\n\"en\", language, descriptions_multilingual[\"en\"]\n)\n# Rename node multi-lingual:\nself.rename_node(\ncurrent_node_id,\nname,\ndescription,\nnames_multilingual,\ndescriptions_multilingual,\n)\n# Get children nodes of the current node:\nresults = self.get_subnodes(current_node_id, limit=200)[\"results\"]\n# Recursive call of all subnodes:\nfor result in results:\nself.volume_translator(\nresult[\"data\"][\"properties\"][\"id\"], translator, languages\n)\n</code></pre>"},{"location":"pyxecm/otds/","title":"OTDS","text":"<p>OTDS Module to implement functions to read / write OTDS objects such as Ressources, Users, Groups, Licenses, Trusted Sites, OAuth Clients, ...</p> <p>Important: userIDs consists of login name + \"@\" + partition name </p> <p>Class: OTDS Methods:</p> <p>init : class initializer config : returns config data set cookie : returns cookie information credentials: returns set of username and password</p> <p>base_url : returns OTDS base URL rest_url : returns OTDS REST base URL credential_url : returns the OTDS Credentials REST URL authHandler_url : returns the OTDS Authentication Handler REST URL partition_url : returns OTDS Partition REST URL access_role_url : returns OTDS Access Role REST URL oauth_client_url : returns OTDS OAuth Client REST URL resource_url : returns OTDS Resource REST URL license_url : returns OTDS License REST URL token_url : returns OTDS Token REST URL users_url : returns OTDS Users REST URL groups_url : returns OTDS Groups REST URL system_config_url : returns OTDS System Config REST URL consolidation_url: returns OTDS consolidation URL</p> <p>authenticate : authenticates at OTDS server</p> <p>add_license_to_resource : Add (or update) a product license to OTDS get_license_for_resource : Get list of licenses for a resource delete_license_from_resource : Delete a license from a resource assign_user_to_license : Assign an OTDS user to a product license (feature) in OTDS. assign_partition_to_license: Assign an OTDS user partition to a license (feature) in OTDS.</p> Return the licensed objects (users, groups, partitions) an OTDS for a <p>license + license feature associated with an OTDS resource (like \"cs\").</p> Check if a user is licensed for a license and license feature associated <p>with a particular OTDS resource.</p> Check if a group is licensed for a license and license feature associated <p>with a particular OTDS resource.</p> Check if a user partition is licensed for a license and license feature <p>associated with a particular OTDS resource.</p> <p>add_partition : Add an OTDS partition get_partition : Get a partition with a specific name add_user : Add a user to a partion get_user : Get a user with a specific user ID (= login name @ partition) get_users: get all users (with option to filter) update_user : Update attributes of on OTDS user delete_user : Delete a user with a specific ID in a specific partition reset_user_password : Reset a password of a specific user ID add_group: Add an OTDS group get_group: Get a OTDS group by its name add_user_to_group : Add an OTDS user to a OTDS group add_group_to_parent_group : Add on OTDS group to a parent group</p> <p>add_resource : Add a new resource to OTDS get_resource : Get an OTDS resource with a specific name update_resource: Update an existing OTDS resource activate_resource : Activate an OTDS resource</p> <p>get_access_roles : Get all OTDS Access Roles get_access_role: Get an OTDS Access Role with a specific name add_partition_to_access_role : Add an OTDS Partition to to an OTDS Access Role add_user_to_access_role : Add an OTDS user to to an OTDS Access Role add_group_to_access_role : Add an OTDS group to to an OTDS Access Role update_access_role_attributes: Update attributes of an existing access role</p> <p>add_system_attribute : Add an OTDS System Attribute</p> <p>get_trusted_sites : Get OTDS Trusted Sites add_trusted_site : Add a new trusted site to OTDS</p> <p>enable_audit: enable OTDS audit</p> <p>add_oauth_client : Add a new OAuth client to OTDS get_oauth_client : Get an OAuth client with a specific client ID update_oauth_client : Update an OAuth client add_oauth_clients_to_access_role : Add an OTDS OAuth Client to an OTDS Access Role get_access_token : Get an OTDS Access Token</p> <p>get_auth_handler: Gen an auth handler with a given name add_auth_handler_saml: Add an authentication handler for SAML (e.g. for SuccessFactors) add_auth_handler_sap: Add an authentication handler for SAP add_auth_handler_oauth: Add an authentication handler for OAuth (used for Salesforce)</p> <p>consolidate: Consolidate an OTDS resource impersonate_resource: Configure impersonation for an OTDS resource impersonate_oauth_client: Configure impersonation for an OTDS OAuth Client</p> <p>get_password_policy: get the global password policy update_password_policy: updates the global password policy</p>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS","title":"<code>OTDS</code>","text":"<p>Used to automate stettings in OpenText Directory Services (OTDS).</p> Source code in <code>pyxecm/otds.py</code> <pre><code>class OTDS:\n\"\"\"Used to automate stettings in OpenText Directory Services (OTDS).\"\"\"\n_config = None\n_cookie = None\ndef __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\nusername: str | None = None,\npassword: str | None = None,\notds_ticket: str | None = None,\n):\n\"\"\"Initialize the OTDS object\n        Args:\n            protocol (str): either http or https\n            hostname (str): hostname of otds\n            port (int): port number - typically 80 or 443\n            username (str, optional): otds user name. Optional if otds_ticket is provided.\n            password (str, optional): otds password. Optional if otds_ticket is provided.\n            otds_ticket (str, optional): Authentication ticket of OTDS\n        \"\"\"\n# Initialize otdsConfig as an empty dictionary\notds_config = {}\nif hostname:\notds_config[\"hostname\"] = hostname\nelse:\notds_config[\"hostname\"] = \"otds\"\nif protocol:\notds_config[\"protocol\"] = protocol\nelse:\notds_config[\"protocol\"] = \"http\"\nif port:\notds_config[\"port\"] = port\nelse:\notds_config[\"port\"] = 80\nif username:\notds_config[\"username\"] = username\nelse:\notds_config[\"username\"] = \"admin\"\nif password:\notds_config[\"password\"] = password\nelse:\notds_config[\"password\"] = \"\"\nif otds_ticket:\nself._cookie = {\"OTDSTicket\": otds_ticket}\notdsBaseUrl = protocol + \"://\" + otds_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notdsBaseUrl += \":{}\".format(port)\notdsBaseUrl += \"/otdsws\"\notds_config[\"baseUrl\"] = otdsBaseUrl\notdsRestUrl = otdsBaseUrl + \"/rest\"\notds_config[\"restUrl\"] = otdsRestUrl\notds_config[\"partitionUrl\"] = otdsRestUrl + \"/partitions\"\notds_config[\"accessRoleUrl\"] = otdsRestUrl + \"/accessroles\"\notds_config[\"credentialUrl\"] = otdsRestUrl + \"/authentication/credentials\"\notds_config[\"oauthClientUrl\"] = otdsRestUrl + \"/oauthclients\"\notds_config[\"tokenUrl\"] = otdsBaseUrl + \"/oauth2/token\"\notds_config[\"resourceUrl\"] = otdsRestUrl + \"/resources\"\notds_config[\"licenseUrl\"] = otdsRestUrl + \"/licensemanagement/licenses\"\notds_config[\"usersUrl\"] = otdsRestUrl + \"/users\"\notds_config[\"groupsUrl\"] = otdsRestUrl + \"/groups\"\notds_config[\"systemConfigUrl\"] = otdsRestUrl + \"/systemconfig\"\notds_config[\"authHandlerUrl\"] = otdsRestUrl + \"/authhandlers\"\notds_config[\"consolidationUrl\"] = otdsRestUrl + \"/consolidation\"\nself._config = otds_config\ndef config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\nreturn self._config\ndef cookie(self) -&gt; dict:\n\"\"\"Returns the login cookie of OTDS.\n           This is set by the authenticate() method\n        Returns:\n            dict: OTDS cookie\n        \"\"\"\nreturn self._cookie\ndef credentials(self) -&gt; dict:\n\"\"\"Returns the credentials (username + password)\n        Returns:\n            dict: dictionary with username and password\n        \"\"\"\nreturn {\n\"userName\": self.config()[\"username\"],\n\"password\": self.config()[\"password\"],\n}\ndef base_url(self) -&gt; str:\n\"\"\"Returns the base URL of OTDS\n        Returns:\n            str: base URL\n        \"\"\"\nreturn self.config()[\"baseUrl\"]\ndef rest_url(self) -&gt; str:\n\"\"\"Returns the REST URL of OTDS\n        Returns:\n            str: REST URL\n        \"\"\"\nreturn self.config()[\"restUrl\"]\ndef credential_url(self) -&gt; str:\n\"\"\"Returns the Credentials URL of OTDS\n        Returns:\n            str: Credentials URL\n        \"\"\"\nreturn self.config()[\"credentialUrl\"]\ndef auth_handler_url(self) -&gt; str:\n\"\"\"Returns the Auth Handler URL of OTDS\n        Returns:\n            str: Auth Handler URL\n        \"\"\"\nreturn self.config()[\"authHandlerUrl\"]\ndef partition_url(self) -&gt; str:\n\"\"\"Returns the Partition URL of OTDS\n        Returns:\n            str: Partition URL\n        \"\"\"\nreturn self.config()[\"partitionUrl\"]\ndef access_role_url(self) -&gt; str:\n\"\"\"Returns the Access Role URL of OTDS\n        Returns:\n            str: Access Role URL\n        \"\"\"\nreturn self.config()[\"accessRoleUrl\"]\ndef oauth_client_url(self) -&gt; str:\n\"\"\"Returns the OAuth Client URL of OTDS\n        Returns:\n            str: OAuth Client URL\n        \"\"\"\nreturn self.config()[\"oauthClientUrl\"]\ndef resource_url(self) -&gt; str:\n\"\"\"Returns the Resource URL of OTDS\n        Returns:\n            str: Resource URL\n        \"\"\"\nreturn self.config()[\"resourceUrl\"]\ndef license_url(self) -&gt; str:\n\"\"\"Returns the License URL of OTDS\n        Returns:\n            str: License URL\n        \"\"\"\nreturn self.config()[\"licenseUrl\"]\ndef token_url(self) -&gt; str:\n\"\"\"Returns the Token URL of OTDS\n        Returns:\n            str: Token URL\n        \"\"\"\nreturn self.config()[\"tokenUrl\"]\ndef users_url(self) -&gt; str:\n\"\"\"Returns the Users URL of OTDS\n        Returns:\n            str: Users URL\n        \"\"\"\nreturn self.config()[\"usersUrl\"]\ndef groups_url(self) -&gt; str:\n\"\"\"Returns the Groups URL of OTDS\n        Returns:\n            str: Groups URL\n        \"\"\"\nreturn self.config()[\"groupsUrl\"]\ndef system_config_url(self) -&gt; str:\n\"\"\"Returns the System Config URL of OTDS\n        Returns:\n            str: System Config URL\n        \"\"\"\nreturn self.config()[\"systemConfigUrl\"]\ndef consolidation_url(self) -&gt; str:\n\"\"\"Returns the Consolidation URL of OTDS\n        Returns:\n            str: Consolidation URL\n        \"\"\"\nreturn self.config()[\"consolidationUrl\"]\ndef parse_request_response(\nself,\nresponse_object: object,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the request response to a Python dict in a safe way\n           that also handles exceptions.\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str): print a custom error message\n            show_error (bool): if True log an error, if False log a warning\n        Returns:\n            dict: response dictionary or None in case of an error\n        \"\"\"\nif not response_object:\nreturn None\ntry:\ndict_object = json.loads(response_object.text)\nexcept json.JSONDecodeError as e:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, e\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(e)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n# end method definition\ndef authenticate(self, revalidate: bool = False) -&gt; dict | None:\n\"\"\"Authenticate at Directory Services and retrieve OTCS Ticket.\n        Args:\n            revalidate (bool, optional): determine if a re-athentication is enforced\n                                         (e.g. if session has timed out with 401 error)\n        Returns:\n            dict: Cookie information. Also stores cookie information in self._cookie\n        \"\"\"\n# Already authenticated and session still valid?\nif self._cookie and not revalidate:\nreturn self._cookie\notds_ticket = \"NotSet\"\nlogger.info(\"Requesting OTDS ticket from -&gt; %s\", self.credential_url())\nresponse = None\ntry:\nresponse = requests.post(\nurl=self.credential_url(),\njson=self.credentials(),\nheaders=REQUEST_HEADERS,\ntimeout=None,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; error -&gt; %s\",\nself.credential_url(),\nexception.strerror,\n)\nlogger.warning(\"OTDS service may not be ready yet.\")\nreturn None\nif response.ok:\nauthenticate_dict = self.parse_request_response(response)\nif not authenticate_dict:\nreturn None\nelse:\notds_ticket = authenticate_dict[\"ticket\"]\nlogger.info(\"Ticket -&gt; %s\", otds_ticket)\nelse:\nlogger.error(\"Failed to request an OTDS ticket; error -&gt; %s\", response.text)\nreturn None\nself._cookie = {\"OTDSTicket\": otds_ticket}\nreturn self._cookie\n# end method definition\ndef add_license_to_resource(\nself,\npath_to_license_file: str,\nproduct_name: str,\nproduct_description: str,\nresource_id: str,\nupdate: bool = True,\n) -&gt; dict | None:\n\"\"\"Add a product license to an OTDS resource.\n        Args:\n            path_to_license_file (str): fully qualified filename of the license file\n            product_name (str): product name\n            product_description (str): product description\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            update (bool, optional): whether or not an existing license should be updated (default = True)\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails\n        \"\"\"\nlogger.info(\"Reading license file -&gt; %s...\", path_to_license_file)\ntry:\nwith open(path_to_license_file, \"rt\", encoding=\"UTF-8\") as license_file:\nlicense_content = license_file.read()\nexcept IOError as exception:\nlogger.error(\n\"Error opening license file -&gt; %s; error -&gt; %s\",\npath_to_license_file,\nexception.strerror,\n)\nreturn None\nlicensePostBodyJson = {\n\"description\": product_description,\n\"name\": product_name,\n\"values\": [\n{\"name\": \"oTLicenseFile\", \"values\": license_content},\n{\"name\": \"oTLicenseResource\", \"values\": resource_id},\n{\"name\": \"oTLicenseFingerprintGenerator\", \"values\": [None]},\n],\n}\nrequest_url = self.license_url()\n# Check if we want to update an existing license:\nif update:\nexisting_license = self.get_license_for_resource(resource_id)\nif existing_license:\nrequest_url += \"/\" + existing_license[0][\"id\"]\nelse:\nlogger.info(\n\"No existing license for resource -&gt; %s found - adding a new license...\",\nresource_id,\n)\n# change strategy to create a new license:\nupdate = False\nlogger.info(\n\"Adding product license -&gt; %s for product -&gt; %s to resource -&gt; %s; calling -&gt; %s\",\npath_to_license_file,\nproduct_description,\nresource_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nif update:\n# Do a REST PUT call for update an existing license:\nresponse = requests.put(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nelse:\n# Do a REST POST call for creation of a new license:\nresponse = requests.post(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add product license -&gt; %s for product -&gt; %s; error -&gt; %s (%s)\",\npath_to_license_file,\nproduct_description,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_license_for_resource(self, resource_id: str):\n\"\"\"Get a product license for a resource in OTDS.\n        Args:\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        Returns:\n            Licenses for a resource or None if the REST call fails\n        licenses have this format:\n        {\n          '_oTLicenseType': 'NON-PRODUCTION',\n          '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n          '_oTLicenseResourceName': 'cs',\n          '_oTLicenseProduct': 'EXTENDED_ECM',\n          'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n          'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n          'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n          'description': 'CS license',\n          'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n        }\n        \"\"\"\nrequest_url = (\nself.license_url()\n+ \"/assignedlicenses?resourceID=\"\n+ resource_id\n+ \"&amp;validOnly=false\"\n)\nlogger.info(\n\"Get license for resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nresponse_dict = self.parse_request_response(response)\nif not response_dict:\nreturn None\nreturn response_dict[\"licenseObjects\"][\"_licenses\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get license for resource -&gt; %s; error -&gt; %s (%s)\",\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef delete_license_from_resource(self, resource_id: str, license_id: str) -&gt; bool:\n\"\"\"Delete a product license for a resource in OTDS.\n        Args:\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_id (str): OTDS license ID (this is the ID not the license name!)\n        Returns:\n            bool: True if successful or False if the REST call fails\n        \"\"\"\nrequest_url = \"{}/{}\".format(self.license_url(), license_id)\nlogger.info(\n\"Deleting product license -&gt; %s from resource -&gt; %s; calling -&gt; %s\",\nlicense_id,\nresource_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to delete license -&gt; %s for resource -&gt; %s; error -&gt; %s (%s)\",\nlicense_id,\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef assign_user_to_license(\nself,\npartition: str,\nuser_id: str,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\nlicense_type: str = \"Full\",\n) -&gt; bool:\n\"\"\"Assign an OTDS user to a product license (feature) in OTDS.\n        Args:\n            partition (str): user partition in OTDS, e.g. \"Content Server Members\"\n            user_id (str): ID of the user (= login name)\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature\n            license_name (str): name of the license to assign\n            license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n        Returns:\n            bool: True if successful or False if the REST call fails or the license is not found\n        \"\"\"\nlicenses = self.get_license_for_resource(resource_id)\nfor lic in licenses:\nif lic[\"_oTLicenseProduct\"] == license_name:\nlicense_location = lic[\"id\"]\ntry:\nlicense_location\nexcept UnboundLocalError:\nlogger.error(\n\"Cannot find license -&gt; %s for resource -&gt; %s\",\nlicense_name,\nresource_id,\n)\nreturn False\nuser = self.get_user(partition, user_id)\nif user:\nuser_location = user[\"location\"]\nelse:\nlogger.error(\"Cannot find location for user -&gt; %s\", user_id)\nreturn False\nlicensePostBodyJson = {\n\"_oTLicenseType\": license_type,\n\"_oTLicenseProduct\": \"users\",\n\"name\": user_location,\n\"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n}\nrequest_url = self.license_url() + \"/object/\" + license_location\nlogger.info(\n\"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to user -&gt; %s; calling -&gt; %s\",\nlicense_feature,\nlicense_location,\nresource_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.info(\n\"Added license feature -&gt; %s for user -&gt; %s\",\nlicense_feature,\nuser_id,\n)\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add license feature -&gt; %s associated with resource -&gt; %s to user -&gt; %s; error -&gt; %s (%s)\",\nlicense_feature,\nresource_id,\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef assign_partition_to_license(\nself,\npartition_name: str,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\nlicense_type: str = \"Full\",\n) -&gt; bool:\n\"\"\"Assign an OTDS partition to a product license (feature).\n        Args:\n            partition_name (str): user partition in OTDS, e.g. \"Content Server Members\"\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n            license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n        Returns:\n            bool: True if successful or False if the REST call fails or the license is not found\n        \"\"\"\nlicenses = self.get_license_for_resource(resource_id)\nif not licenses:\nlogger.error(\n\"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n)\nreturn False\n# licenses have this format:\n# {\n#   '_oTLicenseType': 'NON-PRODUCTION',\n#   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n#   '_oTLicenseResourceName': 'cs',\n#   '_oTLicenseProduct': 'EXTENDED_ECM',\n#   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n#   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'description': 'CS license',\n#   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n# }\nfor lic in licenses:\nif lic[\"_oTLicenseProduct\"] == license_name:\nlicense_location = lic[\"id\"]\ntry:\nlicense_location\nexcept UnboundLocalError:\nlogger.error(\n\"Cannot find license -&gt; %s for resource -&gt; %s\",\nlicense_name,\nresource_id,\n)\nreturn False\nlicensePostBodyJson = {\n\"_oTLicenseType\": license_type,\n\"_oTLicenseProduct\": \"partitions\",\n\"name\": partition_name,\n\"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n}\nrequest_url = self.license_url() + \"/object/\" + license_location\nlogger.info(\n\"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\nlicense_feature,\nlicense_location,\nresource_id,\npartition_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.info(\n\"Added license feature -&gt; %s for partition -&gt; %s\",\nlicense_feature,\npartition_name,\n)\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add license feature -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; error -&gt; %s (%s)\",\nlicense_feature,\nresource_id,\npartition_name,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef get_licensed_objects(\nself,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\n) -&gt; dict | None:\n\"\"\"Return the licensed objects (users, groups, partitions) in OTDS for a license + license feature\n           associated with an OTDS resource (like \"cs\").\n        Args:\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n        Returns:\n            dict: data structure of licensed objects\n            Example return value:\n            {\n                'status': 0,\n                'displayString': 'Success',\n                'exceptions': None,\n                'retValue': 0,\n                'listGroupsResults': {'groups': [...], 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n                'listUsersResults': {'users': [...], 'actualPageSize': 53, 'nextPageCookie': None, 'requestedPageSize': 250},\n                'listUserPartitionResult': {'_userPartitions': [...], 'warningMessage': None, 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n                'version': 1\n            }\n        \"\"\"\nlicenses = self.get_license_for_resource(resource_id)\nif not licenses:\nlogger.error(\n\"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n)\nreturn False\n# licenses have this format:\n# {\n#   '_oTLicenseType': 'NON-PRODUCTION',\n#   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n#   '_oTLicenseResourceName': 'cs',\n#   '_oTLicenseProduct': 'EXTENDED_ECM',\n#   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n#   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'description': 'CS license',\n#   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n# }\nfor lic in licenses:\nif lic[\"_oTLicenseProduct\"] == license_name:\nlicense_location = lic[\"location\"]\ntry:\nlicense_location\nexcept UnboundLocalError:\nlogger.error(\n\"Cannot find license -&gt; %s for resource -&gt; %s\",\nlicense_name,\nresource_id,\n)\nreturn False\nrequest_url = (\nself.license_url()\n+ \"/object/\"\n+ license_location\n+ \"?counter=\"\n+ license_feature\n)\nlogger.info(\n\"Get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; calling -&gt; %s\",\nlicense_name,\nlicense_feature,\nresource_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; error -&gt; %s (%s)\",\nlicense_name,\nlicense_feature,\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef is_user_licensed(\nself, user_name: str, resource_id: str, license_feature: str, license_name: str\n) -&gt; bool:\n\"\"\"Check if a user is licensed for a license and license feature associated with a particular OTDS resource.\n        Args:\n            user_name (str): login name of the OTDS user\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n        Returns:\n            bool: True if the user is licensed and False otherwise\n        \"\"\"\nresponse = self.get_licensed_objects(\nresource_id=resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n)\nif not response or not response[\"listUsersResults\"]:\nreturn False\nusers = response[\"listUsersResults\"][\"users\"]\nif not users:\nreturn False\nuser = next(\n(item for item in users if item[\"name\"] == user_name),\nNone,\n)\nif user:\nreturn True\nreturn False\n# end method definition\ndef is_group_licensed(\nself, group_name: str, resource_id: str, license_feature: str, license_name: str\n) -&gt; bool:\n\"\"\"Check if a group is licensed for a license and license feature associated with a particular OTDS resource.\n        Args:\n            group_name (str): name of the OTDS user group\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n        Returns:\n            bool: True if the group is licensed and False otherwise\n        \"\"\"\nresponse = self.get_licensed_objects(\nresource_id=resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n)\nif not response or not response[\"listGroupsResults\"]:\nreturn False\ngroups = response[\"listGroupsResults\"][\"groups\"]\nif not groups:\nreturn False\ngroup = next(\n(item for item in groups if item[\"name\"] == group_name),\nNone,\n)\nif group:\nreturn True\nreturn False\n# end method definition\ndef is_partition_licensed(\nself,\npartition_name: str,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\n) -&gt; bool:\n\"\"\"Check if a partition is licensed for a license and license feature associated with a particular OTDS resource.\n        Args:\n            partition_name (str): name of the OTDS user partition, e.g. \"Content Server Members\"\n            resource_id (str): OTDS resource ID (this is ID not the resource name!)\n            license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n            license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n        Returns:\n            bool: True if the partition is licensed and False otherwise\n        \"\"\"\nresponse = self.get_licensed_objects(\nresource_id=resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n)\nif not response or not response[\"listUserPartitionResult\"]:\nreturn False\npartitions = response[\"listUserPartitionResult\"][\"_userPartitions\"]\nif not partitions:\nreturn False\npartition = next(\n(item for item in partitions if item[\"name\"] == partition_name),\nNone,\n)\nif partition:\nreturn True\nreturn False\n# end method definition\ndef add_partition(self, name: str, description: str) -&gt; dict | None:\n\"\"\"Add a new user partition to OTDS\n        Args:\n            name (str): name of the new partition\n            description (str): description of the new partition\n        Returns:\n            dict: Request response or None if the creation fails.\n        \"\"\"\npartitionPostBodyJson = {\"name\": name, \"description\": description}\nrequest_url = self.partition_url()\nlogger.info(\n\"Adding user partition -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=partitionPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user partition -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_partition(self, name: str, show_error: bool = True) -&gt; dict | None:\n\"\"\"Get an existing user partition from OTDS\n        Args:\n            name (str): name of the partition to retrieve\n            show_error (bool, optional): whether or not we want to log an error\n                                         if partion is not found\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\nrequest_url = \"{}/{}\".format(self.config()[\"partitionUrl\"], name)\nlogger.info(\"Getting user partition -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get partition -&gt; %s; warning -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_user(\nself,\npartition: str,\nname: str,\ndescription: str = \"\",\nfirst_name: str = \"\",\nlast_name: str = \"\",\nemail: str = \"\",\n) -&gt; dict | None:\n\"\"\"Add a new user to a user partition in OTDS\n        Args:\n            partition (str): name of the OTDS user partition (needs to exist)\n            name (str): login name of the new user\n            description (str, optional): description of the new user\n            first_name (str, optional): first name of the new user\n            last_name (str, optional): last name of the new user\n            email (str, optional): email address of the new user\n        Returns:\n            dict: Request response or None if the creation fails.\n        \"\"\"\nuserPostBodyJson = {\n\"userPartitionID\": partition,\n\"values\": [\n{\"name\": \"sn\", \"values\": [last_name]},\n{\"name\": \"givenName\", \"values\": [first_name]},\n{\"name\": \"mail\", \"values\": [email]},\n],\n\"name\": name,\n\"description\": description,\n}\nrequest_url = self.users_url()\nlogger.info(\n\"Adding user -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\nname,\npartition,\nrequest_url,\n)\nlogger.debug(\"User Attributes -&gt; %s\", str(userPostBodyJson))\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=userPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_user(self, partition: str, user_id: str) -&gt; dict | None:\n\"\"\"Get a user by its partition and user ID\n        Args:\n            partition (str): name of the partition\n            user_id (str): ID of the user (= login name)\n        Returns:\n            dict: Request response or None if the user was not found.\n        \"\"\"\nrequest_url = self.users_url() + \"/\" + user_id + \"@\" + partition\nlogger.info(\n\"Get user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\nuser_id,\npartition,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_users(self, partition: str = \"\", limit: int | None = None) -&gt; dict | None:\n\"\"\"Get all users in a partition partition\n        Args:\n            partition (str, optional): name of the partition\n            limit (int): maximum number of users to return\n        Returns:\n            dict: Request response or None if the user was not found.\n        \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {}\nif limit:\nquery[\"limit\"] = limit\nif partition:\nquery[\"where_partition_name\"] = partition\nencodedQuery = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.users_url()\nif query:\nrequest_url += \"?{}\".format(encodedQuery)\nif partition:\nlogger.info(\n\"Get all users in partition -&gt; %s (limit -&gt; %s); calling -&gt; %s\",\npartition,\nlimit,\nrequest_url,\n)\nelse:\nlogger.info(\n\"Get all users (limit -&gt; %s); calling -&gt; %s\",\nlimit,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif partition:\nlogger.error(\n\"Failed to get users in partition -&gt; %s; error -&gt; %s (%s)\",\npartition,\nresponse.text,\nresponse.status_code,\n)\nelse:\nlogger.error(\n\"Failed to get users; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef update_user(\nself, partition: str, user_id: str, attribute_name: str, attribute_value: str\n) -&gt; dict | None:\n\"\"\"Update a user attribute with a new value\n        Args:\n            partition (str): name of the partition\n            user_id (str): ID of the user (= login name)\n            attribute_name (str): name of the attribute\n            attribute_value (str): new value of the attribute\n        Return:\n            dict: Request response or None if the update fails.\n        \"\"\"\nif attribute_name in [\"description\"]:\nuserPatchBodyJson = {\n\"userPartitionID\": partition,\nattribute_name: attribute_value,\n}\nelse:\nuserPatchBodyJson = {\n\"userPartitionID\": partition,\n\"values\": [{\"name\": attribute_name, \"values\": [attribute_value]}],\n}\nrequest_url = self.users_url() + \"/\" + user_id\nlogger.info(\n\"Update user -&gt; %s attribute -&gt; %s to value -&gt; %s; calling -&gt; %s\",\nuser_id,\nattribute_name,\nattribute_value,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nurl=request_url,\njson=userPatchBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef delete_user(self, partition: str, user_id: str) -&gt; bool:\n\"\"\"Delete an existing user\n        Args:\n            partition (str): name of the partition\n            user_id (str): Id (= login name) of the user\n        Returns:\n            bool: True = success, False = error\n        \"\"\"\nrequest_url = self.users_url() + \"/\" + user_id + \"@\" + partition\nlogger.info(\n\"Delete user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\nuser_id,\npartition,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to delete user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef reset_user_password(self, user_id: str, password: str) -&gt; bool:\n\"\"\"Reset a password of an existing user\n        Args:\n            user_id (str): Id (= login name) of the user\n            password (str): new password of the user\n        Returns:\n            bool: True = success, False = error.\n        \"\"\"\nuserPostBodyJson = {\"newPassword\": password}\nrequest_url = \"{}/{}/password\".format(self.users_url(), user_id)\nlogger.info(\n\"Resetting password for user -&gt; %s; calling -&gt; %s\", user_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=userPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to reset password for user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef add_group(self, partition: str, name: str, description: str) -&gt; dict | None:\n\"\"\"Add a new user group to a user partition in OTDS\n        Args:\n            partition (str): name of the OTDS user partition (needs to exist)\n            name (str): name of the new group\n            description (str): description of the new group\n        Returns:\n            dict: Request response (json) or None if the creation fails.\n        \"\"\"\ngroupPostBodyJson = {\n\"userPartitionID\": partition,\n\"name\": name,\n\"description\": description,\n}\nrequest_url = self.groups_url()\nlogger.info(\n\"Adding group -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\nname,\npartition,\nrequest_url,\n)\nlogger.debug(\"Group Attributes -&gt; %s\", str(groupPostBodyJson))\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=groupPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_group(self, group: str) -&gt; dict | None:\n\"\"\"Get a OTDS group by its group name\n        Args:\n            group (str): ID of the group (= group name)\n        Return:\n            dict: Request response or None if the group was not found.\n            Example values:\n            {\n                'numMembers': 7,\n                'userPartitionID': 'Content Server Members',\n                'name': 'Sales',\n                'location': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net',\n                'id': 'Sales@Content Server Members',\n                'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...],\n                'description': None,\n                'uuid': '3f921294-b92a-4c9e-bf7c-b50df16bb937',\n                'objectClass': 'oTGroup',\n                'customAttributes': None,\n                'originUUID': None,\n                'urlId': 'Sales@Content Server Members',\n                'urlLocation': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net'\n            }\n        \"\"\"\nrequest_url = self.groups_url() + \"/\" + group\nlogger.info(\"Get group -&gt; %s; calling -&gt; %s\", group, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get group -&gt; %s; error -&gt; %s (%s)\",\ngroup,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_user_to_group(self, user: str, group: str) -&gt; bool:\n\"\"\"Add an existing user to an existing group in OTDS\n        Args:\n            user (str): name of the OTDS user (needs to exist)\n            group (str): name of the OTDS group (needs to exist)\n        Returns:\n            bool: True, if request is successful, False otherwise.\n        \"\"\"\nuserToGroupPostBodyJson = {\"stringList\": [group]}\nrequest_url = self.users_url() + \"/\" + user + \"/memberof\"\nlogger.info(\n\"Adding user -&gt; %s to group -&gt; %s; calling -&gt; %s\", user, group, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=userToGroupPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s to group -&gt; %s; error -&gt; %s (%s)\",\nuser,\ngroup,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef add_group_to_parent_group(self, group: str, parent_group: str) -&gt; bool:\n\"\"\"Add an existing group to an existing parent group in OTDS\n        Args:\n            group (str): name of the OTDS group (needs to exist)\n            parent_group (str): name of the OTDS parent group (needs to exist)\n        Returns:\n            bool: True, if request is successful, False otherwise.\n        \"\"\"\ngroupToParentGroupPostBodyJson = {\"stringList\": [parent_group]}\nrequest_url = self.groups_url() + \"/\" + group + \"/memberof\"\nlogger.info(\n\"Adding group -&gt; %s to parent group -&gt; %s; calling -&gt; %s\",\ngroup,\nparent_group,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=groupToParentGroupPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s to parent group -&gt; %s; error -&gt; %s (%s)\",\ngroup,\nparent_group,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef add_resource(\nself,\nname: str,\ndescription: str,\ndisplay_name: str,\nadditional_payload: dict | None = None,\n) -&gt; dict | None:\n\"\"\"Add an OTDS resource\n        Args:\n            name (str): name of the new OTDS resource\n            description (str): description of the new OTDS resource\n            display_name (str): display name of the OTDS resource\n            additional_payload (dict, optional): additional values for the json payload\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\nresourcePostBodyJson = {\n\"resourceName\": name,\n\"description\": description,\n\"displayName\": display_name,\n}\n# Check if there's additional payload for the body provided to handle special cases:\nif additional_payload:\n# Merge additional payload:\nresourcePostBodyJson.update(additional_payload)\nrequest_url = self.config()[\"resourceUrl\"]\nlogger.info(\n\"Adding resource -&gt; %s (%s); calling -&gt; %s\", name, description, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=resourcePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add resource -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_resource(self, name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Get an existing OTDS resource\n        Args:\n            name (str): name of the new OTDS resource\n            show_error (bool, optional): treat as error if resource is not found\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\nrequest_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\nlogger.info(\"Retrieving resource -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\n# We don't necessarily want to log an error as this function\n# is also used in wait loops:\nif show_error:\nlogger.warning(\n\"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\nname,\nresponse.text,\n)\nelse:\nlogger.info(\"Resource -&gt; %s not found.\", name)\nreturn None\n# end method definition\ndef update_resource(\nself, name: str, resource: object, show_error: bool = True\n) -&gt; dict | None:\n\"\"\"Update an existing OTDS resource\n        Args:\n            name (str): name of the new OTDS resource\n            resource (object): updated resource object of get_resource called before\n            show_error (bool, optional): treat as error if resource is not found\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\nrequest_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\nlogger.info(\"Updating resource -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=resource,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\n# We don't necessarily want to log an error as this function\n# is also used in wait loops:\nif show_error:\nlogger.warning(\n\"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\nname,\nresponse.text,\n)\nelse:\nlogger.info(\"Resource -&gt; %s not found.\", name)\nreturn None\n# end method definition\ndef activate_resource(self, resource_id: str) -&gt; dict | None:\n\"\"\"Activate an OTDS resource\n        Args:\n            resource_id (str): ID of the OTDS resource\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\nresourcePostBodyJson = {}\nrequest_url = \"{}/{}/activate\".format(self.config()[\"resourceUrl\"], resource_id)\nlogger.info(\n\"Activating resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=resourcePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to activate resource -&gt; %s; error -&gt; %s (%s)\",\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_access_roles(self) -&gt; dict | None:\n\"\"\"Get a list of all OTDS access roles\n        Args:\n            None\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\nrequest_url = self.config()[\"accessRoleUrl\"]\nlogger.info(\"Retrieving access roles; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve access roles; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_access_role(self, access_role: str) -&gt; dict | None:\n\"\"\"Get an OTDS access role\n        Args:\n            name (str): name of the access role\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\nrequest_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role\nlogger.info(\n\"Retrieving access role -&gt; %s; calling -&gt; %s\", access_role, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve access role -&gt; %s; error -&gt; %s (%s)\",\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_partition_to_access_role(\nself, access_role: str, partition: str, location: str = \"\"\n) -&gt; bool:\n\"\"\"Add an OTDS partition to an OTDS access role\n        Args:\n            access_role (str): name of the OTDS access role\n            partition (str): name of the partition\n            location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                      most of the times you will want to keep it to empty string (\"\")\n        Returns:\n            bool: True if partition is in access role or has been successfully added.\n                  False if partition has been not been added (error)\n        \"\"\"\naccessRolePostBodyJson = {\n\"userPartitions\": [{\"name\": partition, \"location\": location}]\n}\nrequest_url = \"{}/{}/members\".format(\nself.config()[\"accessRoleUrl\"], access_role\n)\nlogger.info(\n\"Add user partition -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\npartition,\naccess_role,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=accessRolePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add partition -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\npartition,\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef add_user_to_access_role(\nself, access_role: str, user_id: str, location: str = \"\"\n) -&gt; bool:\n\"\"\"Add an OTDS user to an OTDS access role\n        Args:\n            access_role (str): name of the OTDS access role\n            user_id (str): ID of the user (= login name)\n            location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                      most of the times you will want to keep it to empty string (\"\")\n        Returns:\n            bool: True if user is in access role or has been successfully added.\n                  False if user has not been added (error)\n        \"\"\"\n# get existing members to check if user is already a member:\naccessRolesGetResponse = self.get_access_role(access_role)\nif not accessRolesGetResponse:\nreturn False\n# Checking if user already added to access role\naccessRoleUsers = accessRolesGetResponse[\"accessRoleMembers\"][\"users\"]\nfor user in accessRoleUsers:\nif user[\"displayName\"] == user_id:\nlogger.info(\n\"User -&gt; %s already added to access role -&gt; %s\",\nuser_id,\naccess_role,\n)\nreturn True\nlogger.info(\n\"User -&gt; %s is not yet in access role -&gt; %s - adding...\",\nuser_id,\naccess_role,\n)\n# create payload for REST call:\naccessRolePostBodyJson = {\"users\": [{\"name\": user_id, \"location\": location}]}\nrequest_url = \"{}/{}/members\".format(\nself.config()[\"accessRoleUrl\"], access_role\n)\nlogger.info(\n\"Add user -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\nuser_id,\naccess_role,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=accessRolePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef add_group_to_access_role(\nself, access_role: str, group: str, location: str = \"\"\n) -&gt; bool:\n\"\"\"Add an OTDS group to an OTDS access role\n        Args:\n            access_role (str): name of the OTDS access role\n            group (str): name of the group\n            location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                      most of the times you will want to keep it to empty string (\"\")\n        Returns:\n            bool: True if group is in access role or has been successfully added.\n                  False if group has been not been added (error)\n        \"\"\"\n# get existing members to check if user is already a member:\naccessRolesGetResponse = self.get_access_role(access_role)\nif not accessRolesGetResponse:\nreturn False\n# Checking if group already added to access role\naccessRoleGroups = accessRolesGetResponse[\"accessRoleMembers\"][\"groups\"]\nfor accessRoleGroup in accessRoleGroups:\nif accessRoleGroup[\"name\"] == group:\nlogger.info(\n\"Group -&gt; %s already added to access role -&gt; %s\", group, access_role\n)\nreturn True\nlogger.info(\n\"Group -&gt; %s is not yet in access role -&gt; %s - adding...\",\ngroup,\naccess_role,\n)\n# create payload for REST call:\naccessRolePostBodyJson = {\"groups\": [{\"name\": group, \"location\": location}]}\nrequest_url = \"{}/{}/members\".format(\nself.config()[\"accessRoleUrl\"], access_role\n)\nlogger.info(\n\"Add group -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\ngroup,\naccess_role,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=accessRolePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\ngroup,\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef update_access_role_attributes(\nself, name: str, attribute_list: list\n) -&gt; dict | None:\n\"\"\"Update some attributes of an existing OTDS Access Role\n        Args:\n            name (str): name of the existing access role\n            attribute_list (list): list of attribute name and attribute value pairs\n                                   The values need to be a list as well. Example:\n                                   [{name: \"pushAllGroups\", values: [\"True\"]}]\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\n# Return if list is empty:\nif not attribute_list:\nreturn None\n# create payload for REST call:\naccess_role = self.get_access_role(name)\nif not access_role:\nlogger.error(\"Failed to get access role -&gt; %s\", name)\nreturn None\naccessRolePutBodyJson = {\"attributes\": attribute_list}\nrequest_url = \"{}/{}/attributes\".format(self.config()[\"accessRoleUrl\"], name)\nlogger.info(\n\"Update access role -&gt; %s with attributes -&gt; %s; calling -&gt; %s\",\nname,\naccessRolePutBodyJson,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=accessRolePutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update access role -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_system_attribute(\nself, name: str, value: str, description: str = \"\"\n) -&gt; dict | None:\n\"\"\"Add a new system attribute to OTDS\n        Args:\n            name (str): name of the new system attribute\n            value (str): value of the system attribute\n            description (str, optional): optional description of the system attribute\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\nsystemAttributePostBodyJson = {\n\"name\": name,\n\"value\": value,\n\"friendlyName\": description,\n}\nrequest_url = \"{}/system_attributes\".format(self.config()[\"systemConfigUrl\"])\nif description:\nlogger.info(\n\"Add system attribute -&gt; %s (%s) with value -&gt; %s; calling -&gt; %s\",\nname,\ndescription,\nvalue,\nrequest_url,\n)\nelse:\nlogger.info(\n\"Add system attribute -&gt; %s with value -&gt; %s; calling -&gt; %s\",\nname,\nvalue,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=systemAttributePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add system attribute -&gt; %s with value -&gt; %s; error -&gt; %s (%s)\",\nname,\nvalue,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_trusted_sites(self) -&gt; dict | None:\n\"\"\"Get all configured OTDS trusted sites\n        Args:\n            None\n        Returns:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\nrequest_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Retrieving trusted sites; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve trusted sites; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_trusted_site(self, trusted_site: str) -&gt; dict | None:\n\"\"\"Add a new OTDS trusted site\n        Args:\n            trusted_site (str): name of the new trusted site\n        Return:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\ntrustedSitePostBodyJson = {\"stringList\": [trusted_site]}\n# we need to first retrieve the existing sites and then\n# append the new one:\nexistingTrustedSites = self.get_trusted_sites()\nif existingTrustedSites:\ntrustedSitePostBodyJson[\"stringList\"].extend(\nexistingTrustedSites[\"stringList\"]\n)\nrequest_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Add trusted site -&gt; %s; calling -&gt; %s\", trusted_site, request_url)\nresponse = requests.put(\nurl=request_url,\njson=trustedSitePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to add trusted site -&gt; %s; error -&gt; %s (%s)\",\ntrusted_site,\nresponse.text,\nresponse.status_code,\n)\nreturn None\nreturn response  # don't parse it!\n# end method definition\ndef enable_audit(self):\n\"\"\"enable OTDS Audit\n        Args:\n            None\n        Return:\n            Request response (json) or None if the REST call fails.\n        \"\"\"\nauditPutBodyJson = {\n\"daysToKeep\": \"7\",\n\"enabled\": \"true\",\n\"auditTo\": \"DATABASE\",\n\"eventIDs\": [\n\"User Create\",\n\"Group Create\",\n\"User Delete\",\n\"Group Delete\",\n\"User Modify\",\n\"Group Modify\",\n\"Initial authentication successful\",\n\"Initial authentication failed\",\n\"Impersonation\",\n\"Import Finished\",\n\"Access Denied\",\n\"Authentication code incorrect\",\n\"Authentication code required\",\n\"User locked out\",\n\"Consolidate Partition with identity provider\",\n\"Recycle Bin User Deleted\",\n\"Recycle Bin Group Deleted\",\n\"User Moved to Recycle Bin\",\n\"Group Moved to Recycle Bin\",\n\"User Restored from Recycle Bin\",\n\"Group Restored from Recycle Bin\",\n\"Scheduled Cleanup\",\n\"Consolidation finished\",\n\"Monitoring session finished\",\n\"User Rename\",\n\"Group Rename\",\n\"Role Create\",\n\"Role Delete\",\n\"Role Modify\",\n\"Role Rename\",\n\"Recycle Bin Role Deleted\",\n\"Role Moved to Recycle Bin\",\n\"Role Restored from Recycle Bin\",\n\"Set group members\",\n\"Set group members for moved in objects\",\n\"User logout\",\n\"Password change successful\",\n\"Password change failed\",\n\"Add Parent Object\",\n\"Remove Parent Object\",\n\"OAuth Client Create\",\n\"OAuth Client Delete\",\n\"OAuth Client Modify\",\n\"Tenant Create\",\n\"Tenant Delete\",\n\"Tenant Modify\",\n\"Migration\",\n],\n}\nrequest_url = \"{}/audit\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Enable audit; calling -&gt; %s\", request_url)\nresponse = requests.put(\nurl=request_url,\njson=auditPutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to enable audit; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn response\n# end method definition\ndef add_oauth_client(\nself,\nclient_id: str,\ndescription: str,\nredirect_urls: list | None = None,\nallow_impersonation: bool = True,\nconfidential: bool = True,\nauth_scopes: list | None = None,  # None = \"Global\"\nallowed_scopes: list | None = None,  # in OTDS UI: Permissible scopes\ndefault_scopes: list | None = None,  # in OTDS UI: Default scopes\nsecret: str = \"\",\n) -&gt; dict | None:\n\"\"\"Add a new OAuth client to OTDS\n        Args:\n            client_id (str): name of the new OAuth client (should not have blanks)\n            description (str): description of the OAuth client\n            redirect_urls (list): list of redirect URLs (strings)\n            allow_impersonation (bool, optional): allow impresonation\n            confidential (bool, optional): is confidential\n            auth_scopes (list, optional): if empty then \"Global\"\n            allowed_scopes (list, optional): in OTDS UI this is called Permissible scopes\n            default_scopes (list, optional): in OTDS UI this is called Default scopes\n            secret (str, optional): predefined OAuth client secret. If empty a new secret is generated.\n        Returns:\n            dict: Request response or None if the creation fails.\n            Example:\n            {\n                \"description\": \"string\",\n                \"redirectURLs\": [\n                    \"string\"\n                ],\n                \"id\": \"string\",\n                \"location\": \"string\",\n                \"accessTokenLifeTime\": 0,\n                \"refreshTokenLifeTime\": 0,\n                \"authCodeLifeTime\": 0,\n                \"allowRefreshToken\": true,\n                \"allowImpersonation\": true,\n                \"useSessionRefreshTokenLifeTime\": true,\n                \"allowedScopes\": [\n                    \"string\"\n                ],\n                \"defaultScopes\": [\n                    \"string\"\n                ],\n                \"impersonateList\": [\n                    \"string\"\n                ],\n                \"confidential\": true,\n                \"secret\": \"string\",\n                \"customAttributes\": [\n                    {\n                    \"type\": \"string\",\n                    \"name\": \"string\",\n                    \"value\": \"string\"\n                    }\n                ],\n                \"logoutURL\": \"string\",\n                \"logoutMethod\": \"string\",\n                \"authScopes\": [\n                    \"string\"\n                ],\n                \"uuid\": \"string\",\n                \"name\": \"string\",\n                \"urlId\": \"string\",\n                \"urlLocation\": \"string\"\n            }\n        \"\"\"\n# Avoid linter warning W0102:\nif redirect_urls is None:\nredirect_urls = []\nif auth_scopes is None:\nauth_scopes = []\nif allowed_scopes is None:\nallowed_scopes = []\nif default_scopes is None:\ndefault_scopes = []\noauthClientPostBodyJson = {\n\"id\": client_id,\n\"description\": description,\n\"redirectURLs\": redirect_urls,\n\"accessTokenLifeTime\": 1000,\n\"refreshTokenLifeTime\": 20000,\n\"authCodeLifeTime\": 20000,\n\"allowRefreshToken\": True,\n\"allowImpersonation\": allow_impersonation,\n\"useSessionRefreshTokenLifeTime\": True,\n\"confidential\": confidential,\n\"authScopes\": auth_scopes,\n\"allowedScopes\": allowed_scopes,\n\"defaultScopes\": default_scopes,\n}\n# Do we have a predefined client secret?\nif secret:\noauthClientPostBodyJson[\"secret\"] = secret\nrequest_url = self.oauth_client_url()\nlogger.info(\n\"Adding oauth client -&gt; %s (%s); calling -&gt; %s\",\ndescription,\nclient_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=oauthClientPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add OAuth client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef get_oauth_client(self, client_id: str, show_error: bool = True) -&gt; dict | None:\n\"\"\"Get an existing OAuth client from OTDS\n        Args:\n            client_id (str): name (= ID) of the OAuth client to retrieve\n            show_error (bool): whether or not we want to log an error if partion is not found\n        Returns:\n            dict: Request response (dictionary) or None if the client is not found.\n        \"\"\"\nrequest_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\nlogger.info(\"Get oauth client -&gt; %s; calling -&gt; %s\", client_id, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get oauth client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef update_oauth_client(self, client_id: str, updates: dict) -&gt; dict | None:\n\"\"\"Updates the OAuth client with new values\n        Args:\n            client_id (str): name (= ID) of the OAuth client\n            updates (dict): new values for OAuth client, e.g.\n                            {\"description\": \"this is the new value\"}\n        Returns:\n            dict: Request response (json) or None if the REST call fails.\n        \"\"\"\noauthClientPatchBodyJson = updates\nrequest_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\nlogger.info(\n\"Update OAuth client -&gt; %s with -&gt; %s; calling -&gt; %s\",\nclient_id,\nupdates,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nurl=request_url,\njson=oauthClientPatchBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update OAuth client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_oauth_clients_to_access_role(self, access_role_name: str):\n\"\"\"Add Oauth clients user partion to an OTDS Access Role\n        Args:\n            access_role_name (str): name of the OTDS Access Role\n        Returns:\n            response of REST call or None in case of an error\n        \"\"\"\nrequest_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role_name\nlogger.info(\n\"Get access role -&gt; %s; calling -&gt; %s\", access_role_name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\naccessRolesJson = self.parse_request_response(response)\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve role -&gt; %s; url -&gt; %s : error -&gt; %s (%s)\",\naccess_role_name,\nrequest_url,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# Checking if OAuthClients partition already added to access role\nuserPartitions = accessRolesJson[\"accessRoleMembers\"][\"userPartitions\"]\nfor userPartition in userPartitions:\nif userPartition[\"userPartition\"] == \"OAuthClients\":\nlogger.error(\n\"OAuthClients partition already added to role -&gt; %s\",\naccess_role_name,\n)\nreturn None\n# Getting location info for the OAuthClients partition\n# so it can be added to access roles json\nrequest_url = self.config()[\"partitionsUrl\"] + \"/OAuthClients\"\npartitionsResponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif partitionsResponse.ok:\nresponse_dict = self.parse_request_response(partitionsResponse)\nif not response_dict:\nreturn None\noauthClientLocation = response_dict[\"location\"]\nelse:\nlogger.error(\n\"Failed to get partition info for OAuthClients; url -&gt; %s : error -&gt; %s (%s)\",\nrequest_url,\npartitionsResponse.text,\nresponse.status_code,\n)\nreturn None\n# adding OAuthClients info to acess roles organizational units\noauthClientsOuBlock = {\n\"location\": oauthClientLocation,\n\"name\": oauthClientLocation,\n\"userPartition\": None,\n}\naccessRolesJson[\"accessRoleMembers\"][\"organizationalUnits\"].append(\noauthClientsOuBlock\n)\nresponse = requests.put(\nurl=request_url,\njson=accessRolesJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.info(\n\"OauthClients partition successfully added to access role -&gt; %s\",\naccess_role_name,\n)\nelse:\nlogger.warning(\n\"Status code of -&gt; %s returned attempting to add OAuthClients to access role -&gt; %s: error -&gt; %s\",\nresponse.status_code,\naccess_role_name,\nresponse.text,\n)\nreturn response\n# end method definition\ndef get_access_token(self, client_id: str, client_secret: str) -&gt; str | None:\n\"\"\"Get the access token\n        Args:\n            client_id (str): OAuth client name (= ID)\n            client_secret (str): OAuth client secret. This is typically returned\n                                 by add_oauth_client() method in [\"secret\"] field\n        Returns:\n            str: access token, or None\n        \"\"\"\nencoded_client_secret = \"{}:{}\".format(client_id, client_secret).encode(\"utf-8\")\naccessTokenRequestHeaders = {\n\"Authorization\": \"Basic \"\n+ base64.b64encode(encoded_client_secret).decode(\"utf-8\"),\n\"Content-Type\": \"application/x-www-form-urlencoded\",\n}\nrequest_url = self.token_url()\nresponse = requests.post(\nurl=request_url,\ndata={\"grant_type\": \"client_credentials\"},\nheaders=accessTokenRequestHeaders,\ntimeout=None,\n)\naccess_token = None\nif response.ok:\naccessTokenJson = self.parse_request_response(response)\nif \"access_token\" in accessTokenJson:\naccess_token = accessTokenJson[\"access_token\"]\nelse:\nreturn None\nreturn access_token\n# end method definition\ndef get_auth_handler(self, name: str, show_error: bool = True) -&gt; dict | None:\n\"\"\"Get the OTDS auth handler with a given name.\n        Args:\n            name (str): Name of the authentication handler\n        Returns:\n            dict | None: auth handler dictionary, or None\n            Example result:\n            {\n                '_name': 'Salesforce',\n                '_id': 'Salesforce',\n                '_description': 'Salesforce OAuth Authentication Handler',\n                '_class': 'com.opentext.otds.as.drivers.http.OAuth2Handler',\n                '_enabled': True,\n                '_credentialBased': True,\n                '_priority': 10,\n                '_scope': None,\n                '_properties': [\n                    {\n                        '_key': 'com.opentext.otds.as.drivers.http.oauth2.provider_name',\n                        '_name': 'Provider Name',\n                        '_description': 'The name of the authentication provider. This name is displayed on the login page.',\n                        '_required': True,\n                        '_fileBased': False,\n                        '_fileName': False,\n                        '_fileExtensions': None,\n                        '_value': 'Salesforce',\n                        '_allowedValues': None,\n                        ...\n                    },\n                    ...\n                ]\n                '_authPrincipalAttrNames': ['oTExtraAttr0'],\n                'createPermission': True,\n                'readPermission': True,\n                'updatePermission': True,\n                'deletePermission': True,\n                'enablePermission': True,\n            }\n        \"\"\"\nrequest_url = \"{}/{}\".format(self.auth_handler_url(), name)\nlogger.info(\n\"Getting authentication handler -&gt; %s; calling -&gt; %s\", name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get authentication handler -&gt; %s; warning -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_auth_handler_saml(\nself,\nname: str,\ndescription: str,\nscope: str | None,\nprovider_name: str,\nsaml_url: str,\notds_sp_endpoint: str,\nenabled: bool = True,\npriority: int = 5,\nactive_by_default: bool = False,\nauth_principal_attributes: list | None = None,\nnameid_format: str = \"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\",\n) -&gt; dict | None:\n\"\"\"Add a new SAML authentication handler\n        Args:\n            name (str): name of the new authentication handler\n            description (str): description of the new authentication handler\n            scope (str): name of the user partition (to define a scope of the auth handler)\n            provider_name (str): description of the new authentication handler\n            saml_url (str): SAML URL\n            otds_sp_endpoint (str): the external(!) service provider URL of OTDS\n            enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n            priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n            active_by_default (bool, optional): should OTDS redirect immediately to provider page\n                                                (not showing the OTDS login at all)\n            auth_principal_attributes (list, optional): List of Authentication principal attributes\n            nameid_format (str, optional): Specifies which NameID format supported by the identity provider\n                                           contains the desired user identifier. The value in this identifier\n                                           must correspond to the value of the user attribute specified for the\n                                           authentication principal attribute.\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\nif auth_principal_attributes is None:\nauth_principal_attributes = [\"oTExternalID1\", \"oTUserID1\"]\nauthHandlerPostBodyJson = {\n\"_name\": name,\n\"_description\": description,\n\"_class\": \"com.opentext.otds.as.drivers.saml.SAML2Handler\",\n\"_enabled\": str.lower(str(enabled)),\n\"_priority\": str(priority),\n\"_authPrincipalAttrNames\": auth_principal_attributes,\n\"_scope\": scope,\n\"_properties\": [\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.provider_name\",\n\"_name\": \"Identity Provider (IdP) Name\",\n\"_description\": \"The name of the identity provider. This should be a single word since it will be part of the metadata URL.\",\n\"_value\": provider_name,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.provider_metadata_description\",\n\"_name\": \"IdP Metadata URL\",\n\"_description\": \"The URL for the IdP's federation metadata. The metadata will be automatically updated by OTDS daily at midnight.\",\n\"_value\": saml_url,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.provider_nameid_format\",\n\"_name\": \"IdP NameID Format\",\n\"_description\": \"Specifies which NameID format supported by the identity provider contains the desired user identifier. The value in this identifier must correspond to the value of the user attribute specified for the authentication principal attribute. This value is usually set to urn:oasis:names:tc:SAML:2.0:nameid-format:persistent or urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress. Please ensure this is consistent with the identity provider's configuration.\",\n\"_value\": nameid_format,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml._impersonator_claim\",\n\"_name\": \"Claim for impersonating user\",\n\"_description\": \"A claim that contains the ID of the actor/impersonator for the user identified by NameID. It must be in the same format as NameID.\",\n\"_value\": \"loggedinuserid\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.sp_url\",\n\"_name\": \"OTDS SP Endpoint\",\n\"_description\": \"Specifies the service provider URL that will be used to identify OTDS to the identity provider. If not specified, the URL will be taken from the request. This generally needs to be configured for environments in which OTDS is behind a reverse-proxy.\",\n\"_value\": otds_sp_endpoint,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.enable_sp_sso\",\n\"_name\": \"Active By Default\",\n\"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to the IdP. If false, the user has to select the provider on the login page.\",\n\"_value\": active_by_default,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml._signature_alg\",\n\"_name\": \"XML Signature Algorithm\",\n\"_description\": \"Only relevant when certificate and private key are configured. Default is http://www.w3.org/2000/09/xmldsig#rsa-sha1. Valid values are defined at http://www.w3.org/TR/xmldsig-core1/#sec-AlgID.\",\n\"_value\": \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.use_acs_url\",\n\"_name\": \"Use AssertionConsumerServiceURL\",\n\"_description\": \"Set to true to have the SAML AuthnRequest use AssertionConsumerServiceURL instead of AssertionConsumerServiceIndex\",\n\"_value\": \"true\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.grace_period\",\n\"_name\": \"Grace Period\",\n\"_description\": 'Specifies the number of minutes to allow for \"NotBefore\" and \"NotOnOrAfter\" fields when validating assertions in order to account for time difference between the identity provider and this service provider.',\n\"_value\": \"5\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.auth_request_binding\",\n\"_name\": \"Auth Request Binding\",\n\"_description\": \"Specifies the preferred SAML binding to use for sending the AuthnRequest, provided it is supported by the identity provider.\",\n\"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.auth_response_binding\",\n\"_name\": \"Auth Response Binding\",\n\"_description\": \"Specifies the SAML binding to use for the response to an AuthnRequest\",\n\"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n},\n],\n}\nrequest_url = self.auth_handler_url()\nlogger.info(\n\"Adding SAML auth handler -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=authHandlerPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add SAML auth handler -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef add_auth_handler_sap(\nself,\nname: str,\ndescription: str,\nscope: str | None,\ncertificate_file: str,\ncertificate_password: str,\nenabled: bool = True,\npriority: int = 10,\nauth_principal_attributes: list | None = None,\n):\n\"\"\"Add a new SAP authentication handler\n        Args:\n            name (str): name of the new authentication handler\n            description (str): description of the new authentication handler\n            scope (str): name of the user partition (to define a scope of the auth handler)\n            certificate_file (str): fully qualified file name (with path) to the certificate file\n            certificate_password (str): password of the certificate\n            enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n            priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n            auth_principal_attributes (list, optional): List of Authentication principal attributes\n        Returns:\n            Request response (json) or None if the REST call fails.\n        \"\"\"\n# Avoid linter warning W0102:\nif auth_principal_attributes is None:\nauth_principal_attributes = [\"oTExternalID1\"]\n# 1. Prepare the body for the AuthHandler REST call:\nauthHandlerPostBodyJson = {\n\"_name\": name,\n\"_description\": description,\n\"_class\": \"com.opentext.otds.as.drivers.sapssoext.SAPSSOEXTAuthHandler\",\n\"_enabled\": str.lower(str(enabled)),\n\"_priority\": str(priority),\n\"_authPrincipalAttrNames\": auth_principal_attributes,\n\"_scope\": scope,\n\"_properties\": [\n{\n\"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_description1\",\n\"_name\": \"SAP Certificate 1 Description\",\n\"_description\": \"Specifies a custom description for the corresponding certificate.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": os.path.basename(\ncertificate_file\n),  # \"TM6_Sandbox.pse\" - file name only\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\",\n\"_name\": \"SAP Certificate (PSE) 1\",\n\"_description\": \"Specifies a certificate (.pse file) to use to decode SAP tokens. Note: The selected file does not need to reside on the server since only its contents will be stored on the server. Clear the string in this field in order to delete the certificate stored on the server.\",\n\"_required\": False,\n\"_fileBased\": True,\n\"_fileName\": False,\n\"_fileExtensions\": [\"pse\"],\n\"_value\": None,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_pass1\",\n\"_name\": \"SAP Certificate 1 Password\",\n\"_description\": \"Specifies the password for the corresponding .pse file.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": certificate_password,\n\"_allowedValues\": None,\n\"_confidential\": True,\n\"_keepOriginal\": False,\n},\n],\n}\n# 2. Create the auth handler in OTDS\nrequest_url = self.auth_handler_url()\nlogger.info(\n\"Adding SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nresponse = requests.post(\nurl=request_url,\njson=authHandlerPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to add SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# 3. Upload the certificate file:\n# Check that the certificate (PSE) file is readable:\nlogger.info(\"Reading certificate file -&gt; %s...\", certificate_file)\ntry:\n# PSE files are binary - so we need to open with \"rb\":\nwith open(certificate_file, \"rb\") as certFile:\ncertContent = certFile.read()\nif not certContent:\nlogger.error(\"No data in certificate file -&gt; %s\", certificate_file)\nreturn None\nexcept IOError as exception:\nlogger.error(\n\"Unable to open certificate file -&gt; %s; error -&gt; %s\",\ncertificate_file,\nexception.strerror,\n)\nreturn None\n# Check that we have the binary certificate file - this is what OTDS expects. If the file content is\n# base64 encoded we will decode it and write it back into the same file\ntry:\n# If file is not base64 encoded the next statement will throw an exception\n# (this is good)\ncertContentDecoded = base64.b64decode(certContent, validate=True)\ncertContentEncoded = base64.b64encode(certContentDecoded).decode(\"utf-8\")\nif certContentEncoded == certContent.decode(\"utf-8\"):\nlogger.info(\n\"Certificate file -&gt; %s is base64 encoded\", certificate_file\n)\ncert_file_encoded = True\nelse:\ncert_file_encoded = False\nexcept TypeError:\nlogger.info(\n\"Certificate file -&gt; %s is not base64 encoded\", certificate_file\n)\ncert_file_encoded = False\nif cert_file_encoded:\ncertificate_file = \"/tmp/\" + os.path.basename(certificate_file)\nlogger.info(\"Writing decoded certificate file -&gt; %s...\", certificate_file)\ntry:\n# PSE files need to be binary - so we need to open with \"wb\":\nwith open(certificate_file, \"wb\") as certFile:\ncertFile.write(base64.b64decode(certContent))\nexcept IOError as exception:\nlogger.error(\n\"Failed writing to file -&gt; %s; error -&gt; %s\",\ncertificate_file,\nexception.strerror,\n)\nreturn None\nauthHandlerPostData = {\n\"file1_property\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\"\n}\n# It is important to send the file pointer and not the actual file content\n# otherwise the file is send base64 encoded which we don't want:\nauthHandlerPostFiles = {\n\"file1\": (\nos.path.basename(certificate_file),\nopen(certificate_file, \"rb\"),\n\"application/octet-stream\",\n)\n}\nrequest_url = self.auth_handler_url() + \"/\" + name + \"/files\"\nlogger.info(\n\"Uploading certificate file -&gt; %s for SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\ncertificate_file,\nname,\ndescription,\nrequest_url,\n)\n# it is important to NOT pass the headers parameter here!\n# Basically, if you specify a files parameter (a dictionary),\n# then requests will send a multipart/form-data POST automatically:\nresponse = requests.post(\nurl=request_url,\ndata=authHandlerPostData,\nfiles=authHandlerPostFiles,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to upload certificate file -&gt; %s for SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\ncertificate_file,\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\nreturn response\n# end method definition\ndef add_auth_handler_oauth(\nself,\nname: str,\ndescription: str,\nscope: str | None,\nprovider_name: str,\nclient_id: str,\nclient_secret: str,\nactive_by_default: bool = False,\nauthorization_endpoint: str = \"\",\ntoken_endpoint: str = \"\",\nscope_string: str = \"\",\nenabled: bool = True,\npriority: int = 10,\nauth_principal_attributes: list | None = None,\n) -&gt; dict | None:\n\"\"\"Add a new OAuth authentication handler\n        Args:\n            name (str): name of the new authentication handler\n            description (str): description of the new authentication handler\n            scope (str): name of the user partition (to define a scope of the auth handler)\n            provider_name (str): the name of the authentication provider. This name is displayed on the login page.\n            client_id (str): the client ID\n            client_secret (str): the client secret\n            active_by_default (bool, optional): Whether to activate this handler for any request to the OTDS login page.\n                                                If True, any login request to the OTDS login page will be redirected to this OAuth provider.\n                                                If False, the user has to select the provider on the login page.\n            authorization_endpoint (str, optional): The URL to redirect the browser to for authentication.\n                                                    It is used to retrieve the authorization code or an OIDC id_token.\n            token_endpoint (str, optional): The URL from which to retrieve the access token.\n                                            Not strictly required with OpenID Connect if using the implicit flow.\n            scope_string (str, optional): Space delimited scope values to send. Include 'openid' to use OpenID Connect.\n            enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n            priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n            auth_principal_attributes (list, optional): List of Authentication principal attributes\n        Returns:\n            dict: Request response (dictionary) or None if the REST call fails.\n        \"\"\"\n# Avoid linter warning W0102:\nif auth_principal_attributes is None:\nauth_principal_attributes = [\"oTExtraAttr0\"]\n# 1. Prepare the body for the AuthHandler REST call:\nauthHandlerPostBodyJson = {\n\"_name\": name,\n\"_description\": description,\n\"_class\": \"com.opentext.otds.as.drivers.http.OAuth2Handler\",\n\"_enabled\": str.lower(str(enabled)),\n\"_priority\": str(priority),\n\"_authPrincipalAttrNames\": auth_principal_attributes,\n\"_scope\": scope,\n\"_properties\": [\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.provider_name\",\n\"_name\": \"Provider Name\",\n\"_description\": \"The name of the authentication provider. This name is displayed on the login page.\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": provider_name,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.active_by_default\",\n\"_name\": \"Active By Default\",\n\"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to this OAuth provider. If false, the user has to select the provider on the login page.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": active_by_default,\n\"_allowedValues\": [\"true\", \"false\"],\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_id\",\n\"_name\": \"Client ID\",\n\"_description\": \"The Client ID\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": client_id,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_secret\",\n\"_name\": \"Client Secret\",\n\"_description\": \"The Client Secret\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": client_secret,\n\"_allowedValues\": None,\n\"_confidential\": True,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.scope_string\",\n\"_name\": \"Scope String\",\n\"_description\": \"Space delimited scope values to send. Include 'openid' to use OpenID Connect.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": scope_string,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_code_url\",\n\"_name\": \"Authorization Endpoint\",\n\"_description\": \"The URL to redirect the browser to for authentication. It is used to retrieve the authorization code or an OIDC id_token.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": authorization_endpoint,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_access_token_url\",\n\"_name\": \"Token Endpoint\",\n\"_description\": \"The URL from which to retrieve the access token. Not strictly required with OpenID Connect if using the implicit flow.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": token_endpoint,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_user_info_url\",\n\"_name\": \"User Info Endpoint\",\n\"_description\": \"The URL from which to retrieve the JSON object representing the authorized user\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"{id}\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.user_identifier\",\n\"_name\": \"User Identifier Field\",\n\"_description\": \"The field corresponding to the user's unique ID at this provider\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"username\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field1\",\n\"_name\": \"Response Field 1\",\n\"_description\": \"A field in the JSON response that should be mapped to an OTDS attribute. This value is case sensitive. Mapped fields are only relevant for auto-provisioned accounts.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"email\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute1\",\n\"_name\": \"OTDS Attribute 1\",\n\"_description\": \"OTDS user attribute to which the response field should be mapped.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"mail\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field2\",\n\"_name\": \"Response Field 2\",\n\"_description\": \"\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"first_name\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute2\",\n\"_name\": \"OTDS Attribute 2\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"givenName\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field3\",\n\"_name\": \"Response Field 3\",\n\"_description\": \"\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"last_name\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute3\",\n\"_name\": \"OTDS Attribute 3\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"sn\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute4\",\n\"_name\": \"OTDS Attribute 4\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"displayName\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute5\",\n\"_name\": \"OTDS Attribute 5\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTStreetAddress\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute6\",\n\"_name\": \"OTDS Attribute 6\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"l\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute7\",\n\"_name\": \"OTDS Attribute 7\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"st\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute8\",\n\"_name\": \"OTDS Attribute 8\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"postalCode\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute9\",\n\"_name\": \"OTDS Attribute 9\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"countryName\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute10\",\n\"_name\": \"OTDS Attribute 10\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTTelephoneNumber\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute11\",\n\"_name\": \"OTDS Attribute 11\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTMemberOf\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute12\",\n\"_name\": \"OTDS Attribute 12\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTDepartment\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute13\",\n\"_name\": \"OTDS Attribute 13\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"title\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n],\n}\nrequest_url = self.auth_handler_url()\nlogger.info(\n\"Adding OAuth auth handler -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=authHandlerPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add OAuth auth handler -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef consolidate(self, resource_name: str) -&gt; bool:\n\"\"\"Consolidate an OTDS resource\n        Args:\n            resource_name (str): resource to be consolidated\n        Returns:\n            bool: True if the consolidation succeeded or False if it failed.\n        \"\"\"\nresource = self.get_resource(resource_name)\nif not resource:\nlogger.error(\"Resource -&gt; %s not found - cannot consolidate\", resource_name)\nreturn False\nresource_dn = resource[\"resourceDN\"]\nif not resource_dn:\nlogger.error(\"Resource DN is empty - cannot consolidate\")\nreturn False\nconsolidationPostBodyJson = {\n\"cleanupUsersInResource\": False,\n\"cleanupGroupsInResource\": False,\n\"resourceList\": [resource_dn],\n\"objectToConsolidate\": resource_dn,\n}\nrequest_url = \"{}\".format(self.consolidation_url())\nlogger.info(\n\"Consolidation of resource -&gt; %s; calling -&gt; %s\", resource_dn, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=consolidationPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to consolidate; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef impersonate_resource(\nself,\nresource_name: str,\nallow_impersonation: bool = True,\nimpersonation_list: list | None = None,\n) -&gt; bool:\n\"\"\"Configure impersonation for an OTDS resource\n        Args:\n            resource_name (str): resource to be configure impersonation for\n            allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n            impersonation_list (list, optional): list of users to restrict it to\n                                                 (default = empty list = all users)\n        Returns:\n            bool: True if the impersonation setting succeeded or False if it failed.\n        \"\"\"\n# Avoid linter warning W0102:\nif impersonation_list is None:\nimpersonation_list = []\nimpersonationPutBodyJson = {\n\"allowImpersonation\": allow_impersonation,\n\"impersonateList\": impersonation_list,\n}\nrequest_url = \"{}/{}/impersonation\".format(self.resource_url(), resource_name)\nlogger.info(\n\"Impersonation settings for resource -&gt; %s; calling -&gt; %s\",\nresource_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=impersonationPutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set impersonation for resource -&gt; %s; error -&gt; %s\",\nresource_name,\nresponse.text,\n)\nreturn False\n# end method definition\ndef impersonate_oauth_client(\nself,\nclient_id: str,\nallow_impersonation: bool = True,\nimpersonation_list: list | None = None,\n) -&gt; bool:\n\"\"\"Configure impersonation for an OTDS OAuth Client\n        Args:\n            client_id (str): OAuth Client to be configure impersonation for\n            allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n            impersonation_list (list, optional): list of users to restrict it to; (default = empty list = all users)\n        Returns:\n            bool: True if the impersonation setting succeeded or False if it failed.\n        \"\"\"\n# Avoid linter warning W0102:\nif impersonation_list is None:\nimpersonation_list = []\nimpersonationPutBodyJson = {\n\"allowImpersonation\": allow_impersonation,\n\"impersonateList\": impersonation_list,\n}\nrequest_url = \"{}/{}/impersonation\".format(self.oauth_client_url(), client_id)\nlogger.info(\n\"Impersonation settings for OAuth Client -&gt; %s; calling -&gt; %s\",\nclient_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=impersonationPutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set impersonation for OAuth Client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n# end method definition\ndef get_password_policy(self):\n\"\"\"Get the global password policy\n        Args:\n            None\n        Returns:\n            dict: Request response or None if the REST call fails.\n            Example response:\n            {\n                'passwordHistoryMaximumCount': 3,\n                'daysBeforeNewPasswordMayBeChanged': 1,\n                'passwordMaximumDuration': 90,\n                'daysBeforeOldPasswordMayBeReused': 0,\n                'lockoutFailureCount': 0,\n                'lockoutDuration': 15,\n                'minimumNumberOfCharacters': 8,\n                'complexPasswordValidationEnabled': True,\n                'minimumNumberOfDigits': 1,\n                'minimumNumberOfSymbols': 1,\n                'minimumNumberOfUppercase': 1,\n                'minimumNumberOfLowercase': 1,\n                'minimumChangesToPreviousPassword': 0,\n                'maxNumberOfConsecutiveANCharsInPassword': 0,\n                'blockCommonPassword': False\n                ...\n            }\n        \"\"\"\nrequest_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Getting password policy; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get password policy; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# end method definition\ndef update_password_policy(self, update_values: dict) -&gt; bool:\n\"\"\"Update the global password policy\n        Args:\n            update_values (dict): new values for selected settings.\n                                  A value of 0 means the settings is deactivated.\n            Example values:\n            {\n                'passwordHistoryMaximumCount': 3,\n                'daysBeforeNewPasswordMayBeChanged': 1,\n                'passwordMaximumDuration': 90,\n                'daysBeforeOldPasswordMayBeReused': 0,\n                'lockoutFailureCount': 0,\n                'lockoutDuration': 15,\n                'minimumNumberOfCharacters': 8,\n                'complexPasswordValidationEnabled': True,\n                'minimumNumberOfDigits': 1,\n                'minimumNumberOfSymbols': 1,\n                'minimumNumberOfUppercase': 1,\n                'minimumNumberOfLowercase': 1,\n                'minimumChangesToPreviousPassword': 0,\n                'maxNumberOfConsecutiveANCharsInPassword': 0,\n                'blockCommonPassword': False\n                ...\n            }\n        Returns:\n            bool: True if the REST call succeeds, otherwise False. We use a boolean return\n                  value as the response of the REST call does not have meaningful content.\n        \"\"\"\nrequest_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\n\"Update password policy with these new values -&gt; %s; calling -&gt; %s\",\nupdate_values,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=update_values,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update password policy with values -&gt; %s; error -&gt; %s (%s)\",\nupdate_values,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.__init__","title":"<code>__init__(protocol, hostname, port, username=None, password=None, otds_ticket=None)</code>","text":"<p>Initialize the OTDS object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>either http or https</p> required <code>hostname</code> <code>str</code> <p>hostname of otds</p> required <code>port</code> <code>int</code> <p>port number - typically 80 or 443</p> required <code>username</code> <code>str</code> <p>otds user name. Optional if otds_ticket is provided.</p> <code>None</code> <code>password</code> <code>str</code> <p>otds password. Optional if otds_ticket is provided.</p> <code>None</code> <code>otds_ticket</code> <code>str</code> <p>Authentication ticket of OTDS</p> <code>None</code> Source code in <code>pyxecm/otds.py</code> <pre><code>def __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\nusername: str | None = None,\npassword: str | None = None,\notds_ticket: str | None = None,\n):\n\"\"\"Initialize the OTDS object\n    Args:\n        protocol (str): either http or https\n        hostname (str): hostname of otds\n        port (int): port number - typically 80 or 443\n        username (str, optional): otds user name. Optional if otds_ticket is provided.\n        password (str, optional): otds password. Optional if otds_ticket is provided.\n        otds_ticket (str, optional): Authentication ticket of OTDS\n    \"\"\"\n# Initialize otdsConfig as an empty dictionary\notds_config = {}\nif hostname:\notds_config[\"hostname\"] = hostname\nelse:\notds_config[\"hostname\"] = \"otds\"\nif protocol:\notds_config[\"protocol\"] = protocol\nelse:\notds_config[\"protocol\"] = \"http\"\nif port:\notds_config[\"port\"] = port\nelse:\notds_config[\"port\"] = 80\nif username:\notds_config[\"username\"] = username\nelse:\notds_config[\"username\"] = \"admin\"\nif password:\notds_config[\"password\"] = password\nelse:\notds_config[\"password\"] = \"\"\nif otds_ticket:\nself._cookie = {\"OTDSTicket\": otds_ticket}\notdsBaseUrl = protocol + \"://\" + otds_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notdsBaseUrl += \":{}\".format(port)\notdsBaseUrl += \"/otdsws\"\notds_config[\"baseUrl\"] = otdsBaseUrl\notdsRestUrl = otdsBaseUrl + \"/rest\"\notds_config[\"restUrl\"] = otdsRestUrl\notds_config[\"partitionUrl\"] = otdsRestUrl + \"/partitions\"\notds_config[\"accessRoleUrl\"] = otdsRestUrl + \"/accessroles\"\notds_config[\"credentialUrl\"] = otdsRestUrl + \"/authentication/credentials\"\notds_config[\"oauthClientUrl\"] = otdsRestUrl + \"/oauthclients\"\notds_config[\"tokenUrl\"] = otdsBaseUrl + \"/oauth2/token\"\notds_config[\"resourceUrl\"] = otdsRestUrl + \"/resources\"\notds_config[\"licenseUrl\"] = otdsRestUrl + \"/licensemanagement/licenses\"\notds_config[\"usersUrl\"] = otdsRestUrl + \"/users\"\notds_config[\"groupsUrl\"] = otdsRestUrl + \"/groups\"\notds_config[\"systemConfigUrl\"] = otdsRestUrl + \"/systemconfig\"\notds_config[\"authHandlerUrl\"] = otdsRestUrl + \"/authhandlers\"\notds_config[\"consolidationUrl\"] = otdsRestUrl + \"/consolidation\"\nself._config = otds_config\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.access_role_url","title":"<code>access_role_url()</code>","text":"<p>Returns the Access Role URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Access Role URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def access_role_url(self) -&gt; str:\n\"\"\"Returns the Access Role URL of OTDS\n    Returns:\n        str: Access Role URL\n    \"\"\"\nreturn self.config()[\"accessRoleUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.activate_resource","title":"<code>activate_resource(resource_id)</code>","text":"<p>Activate an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>ID of the OTDS resource</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def activate_resource(self, resource_id: str) -&gt; dict | None:\n\"\"\"Activate an OTDS resource\n    Args:\n        resource_id (str): ID of the OTDS resource\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\nresourcePostBodyJson = {}\nrequest_url = \"{}/{}/activate\".format(self.config()[\"resourceUrl\"], resource_id)\nlogger.info(\n\"Activating resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=resourcePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to activate resource -&gt; %s; error -&gt; %s (%s)\",\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_auth_handler_oauth","title":"<code>add_auth_handler_oauth(name, description, scope, provider_name, client_id, client_secret, active_by_default=False, authorization_endpoint='', token_endpoint='', scope_string='', enabled=True, priority=10, auth_principal_attributes=None)</code>","text":"<p>Add a new OAuth authentication handler</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new authentication handler</p> required <code>description</code> <code>str</code> <p>description of the new authentication handler</p> required <code>scope</code> <code>str</code> <p>name of the user partition (to define a scope of the auth handler)</p> required <code>provider_name</code> <code>str</code> <p>the name of the authentication provider. This name is displayed on the login page.</p> required <code>client_id</code> <code>str</code> <p>the client ID</p> required <code>client_secret</code> <code>str</code> <p>the client secret</p> required <code>active_by_default</code> <code>bool</code> <p>Whether to activate this handler for any request to the OTDS login page.                                 If True, any login request to the OTDS login page will be redirected to this OAuth provider.                                 If False, the user has to select the provider on the login page.</p> <code>False</code> <code>authorization_endpoint</code> <code>str</code> <p>The URL to redirect the browser to for authentication.                                     It is used to retrieve the authorization code or an OIDC id_token.</p> <code>''</code> <code>token_endpoint</code> <code>str</code> <p>The URL from which to retrieve the access token.                             Not strictly required with OpenID Connect if using the implicit flow.</p> <code>''</code> <code>scope_string</code> <code>str</code> <p>Space delimited scope values to send. Include 'openid' to use OpenID Connect.</p> <code>''</code> <code>enabled</code> <code>bool</code> <p>if the handler should be enabled or disabled. Default is True = enabled.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the Authentical Handler (compared to others). Default is 5</p> <code>10</code> <code>auth_principal_attributes</code> <code>list</code> <p>List of Authentication principal attributes</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_auth_handler_oauth(\nself,\nname: str,\ndescription: str,\nscope: str | None,\nprovider_name: str,\nclient_id: str,\nclient_secret: str,\nactive_by_default: bool = False,\nauthorization_endpoint: str = \"\",\ntoken_endpoint: str = \"\",\nscope_string: str = \"\",\nenabled: bool = True,\npriority: int = 10,\nauth_principal_attributes: list | None = None,\n) -&gt; dict | None:\n\"\"\"Add a new OAuth authentication handler\n    Args:\n        name (str): name of the new authentication handler\n        description (str): description of the new authentication handler\n        scope (str): name of the user partition (to define a scope of the auth handler)\n        provider_name (str): the name of the authentication provider. This name is displayed on the login page.\n        client_id (str): the client ID\n        client_secret (str): the client secret\n        active_by_default (bool, optional): Whether to activate this handler for any request to the OTDS login page.\n                                            If True, any login request to the OTDS login page will be redirected to this OAuth provider.\n                                            If False, the user has to select the provider on the login page.\n        authorization_endpoint (str, optional): The URL to redirect the browser to for authentication.\n                                                It is used to retrieve the authorization code or an OIDC id_token.\n        token_endpoint (str, optional): The URL from which to retrieve the access token.\n                                        Not strictly required with OpenID Connect if using the implicit flow.\n        scope_string (str, optional): Space delimited scope values to send. Include 'openid' to use OpenID Connect.\n        enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n        priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n        auth_principal_attributes (list, optional): List of Authentication principal attributes\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\n# Avoid linter warning W0102:\nif auth_principal_attributes is None:\nauth_principal_attributes = [\"oTExtraAttr0\"]\n# 1. Prepare the body for the AuthHandler REST call:\nauthHandlerPostBodyJson = {\n\"_name\": name,\n\"_description\": description,\n\"_class\": \"com.opentext.otds.as.drivers.http.OAuth2Handler\",\n\"_enabled\": str.lower(str(enabled)),\n\"_priority\": str(priority),\n\"_authPrincipalAttrNames\": auth_principal_attributes,\n\"_scope\": scope,\n\"_properties\": [\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.provider_name\",\n\"_name\": \"Provider Name\",\n\"_description\": \"The name of the authentication provider. This name is displayed on the login page.\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": provider_name,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.active_by_default\",\n\"_name\": \"Active By Default\",\n\"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to this OAuth provider. If false, the user has to select the provider on the login page.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": active_by_default,\n\"_allowedValues\": [\"true\", \"false\"],\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_id\",\n\"_name\": \"Client ID\",\n\"_description\": \"The Client ID\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": client_id,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.client_secret\",\n\"_name\": \"Client Secret\",\n\"_description\": \"The Client Secret\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": client_secret,\n\"_allowedValues\": None,\n\"_confidential\": True,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.scope_string\",\n\"_name\": \"Scope String\",\n\"_description\": \"Space delimited scope values to send. Include 'openid' to use OpenID Connect.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": scope_string,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_code_url\",\n\"_name\": \"Authorization Endpoint\",\n\"_description\": \"The URL to redirect the browser to for authentication. It is used to retrieve the authorization code or an OIDC id_token.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": authorization_endpoint,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_access_token_url\",\n\"_name\": \"Token Endpoint\",\n\"_description\": \"The URL from which to retrieve the access token. Not strictly required with OpenID Connect if using the implicit flow.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": token_endpoint,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.get_user_info_url\",\n\"_name\": \"User Info Endpoint\",\n\"_description\": \"The URL from which to retrieve the JSON object representing the authorized user\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"{id}\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.user_identifier\",\n\"_name\": \"User Identifier Field\",\n\"_description\": \"The field corresponding to the user's unique ID at this provider\",\n\"_required\": True,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"username\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field1\",\n\"_name\": \"Response Field 1\",\n\"_description\": \"A field in the JSON response that should be mapped to an OTDS attribute. This value is case sensitive. Mapped fields are only relevant for auto-provisioned accounts.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"email\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute1\",\n\"_name\": \"OTDS Attribute 1\",\n\"_description\": \"OTDS user attribute to which the response field should be mapped.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"mail\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field2\",\n\"_name\": \"Response Field 2\",\n\"_description\": \"\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"first_name\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute2\",\n\"_name\": \"OTDS Attribute 2\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"givenName\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.field3\",\n\"_name\": \"Response Field 3\",\n\"_description\": \"\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"last_name\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute3\",\n\"_name\": \"OTDS Attribute 3\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"sn\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute4\",\n\"_name\": \"OTDS Attribute 4\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"displayName\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute5\",\n\"_name\": \"OTDS Attribute 5\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTStreetAddress\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute6\",\n\"_name\": \"OTDS Attribute 6\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"l\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute7\",\n\"_name\": \"OTDS Attribute 7\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"st\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute8\",\n\"_name\": \"OTDS Attribute 8\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"postalCode\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute9\",\n\"_name\": \"OTDS Attribute 9\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"countryName\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute10\",\n\"_name\": \"OTDS Attribute 10\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTTelephoneNumber\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute11\",\n\"_name\": \"OTDS Attribute 11\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTMemberOf\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute12\",\n\"_name\": \"OTDS Attribute 12\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"oTDepartment\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.http.oauth2.attribute13\",\n\"_name\": \"OTDS Attribute 13\",\n\"_description\": None,\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": \"title\",\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n],\n}\nrequest_url = self.auth_handler_url()\nlogger.info(\n\"Adding OAuth auth handler -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=authHandlerPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add OAuth auth handler -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_auth_handler_saml","title":"<code>add_auth_handler_saml(name, description, scope, provider_name, saml_url, otds_sp_endpoint, enabled=True, priority=5, active_by_default=False, auth_principal_attributes=None, nameid_format='urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified')</code>","text":"<p>Add a new SAML authentication handler</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new authentication handler</p> required <code>description</code> <code>str</code> <p>description of the new authentication handler</p> required <code>scope</code> <code>str</code> <p>name of the user partition (to define a scope of the auth handler)</p> required <code>provider_name</code> <code>str</code> <p>description of the new authentication handler</p> required <code>saml_url</code> <code>str</code> <p>SAML URL</p> required <code>otds_sp_endpoint</code> <code>str</code> <p>the external(!) service provider URL of OTDS</p> required <code>enabled</code> <code>bool</code> <p>if the handler should be enabled or disabled. Default is True = enabled.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the Authentical Handler (compared to others). Default is 5</p> <code>5</code> <code>active_by_default</code> <code>bool</code> <p>should OTDS redirect immediately to provider page                                 (not showing the OTDS login at all)</p> <code>False</code> <code>auth_principal_attributes</code> <code>list</code> <p>List of Authentication principal attributes</p> <code>None</code> <code>nameid_format</code> <code>str</code> <p>Specifies which NameID format supported by the identity provider                            contains the desired user identifier. The value in this identifier                            must correspond to the value of the user attribute specified for the                            authentication principal attribute.</p> <code>'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_auth_handler_saml(\nself,\nname: str,\ndescription: str,\nscope: str | None,\nprovider_name: str,\nsaml_url: str,\notds_sp_endpoint: str,\nenabled: bool = True,\npriority: int = 5,\nactive_by_default: bool = False,\nauth_principal_attributes: list | None = None,\nnameid_format: str = \"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\",\n) -&gt; dict | None:\n\"\"\"Add a new SAML authentication handler\n    Args:\n        name (str): name of the new authentication handler\n        description (str): description of the new authentication handler\n        scope (str): name of the user partition (to define a scope of the auth handler)\n        provider_name (str): description of the new authentication handler\n        saml_url (str): SAML URL\n        otds_sp_endpoint (str): the external(!) service provider URL of OTDS\n        enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n        priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n        active_by_default (bool, optional): should OTDS redirect immediately to provider page\n                                            (not showing the OTDS login at all)\n        auth_principal_attributes (list, optional): List of Authentication principal attributes\n        nameid_format (str, optional): Specifies which NameID format supported by the identity provider\n                                       contains the desired user identifier. The value in this identifier\n                                       must correspond to the value of the user attribute specified for the\n                                       authentication principal attribute.\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\nif auth_principal_attributes is None:\nauth_principal_attributes = [\"oTExternalID1\", \"oTUserID1\"]\nauthHandlerPostBodyJson = {\n\"_name\": name,\n\"_description\": description,\n\"_class\": \"com.opentext.otds.as.drivers.saml.SAML2Handler\",\n\"_enabled\": str.lower(str(enabled)),\n\"_priority\": str(priority),\n\"_authPrincipalAttrNames\": auth_principal_attributes,\n\"_scope\": scope,\n\"_properties\": [\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.provider_name\",\n\"_name\": \"Identity Provider (IdP) Name\",\n\"_description\": \"The name of the identity provider. This should be a single word since it will be part of the metadata URL.\",\n\"_value\": provider_name,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.provider_metadata_description\",\n\"_name\": \"IdP Metadata URL\",\n\"_description\": \"The URL for the IdP's federation metadata. The metadata will be automatically updated by OTDS daily at midnight.\",\n\"_value\": saml_url,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.provider_nameid_format\",\n\"_name\": \"IdP NameID Format\",\n\"_description\": \"Specifies which NameID format supported by the identity provider contains the desired user identifier. The value in this identifier must correspond to the value of the user attribute specified for the authentication principal attribute. This value is usually set to urn:oasis:names:tc:SAML:2.0:nameid-format:persistent or urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress. Please ensure this is consistent with the identity provider's configuration.\",\n\"_value\": nameid_format,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml._impersonator_claim\",\n\"_name\": \"Claim for impersonating user\",\n\"_description\": \"A claim that contains the ID of the actor/impersonator for the user identified by NameID. It must be in the same format as NameID.\",\n\"_value\": \"loggedinuserid\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.sp_url\",\n\"_name\": \"OTDS SP Endpoint\",\n\"_description\": \"Specifies the service provider URL that will be used to identify OTDS to the identity provider. If not specified, the URL will be taken from the request. This generally needs to be configured for environments in which OTDS is behind a reverse-proxy.\",\n\"_value\": otds_sp_endpoint,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.enable_sp_sso\",\n\"_name\": \"Active By Default\",\n\"_description\": \"Whether to activate this handler for any request to the OTDS login page. If true, any login request to the OTDS login page will be redirected to the IdP. If false, the user has to select the provider on the login page.\",\n\"_value\": active_by_default,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml._signature_alg\",\n\"_name\": \"XML Signature Algorithm\",\n\"_description\": \"Only relevant when certificate and private key are configured. Default is http://www.w3.org/2000/09/xmldsig#rsa-sha1. Valid values are defined at http://www.w3.org/TR/xmldsig-core1/#sec-AlgID.\",\n\"_value\": \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.use_acs_url\",\n\"_name\": \"Use AssertionConsumerServiceURL\",\n\"_description\": \"Set to true to have the SAML AuthnRequest use AssertionConsumerServiceURL instead of AssertionConsumerServiceIndex\",\n\"_value\": \"true\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.grace_period\",\n\"_name\": \"Grace Period\",\n\"_description\": 'Specifies the number of minutes to allow for \"NotBefore\" and \"NotOnOrAfter\" fields when validating assertions in order to account for time difference between the identity provider and this service provider.',\n\"_value\": \"5\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.auth_request_binding\",\n\"_name\": \"Auth Request Binding\",\n\"_description\": \"Specifies the preferred SAML binding to use for sending the AuthnRequest, provided it is supported by the identity provider.\",\n\"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.saml.auth_response_binding\",\n\"_name\": \"Auth Response Binding\",\n\"_description\": \"Specifies the SAML binding to use for the response to an AuthnRequest\",\n\"_value\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\",\n},\n],\n}\nrequest_url = self.auth_handler_url()\nlogger.info(\n\"Adding SAML auth handler -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=authHandlerPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add SAML auth handler -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_auth_handler_sap","title":"<code>add_auth_handler_sap(name, description, scope, certificate_file, certificate_password, enabled=True, priority=10, auth_principal_attributes=None)</code>","text":"<p>Add a new SAP authentication handler</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new authentication handler</p> required <code>description</code> <code>str</code> <p>description of the new authentication handler</p> required <code>scope</code> <code>str</code> <p>name of the user partition (to define a scope of the auth handler)</p> required <code>certificate_file</code> <code>str</code> <p>fully qualified file name (with path) to the certificate file</p> required <code>certificate_password</code> <code>str</code> <p>password of the certificate</p> required <code>enabled</code> <code>bool</code> <p>if the handler should be enabled or disabled. Default is True = enabled.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the Authentical Handler (compared to others). Default is 5</p> <code>10</code> <code>auth_principal_attributes</code> <code>list</code> <p>List of Authentication principal attributes</p> <code>None</code> <p>Returns:</p> Type Description <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_auth_handler_sap(\nself,\nname: str,\ndescription: str,\nscope: str | None,\ncertificate_file: str,\ncertificate_password: str,\nenabled: bool = True,\npriority: int = 10,\nauth_principal_attributes: list | None = None,\n):\n\"\"\"Add a new SAP authentication handler\n    Args:\n        name (str): name of the new authentication handler\n        description (str): description of the new authentication handler\n        scope (str): name of the user partition (to define a scope of the auth handler)\n        certificate_file (str): fully qualified file name (with path) to the certificate file\n        certificate_password (str): password of the certificate\n        enabled (bool, optional): if the handler should be enabled or disabled. Default is True = enabled.\n        priority (int, optional): Priority of the Authentical Handler (compared to others). Default is 5\n        auth_principal_attributes (list, optional): List of Authentication principal attributes\n    Returns:\n        Request response (json) or None if the REST call fails.\n    \"\"\"\n# Avoid linter warning W0102:\nif auth_principal_attributes is None:\nauth_principal_attributes = [\"oTExternalID1\"]\n# 1. Prepare the body for the AuthHandler REST call:\nauthHandlerPostBodyJson = {\n\"_name\": name,\n\"_description\": description,\n\"_class\": \"com.opentext.otds.as.drivers.sapssoext.SAPSSOEXTAuthHandler\",\n\"_enabled\": str.lower(str(enabled)),\n\"_priority\": str(priority),\n\"_authPrincipalAttrNames\": auth_principal_attributes,\n\"_scope\": scope,\n\"_properties\": [\n{\n\"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_description1\",\n\"_name\": \"SAP Certificate 1 Description\",\n\"_description\": \"Specifies a custom description for the corresponding certificate.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": os.path.basename(\ncertificate_file\n),  # \"TM6_Sandbox.pse\" - file name only\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\",\n\"_name\": \"SAP Certificate (PSE) 1\",\n\"_description\": \"Specifies a certificate (.pse file) to use to decode SAP tokens. Note: The selected file does not need to reside on the server since only its contents will be stored on the server. Clear the string in this field in order to delete the certificate stored on the server.\",\n\"_required\": False,\n\"_fileBased\": True,\n\"_fileName\": False,\n\"_fileExtensions\": [\"pse\"],\n\"_value\": None,\n\"_allowedValues\": None,\n\"_confidential\": False,\n\"_keepOriginal\": False,\n},\n{\n\"_key\": \"com.opentext.otds.as.drivers.sapssoext.certificate_pass1\",\n\"_name\": \"SAP Certificate 1 Password\",\n\"_description\": \"Specifies the password for the corresponding .pse file.\",\n\"_required\": False,\n\"_fileBased\": False,\n\"_fileName\": False,\n\"_fileExtensions\": None,\n\"_value\": certificate_password,\n\"_allowedValues\": None,\n\"_confidential\": True,\n\"_keepOriginal\": False,\n},\n],\n}\n# 2. Create the auth handler in OTDS\nrequest_url = self.auth_handler_url()\nlogger.info(\n\"Adding SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nresponse = requests.post(\nurl=request_url,\njson=authHandlerPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to add SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# 3. Upload the certificate file:\n# Check that the certificate (PSE) file is readable:\nlogger.info(\"Reading certificate file -&gt; %s...\", certificate_file)\ntry:\n# PSE files are binary - so we need to open with \"rb\":\nwith open(certificate_file, \"rb\") as certFile:\ncertContent = certFile.read()\nif not certContent:\nlogger.error(\"No data in certificate file -&gt; %s\", certificate_file)\nreturn None\nexcept IOError as exception:\nlogger.error(\n\"Unable to open certificate file -&gt; %s; error -&gt; %s\",\ncertificate_file,\nexception.strerror,\n)\nreturn None\n# Check that we have the binary certificate file - this is what OTDS expects. If the file content is\n# base64 encoded we will decode it and write it back into the same file\ntry:\n# If file is not base64 encoded the next statement will throw an exception\n# (this is good)\ncertContentDecoded = base64.b64decode(certContent, validate=True)\ncertContentEncoded = base64.b64encode(certContentDecoded).decode(\"utf-8\")\nif certContentEncoded == certContent.decode(\"utf-8\"):\nlogger.info(\n\"Certificate file -&gt; %s is base64 encoded\", certificate_file\n)\ncert_file_encoded = True\nelse:\ncert_file_encoded = False\nexcept TypeError:\nlogger.info(\n\"Certificate file -&gt; %s is not base64 encoded\", certificate_file\n)\ncert_file_encoded = False\nif cert_file_encoded:\ncertificate_file = \"/tmp/\" + os.path.basename(certificate_file)\nlogger.info(\"Writing decoded certificate file -&gt; %s...\", certificate_file)\ntry:\n# PSE files need to be binary - so we need to open with \"wb\":\nwith open(certificate_file, \"wb\") as certFile:\ncertFile.write(base64.b64decode(certContent))\nexcept IOError as exception:\nlogger.error(\n\"Failed writing to file -&gt; %s; error -&gt; %s\",\ncertificate_file,\nexception.strerror,\n)\nreturn None\nauthHandlerPostData = {\n\"file1_property\": \"com.opentext.otds.as.drivers.sapssoext.certificate1\"\n}\n# It is important to send the file pointer and not the actual file content\n# otherwise the file is send base64 encoded which we don't want:\nauthHandlerPostFiles = {\n\"file1\": (\nos.path.basename(certificate_file),\nopen(certificate_file, \"rb\"),\n\"application/octet-stream\",\n)\n}\nrequest_url = self.auth_handler_url() + \"/\" + name + \"/files\"\nlogger.info(\n\"Uploading certificate file -&gt; %s for SAP auth handler -&gt; %s (%s); calling -&gt; %s\",\ncertificate_file,\nname,\ndescription,\nrequest_url,\n)\n# it is important to NOT pass the headers parameter here!\n# Basically, if you specify a files parameter (a dictionary),\n# then requests will send a multipart/form-data POST automatically:\nresponse = requests.post(\nurl=request_url,\ndata=authHandlerPostData,\nfiles=authHandlerPostFiles,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to upload certificate file -&gt; %s for SAP auth handler -&gt; %s; error -&gt; %s (%s)\",\ncertificate_file,\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\nreturn response\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_group","title":"<code>add_group(partition, name, description)</code>","text":"<p>Add a new user group to a user partition in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the OTDS user partition (needs to exist)</p> required <code>name</code> <code>str</code> <p>name of the new group</p> required <code>description</code> <code>str</code> <p>description of the new group</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (json) or None if the creation fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_group(self, partition: str, name: str, description: str) -&gt; dict | None:\n\"\"\"Add a new user group to a user partition in OTDS\n    Args:\n        partition (str): name of the OTDS user partition (needs to exist)\n        name (str): name of the new group\n        description (str): description of the new group\n    Returns:\n        dict: Request response (json) or None if the creation fails.\n    \"\"\"\ngroupPostBodyJson = {\n\"userPartitionID\": partition,\n\"name\": name,\n\"description\": description,\n}\nrequest_url = self.groups_url()\nlogger.info(\n\"Adding group -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\nname,\npartition,\nrequest_url,\n)\nlogger.debug(\"Group Attributes -&gt; %s\", str(groupPostBodyJson))\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=groupPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_group_to_access_role","title":"<code>add_group_to_access_role(access_role, group, location='')</code>","text":"<p>Add an OTDS group to an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>access_role</code> <code>str</code> <p>name of the OTDS access role</p> required <code>group</code> <code>str</code> <p>name of the group</p> required <code>location</code> <code>str</code> <p>this is kind of a unique identifier DN (Distinguished Name)                       most of the times you will want to keep it to empty string (\"\")</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if group is in access role or has been successfully added.   False if group has been not been added (error)</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_group_to_access_role(\nself, access_role: str, group: str, location: str = \"\"\n) -&gt; bool:\n\"\"\"Add an OTDS group to an OTDS access role\n    Args:\n        access_role (str): name of the OTDS access role\n        group (str): name of the group\n        location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                  most of the times you will want to keep it to empty string (\"\")\n    Returns:\n        bool: True if group is in access role or has been successfully added.\n              False if group has been not been added (error)\n    \"\"\"\n# get existing members to check if user is already a member:\naccessRolesGetResponse = self.get_access_role(access_role)\nif not accessRolesGetResponse:\nreturn False\n# Checking if group already added to access role\naccessRoleGroups = accessRolesGetResponse[\"accessRoleMembers\"][\"groups\"]\nfor accessRoleGroup in accessRoleGroups:\nif accessRoleGroup[\"name\"] == group:\nlogger.info(\n\"Group -&gt; %s already added to access role -&gt; %s\", group, access_role\n)\nreturn True\nlogger.info(\n\"Group -&gt; %s is not yet in access role -&gt; %s - adding...\",\ngroup,\naccess_role,\n)\n# create payload for REST call:\naccessRolePostBodyJson = {\"groups\": [{\"name\": group, \"location\": location}]}\nrequest_url = \"{}/{}/members\".format(\nself.config()[\"accessRoleUrl\"], access_role\n)\nlogger.info(\n\"Add group -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\ngroup,\naccess_role,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=accessRolePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\ngroup,\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_group_to_parent_group","title":"<code>add_group_to_parent_group(group, parent_group)</code>","text":"<p>Add an existing group to an existing parent group in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>name of the OTDS group (needs to exist)</p> required <code>parent_group</code> <code>str</code> <p>name of the OTDS parent group (needs to exist)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True, if request is successful, False otherwise.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_group_to_parent_group(self, group: str, parent_group: str) -&gt; bool:\n\"\"\"Add an existing group to an existing parent group in OTDS\n    Args:\n        group (str): name of the OTDS group (needs to exist)\n        parent_group (str): name of the OTDS parent group (needs to exist)\n    Returns:\n        bool: True, if request is successful, False otherwise.\n    \"\"\"\ngroupToParentGroupPostBodyJson = {\"stringList\": [parent_group]}\nrequest_url = self.groups_url() + \"/\" + group + \"/memberof\"\nlogger.info(\n\"Adding group -&gt; %s to parent group -&gt; %s; calling -&gt; %s\",\ngroup,\nparent_group,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=groupToParentGroupPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add group -&gt; %s to parent group -&gt; %s; error -&gt; %s (%s)\",\ngroup,\nparent_group,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_license_to_resource","title":"<code>add_license_to_resource(path_to_license_file, product_name, product_description, resource_id, update=True)</code>","text":"<p>Add a product license to an OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_license_file</code> <code>str</code> <p>fully qualified filename of the license file</p> required <code>product_name</code> <code>str</code> <p>product name</p> required <code>product_description</code> <code>str</code> <p>product description</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>update</code> <code>bool</code> <p>whether or not an existing license should be updated (default = True)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (dictionary) or None if the REST call fails</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_license_to_resource(\nself,\npath_to_license_file: str,\nproduct_name: str,\nproduct_description: str,\nresource_id: str,\nupdate: bool = True,\n) -&gt; dict | None:\n\"\"\"Add a product license to an OTDS resource.\n    Args:\n        path_to_license_file (str): fully qualified filename of the license file\n        product_name (str): product name\n        product_description (str): product description\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        update (bool, optional): whether or not an existing license should be updated (default = True)\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails\n    \"\"\"\nlogger.info(\"Reading license file -&gt; %s...\", path_to_license_file)\ntry:\nwith open(path_to_license_file, \"rt\", encoding=\"UTF-8\") as license_file:\nlicense_content = license_file.read()\nexcept IOError as exception:\nlogger.error(\n\"Error opening license file -&gt; %s; error -&gt; %s\",\npath_to_license_file,\nexception.strerror,\n)\nreturn None\nlicensePostBodyJson = {\n\"description\": product_description,\n\"name\": product_name,\n\"values\": [\n{\"name\": \"oTLicenseFile\", \"values\": license_content},\n{\"name\": \"oTLicenseResource\", \"values\": resource_id},\n{\"name\": \"oTLicenseFingerprintGenerator\", \"values\": [None]},\n],\n}\nrequest_url = self.license_url()\n# Check if we want to update an existing license:\nif update:\nexisting_license = self.get_license_for_resource(resource_id)\nif existing_license:\nrequest_url += \"/\" + existing_license[0][\"id\"]\nelse:\nlogger.info(\n\"No existing license for resource -&gt; %s found - adding a new license...\",\nresource_id,\n)\n# change strategy to create a new license:\nupdate = False\nlogger.info(\n\"Adding product license -&gt; %s for product -&gt; %s to resource -&gt; %s; calling -&gt; %s\",\npath_to_license_file,\nproduct_description,\nresource_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nif update:\n# Do a REST PUT call for update an existing license:\nresponse = requests.put(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nelse:\n# Do a REST POST call for creation of a new license:\nresponse = requests.post(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add product license -&gt; %s for product -&gt; %s; error -&gt; %s (%s)\",\npath_to_license_file,\nproduct_description,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_oauth_client","title":"<code>add_oauth_client(client_id, description, redirect_urls=None, allow_impersonation=True, confidential=True, auth_scopes=None, allowed_scopes=None, default_scopes=None, secret='')</code>","text":"<p>Add a new OAuth client to OTDS</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>name of the new OAuth client (should not have blanks)</p> required <code>description</code> <code>str</code> <p>description of the OAuth client</p> required <code>redirect_urls</code> <code>list</code> <p>list of redirect URLs (strings)</p> <code>None</code> <code>allow_impersonation</code> <code>bool</code> <p>allow impresonation</p> <code>True</code> <code>confidential</code> <code>bool</code> <p>is confidential</p> <code>True</code> <code>auth_scopes</code> <code>list</code> <p>if empty then \"Global\"</p> <code>None</code> <code>allowed_scopes</code> <code>list</code> <p>in OTDS UI this is called Permissible scopes</p> <code>None</code> <code>default_scopes</code> <code>list</code> <p>in OTDS UI this is called Default scopes</p> <code>None</code> <code>secret</code> <code>str</code> <p>predefined OAuth client secret. If empty a new secret is generated.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the creation fails.</p> <code>Example</code> <code>dict | None</code> <code>dict | None</code> <p>{ \"description\": \"string\", \"redirectURLs\": [     \"string\" ], \"id\": \"string\", \"location\": \"string\", \"accessTokenLifeTime\": 0, \"refreshTokenLifeTime\": 0, \"authCodeLifeTime\": 0, \"allowRefreshToken\": true, \"allowImpersonation\": true, \"useSessionRefreshTokenLifeTime\": true, \"allowedScopes\": [     \"string\" ], \"defaultScopes\": [     \"string\" ], \"impersonateList\": [     \"string\" ], \"confidential\": true, \"secret\": \"string\", \"customAttributes\": [     {     \"type\": \"string\",     \"name\": \"string\",     \"value\": \"string\"     } ], \"logoutURL\": \"string\", \"logoutMethod\": \"string\", \"authScopes\": [     \"string\" ], \"uuid\": \"string\", \"name\": \"string\", \"urlId\": \"string\", \"urlLocation\": \"string\"</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_oauth_client(\nself,\nclient_id: str,\ndescription: str,\nredirect_urls: list | None = None,\nallow_impersonation: bool = True,\nconfidential: bool = True,\nauth_scopes: list | None = None,  # None = \"Global\"\nallowed_scopes: list | None = None,  # in OTDS UI: Permissible scopes\ndefault_scopes: list | None = None,  # in OTDS UI: Default scopes\nsecret: str = \"\",\n) -&gt; dict | None:\n\"\"\"Add a new OAuth client to OTDS\n    Args:\n        client_id (str): name of the new OAuth client (should not have blanks)\n        description (str): description of the OAuth client\n        redirect_urls (list): list of redirect URLs (strings)\n        allow_impersonation (bool, optional): allow impresonation\n        confidential (bool, optional): is confidential\n        auth_scopes (list, optional): if empty then \"Global\"\n        allowed_scopes (list, optional): in OTDS UI this is called Permissible scopes\n        default_scopes (list, optional): in OTDS UI this is called Default scopes\n        secret (str, optional): predefined OAuth client secret. If empty a new secret is generated.\n    Returns:\n        dict: Request response or None if the creation fails.\n        Example:\n        {\n            \"description\": \"string\",\n            \"redirectURLs\": [\n                \"string\"\n            ],\n            \"id\": \"string\",\n            \"location\": \"string\",\n            \"accessTokenLifeTime\": 0,\n            \"refreshTokenLifeTime\": 0,\n            \"authCodeLifeTime\": 0,\n            \"allowRefreshToken\": true,\n            \"allowImpersonation\": true,\n            \"useSessionRefreshTokenLifeTime\": true,\n            \"allowedScopes\": [\n                \"string\"\n            ],\n            \"defaultScopes\": [\n                \"string\"\n            ],\n            \"impersonateList\": [\n                \"string\"\n            ],\n            \"confidential\": true,\n            \"secret\": \"string\",\n            \"customAttributes\": [\n                {\n                \"type\": \"string\",\n                \"name\": \"string\",\n                \"value\": \"string\"\n                }\n            ],\n            \"logoutURL\": \"string\",\n            \"logoutMethod\": \"string\",\n            \"authScopes\": [\n                \"string\"\n            ],\n            \"uuid\": \"string\",\n            \"name\": \"string\",\n            \"urlId\": \"string\",\n            \"urlLocation\": \"string\"\n        }\n    \"\"\"\n# Avoid linter warning W0102:\nif redirect_urls is None:\nredirect_urls = []\nif auth_scopes is None:\nauth_scopes = []\nif allowed_scopes is None:\nallowed_scopes = []\nif default_scopes is None:\ndefault_scopes = []\noauthClientPostBodyJson = {\n\"id\": client_id,\n\"description\": description,\n\"redirectURLs\": redirect_urls,\n\"accessTokenLifeTime\": 1000,\n\"refreshTokenLifeTime\": 20000,\n\"authCodeLifeTime\": 20000,\n\"allowRefreshToken\": True,\n\"allowImpersonation\": allow_impersonation,\n\"useSessionRefreshTokenLifeTime\": True,\n\"confidential\": confidential,\n\"authScopes\": auth_scopes,\n\"allowedScopes\": allowed_scopes,\n\"defaultScopes\": default_scopes,\n}\n# Do we have a predefined client secret?\nif secret:\noauthClientPostBodyJson[\"secret\"] = secret\nrequest_url = self.oauth_client_url()\nlogger.info(\n\"Adding oauth client -&gt; %s (%s); calling -&gt; %s\",\ndescription,\nclient_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=oauthClientPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add OAuth client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_oauth_clients_to_access_role","title":"<code>add_oauth_clients_to_access_role(access_role_name)</code>","text":"<p>Add Oauth clients user partion to an OTDS Access Role</p> <p>Parameters:</p> Name Type Description Default <code>access_role_name</code> <code>str</code> <p>name of the OTDS Access Role</p> required <p>Returns:</p> Type Description <p>response of REST call or None in case of an error</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_oauth_clients_to_access_role(self, access_role_name: str):\n\"\"\"Add Oauth clients user partion to an OTDS Access Role\n    Args:\n        access_role_name (str): name of the OTDS Access Role\n    Returns:\n        response of REST call or None in case of an error\n    \"\"\"\nrequest_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role_name\nlogger.info(\n\"Get access role -&gt; %s; calling -&gt; %s\", access_role_name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\naccessRolesJson = self.parse_request_response(response)\nbreak\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve role -&gt; %s; url -&gt; %s : error -&gt; %s (%s)\",\naccess_role_name,\nrequest_url,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n# Checking if OAuthClients partition already added to access role\nuserPartitions = accessRolesJson[\"accessRoleMembers\"][\"userPartitions\"]\nfor userPartition in userPartitions:\nif userPartition[\"userPartition\"] == \"OAuthClients\":\nlogger.error(\n\"OAuthClients partition already added to role -&gt; %s\",\naccess_role_name,\n)\nreturn None\n# Getting location info for the OAuthClients partition\n# so it can be added to access roles json\nrequest_url = self.config()[\"partitionsUrl\"] + \"/OAuthClients\"\npartitionsResponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif partitionsResponse.ok:\nresponse_dict = self.parse_request_response(partitionsResponse)\nif not response_dict:\nreturn None\noauthClientLocation = response_dict[\"location\"]\nelse:\nlogger.error(\n\"Failed to get partition info for OAuthClients; url -&gt; %s : error -&gt; %s (%s)\",\nrequest_url,\npartitionsResponse.text,\nresponse.status_code,\n)\nreturn None\n# adding OAuthClients info to acess roles organizational units\noauthClientsOuBlock = {\n\"location\": oauthClientLocation,\n\"name\": oauthClientLocation,\n\"userPartition\": None,\n}\naccessRolesJson[\"accessRoleMembers\"][\"organizationalUnits\"].append(\noauthClientsOuBlock\n)\nresponse = requests.put(\nurl=request_url,\njson=accessRolesJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.info(\n\"OauthClients partition successfully added to access role -&gt; %s\",\naccess_role_name,\n)\nelse:\nlogger.warning(\n\"Status code of -&gt; %s returned attempting to add OAuthClients to access role -&gt; %s: error -&gt; %s\",\nresponse.status_code,\naccess_role_name,\nresponse.text,\n)\nreturn response\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_partition","title":"<code>add_partition(name, description)</code>","text":"<p>Add a new user partition to OTDS</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new partition</p> required <code>description</code> <code>str</code> <p>description of the new partition</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the creation fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_partition(self, name: str, description: str) -&gt; dict | None:\n\"\"\"Add a new user partition to OTDS\n    Args:\n        name (str): name of the new partition\n        description (str): description of the new partition\n    Returns:\n        dict: Request response or None if the creation fails.\n    \"\"\"\npartitionPostBodyJson = {\"name\": name, \"description\": description}\nrequest_url = self.partition_url()\nlogger.info(\n\"Adding user partition -&gt; %s (%s); calling -&gt; %s\",\nname,\ndescription,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=partitionPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user partition -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_partition_to_access_role","title":"<code>add_partition_to_access_role(access_role, partition, location='')</code>","text":"<p>Add an OTDS partition to an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>access_role</code> <code>str</code> <p>name of the OTDS access role</p> required <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>location</code> <code>str</code> <p>this is kind of a unique identifier DN (Distinguished Name)                       most of the times you will want to keep it to empty string (\"\")</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if partition is in access role or has been successfully added.   False if partition has been not been added (error)</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_partition_to_access_role(\nself, access_role: str, partition: str, location: str = \"\"\n) -&gt; bool:\n\"\"\"Add an OTDS partition to an OTDS access role\n    Args:\n        access_role (str): name of the OTDS access role\n        partition (str): name of the partition\n        location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                  most of the times you will want to keep it to empty string (\"\")\n    Returns:\n        bool: True if partition is in access role or has been successfully added.\n              False if partition has been not been added (error)\n    \"\"\"\naccessRolePostBodyJson = {\n\"userPartitions\": [{\"name\": partition, \"location\": location}]\n}\nrequest_url = \"{}/{}/members\".format(\nself.config()[\"accessRoleUrl\"], access_role\n)\nlogger.info(\n\"Add user partition -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\npartition,\naccess_role,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=accessRolePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add partition -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\npartition,\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_resource","title":"<code>add_resource(name, description, display_name, additional_payload=None)</code>","text":"<p>Add an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new OTDS resource</p> required <code>description</code> <code>str</code> <p>description of the new OTDS resource</p> required <code>display_name</code> <code>str</code> <p>display name of the OTDS resource</p> required <code>additional_payload</code> <code>dict</code> <p>additional values for the json payload</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_resource(\nself,\nname: str,\ndescription: str,\ndisplay_name: str,\nadditional_payload: dict | None = None,\n) -&gt; dict | None:\n\"\"\"Add an OTDS resource\n    Args:\n        name (str): name of the new OTDS resource\n        description (str): description of the new OTDS resource\n        display_name (str): display name of the OTDS resource\n        additional_payload (dict, optional): additional values for the json payload\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\nresourcePostBodyJson = {\n\"resourceName\": name,\n\"description\": description,\n\"displayName\": display_name,\n}\n# Check if there's additional payload for the body provided to handle special cases:\nif additional_payload:\n# Merge additional payload:\nresourcePostBodyJson.update(additional_payload)\nrequest_url = self.config()[\"resourceUrl\"]\nlogger.info(\n\"Adding resource -&gt; %s (%s); calling -&gt; %s\", name, description, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=resourcePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add resource -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_system_attribute","title":"<code>add_system_attribute(name, value, description='')</code>","text":"<p>Add a new system attribute to OTDS</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new system attribute</p> required <code>value</code> <code>str</code> <p>value of the system attribute</p> required <code>description</code> <code>str</code> <p>optional description of the system attribute</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (dictionary) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_system_attribute(\nself, name: str, value: str, description: str = \"\"\n) -&gt; dict | None:\n\"\"\"Add a new system attribute to OTDS\n    Args:\n        name (str): name of the new system attribute\n        value (str): value of the system attribute\n        description (str, optional): optional description of the system attribute\n    Returns:\n        dict: Request response (dictionary) or None if the REST call fails.\n    \"\"\"\nsystemAttributePostBodyJson = {\n\"name\": name,\n\"value\": value,\n\"friendlyName\": description,\n}\nrequest_url = \"{}/system_attributes\".format(self.config()[\"systemConfigUrl\"])\nif description:\nlogger.info(\n\"Add system attribute -&gt; %s (%s) with value -&gt; %s; calling -&gt; %s\",\nname,\ndescription,\nvalue,\nrequest_url,\n)\nelse:\nlogger.info(\n\"Add system attribute -&gt; %s with value -&gt; %s; calling -&gt; %s\",\nname,\nvalue,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=systemAttributePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add system attribute -&gt; %s with value -&gt; %s; error -&gt; %s (%s)\",\nname,\nvalue,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_trusted_site","title":"<code>add_trusted_site(trusted_site)</code>","text":"<p>Add a new OTDS trusted site</p> <p>Parameters:</p> Name Type Description Default <code>trusted_site</code> <code>str</code> <p>name of the new trusted site</p> required Return <p>dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_trusted_site(self, trusted_site: str) -&gt; dict | None:\n\"\"\"Add a new OTDS trusted site\n    Args:\n        trusted_site (str): name of the new trusted site\n    Return:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\ntrustedSitePostBodyJson = {\"stringList\": [trusted_site]}\n# we need to first retrieve the existing sites and then\n# append the new one:\nexistingTrustedSites = self.get_trusted_sites()\nif existingTrustedSites:\ntrustedSitePostBodyJson[\"stringList\"].extend(\nexistingTrustedSites[\"stringList\"]\n)\nrequest_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Add trusted site -&gt; %s; calling -&gt; %s\", trusted_site, request_url)\nresponse = requests.put(\nurl=request_url,\njson=trustedSitePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to add trusted site -&gt; %s; error -&gt; %s (%s)\",\ntrusted_site,\nresponse.text,\nresponse.status_code,\n)\nreturn None\nreturn response  # don't parse it!\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_user","title":"<code>add_user(partition, name, description='', first_name='', last_name='', email='')</code>","text":"<p>Add a new user to a user partition in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the OTDS user partition (needs to exist)</p> required <code>name</code> <code>str</code> <p>login name of the new user</p> required <code>description</code> <code>str</code> <p>description of the new user</p> <code>''</code> <code>first_name</code> <code>str</code> <p>first name of the new user</p> <code>''</code> <code>last_name</code> <code>str</code> <p>last name of the new user</p> <code>''</code> <code>email</code> <code>str</code> <p>email address of the new user</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the creation fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_user(\nself,\npartition: str,\nname: str,\ndescription: str = \"\",\nfirst_name: str = \"\",\nlast_name: str = \"\",\nemail: str = \"\",\n) -&gt; dict | None:\n\"\"\"Add a new user to a user partition in OTDS\n    Args:\n        partition (str): name of the OTDS user partition (needs to exist)\n        name (str): login name of the new user\n        description (str, optional): description of the new user\n        first_name (str, optional): first name of the new user\n        last_name (str, optional): last name of the new user\n        email (str, optional): email address of the new user\n    Returns:\n        dict: Request response or None if the creation fails.\n    \"\"\"\nuserPostBodyJson = {\n\"userPartitionID\": partition,\n\"values\": [\n{\"name\": \"sn\", \"values\": [last_name]},\n{\"name\": \"givenName\", \"values\": [first_name]},\n{\"name\": \"mail\", \"values\": [email]},\n],\n\"name\": name,\n\"description\": description,\n}\nrequest_url = self.users_url()\nlogger.info(\n\"Adding user -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\nname,\npartition,\nrequest_url,\n)\nlogger.debug(\"User Attributes -&gt; %s\", str(userPostBodyJson))\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=userPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_user_to_access_role","title":"<code>add_user_to_access_role(access_role, user_id, location='')</code>","text":"<p>Add an OTDS user to an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>access_role</code> <code>str</code> <p>name of the OTDS access role</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <code>location</code> <code>str</code> <p>this is kind of a unique identifier DN (Distinguished Name)                       most of the times you will want to keep it to empty string (\"\")</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if user is in access role or has been successfully added.   False if user has not been added (error)</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_user_to_access_role(\nself, access_role: str, user_id: str, location: str = \"\"\n) -&gt; bool:\n\"\"\"Add an OTDS user to an OTDS access role\n    Args:\n        access_role (str): name of the OTDS access role\n        user_id (str): ID of the user (= login name)\n        location (str, optional): this is kind of a unique identifier DN (Distinguished Name)\n                                  most of the times you will want to keep it to empty string (\"\")\n    Returns:\n        bool: True if user is in access role or has been successfully added.\n              False if user has not been added (error)\n    \"\"\"\n# get existing members to check if user is already a member:\naccessRolesGetResponse = self.get_access_role(access_role)\nif not accessRolesGetResponse:\nreturn False\n# Checking if user already added to access role\naccessRoleUsers = accessRolesGetResponse[\"accessRoleMembers\"][\"users\"]\nfor user in accessRoleUsers:\nif user[\"displayName\"] == user_id:\nlogger.info(\n\"User -&gt; %s already added to access role -&gt; %s\",\nuser_id,\naccess_role,\n)\nreturn True\nlogger.info(\n\"User -&gt; %s is not yet in access role -&gt; %s - adding...\",\nuser_id,\naccess_role,\n)\n# create payload for REST call:\naccessRolePostBodyJson = {\"users\": [{\"name\": user_id, \"location\": location}]}\nrequest_url = \"{}/{}/members\".format(\nself.config()[\"accessRoleUrl\"], access_role\n)\nlogger.info(\n\"Add user -&gt; %s to access role -&gt; %s; calling -&gt; %s\",\nuser_id,\naccess_role,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=accessRolePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s to access role -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.add_user_to_group","title":"<code>add_user_to_group(user, group)</code>","text":"<p>Add an existing user to an existing group in OTDS</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>name of the OTDS user (needs to exist)</p> required <code>group</code> <code>str</code> <p>name of the OTDS group (needs to exist)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True, if request is successful, False otherwise.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def add_user_to_group(self, user: str, group: str) -&gt; bool:\n\"\"\"Add an existing user to an existing group in OTDS\n    Args:\n        user (str): name of the OTDS user (needs to exist)\n        group (str): name of the OTDS group (needs to exist)\n    Returns:\n        bool: True, if request is successful, False otherwise.\n    \"\"\"\nuserToGroupPostBodyJson = {\"stringList\": [group]}\nrequest_url = self.users_url() + \"/\" + user + \"/memberof\"\nlogger.info(\n\"Adding user -&gt; %s to group -&gt; %s; calling -&gt; %s\", user, group, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=userToGroupPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add user -&gt; %s to group -&gt; %s; error -&gt; %s (%s)\",\nuser,\ngroup,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.assign_partition_to_license","title":"<code>assign_partition_to_license(partition_name, resource_id, license_feature, license_name, license_type='Full')</code>","text":"<p>Assign an OTDS partition to a product license (feature).</p> <p>Parameters:</p> Name Type Description Default <code>partition_name</code> <code>str</code> <p>user partition in OTDS, e.g. \"Content Server Members\"</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <code>license_type</code> <code>str</code> <p>deault is \"Full\", Extended ECM also has \"Occasional\"</p> <code>'Full'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful or False if the REST call fails or the license is not found</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def assign_partition_to_license(\nself,\npartition_name: str,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\nlicense_type: str = \"Full\",\n) -&gt; bool:\n\"\"\"Assign an OTDS partition to a product license (feature).\n    Args:\n        partition_name (str): user partition in OTDS, e.g. \"Content Server Members\"\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n        license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n    Returns:\n        bool: True if successful or False if the REST call fails or the license is not found\n    \"\"\"\nlicenses = self.get_license_for_resource(resource_id)\nif not licenses:\nlogger.error(\n\"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n)\nreturn False\n# licenses have this format:\n# {\n#   '_oTLicenseType': 'NON-PRODUCTION',\n#   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n#   '_oTLicenseResourceName': 'cs',\n#   '_oTLicenseProduct': 'EXTENDED_ECM',\n#   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n#   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'description': 'CS license',\n#   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n# }\nfor lic in licenses:\nif lic[\"_oTLicenseProduct\"] == license_name:\nlicense_location = lic[\"id\"]\ntry:\nlicense_location\nexcept UnboundLocalError:\nlogger.error(\n\"Cannot find license -&gt; %s for resource -&gt; %s\",\nlicense_name,\nresource_id,\n)\nreturn False\nlicensePostBodyJson = {\n\"_oTLicenseType\": license_type,\n\"_oTLicenseProduct\": \"partitions\",\n\"name\": partition_name,\n\"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n}\nrequest_url = self.license_url() + \"/object/\" + license_location\nlogger.info(\n\"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; calling -&gt; %s\",\nlicense_feature,\nlicense_location,\nresource_id,\npartition_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.info(\n\"Added license feature -&gt; %s for partition -&gt; %s\",\nlicense_feature,\npartition_name,\n)\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add license feature -&gt; %s associated with resource -&gt; %s to partition -&gt; %s; error -&gt; %s (%s)\",\nlicense_feature,\nresource_id,\npartition_name,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.assign_user_to_license","title":"<code>assign_user_to_license(partition, user_id, resource_id, license_feature, license_name, license_type='Full')</code>","text":"<p>Assign an OTDS user to a product license (feature) in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>user partition in OTDS, e.g. \"Content Server Members\"</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign</p> required <code>license_type</code> <code>str</code> <p>deault is \"Full\", Extended ECM also has \"Occasional\"</p> <code>'Full'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful or False if the REST call fails or the license is not found</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def assign_user_to_license(\nself,\npartition: str,\nuser_id: str,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\nlicense_type: str = \"Full\",\n) -&gt; bool:\n\"\"\"Assign an OTDS user to a product license (feature) in OTDS.\n    Args:\n        partition (str): user partition in OTDS, e.g. \"Content Server Members\"\n        user_id (str): ID of the user (= login name)\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature\n        license_name (str): name of the license to assign\n        license_type (str, optional): deault is \"Full\", Extended ECM also has \"Occasional\"\n    Returns:\n        bool: True if successful or False if the REST call fails or the license is not found\n    \"\"\"\nlicenses = self.get_license_for_resource(resource_id)\nfor lic in licenses:\nif lic[\"_oTLicenseProduct\"] == license_name:\nlicense_location = lic[\"id\"]\ntry:\nlicense_location\nexcept UnboundLocalError:\nlogger.error(\n\"Cannot find license -&gt; %s for resource -&gt; %s\",\nlicense_name,\nresource_id,\n)\nreturn False\nuser = self.get_user(partition, user_id)\nif user:\nuser_location = user[\"location\"]\nelse:\nlogger.error(\"Cannot find location for user -&gt; %s\", user_id)\nreturn False\nlicensePostBodyJson = {\n\"_oTLicenseType\": license_type,\n\"_oTLicenseProduct\": \"users\",\n\"name\": user_location,\n\"values\": [{\"name\": \"counter\", \"values\": [license_feature]}],\n}\nrequest_url = self.license_url() + \"/object/\" + license_location\nlogger.info(\n\"Assign license feature -&gt; %s of license -&gt; %s associated with resource -&gt; %s to user -&gt; %s; calling -&gt; %s\",\nlicense_feature,\nlicense_location,\nresource_id,\nuser_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=licensePostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nlogger.info(\n\"Added license feature -&gt; %s for user -&gt; %s\",\nlicense_feature,\nuser_id,\n)\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to add license feature -&gt; %s associated with resource -&gt; %s to user -&gt; %s; error -&gt; %s (%s)\",\nlicense_feature,\nresource_id,\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.auth_handler_url","title":"<code>auth_handler_url()</code>","text":"<p>Returns the Auth Handler URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Auth Handler URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def auth_handler_url(self) -&gt; str:\n\"\"\"Returns the Auth Handler URL of OTDS\n    Returns:\n        str: Auth Handler URL\n    \"\"\"\nreturn self.config()[\"authHandlerUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticate at Directory Services and retrieve OTCS Ticket.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determine if a re-athentication is enforced                          (e.g. if session has timed out with 401 error)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Cookie information. Also stores cookie information in self._cookie</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; dict | None:\n\"\"\"Authenticate at Directory Services and retrieve OTCS Ticket.\n    Args:\n        revalidate (bool, optional): determine if a re-athentication is enforced\n                                     (e.g. if session has timed out with 401 error)\n    Returns:\n        dict: Cookie information. Also stores cookie information in self._cookie\n    \"\"\"\n# Already authenticated and session still valid?\nif self._cookie and not revalidate:\nreturn self._cookie\notds_ticket = \"NotSet\"\nlogger.info(\"Requesting OTDS ticket from -&gt; %s\", self.credential_url())\nresponse = None\ntry:\nresponse = requests.post(\nurl=self.credential_url(),\njson=self.credentials(),\nheaders=REQUEST_HEADERS,\ntimeout=None,\n)\nexcept requests.exceptions.RequestException as exception:\nlogger.warning(\n\"Unable to connect to -&gt; %s; error -&gt; %s\",\nself.credential_url(),\nexception.strerror,\n)\nlogger.warning(\"OTDS service may not be ready yet.\")\nreturn None\nif response.ok:\nauthenticate_dict = self.parse_request_response(response)\nif not authenticate_dict:\nreturn None\nelse:\notds_ticket = authenticate_dict[\"ticket\"]\nlogger.info(\"Ticket -&gt; %s\", otds_ticket)\nelse:\nlogger.error(\"Failed to request an OTDS ticket; error -&gt; %s\", response.text)\nreturn None\nself._cookie = {\"OTDSTicket\": otds_ticket}\nreturn self._cookie\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.base_url","title":"<code>base_url()</code>","text":"<p>Returns the base URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>base URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def base_url(self) -&gt; str:\n\"\"\"Returns the base URL of OTDS\n    Returns:\n        str: base URL\n    \"\"\"\nreturn self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.consolidate","title":"<code>consolidate(resource_name)</code>","text":"<p>Consolidate an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>resource to be consolidated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the consolidation succeeded or False if it failed.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def consolidate(self, resource_name: str) -&gt; bool:\n\"\"\"Consolidate an OTDS resource\n    Args:\n        resource_name (str): resource to be consolidated\n    Returns:\n        bool: True if the consolidation succeeded or False if it failed.\n    \"\"\"\nresource = self.get_resource(resource_name)\nif not resource:\nlogger.error(\"Resource -&gt; %s not found - cannot consolidate\", resource_name)\nreturn False\nresource_dn = resource[\"resourceDN\"]\nif not resource_dn:\nlogger.error(\"Resource DN is empty - cannot consolidate\")\nreturn False\nconsolidationPostBodyJson = {\n\"cleanupUsersInResource\": False,\n\"cleanupGroupsInResource\": False,\n\"resourceList\": [resource_dn],\n\"objectToConsolidate\": resource_dn,\n}\nrequest_url = \"{}\".format(self.consolidation_url())\nlogger.info(\n\"Consolidation of resource -&gt; %s; calling -&gt; %s\", resource_dn, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.post(\nurl=request_url,\njson=consolidationPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to consolidate; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.consolidation_url","title":"<code>consolidation_url()</code>","text":"<p>Returns the Consolidation URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Consolidation URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def consolidation_url(self) -&gt; str:\n\"\"\"Returns the Consolidation URL of OTDS\n    Returns:\n        str: Consolidation URL\n    \"\"\"\nreturn self.config()[\"consolidationUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.cookie","title":"<code>cookie()</code>","text":"<p>Returns the login cookie of OTDS.    This is set by the authenticate() method</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>OTDS cookie</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def cookie(self) -&gt; dict:\n\"\"\"Returns the login cookie of OTDS.\n       This is set by the authenticate() method\n    Returns:\n        dict: OTDS cookie\n    \"\"\"\nreturn self._cookie\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.credential_url","title":"<code>credential_url()</code>","text":"<p>Returns the Credentials URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Credentials URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def credential_url(self) -&gt; str:\n\"\"\"Returns the Credentials URL of OTDS\n    Returns:\n        str: Credentials URL\n    \"\"\"\nreturn self.config()[\"credentialUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.credentials","title":"<code>credentials()</code>","text":"<p>Returns the credentials (username + password)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with username and password</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def credentials(self) -&gt; dict:\n\"\"\"Returns the credentials (username + password)\n    Returns:\n        dict: dictionary with username and password\n    \"\"\"\nreturn {\n\"userName\": self.config()[\"username\"],\n\"password\": self.config()[\"password\"],\n}\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.delete_license_from_resource","title":"<code>delete_license_from_resource(resource_id, license_id)</code>","text":"<p>Delete a product license for a resource in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_id</code> <code>str</code> <p>OTDS license ID (this is the ID not the license name!)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful or False if the REST call fails</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def delete_license_from_resource(self, resource_id: str, license_id: str) -&gt; bool:\n\"\"\"Delete a product license for a resource in OTDS.\n    Args:\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_id (str): OTDS license ID (this is the ID not the license name!)\n    Returns:\n        bool: True if successful or False if the REST call fails\n    \"\"\"\nrequest_url = \"{}/{}\".format(self.license_url(), license_id)\nlogger.info(\n\"Deleting product license -&gt; %s from resource -&gt; %s; calling -&gt; %s\",\nlicense_id,\nresource_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to delete license -&gt; %s for resource -&gt; %s; error -&gt; %s (%s)\",\nlicense_id,\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.delete_user","title":"<code>delete_user(partition, user_id)</code>","text":"<p>Delete an existing user</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>user_id</code> <code>str</code> <p>Id (= login name) of the user</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True = success, False = error</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def delete_user(self, partition: str, user_id: str) -&gt; bool:\n\"\"\"Delete an existing user\n    Args:\n        partition (str): name of the partition\n        user_id (str): Id (= login name) of the user\n    Returns:\n        bool: True = success, False = error\n    \"\"\"\nrequest_url = self.users_url() + \"/\" + user_id + \"@\" + partition\nlogger.info(\n\"Delete user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\nuser_id,\npartition,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.delete(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to delete user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.enable_audit","title":"<code>enable_audit()</code>","text":"<p>enable OTDS Audit</p> Return <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def enable_audit(self):\n\"\"\"enable OTDS Audit\n    Args:\n        None\n    Return:\n        Request response (json) or None if the REST call fails.\n    \"\"\"\nauditPutBodyJson = {\n\"daysToKeep\": \"7\",\n\"enabled\": \"true\",\n\"auditTo\": \"DATABASE\",\n\"eventIDs\": [\n\"User Create\",\n\"Group Create\",\n\"User Delete\",\n\"Group Delete\",\n\"User Modify\",\n\"Group Modify\",\n\"Initial authentication successful\",\n\"Initial authentication failed\",\n\"Impersonation\",\n\"Import Finished\",\n\"Access Denied\",\n\"Authentication code incorrect\",\n\"Authentication code required\",\n\"User locked out\",\n\"Consolidate Partition with identity provider\",\n\"Recycle Bin User Deleted\",\n\"Recycle Bin Group Deleted\",\n\"User Moved to Recycle Bin\",\n\"Group Moved to Recycle Bin\",\n\"User Restored from Recycle Bin\",\n\"Group Restored from Recycle Bin\",\n\"Scheduled Cleanup\",\n\"Consolidation finished\",\n\"Monitoring session finished\",\n\"User Rename\",\n\"Group Rename\",\n\"Role Create\",\n\"Role Delete\",\n\"Role Modify\",\n\"Role Rename\",\n\"Recycle Bin Role Deleted\",\n\"Role Moved to Recycle Bin\",\n\"Role Restored from Recycle Bin\",\n\"Set group members\",\n\"Set group members for moved in objects\",\n\"User logout\",\n\"Password change successful\",\n\"Password change failed\",\n\"Add Parent Object\",\n\"Remove Parent Object\",\n\"OAuth Client Create\",\n\"OAuth Client Delete\",\n\"OAuth Client Modify\",\n\"Tenant Create\",\n\"Tenant Delete\",\n\"Tenant Modify\",\n\"Migration\",\n],\n}\nrequest_url = \"{}/audit\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Enable audit; calling -&gt; %s\", request_url)\nresponse = requests.put(\nurl=request_url,\njson=auditPutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif not response.ok:\nlogger.error(\n\"Failed to enable audit; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn response\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_access_role","title":"<code>get_access_role(access_role)</code>","text":"<p>Get an OTDS access role</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the access role</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_access_role(self, access_role: str) -&gt; dict | None:\n\"\"\"Get an OTDS access role\n    Args:\n        name (str): name of the access role\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\nrequest_url = self.config()[\"accessRoleUrl\"] + \"/\" + access_role\nlogger.info(\n\"Retrieving access role -&gt; %s; calling -&gt; %s\", access_role, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve access role -&gt; %s; error -&gt; %s (%s)\",\naccess_role,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_access_roles","title":"<code>get_access_roles()</code>","text":"<p>Get a list of all OTDS access roles</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_access_roles(self) -&gt; dict | None:\n\"\"\"Get a list of all OTDS access roles\n    Args:\n        None\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\nrequest_url = self.config()[\"accessRoleUrl\"]\nlogger.info(\"Retrieving access roles; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve access roles; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_access_token","title":"<code>get_access_token(client_id, client_secret)</code>","text":"<p>Get the access token</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>OAuth client name (= ID)</p> required <code>client_secret</code> <code>str</code> <p>OAuth client secret. This is typically returned                  by add_oauth_client() method in [\"secret\"] field</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>access token, or None</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_access_token(self, client_id: str, client_secret: str) -&gt; str | None:\n\"\"\"Get the access token\n    Args:\n        client_id (str): OAuth client name (= ID)\n        client_secret (str): OAuth client secret. This is typically returned\n                             by add_oauth_client() method in [\"secret\"] field\n    Returns:\n        str: access token, or None\n    \"\"\"\nencoded_client_secret = \"{}:{}\".format(client_id, client_secret).encode(\"utf-8\")\naccessTokenRequestHeaders = {\n\"Authorization\": \"Basic \"\n+ base64.b64encode(encoded_client_secret).decode(\"utf-8\"),\n\"Content-Type\": \"application/x-www-form-urlencoded\",\n}\nrequest_url = self.token_url()\nresponse = requests.post(\nurl=request_url,\ndata={\"grant_type\": \"client_credentials\"},\nheaders=accessTokenRequestHeaders,\ntimeout=None,\n)\naccess_token = None\nif response.ok:\naccessTokenJson = self.parse_request_response(response)\nif \"access_token\" in accessTokenJson:\naccess_token = accessTokenJson[\"access_token\"]\nelse:\nreturn None\nreturn access_token\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_auth_handler","title":"<code>get_auth_handler(name, show_error=True)</code>","text":"<p>Get the OTDS auth handler with a given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the authentication handler</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: auth handler dictionary, or None</p> <code>dict | None</code> <p>Example result:</p> <code>dict | None</code> <p>{ '_name': 'Salesforce', '_id': 'Salesforce', '_description': 'Salesforce OAuth Authentication Handler', '_class': 'com.opentext.otds.as.drivers.http.OAuth2Handler', '_enabled': True, '_credentialBased': True, '_priority': 10, '_scope': None, '_properties': [     {         '_key': 'com.opentext.otds.as.drivers.http.oauth2.provider_name',         '_name': 'Provider Name',         '_description': 'The name of the authentication provider. This name is displayed on the login page.',         '_required': True,         '_fileBased': False,         '_fileName': False,         '_fileExtensions': None,         '_value': 'Salesforce',         '_allowedValues': None,         ...     },     ... ] '_authPrincipalAttrNames': ['oTExtraAttr0'], 'createPermission': True, 'readPermission': True, 'updatePermission': True, 'deletePermission': True, 'enablePermission': True,</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_auth_handler(self, name: str, show_error: bool = True) -&gt; dict | None:\n\"\"\"Get the OTDS auth handler with a given name.\n    Args:\n        name (str): Name of the authentication handler\n    Returns:\n        dict | None: auth handler dictionary, or None\n        Example result:\n        {\n            '_name': 'Salesforce',\n            '_id': 'Salesforce',\n            '_description': 'Salesforce OAuth Authentication Handler',\n            '_class': 'com.opentext.otds.as.drivers.http.OAuth2Handler',\n            '_enabled': True,\n            '_credentialBased': True,\n            '_priority': 10,\n            '_scope': None,\n            '_properties': [\n                {\n                    '_key': 'com.opentext.otds.as.drivers.http.oauth2.provider_name',\n                    '_name': 'Provider Name',\n                    '_description': 'The name of the authentication provider. This name is displayed on the login page.',\n                    '_required': True,\n                    '_fileBased': False,\n                    '_fileName': False,\n                    '_fileExtensions': None,\n                    '_value': 'Salesforce',\n                    '_allowedValues': None,\n                    ...\n                },\n                ...\n            ]\n            '_authPrincipalAttrNames': ['oTExtraAttr0'],\n            'createPermission': True,\n            'readPermission': True,\n            'updatePermission': True,\n            'deletePermission': True,\n            'enablePermission': True,\n        }\n    \"\"\"\nrequest_url = \"{}/{}\".format(self.auth_handler_url(), name)\nlogger.info(\n\"Getting authentication handler -&gt; %s; calling -&gt; %s\", name, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get authentication handler -&gt; %s; warning -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_group","title":"<code>get_group(group)</code>","text":"<p>Get a OTDS group by its group name</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>ID of the group (= group name)</p> required Return <p>dict: Request response or None if the group was not found. Example values: {     'numMembers': 7,     'userPartitionID': 'Content Server Members',     'name': 'Sales',     'location': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net',     'id': 'Sales@Content Server Members',     'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...],     'description': None,     'uuid': '3f921294-b92a-4c9e-bf7c-b50df16bb937',     'objectClass': 'oTGroup',     'customAttributes': None,     'originUUID': None,     'urlId': 'Sales@Content Server Members',     'urlLocation': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net' }</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_group(self, group: str) -&gt; dict | None:\n\"\"\"Get a OTDS group by its group name\n    Args:\n        group (str): ID of the group (= group name)\n    Return:\n        dict: Request response or None if the group was not found.\n        Example values:\n        {\n            'numMembers': 7,\n            'userPartitionID': 'Content Server Members',\n            'name': 'Sales',\n            'location': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net',\n            'id': 'Sales@Content Server Members',\n            'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...],\n            'description': None,\n            'uuid': '3f921294-b92a-4c9e-bf7c-b50df16bb937',\n            'objectClass': 'oTGroup',\n            'customAttributes': None,\n            'originUUID': None,\n            'urlId': 'Sales@Content Server Members',\n            'urlLocation': 'oTGroup=3f921294-b92a-4c9e-bf7c-b50df16bb937,orgunit=groups,partition=Content Server Members,dc=identity,dc=opentext,dc=net'\n        }\n    \"\"\"\nrequest_url = self.groups_url() + \"/\" + group\nlogger.info(\"Get group -&gt; %s; calling -&gt; %s\", group, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get group -&gt; %s; error -&gt; %s (%s)\",\ngroup,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_license_for_resource","title":"<code>get_license_for_resource(resource_id)</code>","text":"<p>Get a product license for a resource in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <p>Returns:</p> Type Description <p>Licenses for a resource or None if the REST call fails</p> <p>licenses have this format: {   '_oTLicenseType': 'NON-PRODUCTION',   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',   '_oTLicenseResourceName': 'cs',   '_oTLicenseProduct': 'EXTENDED_ECM',   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',   'description': 'CS license',   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...] }</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_license_for_resource(self, resource_id: str):\n\"\"\"Get a product license for a resource in OTDS.\n    Args:\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n    Returns:\n        Licenses for a resource or None if the REST call fails\n    licenses have this format:\n    {\n      '_oTLicenseType': 'NON-PRODUCTION',\n      '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n      '_oTLicenseResourceName': 'cs',\n      '_oTLicenseProduct': 'EXTENDED_ECM',\n      'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n      'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n      'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n      'description': 'CS license',\n      'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n    }\n    \"\"\"\nrequest_url = (\nself.license_url()\n+ \"/assignedlicenses?resourceID=\"\n+ resource_id\n+ \"&amp;validOnly=false\"\n)\nlogger.info(\n\"Get license for resource -&gt; %s; calling -&gt; %s\", resource_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nresponse_dict = self.parse_request_response(response)\nif not response_dict:\nreturn None\nreturn response_dict[\"licenseObjects\"][\"_licenses\"]\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get license for resource -&gt; %s; error -&gt; %s (%s)\",\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_licensed_objects","title":"<code>get_licensed_objects(resource_id, license_feature, license_name)</code>","text":"<p>Return the licensed objects (users, groups, partitions) in OTDS for a license + license feature    associated with an OTDS resource (like \"cs\").</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>data structure of licensed objects</p> <code>dict | None</code> <p>Example return value:</p> <code>dict | None</code> <p>{ 'status': 0, 'displayString': 'Success', 'exceptions': None, 'retValue': 0, 'listGroupsResults': {'groups': [...], 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250}, 'listUsersResults': {'users': [...], 'actualPageSize': 53, 'nextPageCookie': None, 'requestedPageSize': 250}, 'listUserPartitionResult': {'_userPartitions': [...], 'warningMessage': None, 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250}, 'version': 1</p> <code>dict | None</code> <p>}</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_licensed_objects(\nself,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\n) -&gt; dict | None:\n\"\"\"Return the licensed objects (users, groups, partitions) in OTDS for a license + license feature\n       associated with an OTDS resource (like \"cs\").\n    Args:\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n    Returns:\n        dict: data structure of licensed objects\n        Example return value:\n        {\n            'status': 0,\n            'displayString': 'Success',\n            'exceptions': None,\n            'retValue': 0,\n            'listGroupsResults': {'groups': [...], 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n            'listUsersResults': {'users': [...], 'actualPageSize': 53, 'nextPageCookie': None, 'requestedPageSize': 250},\n            'listUserPartitionResult': {'_userPartitions': [...], 'warningMessage': None, 'actualPageSize': 0, 'nextPageCookie': None, 'requestedPageSize': 250},\n            'version': 1\n        }\n    \"\"\"\nlicenses = self.get_license_for_resource(resource_id)\nif not licenses:\nlogger.error(\n\"Resource with ID -&gt; %s does not exist or has no licenses\", resource_id\n)\nreturn False\n# licenses have this format:\n# {\n#   '_oTLicenseType': 'NON-PRODUCTION',\n#   '_oTLicenseResource': '7382094f-a434-4714-9696-82864b6803da',\n#   '_oTLicenseResourceName': 'cs',\n#   '_oTLicenseProduct': 'EXTENDED_ECM',\n#   'name': 'EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da',\n#   'location': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'id': 'cn=EXTENDED_ECM\u00b97382094f-a434-4714-9696-82864b6803da,ou=Licenses,dc=identity,dc=opentext,dc=net',\n#   'description': 'CS license',\n#   'values': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, ...]\n# }\nfor lic in licenses:\nif lic[\"_oTLicenseProduct\"] == license_name:\nlicense_location = lic[\"location\"]\ntry:\nlicense_location\nexcept UnboundLocalError:\nlogger.error(\n\"Cannot find license -&gt; %s for resource -&gt; %s\",\nlicense_name,\nresource_id,\n)\nreturn False\nrequest_url = (\nself.license_url()\n+ \"/object/\"\n+ license_location\n+ \"?counter=\"\n+ license_feature\n)\nlogger.info(\n\"Get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; calling -&gt; %s\",\nlicense_name,\nlicense_feature,\nresource_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get licensed objects for license -&gt; %s and license feature -&gt; %s associated with resource -&gt; %s; error -&gt; %s (%s)\",\nlicense_name,\nlicense_feature,\nresource_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_oauth_client","title":"<code>get_oauth_client(client_id, show_error=True)</code>","text":"<p>Get an existing OAuth client from OTDS</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>name (= ID) of the OAuth client to retrieve</p> required <code>show_error</code> <code>bool</code> <p>whether or not we want to log an error if partion is not found</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (dictionary) or None if the client is not found.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_oauth_client(self, client_id: str, show_error: bool = True) -&gt; dict | None:\n\"\"\"Get an existing OAuth client from OTDS\n    Args:\n        client_id (str): name (= ID) of the OAuth client to retrieve\n        show_error (bool): whether or not we want to log an error if partion is not found\n    Returns:\n        dict: Request response (dictionary) or None if the client is not found.\n    \"\"\"\nrequest_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\nlogger.info(\"Get oauth client -&gt; %s; calling -&gt; %s\", client_id, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get oauth client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_partition","title":"<code>get_partition(name, show_error=True)</code>","text":"<p>Get an existing user partition from OTDS</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the partition to retrieve</p> required <code>show_error</code> <code>bool</code> <p>whether or not we want to log an error                          if partion is not found</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_partition(self, name: str, show_error: bool = True) -&gt; dict | None:\n\"\"\"Get an existing user partition from OTDS\n    Args:\n        name (str): name of the partition to retrieve\n        show_error (bool, optional): whether or not we want to log an error\n                                     if partion is not found\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\nrequest_url = \"{}/{}\".format(self.config()[\"partitionUrl\"], name)\nlogger.info(\"Getting user partition -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif show_error:\nlogger.error(\n\"Failed to get partition -&gt; %s; warning -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_password_policy","title":"<code>get_password_policy()</code>","text":"<p>Get the global password policy</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Request response or None if the REST call fails.</p> <p>Example response:</p> <p>{ 'passwordHistoryMaximumCount': 3, 'daysBeforeNewPasswordMayBeChanged': 1, 'passwordMaximumDuration': 90, 'daysBeforeOldPasswordMayBeReused': 0, 'lockoutFailureCount': 0, 'lockoutDuration': 15, 'minimumNumberOfCharacters': 8, 'complexPasswordValidationEnabled': True, 'minimumNumberOfDigits': 1, 'minimumNumberOfSymbols': 1, 'minimumNumberOfUppercase': 1, 'minimumNumberOfLowercase': 1, 'minimumChangesToPreviousPassword': 0, 'maxNumberOfConsecutiveANCharsInPassword': 0, 'blockCommonPassword': False ...</p> <p>}</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_password_policy(self):\n\"\"\"Get the global password policy\n    Args:\n        None\n    Returns:\n        dict: Request response or None if the REST call fails.\n        Example response:\n        {\n            'passwordHistoryMaximumCount': 3,\n            'daysBeforeNewPasswordMayBeChanged': 1,\n            'passwordMaximumDuration': 90,\n            'daysBeforeOldPasswordMayBeReused': 0,\n            'lockoutFailureCount': 0,\n            'lockoutDuration': 15,\n            'minimumNumberOfCharacters': 8,\n            'complexPasswordValidationEnabled': True,\n            'minimumNumberOfDigits': 1,\n            'minimumNumberOfSymbols': 1,\n            'minimumNumberOfUppercase': 1,\n            'minimumNumberOfLowercase': 1,\n            'minimumChangesToPreviousPassword': 0,\n            'maxNumberOfConsecutiveANCharsInPassword': 0,\n            'blockCommonPassword': False\n            ...\n        }\n    \"\"\"\nrequest_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Getting password policy; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get password policy; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_resource","title":"<code>get_resource(name, show_error=False)</code>","text":"<p>Get an existing OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new OTDS resource</p> required <code>show_error</code> <code>bool</code> <p>treat as error if resource is not found</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_resource(self, name: str, show_error: bool = False) -&gt; dict | None:\n\"\"\"Get an existing OTDS resource\n    Args:\n        name (str): name of the new OTDS resource\n        show_error (bool, optional): treat as error if resource is not found\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\nrequest_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\nlogger.info(\"Retrieving resource -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\n# We don't necessarily want to log an error as this function\n# is also used in wait loops:\nif show_error:\nlogger.warning(\n\"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\nname,\nresponse.text,\n)\nelse:\nlogger.info(\"Resource -&gt; %s not found.\", name)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_trusted_sites","title":"<code>get_trusted_sites()</code>","text":"<p>Get all configured OTDS trusted sites</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_trusted_sites(self) -&gt; dict | None:\n\"\"\"Get all configured OTDS trusted sites\n    Args:\n        None\n    Returns:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\nrequest_url = \"{}/whitelist\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\"Retrieving trusted sites; calling -&gt; %s\", request_url)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to retrieve trusted sites; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_user","title":"<code>get_user(partition, user_id)</code>","text":"<p>Get a user by its partition and user ID</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the user was not found.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_user(self, partition: str, user_id: str) -&gt; dict | None:\n\"\"\"Get a user by its partition and user ID\n    Args:\n        partition (str): name of the partition\n        user_id (str): ID of the user (= login name)\n    Returns:\n        dict: Request response or None if the user was not found.\n    \"\"\"\nrequest_url = self.users_url() + \"/\" + user_id + \"@\" + partition\nlogger.info(\n\"Get user -&gt; %s in partition -&gt; %s; calling -&gt; %s\",\nuser_id,\npartition,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to get user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.get_users","title":"<code>get_users(partition='', limit=None)</code>","text":"<p>Get all users in a partition partition</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> <code>''</code> <code>limit</code> <code>int</code> <p>maximum number of users to return</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response or None if the user was not found.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def get_users(self, partition: str = \"\", limit: int | None = None) -&gt; dict | None:\n\"\"\"Get all users in a partition partition\n    Args:\n        partition (str, optional): name of the partition\n        limit (int): maximum number of users to return\n    Returns:\n        dict: Request response or None if the user was not found.\n    \"\"\"\n# Add query parameters (these are NOT passed via JSon body!)\nquery = {}\nif limit:\nquery[\"limit\"] = limit\nif partition:\nquery[\"where_partition_name\"] = partition\nencodedQuery = urllib.parse.urlencode(query, doseq=True)\nrequest_url = self.users_url()\nif query:\nrequest_url += \"?{}\".format(encodedQuery)\nif partition:\nlogger.info(\n\"Get all users in partition -&gt; %s (limit -&gt; %s); calling -&gt; %s\",\npartition,\nlimit,\nrequest_url,\n)\nelse:\nlogger.info(\n\"Get all users (limit -&gt; %s); calling -&gt; %s\",\nlimit,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.get(\nurl=request_url,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nif partition:\nlogger.error(\n\"Failed to get users in partition -&gt; %s; error -&gt; %s (%s)\",\npartition,\nresponse.text,\nresponse.status_code,\n)\nelse:\nlogger.error(\n\"Failed to get users; error -&gt; %s (%s)\",\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.groups_url","title":"<code>groups_url()</code>","text":"<p>Returns the Groups URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Groups URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def groups_url(self) -&gt; str:\n\"\"\"Returns the Groups URL of OTDS\n    Returns:\n        str: Groups URL\n    \"\"\"\nreturn self.config()[\"groupsUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.impersonate_oauth_client","title":"<code>impersonate_oauth_client(client_id, allow_impersonation=True, impersonation_list=None)</code>","text":"<p>Configure impersonation for an OTDS OAuth Client</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>OAuth Client to be configure impersonation for</p> required <code>allow_impersonation</code> <code>bool</code> <p>wether to turn on or off impersonation (default = True)</p> <code>True</code> <code>impersonation_list</code> <code>list</code> <p>list of users to restrict it to; (default = empty list = all users)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the impersonation setting succeeded or False if it failed.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def impersonate_oauth_client(\nself,\nclient_id: str,\nallow_impersonation: bool = True,\nimpersonation_list: list | None = None,\n) -&gt; bool:\n\"\"\"Configure impersonation for an OTDS OAuth Client\n    Args:\n        client_id (str): OAuth Client to be configure impersonation for\n        allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n        impersonation_list (list, optional): list of users to restrict it to; (default = empty list = all users)\n    Returns:\n        bool: True if the impersonation setting succeeded or False if it failed.\n    \"\"\"\n# Avoid linter warning W0102:\nif impersonation_list is None:\nimpersonation_list = []\nimpersonationPutBodyJson = {\n\"allowImpersonation\": allow_impersonation,\n\"impersonateList\": impersonation_list,\n}\nrequest_url = \"{}/{}/impersonation\".format(self.oauth_client_url(), client_id)\nlogger.info(\n\"Impersonation settings for OAuth Client -&gt; %s; calling -&gt; %s\",\nclient_id,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=impersonationPutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set impersonation for OAuth Client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.impersonate_resource","title":"<code>impersonate_resource(resource_name, allow_impersonation=True, impersonation_list=None)</code>","text":"<p>Configure impersonation for an OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>resource to be configure impersonation for</p> required <code>allow_impersonation</code> <code>bool</code> <p>wether to turn on or off impersonation (default = True)</p> <code>True</code> <code>impersonation_list</code> <code>list</code> <p>list of users to restrict it to                                  (default = empty list = all users)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the impersonation setting succeeded or False if it failed.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def impersonate_resource(\nself,\nresource_name: str,\nallow_impersonation: bool = True,\nimpersonation_list: list | None = None,\n) -&gt; bool:\n\"\"\"Configure impersonation for an OTDS resource\n    Args:\n        resource_name (str): resource to be configure impersonation for\n        allow_impersonation (bool, optional): wether to turn on or off impersonation (default = True)\n        impersonation_list (list, optional): list of users to restrict it to\n                                             (default = empty list = all users)\n    Returns:\n        bool: True if the impersonation setting succeeded or False if it failed.\n    \"\"\"\n# Avoid linter warning W0102:\nif impersonation_list is None:\nimpersonation_list = []\nimpersonationPutBodyJson = {\n\"allowImpersonation\": allow_impersonation,\n\"impersonateList\": impersonation_list,\n}\nrequest_url = \"{}/{}/impersonation\".format(self.resource_url(), resource_name)\nlogger.info(\n\"Impersonation settings for resource -&gt; %s; calling -&gt; %s\",\nresource_name,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=impersonationPutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to set impersonation for resource -&gt; %s; error -&gt; %s\",\nresource_name,\nresponse.text,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.is_group_licensed","title":"<code>is_group_licensed(group_name, resource_id, license_feature, license_name)</code>","text":"<p>Check if a group is licensed for a license and license feature associated with a particular OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>name of the OTDS user group</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the group is licensed and False otherwise</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def is_group_licensed(\nself, group_name: str, resource_id: str, license_feature: str, license_name: str\n) -&gt; bool:\n\"\"\"Check if a group is licensed for a license and license feature associated with a particular OTDS resource.\n    Args:\n        group_name (str): name of the OTDS user group\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n    Returns:\n        bool: True if the group is licensed and False otherwise\n    \"\"\"\nresponse = self.get_licensed_objects(\nresource_id=resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n)\nif not response or not response[\"listGroupsResults\"]:\nreturn False\ngroups = response[\"listGroupsResults\"][\"groups\"]\nif not groups:\nreturn False\ngroup = next(\n(item for item in groups if item[\"name\"] == group_name),\nNone,\n)\nif group:\nreturn True\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.is_partition_licensed","title":"<code>is_partition_licensed(partition_name, resource_id, license_feature, license_name)</code>","text":"<p>Check if a partition is licensed for a license and license feature associated with a particular OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>partition_name</code> <code>str</code> <p>name of the OTDS user partition, e.g. \"Content Server Members\"</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the partition is licensed and False otherwise</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def is_partition_licensed(\nself,\npartition_name: str,\nresource_id: str,\nlicense_feature: str,\nlicense_name: str,\n) -&gt; bool:\n\"\"\"Check if a partition is licensed for a license and license feature associated with a particular OTDS resource.\n    Args:\n        partition_name (str): name of the OTDS user partition, e.g. \"Content Server Members\"\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n    Returns:\n        bool: True if the partition is licensed and False otherwise\n    \"\"\"\nresponse = self.get_licensed_objects(\nresource_id=resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n)\nif not response or not response[\"listUserPartitionResult\"]:\nreturn False\npartitions = response[\"listUserPartitionResult\"][\"_userPartitions\"]\nif not partitions:\nreturn False\npartition = next(\n(item for item in partitions if item[\"name\"] == partition_name),\nNone,\n)\nif partition:\nreturn True\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.is_user_licensed","title":"<code>is_user_licensed(user_name, resource_id, license_feature, license_name)</code>","text":"<p>Check if a user is licensed for a license and license feature associated with a particular OTDS resource.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> <p>login name of the OTDS user</p> required <code>resource_id</code> <code>str</code> <p>OTDS resource ID (this is ID not the resource name!)</p> required <code>license_feature</code> <code>str</code> <p>name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"</p> required <code>license_name</code> <code>str</code> <p>name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user is licensed and False otherwise</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def is_user_licensed(\nself, user_name: str, resource_id: str, license_feature: str, license_name: str\n) -&gt; bool:\n\"\"\"Check if a user is licensed for a license and license feature associated with a particular OTDS resource.\n    Args:\n        user_name (str): login name of the OTDS user\n        resource_id (str): OTDS resource ID (this is ID not the resource name!)\n        license_feature (str): name of the license feature, e.g. \"X2\" or \"ADDON_ENGINEERING\"\n        license_name (str): name of the license to assign, e.g. \"EXTENDED_ECM\" or \"INTELLGENT_VIEWIMG\"\n    Returns:\n        bool: True if the user is licensed and False otherwise\n    \"\"\"\nresponse = self.get_licensed_objects(\nresource_id=resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n)\nif not response or not response[\"listUsersResults\"]:\nreturn False\nusers = response[\"listUsersResults\"][\"users\"]\nif not users:\nreturn False\nuser = next(\n(item for item in users if item[\"name\"] == user_name),\nNone,\n)\nif user:\nreturn True\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.license_url","title":"<code>license_url()</code>","text":"<p>Returns the License URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>License URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def license_url(self) -&gt; str:\n\"\"\"Returns the License URL of OTDS\n    Returns:\n        str: License URL\n    \"\"\"\nreturn self.config()[\"licenseUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.oauth_client_url","title":"<code>oauth_client_url()</code>","text":"<p>Returns the OAuth Client URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>OAuth Client URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def oauth_client_url(self) -&gt; str:\n\"\"\"Returns the OAuth Client URL of OTDS\n    Returns:\n        str: OAuth Client URL\n    \"\"\"\nreturn self.config()[\"oauthClientUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the request response to a Python dict in a safe way    that also handles exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>print a custom error message</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>if True log an error, if False log a warning</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>response dictionary or None in case of an error</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def parse_request_response(\nself,\nresponse_object: object,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the request response to a Python dict in a safe way\n       that also handles exceptions.\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str): print a custom error message\n        show_error (bool): if True log an error, if False log a warning\n    Returns:\n        dict: response dictionary or None in case of an error\n    \"\"\"\nif not response_object:\nreturn None\ntry:\ndict_object = json.loads(response_object.text)\nexcept json.JSONDecodeError as e:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, e\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(e)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.partition_url","title":"<code>partition_url()</code>","text":"<p>Returns the Partition URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Partition URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def partition_url(self) -&gt; str:\n\"\"\"Returns the Partition URL of OTDS\n    Returns:\n        str: Partition URL\n    \"\"\"\nreturn self.config()[\"partitionUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.reset_user_password","title":"<code>reset_user_password(user_id, password)</code>","text":"<p>Reset a password of an existing user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Id (= login name) of the user</p> required <code>password</code> <code>str</code> <p>new password of the user</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True = success, False = error.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def reset_user_password(self, user_id: str, password: str) -&gt; bool:\n\"\"\"Reset a password of an existing user\n    Args:\n        user_id (str): Id (= login name) of the user\n        password (str): new password of the user\n    Returns:\n        bool: True = success, False = error.\n    \"\"\"\nuserPostBodyJson = {\"newPassword\": password}\nrequest_url = \"{}/{}/password\".format(self.users_url(), user_id)\nlogger.info(\n\"Resetting password for user -&gt; %s; calling -&gt; %s\", user_id, request_url\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=userPostBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to reset password for user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.resource_url","title":"<code>resource_url()</code>","text":"<p>Returns the Resource URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Resource URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def resource_url(self) -&gt; str:\n\"\"\"Returns the Resource URL of OTDS\n    Returns:\n        str: Resource URL\n    \"\"\"\nreturn self.config()[\"resourceUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.rest_url","title":"<code>rest_url()</code>","text":"<p>Returns the REST URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>REST URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def rest_url(self) -&gt; str:\n\"\"\"Returns the REST URL of OTDS\n    Returns:\n        str: REST URL\n    \"\"\"\nreturn self.config()[\"restUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.system_config_url","title":"<code>system_config_url()</code>","text":"<p>Returns the System Config URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>System Config URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def system_config_url(self) -&gt; str:\n\"\"\"Returns the System Config URL of OTDS\n    Returns:\n        str: System Config URL\n    \"\"\"\nreturn self.config()[\"systemConfigUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.token_url","title":"<code>token_url()</code>","text":"<p>Returns the Token URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Token URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def token_url(self) -&gt; str:\n\"\"\"Returns the Token URL of OTDS\n    Returns:\n        str: Token URL\n    \"\"\"\nreturn self.config()[\"tokenUrl\"]\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_access_role_attributes","title":"<code>update_access_role_attributes(name, attribute_list)</code>","text":"<p>Update some attributes of an existing OTDS Access Role</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the existing access role</p> required <code>attribute_list</code> <code>list</code> <p>list of attribute name and attribute value pairs                    The values need to be a list as well. Example:                    [{name: \"pushAllGroups\", values: [\"True\"]}]</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_access_role_attributes(\nself, name: str, attribute_list: list\n) -&gt; dict | None:\n\"\"\"Update some attributes of an existing OTDS Access Role\n    Args:\n        name (str): name of the existing access role\n        attribute_list (list): list of attribute name and attribute value pairs\n                               The values need to be a list as well. Example:\n                               [{name: \"pushAllGroups\", values: [\"True\"]}]\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\n# Return if list is empty:\nif not attribute_list:\nreturn None\n# create payload for REST call:\naccess_role = self.get_access_role(name)\nif not access_role:\nlogger.error(\"Failed to get access role -&gt; %s\", name)\nreturn None\naccessRolePutBodyJson = {\"attributes\": attribute_list}\nrequest_url = \"{}/{}/attributes\".format(self.config()[\"accessRoleUrl\"], name)\nlogger.info(\n\"Update access role -&gt; %s with attributes -&gt; %s; calling -&gt; %s\",\nname,\naccessRolePutBodyJson,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=accessRolePutBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update access role -&gt; %s; error -&gt; %s (%s)\",\nname,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_oauth_client","title":"<code>update_oauth_client(client_id, updates)</code>","text":"<p>Updates the OAuth client with new values</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>name (= ID) of the OAuth client</p> required <code>updates</code> <code>dict</code> <p>new values for OAuth client, e.g.             {\"description\": \"this is the new value\"}</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_oauth_client(self, client_id: str, updates: dict) -&gt; dict | None:\n\"\"\"Updates the OAuth client with new values\n    Args:\n        client_id (str): name (= ID) of the OAuth client\n        updates (dict): new values for OAuth client, e.g.\n                        {\"description\": \"this is the new value\"}\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\noauthClientPatchBodyJson = updates\nrequest_url = \"{}/{}\".format(self.oauth_client_url(), client_id)\nlogger.info(\n\"Update OAuth client -&gt; %s with -&gt; %s; calling -&gt; %s\",\nclient_id,\nupdates,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nurl=request_url,\njson=oauthClientPatchBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update OAuth client -&gt; %s; error -&gt; %s (%s)\",\nclient_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_password_policy","title":"<code>update_password_policy(update_values)</code>","text":"<p>Update the global password policy</p> <p>Parameters:</p> Name Type Description Default <code>update_values</code> <code>dict</code> <p>new values for selected settings.                   A value of 0 means the settings is deactivated.</p> required <code>Example</code> <code>values</code> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the REST call succeeds, otherwise False. We use a boolean return   value as the response of the REST call does not have meaningful content.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_password_policy(self, update_values: dict) -&gt; bool:\n\"\"\"Update the global password policy\n    Args:\n        update_values (dict): new values for selected settings.\n                              A value of 0 means the settings is deactivated.\n        Example values:\n        {\n            'passwordHistoryMaximumCount': 3,\n            'daysBeforeNewPasswordMayBeChanged': 1,\n            'passwordMaximumDuration': 90,\n            'daysBeforeOldPasswordMayBeReused': 0,\n            'lockoutFailureCount': 0,\n            'lockoutDuration': 15,\n            'minimumNumberOfCharacters': 8,\n            'complexPasswordValidationEnabled': True,\n            'minimumNumberOfDigits': 1,\n            'minimumNumberOfSymbols': 1,\n            'minimumNumberOfUppercase': 1,\n            'minimumNumberOfLowercase': 1,\n            'minimumChangesToPreviousPassword': 0,\n            'maxNumberOfConsecutiveANCharsInPassword': 0,\n            'blockCommonPassword': False\n            ...\n        }\n    Returns:\n        bool: True if the REST call succeeds, otherwise False. We use a boolean return\n              value as the response of the REST call does not have meaningful content.\n    \"\"\"\nrequest_url = \"{}/passwordpolicy\".format(self.config()[\"systemConfigUrl\"])\nlogger.info(\n\"Update password policy with these new values -&gt; %s; calling -&gt; %s\",\nupdate_values,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=update_values,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn True\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update password policy with values -&gt; %s; error -&gt; %s (%s)\",\nupdate_values,\nresponse.text,\nresponse.status_code,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_resource","title":"<code>update_resource(name, resource, show_error=True)</code>","text":"<p>Update an existing OTDS resource</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the new OTDS resource</p> required <code>resource</code> <code>object</code> <p>updated resource object of get_resource called before</p> required <code>show_error</code> <code>bool</code> <p>treat as error if resource is not found</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Request response (json) or None if the REST call fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_resource(\nself, name: str, resource: object, show_error: bool = True\n) -&gt; dict | None:\n\"\"\"Update an existing OTDS resource\n    Args:\n        name (str): name of the new OTDS resource\n        resource (object): updated resource object of get_resource called before\n        show_error (bool, optional): treat as error if resource is not found\n    Returns:\n        dict: Request response (json) or None if the REST call fails.\n    \"\"\"\nrequest_url = \"{}/{}\".format(self.config()[\"resourceUrl\"], name)\nlogger.info(\"Updating resource -&gt; %s; calling -&gt; %s\", name, request_url)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=resource,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\n# We don't necessarily want to log an error as this function\n# is also used in wait loops:\nif show_error:\nlogger.warning(\n\"Failed to retrieve resource -&gt; %s; warning -&gt; %s\",\nname,\nresponse.text,\n)\nelse:\nlogger.info(\"Resource -&gt; %s not found.\", name)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.update_user","title":"<code>update_user(partition, user_id, attribute_name, attribute_value)</code>","text":"<p>Update a user attribute with a new value</p> <p>Parameters:</p> Name Type Description Default <code>partition</code> <code>str</code> <p>name of the partition</p> required <code>user_id</code> <code>str</code> <p>ID of the user (= login name)</p> required <code>attribute_name</code> <code>str</code> <p>name of the attribute</p> required <code>attribute_value</code> <code>str</code> <p>new value of the attribute</p> required Return <p>dict: Request response or None if the update fails.</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def update_user(\nself, partition: str, user_id: str, attribute_name: str, attribute_value: str\n) -&gt; dict | None:\n\"\"\"Update a user attribute with a new value\n    Args:\n        partition (str): name of the partition\n        user_id (str): ID of the user (= login name)\n        attribute_name (str): name of the attribute\n        attribute_value (str): new value of the attribute\n    Return:\n        dict: Request response or None if the update fails.\n    \"\"\"\nif attribute_name in [\"description\"]:\nuserPatchBodyJson = {\n\"userPartitionID\": partition,\nattribute_name: attribute_value,\n}\nelse:\nuserPatchBodyJson = {\n\"userPartitionID\": partition,\n\"values\": [{\"name\": attribute_name, \"values\": [attribute_value]}],\n}\nrequest_url = self.users_url() + \"/\" + user_id\nlogger.info(\n\"Update user -&gt; %s attribute -&gt; %s to value -&gt; %s; calling -&gt; %s\",\nuser_id,\nattribute_name,\nattribute_value,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.patch(\nurl=request_url,\njson=userPatchBodyJson,\nheaders=REQUEST_HEADERS,\ncookies=self.cookie(),\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update user -&gt; %s; error -&gt; %s (%s)\",\nuser_id,\nresponse.text,\nresponse.status_code,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otds/#pyxecm.otds.OTDS.users_url","title":"<code>users_url()</code>","text":"<p>Returns the Users URL of OTDS</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Users URL</p> Source code in <code>pyxecm/otds.py</code> <pre><code>def users_url(self) -&gt; str:\n\"\"\"Returns the Users URL of OTDS\n    Returns:\n        str: Users URL\n    \"\"\"\nreturn self.config()[\"usersUrl\"]\n</code></pre>"},{"location":"pyxecm/otiv/","title":"OTIV","text":"<p>OTIV Module to keep Intelligent Viewing specific data such as connection parameters, license information ...</p> <p>Class: OTIV Methods:</p> <p>init : class initializer config : returns config data set</p>"},{"location":"pyxecm/otiv/#pyxecm.otiv.OTIV","title":"<code>OTIV</code>","text":"<p>Used to manage stettings for OpenText Intelligent Viewing.</p> Source code in <code>pyxecm/otiv.py</code> <pre><code>class OTIV:\n\"\"\"Used to manage stettings for OpenText Intelligent Viewing.\"\"\"\n_config: dict\ndef __init__(\nself,\nresource_name: str,\nproduct_name: str,\nproduct_description: str,\nlicense_file: str,\ndefault_license: str = \"FULLTIME_USERS_REGULAR\",\n):\n\"\"\"Initialize the OTIV class for Intelligent Viewing\n        Args:\n            resource_name (str): OTDS resource name\n            product_name (str): OTDS product name for licensing\n            license_file (str): path to license file\n            default_license (str, optional): Defaults to \"FULLTIME_USERS_REGULAR\".\n        \"\"\"\n# Initialize otiv_config as an empty dictionary\notiv_config = {}\notiv_config[\"resource\"] = resource_name\notiv_config[\"product\"] = product_name\notiv_config[\"description\"] = product_description\notiv_config[\"license_file\"] = license_file\notiv_config[\"license\"] = default_license\nself._config = otiv_config\n# end method definition\ndef config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/otiv/#pyxecm.otiv.OTIV.__init__","title":"<code>__init__(resource_name, product_name, product_description, license_file, default_license='FULLTIME_USERS_REGULAR')</code>","text":"<p>Initialize the OTIV class for Intelligent Viewing</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>OTDS resource name</p> required <code>product_name</code> <code>str</code> <p>OTDS product name for licensing</p> required <code>license_file</code> <code>str</code> <p>path to license file</p> required <code>default_license</code> <code>str</code> <p>Defaults to \"FULLTIME_USERS_REGULAR\".</p> <code>'FULLTIME_USERS_REGULAR'</code> Source code in <code>pyxecm/otiv.py</code> <pre><code>def __init__(\nself,\nresource_name: str,\nproduct_name: str,\nproduct_description: str,\nlicense_file: str,\ndefault_license: str = \"FULLTIME_USERS_REGULAR\",\n):\n\"\"\"Initialize the OTIV class for Intelligent Viewing\n    Args:\n        resource_name (str): OTDS resource name\n        product_name (str): OTDS product name for licensing\n        license_file (str): path to license file\n        default_license (str, optional): Defaults to \"FULLTIME_USERS_REGULAR\".\n    \"\"\"\n# Initialize otiv_config as an empty dictionary\notiv_config = {}\notiv_config[\"resource\"] = resource_name\notiv_config[\"product\"] = product_name\notiv_config[\"description\"] = product_description\notiv_config[\"license_file\"] = license_file\notiv_config[\"license\"] = default_license\nself._config = otiv_config\n</code></pre>"},{"location":"pyxecm/otiv/#pyxecm.otiv.OTIV.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otiv.py</code> <pre><code>def config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/otpd/","title":"OTPD","text":"<p>OTPD Module to implement functions to read / write PowerDocs objects</p> <p>Class: OTPD Methods:</p> <p>init : class initializer config : returns config data set credentials: Get credentials (username and password) set_credentials: Set new credentials hostname: Get the configured PowerDocs hostname set_hostname: Set the hostname of PowerDocs base_url : Get PowerDocs base URL rest_url : Get PowerDocs REST base URL</p> Converts the text property of a request <p>response object to a Python dict in a safe way</p> <p>authenticate : Authenticates at PowerDocs and retrieve OTCS Ticket.</p> <p>import_database: imports the PowerDocs database from a zip file apply_setting: apply a setting to a PowerDocs tenant</p>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD","title":"<code>OTPD</code>","text":"<p>Used to automate stettings in OpenText Extended ECM PowerDocs.</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>class OTPD:\n\"\"\"Used to automate stettings in OpenText Extended ECM PowerDocs.\"\"\"\n_config = None\n_jsessionid = None\ndef __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\nusername: str,\npassword: str,\n):\n\"\"\"Initialize the OTPD object\n        Args:\n            protocol (str): Either http or https.\n            hostname (str): The hostname of the PowerDocs Server Manager to communicate with.\n            port (int): The port number used to talk to the PowerDocs Server Manager.\n            username (str): The admin user name of PowerDocs Server Manager.\n            password (str): The admin password of PowerDocs Server Manager.\n        \"\"\"\notpd_config = {}\nif hostname:\notpd_config[\"hostname\"] = hostname\nelse:\notpd_config[\"hostname\"] = \"\"\nif protocol:\notpd_config[\"protocol\"] = protocol\nelse:\notpd_config[\"protocol\"] = \"http\"\nif port:\notpd_config[\"port\"] = port\nelse:\notpd_config[\"port\"] = 80\nif username:\notpd_config[\"username\"] = username\nelse:\notpd_config[\"username\"] = \"admin\"\nif password:\notpd_config[\"password\"] = password\nelse:\notpd_config[\"password\"] = \"\"\notpd_base_url = protocol + \"://\" + otpd_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notpd_base_url += \":{}\".format(port)\notpd_base_url += \"/ServerManager\"\notpd_config[\"baseUrl\"] = otpd_base_url\notpd_rest_url = otpd_base_url + \"/api\"\notpd_config[\"restUrl\"] = otpd_rest_url\notpd_config[\"settingsUrl\"] = otpd_rest_url + \"/v1/settings\"\notpd_config[\"importDatabaseUrl\"] = otpd_base_url + \"/servlet/import\"\nself._config = otpd_config\ndef config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n        Returns:\n            dict: Configuration dictionary\n        \"\"\"\nreturn self._config\ndef credentials(self) -&gt; dict:\n\"\"\"Get credentials (username + password)\n        Returns:\n            dict: dictionary with username and password\n        \"\"\"\nreturn {\n\"username\": self.config()[\"username\"],\n\"password\": self.config()[\"password\"],\n}\ndef set_credentials(self, username: str = \"admin\", password: str = \"\"):\n\"\"\"Set the credentials for PowerDocs for the based on user name and password.\n        Args:\n            username (str, optional): Username. Defaults to \"admin\".\n            password (str, optional): Password of the user. Defaults to \"\".\n        \"\"\"\nself.config()[\"username\"] = username\nself.config()[\"password\"] = password\ndef hostname(self) -&gt; str:\n\"\"\"Returns the hostname of PowerDocs (e.g. \"otpd\")\n        Returns:\n            string: hostname\n        \"\"\"\nreturn self.config()[\"hostname\"]\ndef set_hostname(self, hostname: str):\n\"\"\"Sets the hostname of PowerDocs\n        Args:\n            hostname (str): new hostname\n        \"\"\"\nself.config()[\"hostname\"] = hostname\ndef base_url(self):\n\"\"\"Returns the base URL of PowerDocs\n        Returns:\n            string: base URL\n        \"\"\"\nreturn self.config()[\"baseUrl\"]\ndef rest_url(self):\n\"\"\"Returns the REST URL of PowerDocs\n        Returns:\n            string: REST URL\n        \"\"\"\nreturn self.config()[\"restUrl\"]\ndef parse_request_response(\nself,\nresponse_object: object,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the request response to a Python dict in a safe way\n           that also handles exceptions.\n        Args:\n            response_object (object): this is reponse object delivered by the request call\n            additional_error_message (str): print a custom error message\n            show_error (bool): if True log an error, if False log a warning\n        Returns:\n            dict: a python dict object or None in case of an error\n        \"\"\"\nif not response_object:\nreturn None\ntry:\ndict_object = json.loads(response_object.text)\nexcept json.JSONDecodeError as exception:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, exception\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(exception)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n# end method definition\n# This method is currently not used and not working...\n# It cannot handle the Request - ServerManager returns an\n# error stating that JavaScript is not enabled...\ndef authenticate(self, revalidate: bool = False) -&gt; dict:\n\"\"\"Authenticates at PowerDocs and retrieve session ID.\n        Args:\n            revalidate (bool): determinse if a re-athentication is enforced\n                               (e.g. if session has timed out with 401 error)\n        Returns:\n            dict: Cookie information of None in case of an error.\n                  Also stores cookie information in self._cookie\n        \"\"\"\n# Already authenticated and session still valid?\nif self._jsessionid and not revalidate:\nreturn self._jsessionid\nauth_url = (\nself.base_url()\n+ \"/j_security_check?j_username=\"\n+ self.config()[\"username\"]\n+ \"&amp;j_password=\"\n+ self.config()[\"password\"]\n)\npayload = {}\npayload[\"settingname\"] = \"LocalOtdsUrl\"\npayload[\"settingvalue\"] = \"http://otds/otdsws\"\nrequest_url = self.config()[\"settingsUrl\"]\n##Fetching session id will be three step process\n# Step1: intiate a dummy request to tomcat\n# Step2: fetch session id from the response, and hit j_security_check with proper authentication\n# Step3: get session id from the response, add to self. It can be used for other transactions\nsession = requests.Session()\nlogger.info(\"Initiating dummy rest call to Tomcat to get initial session id\")\nresponse = session.put(request_url, json=payload)\nlogger.info(response.text)\nif response.ok:\nlogger.info(\"Url to authenticate Tomcat for Session id -&gt; %s\", auth_url)\nsession_response = session.post(auth_url)\nif session_response.ok:\nlogger.info(\n\"Response for -&gt; %s is -&gt; %s\", auth_url, str(session_response)\n)\nsession_dict = session.cookies.get_dict()\nlogger.info(\n\"Session id to perform Rest API calls to Tomcat -&gt; %s\",\nsession_dict[\"JSESSIONID\"],\n)\n# store session ID an write it into the global requestHeaders variable:\nself._jsessionid = session_dict[\"JSESSIONID\"]\nrequestHeaders[\"Cookie\"] = \"JSESSIONID=\" + self._jsessionid\nreturn session_response\nelse:\nlogger.error(\n\"Fetching session id from -&gt; %s failed with j_security_check. Response -&gt; %s\",\nauth_url,\nsession_response.text,\n)\nreturn None\nelse:\nlogger.error(\n\"Fetching session id from -&gt; %s failed. Response -&gt; %s\",\nrequest_url,\nresponse.text,\n)\nreturn None\n# end method definition\ndef import_database(self, filename: str):\n\"\"\"Import PowerDocs database backup from a zip file\"\"\"\nfile = filename.split(\"/\")[-1]\nfile_tup = (file, open(filename, \"rb\"), \"application/zip\")\n# fields attribute is set according to the other party's interface description\nm = MultipartEncoder(fields={\"name\": file, \"zipfile\": file_tup})\nrequest_url = self.config()[\"otpdImportDatabaseUrl\"]\nlogger.info(\n\"Importing Database backup -&gt; %s, into PowerDocs ServerManager on -&gt; %s\",\nfilename,\nrequest_url,\n)\nresponse = requests.post(\nrequest_url, data=m, headers={\"content-type\": m.content_type}, timeout=60\n)\nif response.ok:\nreturn response\nelse:\nlogger.error(\n\"Failed to Import Database backup -&gt; %s into -&gt; %s; error -&gt; %s\",\nfilename,\nrequest_url,\nresponse.text,\n)\nreturn None\n# end method definition\ndef apply_setting(\nself, setting_name: str, setting_value: str, tenant_name: str = \"\"\n) -&gt; dict | None:\n\"\"\"Appy a setting to the PowerDocs Server Manager\n        Args:\n            setting_name (str): name of the setting\n            setting_value (str): new value of the setting\n            tenant_name (str): name of the PowerDocs tenant - this is optional as some settings are not tenant-specific!\n        Return:\n            dict: Request response or None if the REST call fails.\n        \"\"\"\nsettingsPutBody = {\n\"settingname\": setting_name,\n\"settingvalue\": setting_value,\n}\nif tenant_name:\nsettingsPutBody[\"tenantName\"] = tenant_name\nrequest_url = self.config()[\"settingsUrl\"]\nlogger.info(\n\"Update setting -&gt; %s with value -&gt; %s; calling -&gt; %s\",\nsetting_name,\nsetting_value,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=settingsPutBody,\nheaders=requestHeaders,\nauth=HTTPBasicAuth(\nself.config()[\"username\"], self.config()[\"password\"]\n),\nverify=False,  # for localhost deployments this will fail otherwise\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update setting -&gt; %s; error -&gt; %s\",\nsetting_name,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.__init__","title":"<code>__init__(protocol, hostname, port, username, password)</code>","text":"<p>Initialize the OTPD object</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>Either http or https.</p> required <code>hostname</code> <code>str</code> <p>The hostname of the PowerDocs Server Manager to communicate with.</p> required <code>port</code> <code>int</code> <p>The port number used to talk to the PowerDocs Server Manager.</p> required <code>username</code> <code>str</code> <p>The admin user name of PowerDocs Server Manager.</p> required <code>password</code> <code>str</code> <p>The admin password of PowerDocs Server Manager.</p> required Source code in <code>pyxecm/otpd.py</code> <pre><code>def __init__(\nself,\nprotocol: str,\nhostname: str,\nport: int,\nusername: str,\npassword: str,\n):\n\"\"\"Initialize the OTPD object\n    Args:\n        protocol (str): Either http or https.\n        hostname (str): The hostname of the PowerDocs Server Manager to communicate with.\n        port (int): The port number used to talk to the PowerDocs Server Manager.\n        username (str): The admin user name of PowerDocs Server Manager.\n        password (str): The admin password of PowerDocs Server Manager.\n    \"\"\"\notpd_config = {}\nif hostname:\notpd_config[\"hostname\"] = hostname\nelse:\notpd_config[\"hostname\"] = \"\"\nif protocol:\notpd_config[\"protocol\"] = protocol\nelse:\notpd_config[\"protocol\"] = \"http\"\nif port:\notpd_config[\"port\"] = port\nelse:\notpd_config[\"port\"] = 80\nif username:\notpd_config[\"username\"] = username\nelse:\notpd_config[\"username\"] = \"admin\"\nif password:\notpd_config[\"password\"] = password\nelse:\notpd_config[\"password\"] = \"\"\notpd_base_url = protocol + \"://\" + otpd_config[\"hostname\"]\nif str(port) not in [\"80\", \"443\"]:\notpd_base_url += \":{}\".format(port)\notpd_base_url += \"/ServerManager\"\notpd_config[\"baseUrl\"] = otpd_base_url\notpd_rest_url = otpd_base_url + \"/api\"\notpd_config[\"restUrl\"] = otpd_rest_url\notpd_config[\"settingsUrl\"] = otpd_rest_url + \"/v1/settings\"\notpd_config[\"importDatabaseUrl\"] = otpd_base_url + \"/servlet/import\"\nself._config = otpd_config\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.apply_setting","title":"<code>apply_setting(setting_name, setting_value, tenant_name='')</code>","text":"<p>Appy a setting to the PowerDocs Server Manager</p> <p>Parameters:</p> Name Type Description Default <code>setting_name</code> <code>str</code> <p>name of the setting</p> required <code>setting_value</code> <code>str</code> <p>new value of the setting</p> required <code>tenant_name</code> <code>str</code> <p>name of the PowerDocs tenant - this is optional as some settings are not tenant-specific!</p> <code>''</code> Return <p>dict: Request response or None if the REST call fails.</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def apply_setting(\nself, setting_name: str, setting_value: str, tenant_name: str = \"\"\n) -&gt; dict | None:\n\"\"\"Appy a setting to the PowerDocs Server Manager\n    Args:\n        setting_name (str): name of the setting\n        setting_value (str): new value of the setting\n        tenant_name (str): name of the PowerDocs tenant - this is optional as some settings are not tenant-specific!\n    Return:\n        dict: Request response or None if the REST call fails.\n    \"\"\"\nsettingsPutBody = {\n\"settingname\": setting_name,\n\"settingvalue\": setting_value,\n}\nif tenant_name:\nsettingsPutBody[\"tenantName\"] = tenant_name\nrequest_url = self.config()[\"settingsUrl\"]\nlogger.info(\n\"Update setting -&gt; %s with value -&gt; %s; calling -&gt; %s\",\nsetting_name,\nsetting_value,\nrequest_url,\n)\nretries = 0\nwhile True:\nresponse = requests.put(\nurl=request_url,\njson=settingsPutBody,\nheaders=requestHeaders,\nauth=HTTPBasicAuth(\nself.config()[\"username\"], self.config()[\"password\"]\n),\nverify=False,  # for localhost deployments this will fail otherwise\ntimeout=None,\n)\nif response.ok:\nreturn self.parse_request_response(response)\n# Check if Session has expired - then re-authenticate and try once more\nelif response.status_code == 401 and retries == 0:\nlogger.warning(\"Session has expired - try to re-authenticate...\")\nself.authenticate(True)\nretries += 1\nelse:\nlogger.error(\n\"Failed to update setting -&gt; %s; error -&gt; %s\",\nsetting_name,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.authenticate","title":"<code>authenticate(revalidate=False)</code>","text":"<p>Authenticates at PowerDocs and retrieve session ID.</p> <p>Parameters:</p> Name Type Description Default <code>revalidate</code> <code>bool</code> <p>determinse if a re-athentication is enforced                (e.g. if session has timed out with 401 error)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Cookie information of None in case of an error.   Also stores cookie information in self._cookie</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def authenticate(self, revalidate: bool = False) -&gt; dict:\n\"\"\"Authenticates at PowerDocs and retrieve session ID.\n    Args:\n        revalidate (bool): determinse if a re-athentication is enforced\n                           (e.g. if session has timed out with 401 error)\n    Returns:\n        dict: Cookie information of None in case of an error.\n              Also stores cookie information in self._cookie\n    \"\"\"\n# Already authenticated and session still valid?\nif self._jsessionid and not revalidate:\nreturn self._jsessionid\nauth_url = (\nself.base_url()\n+ \"/j_security_check?j_username=\"\n+ self.config()[\"username\"]\n+ \"&amp;j_password=\"\n+ self.config()[\"password\"]\n)\npayload = {}\npayload[\"settingname\"] = \"LocalOtdsUrl\"\npayload[\"settingvalue\"] = \"http://otds/otdsws\"\nrequest_url = self.config()[\"settingsUrl\"]\n##Fetching session id will be three step process\n# Step1: intiate a dummy request to tomcat\n# Step2: fetch session id from the response, and hit j_security_check with proper authentication\n# Step3: get session id from the response, add to self. It can be used for other transactions\nsession = requests.Session()\nlogger.info(\"Initiating dummy rest call to Tomcat to get initial session id\")\nresponse = session.put(request_url, json=payload)\nlogger.info(response.text)\nif response.ok:\nlogger.info(\"Url to authenticate Tomcat for Session id -&gt; %s\", auth_url)\nsession_response = session.post(auth_url)\nif session_response.ok:\nlogger.info(\n\"Response for -&gt; %s is -&gt; %s\", auth_url, str(session_response)\n)\nsession_dict = session.cookies.get_dict()\nlogger.info(\n\"Session id to perform Rest API calls to Tomcat -&gt; %s\",\nsession_dict[\"JSESSIONID\"],\n)\n# store session ID an write it into the global requestHeaders variable:\nself._jsessionid = session_dict[\"JSESSIONID\"]\nrequestHeaders[\"Cookie\"] = \"JSESSIONID=\" + self._jsessionid\nreturn session_response\nelse:\nlogger.error(\n\"Fetching session id from -&gt; %s failed with j_security_check. Response -&gt; %s\",\nauth_url,\nsession_response.text,\n)\nreturn None\nelse:\nlogger.error(\n\"Fetching session id from -&gt; %s failed. Response -&gt; %s\",\nrequest_url,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.base_url","title":"<code>base_url()</code>","text":"<p>Returns the base URL of PowerDocs</p> <p>Returns:</p> Name Type Description <code>string</code> <p>base URL</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def base_url(self):\n\"\"\"Returns the base URL of PowerDocs\n    Returns:\n        string: base URL\n    \"\"\"\nreturn self.config()[\"baseUrl\"]\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.config","title":"<code>config()</code>","text":"<p>Returns the configuration dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration dictionary</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def config(self) -&gt; dict:\n\"\"\"Returns the configuration dictionary\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.credentials","title":"<code>credentials()</code>","text":"<p>Get credentials (username + password)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary with username and password</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def credentials(self) -&gt; dict:\n\"\"\"Get credentials (username + password)\n    Returns:\n        dict: dictionary with username and password\n    \"\"\"\nreturn {\n\"username\": self.config()[\"username\"],\n\"password\": self.config()[\"password\"],\n}\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.hostname","title":"<code>hostname()</code>","text":"<p>Returns the hostname of PowerDocs (e.g. \"otpd\")</p> <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> <p>hostname</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def hostname(self) -&gt; str:\n\"\"\"Returns the hostname of PowerDocs (e.g. \"otpd\")\n    Returns:\n        string: hostname\n    \"\"\"\nreturn self.config()[\"hostname\"]\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.import_database","title":"<code>import_database(filename)</code>","text":"<p>Import PowerDocs database backup from a zip file</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def import_database(self, filename: str):\n\"\"\"Import PowerDocs database backup from a zip file\"\"\"\nfile = filename.split(\"/\")[-1]\nfile_tup = (file, open(filename, \"rb\"), \"application/zip\")\n# fields attribute is set according to the other party's interface description\nm = MultipartEncoder(fields={\"name\": file, \"zipfile\": file_tup})\nrequest_url = self.config()[\"otpdImportDatabaseUrl\"]\nlogger.info(\n\"Importing Database backup -&gt; %s, into PowerDocs ServerManager on -&gt; %s\",\nfilename,\nrequest_url,\n)\nresponse = requests.post(\nrequest_url, data=m, headers={\"content-type\": m.content_type}, timeout=60\n)\nif response.ok:\nreturn response\nelse:\nlogger.error(\n\"Failed to Import Database backup -&gt; %s into -&gt; %s; error -&gt; %s\",\nfilename,\nrequest_url,\nresponse.text,\n)\nreturn None\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.parse_request_response","title":"<code>parse_request_response(response_object, additional_error_message='', show_error=True)</code>","text":"<p>Converts the request response to a Python dict in a safe way    that also handles exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>response_object</code> <code>object</code> <p>this is reponse object delivered by the request call</p> required <code>additional_error_message</code> <code>str</code> <p>print a custom error message</p> <code>''</code> <code>show_error</code> <code>bool</code> <p>if True log an error, if False log a warning</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>a python dict object or None in case of an error</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def parse_request_response(\nself,\nresponse_object: object,\nadditional_error_message: str = \"\",\nshow_error: bool = True,\n) -&gt; dict | None:\n\"\"\"Converts the request response to a Python dict in a safe way\n       that also handles exceptions.\n    Args:\n        response_object (object): this is reponse object delivered by the request call\n        additional_error_message (str): print a custom error message\n        show_error (bool): if True log an error, if False log a warning\n    Returns:\n        dict: a python dict object or None in case of an error\n    \"\"\"\nif not response_object:\nreturn None\ntry:\ndict_object = json.loads(response_object.text)\nexcept json.JSONDecodeError as exception:\nif additional_error_message:\nmessage = \"Cannot decode response as JSon. {}; error -&gt; {}\".format(\nadditional_error_message, exception\n)\nelse:\nmessage = \"Cannot decode response as JSon; error -&gt; {}\".format(exception)\nif show_error:\nlogger.error(message)\nelse:\nlogger.warning(message)\nreturn None\nelse:\nreturn dict_object\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.rest_url","title":"<code>rest_url()</code>","text":"<p>Returns the REST URL of PowerDocs</p> <p>Returns:</p> Name Type Description <code>string</code> <p>REST URL</p> Source code in <code>pyxecm/otpd.py</code> <pre><code>def rest_url(self):\n\"\"\"Returns the REST URL of PowerDocs\n    Returns:\n        string: REST URL\n    \"\"\"\nreturn self.config()[\"restUrl\"]\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.set_credentials","title":"<code>set_credentials(username='admin', password='')</code>","text":"<p>Set the credentials for PowerDocs for the based on user name and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username. Defaults to \"admin\".</p> <code>'admin'</code> <code>password</code> <code>str</code> <p>Password of the user. Defaults to \"\".</p> <code>''</code> Source code in <code>pyxecm/otpd.py</code> <pre><code>def set_credentials(self, username: str = \"admin\", password: str = \"\"):\n\"\"\"Set the credentials for PowerDocs for the based on user name and password.\n    Args:\n        username (str, optional): Username. Defaults to \"admin\".\n        password (str, optional): Password of the user. Defaults to \"\".\n    \"\"\"\nself.config()[\"username\"] = username\nself.config()[\"password\"] = password\n</code></pre>"},{"location":"pyxecm/otpd/#pyxecm.otpd.OTPD.set_hostname","title":"<code>set_hostname(hostname)</code>","text":"<p>Sets the hostname of PowerDocs</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>new hostname</p> required Source code in <code>pyxecm/otpd.py</code> <pre><code>def set_hostname(self, hostname: str):\n\"\"\"Sets the hostname of PowerDocs\n    Args:\n        hostname (str): new hostname\n    \"\"\"\nself.config()[\"hostname\"] = hostname\n</code></pre>"},{"location":"pyxecm/payload/","title":"Payload","text":"<p>Payload Module to implement functions to process Terrarium payload</p> <p>This code processes a YAML payload file that includes various settings: * WebHooks (URLs) to call (e.g. to start-up external services or applications) * OTDS partitions and OAuth clients * OTDS trusted sites and system attributes * OTDS licenses * Extended ECM users and groups * Microsoft 365 user, groups, and teams * Extended ECM Admin Settings (LLConfig) * Extended ECM External System Connections (SAP, SuccessFactors, ...) * Extended ECM Transport Packages (scenarios and demo content) * Extended ECM CS Applications (typically based on Web Reports) * Extended ECM Web Reports to run * Extended ECM Workspaces to create (incl. members, workspace relationships) * Extended ECM user photos, user favorites and user settings * Extended ECM items to create and permissions to apply * Extended ECM items to rename * Extended ECM Documents to generate (from templates) * Extended ECM assignments (used e.g. for Government scenario) * Extended ECM Records Management settings, Security Clearance, Supplemental Markings, and Holds * SAP RFCs (Remote Function Calls) * Commands to execute in Kubernetes Pods</p> <p>This code typically runs in a container as part of the cloud automation.</p> <p>Class: Payload Methods:</p> <p>init : class initializer replace_placeholders: replace placeholder in admin config files init_payload: load and initialize the YAML payload get_payload_section: delivers a section of the payload as a list of settings get_all_group_names: construct a list of all group name</p> <p>check_status_file: check if the payload section has been processed before</p> Write a status file into the Admin Personal Workspace in Extended ECM <p>to indicate that the payload section has been deployed successfully</p> <p>get_status_file: Retrieve the content of the status file</p> <p>determine_group_id: determine the id of a group - either from payload or from OTCS determine_user_id: determine the id of a user - either from payload or from OTCS determine_user_id_m365: determine the id of a M365 user - either from payload or from M365 via Graph API determine_workspace_id: determine the nodeID of a workspace - either from payload or from OTCS</p> <p>process_payload: process payload (main method) process_web_hooks: process list of web hooks process_partitions: process the OTDS partitions</p> process the licenses that should be assigned to OTDS partitions <p>(this includes existing partitions)</p> <p>process_oauth_clients: process the OTDS OAuth clients process_auth_handlers: process the OTDS auth handlers (some are implicitly generated by external system payload) process_trusted_sites: process the OTDS trusted sites process_system_attributes: process the OTDS system attributes process_group_placeholders: collect group placeholders process_user_placeholders: collect user placeholders process_groups: process Extended ECM user groups process_groups_m365: process M365 user groups process_users: process Extended ECM users process_users_m365: process M365 users process_users_sap: process users that are SAP enabled (if SAP is enabled) process_teams_m365: process groups in payload and create matching M365 Teams</p> Delete Microsoft Teams that are left-overs from former deployments. <p>This method is currently not used.</p> <p>cleanup_all_teams_m365: Delete Microsoft Teams that are left-overs from former deployments process_admin_settings: process Extended ECM administration settings (LLConfig) process_external_systems: process Extended ECM external systems process_transport_packages: process Extended ECM transport packages process_user_photos: process Extended ECM user photos (user profile) process_user_photos_m365: process user photos in payload and assign them to Microsoft 365 users.</p> process Extended ECM workspace types <p>(needs to run after process_transport_packages)</p> <p>process_workspaces: process Extended ECM workspace instances process_workspace_relationships: process Extended ECM workspace relationships process_workspace_members: process Extended ECM workspace members (users and groups)</p> Process workspaces Content Aviator settings in payload and <p>enable Aviator for selected workspaces</p> <p>process_web_reports: process Extended ECM Web Reports (starts them with parameters) process_cs_applications: process Extended ECM CS Applications process_user_settings: Process user settings in payload and apply themin OTDS. process_user_favorites_and_profiles: Process user favorites in payload and create them in Extended ECM process_security_clearances: process Security Clearance for users process_supplemental_markings: process Supplemental Markings for users process_user_security: process Security Clearance and Supplemental Markings for users process_records_management_settings: process Records Management settings by applying settings files process_holds: process Records Management Holds process_additional_group_members: process additional OTDS group memberships process_additional_access_role_members: process additional OTDS group memberships process_renamings: process Extended ECM node renamings process_items: process Extended ECM items (nodes) to create process_permissions: process permission changes for alist of Extended ECM items or volumes process_assignments: process assignments of workspaces / documents to users / groups process_user_licenses: process and apply licenses to all Extended ECM users (used for OTIV) process_exec_pod_commands: process Kubernetes pod commands process_document_generators: Generate documents for a defined workspace type based on template process_browser_automations: process Selenium-based browser automation payload init_sap: initalize SAP object for RFC communication process_sap_rfcs: process SAP Remote Function Calls (RFC) to trigger automation in SAP S/4HANA</p> <p>get_payload: return the payload data structure get_users: return list of users get_groups: return list of groups get_workspaces: return list of workspaces get_otcs_frontend: return OTCS object for OTCS frontend get_otcs_backend: return OTCS object for OTCS backend get_otds: return OTDS object get_k8s: return the Kubernetes object</p>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload","title":"<code>Payload</code>","text":"<p>Used to process Terrarium payload.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>class Payload:\n\"\"\"Used to process Terrarium payload.\"\"\"\n# _debug controls whether or not transport processing is\n# stopped if one transport fails:\n_debug: bool = False\n_otcs: OTCS\n_otcs_backend: OTCS\n_otcs_frontend: OTCS\n_otac: OTAC | None\n_otds: OTDS\n_otiv: OTIV | None\n_k8s: K8s | None\n_web: HTTP | None\n_m365: M365 | None\n_browser_automation: BrowserAutomation | None\n_custom_settings_dir = \"\"\n# _payload_source (string): This is either path + filename of the yaml payload\n# or an path + filename of the Terraform HCL payload\n_payload_source = \"\"\n# _payload is a dict of the complete payload file.\n# It is initialized by the init_payload() method:\n_payload = {}\n# _payload_sections is a list of dicts with these keys:\n# - name (string)\n# - enabled (bool)\n# - restart (bool)\n_payload_sections = []\n#\n# Initialize payload section variables. They are all list of dicts:\n#\n# webhooks and webhooks_post: List of webHooks. List items are dicts with these key:\n# - enabled (bool)\n# - description (str)\n# - url (str)\n# - method (str) - either POST, PUT, GET\n# - payload (dict)\n# - headers (dict)\n_webhooks = []\n_webhooks_post = []\n# partitions: list of dicts with these key / value pairs:\n# - enabled (bool)\n# - name (str)\n# - description (str)\n# - synced (bool)\n# - access_role (str)\n# - licenses (list)\n_partitions = []\n# oauth_clients: list of dicts with these key / value pairs:\n# - enabled (bool)\n# - name (str)\n# - description (str)\n# - confidential (bool)\n# - partition (str)\n# - redirect_urls (list)\n# - permission_scopes (list)\n# - default_scopes (list)\n# - allow_impersonation (bool)\n_oauth_clients = []\n# oauth_handlers: list of dicts with these key / value pairs:\n# - enabled (bool)\n# - name (str)\n# - description (str)\n# - scope (str)\n# - type (str) - like SAML, SAP, OAUTH\n# - priority (int)\n# - active_by_default (bool)\n# - auth_principal_attributes (list)\n# - saml_url (str)\n# - otds_sp_endpoint (str)\n# - nameid_format (str)\n_auth_handlers = []\n# trusted_sites: list of dicts with these key / value pairs:\n# - enabled (bool)\n# - url (str)\n_trusted_sites = []\n# system_attributes: list of dicts with these key / value pairs:\n# - enabled (bool)\n# - name (str)\n# - value (str)\n# - description (str)\n_system_attributes = []\n# groups: List of groups. List items are dicts with these key / value pairs:\n# - name (str),\n# - parent_groups (list),\n# - enable_o365 (bool)\n_groups = []\n# users: List of users. List items are dicts with these key / value pairs:\n# - enabled (bool)\n# - name (str) (= login)\n# - password (str)\n# - firstname (str)\n# - lastname (str)\n# - email (str)\n# - base_group (str)\n# - groups (list)\n# - favorites (list of str)\n# - security_clearance (int)\n# - supplemental_markings (list of str)\n# - enable_sap (bool)\n# - enable_o365 (bool)\n# - m365_skus (list of str)\n# - extra_attributes (list of dict)\n_users = []\n_admin_settings = []\n# exec_pod_commands: list of commands to be executed in the pods\n# list elements need to be dicts with pod name, command, etc.\n_exec_pod_commands = []\n# external_systems (list): List of external systems. Each list element is a dict with\n# - enabled (bool)\n# - external_system_type (str)\n# - external_system_name (str)\n# - external_system_number (str)\n# - description (str)\n# - as_url (str)\n# - base_url (str)\n# - client (str)\n# - username (str)\n# - password (str)\n# - certificate_file (str)\n# - certificate_password (str)\n# - destination (str)\n# - archive_logical_name (str)\n# - archive_certificate_file (str)\n_external_systems = []\n# transport_packages (list): List of transport packages systems. Each list element is a\n# dict with \"url\", \"name\", and \"description\" keys.\n_transport_packages = []\n_content_transport_packages = []\n_transport_packages_post = []\n_workspace_types = []\n_workspace_templates = []\n_workspaces = []\n_sap_rfcs = []\n_web_reports = []\n_web_reports_post = []\n_cs_applications = []\n_admin_settings_post = []\n# additional_group_members: List of memberships to establish. Each element\n# is a dict with these keys:\n# - parent_group (string)\n# - user_name (string)\n# - group_name (string)\n_additional_group_members = []\n# additional_access_role_members: List of memberships to establish. Each element\n# is a dict with these keys:\n# - access_role (string)\n# - user_name (string)\n# - group_name (string)\n# - partition_name (string)\n_additional_access_role_members = []\n_renamings = []\n_items = []\n_items_post = []\n_permissions = []\n_permissions_post = []\n# assignments: List of assignments. Each element is a dict with these keys:\n# - subject (string)\n# - instruction (string)\n# - workspace (string)\n# - nickname (string)\n# - groups (list)\n# - users (list)\n_assignments = []\n_workspace_template_registrations = []\n_security_clearances = []\n_supplemental_markings = []\n_records_management_settings = []\n_holds = []\n_doc_generators = []\n_browser_automations = []\n_placeholder_values = {}\n_otcs_restart_callback: Callable\n_log_header_callback: Callable\n_aviator_enabled = False\ndef __init__(\nself,\npayload_source: str,\ncustom_settings_dir: str,\nk8s_object: K8s | None,\notds_object: OTDS,\notac_object: OTAC | None,\notcs_backend_object: OTCS,\notcs_frontend_object: OTCS,\notcs_restart_callback: Callable,\notiv_object: OTIV | None,\nm365_object: M365 | None,\nbrowser_automation_object: BrowserAutomation | None,\nplaceholder_values: dict,\nlog_header_callback: Callable,\nstop_on_error: bool = False,\naviator_enabled: bool = False,\n):\n\"\"\"Initialize the Payload object\n        Args:\n            payload_source (str): path or URL to payload source file\n            k8s_object (object): Kubernetes object\n            otds_object (OTDS): OTDS object\n            otac_object (OTAC): OTAC object\n            otcs_backend_object (OTCS): OTCS backend object\n            otcs_frontend_object (OTCS): OTCS frontend object\n            otcs_restart_callback (Callable): function to call if OTCS service needs a restart\n            otiv_object (object): OTIV object\n            m365_object (object): M365 object to talk to Microsoft Graph API\n            browser_automation_object (object): BrowserAutomation object to automate things which don't have a REST API\n            placeholder_values (dict): dictionary of placeholder values\n                                       to be replaced in admin settings\n            log_header_callback: prints a section break / header line into the log\n            stop_on_error (bool): controls if transport deployment should stop\n                                  if one transport fails\n            aviator_enabled (bool): whether or not the Content Aviator is enabled\n        \"\"\"\nself._stop_on_error = stop_on_error\nself._payload_source = payload_source\nself._k8s = k8s_object\nself._otds = otds_object\nself._otac = otac_object\nself._otcs = otcs_backend_object\nself._otcs_backend = otcs_backend_object\nself._otcs_frontend = otcs_frontend_object\nself._otiv = otiv_object\nself._m365 = m365_object\nself._browser_automation = browser_automation_object\nself._custom_settings_dir = custom_settings_dir\nself._placeholder_values = placeholder_values\nself._otcs_restart_callback = otcs_restart_callback\nself._log_header_callback = log_header_callback\nself._aviator_enabled = aviator_enabled\nself._http_object = HTTP()\n# end method definition\ndef replace_placeholders(self, content: str) -&gt; str:\n\"\"\"Function to replace placeholders in file content.\n           The content of the file is provided via a parameter.\n           The replacements are defined in a object variable\n           _placeholder_values (type = dictionary)\n           The placeholder values are supposed to be surrounded by\n           double % signs like %%OTAWP_RESOURCE_ID%%\n        Args:\n            content (str): file content to replace placeholders in\n        Returns:\n            str: updated content with all defined replacements\n        \"\"\"\n# https://stackoverflow.com/questions/63502218/replacing-placeholders-in-a-text-file-with-python\n# if no placeholders are defined we can return the\n# initial value:\nif not self._placeholder_values:\nreturn content\ntry:\n# We do a dynamic replacement here. The replacement is calculated\n# by the lambda function that is basically a lookup of the replacement\n# key found in the settings file with the value defined in the list\n# of replacement values in self._placeholder_values\nreturn re.sub(\nr\"%%(\\w+?)%%\",\nlambda match: self._placeholder_values[match.group(1)],\ncontent,\n)\nexcept KeyError as key_error:\nlogger.error(\n\"Found placeholder in settings file without a defined value; error -&gt; %s\",\nstr(key_error),\n)\nreturn content\nexcept re.error as re_error:\nlogger.error(\"Regex substitution error -&gt; %s\", str(re_error))\nreturn content\n# end method definition\ndef init_payload(self) -&gt; dict | None:\n\"\"\"Read the YAML or Terraform HCL payload file.\n        Args:\n            None\n        Returns:\n            dict: payload as a Python dict. Elements are the different payload sections.\n                  None in case the file couldn't be found or read.\n        \"\"\"\nif not os.path.exists(self._payload_source):\nlogger.error(\"Cannot access payload file -&gt; %s\", self._payload_source)\nreturn None\n# Is it a YAML file?\nif self._payload_source.endswith(\".yaml\"):\nlogger.info(\"Open payload from YAML file -&gt; %s\", self._payload_source)\ntry:\nwith open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\npayload_data = stream.read()\nself._payload = yaml.safe_load(payload_data)\nexcept yaml.YAMLError as exception:\nlogger.error(\n\"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\nself._payload_source,\nexception,\n)\nself._payload = {}\n# Or is it a Terraform HCL file?\nelif self._payload_source.endswith(\".tf\"):\nlogger.info(\n\"Open payload from Terraform HCL file -&gt; %s\", self._payload_source\n)\ntry:\nwith open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\nself._payload = hcl2.api.load(stream)\n# If payload is wrapped into \"external_payload\" we unwrap it:\nif self._payload.get(\"external_payload\"):\nself._payload = self._payload[\"external_payload\"]\nexcept FileNotFoundError as exception:\nlogger.error(\n\"Error while reading Terraform HCL payload file -&gt; %s; error -&gt; %s\",\nself._payload_source,\nexception,\n)\nself._payload = {}\nelif self._payload_source.endswith(\".yml.gz.b64\"):\nlogger.info(\n\"Open payload from base64-gz-YAML file -&gt; %s\", self._payload_source\n)\ntry:\nwith open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\ncontent = base64.b64decode(stream.read())\ndecoded_data = gzip.decompress(content)\nself._payload = yaml.safe_load(decoded_data)\nexcept yaml.YAMLError as exception:\nlogger.error(\n\"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\nself._payload_source,\nexception,\n)\nself._payload = {}\n# If not, it is an unsupported type:\nelse:\nlogger.error(\n\"File -&gt; %s has unsupported file type\",\nself._payload_source,\n)\nself._payload = {}\nif self._payload is not None:\nself._payload_sections = self._payload[\"payloadSections\"]\nif not self._payload_sections:\nlogger.error(\n\"Sections for payload -&gt; %s are undefined. Skipping...\",\nself._payload_source,\n)\nreturn None\n# Retrieve all the payload sections and store them in lists:\nself._webhooks = self.get_payload_section(\"webHooks\")\nself._webhooks_post = self.get_payload_section(\"webHooksPost\")\nself._partitions = self.get_payload_section(\"partitions\")\nself._oauth_clients = self.get_payload_section(\"oauthClients\")\nself._auth_handlers = self.get_payload_section(\"authHandlers\")\nself._trusted_sites = self.get_payload_section(\"trustedSites\")\nself._system_attributes = self.get_payload_section(\"systemAttributes\")\nself._groups = self.get_payload_section(\"groups\")\nself._users = self.get_payload_section(\"users\")\nself._admin_settings = self.get_payload_section(\"adminSettings\")\nself._exec_pod_commands = self.get_payload_section(\"execPodCommands\")\nself._external_systems = self.get_payload_section(\"externalSystems\")\nself._transport_packages = self.get_payload_section(\"transportPackages\")\nself._content_transport_packages = self.get_payload_section(\n\"contentTransportPackages\"\n)\nself._transport_packages_post = self.get_payload_section(\n\"transportPackagesPost\"\n)\nself._workspace_templates = self.get_payload_section(\"workspaceTemplates\")\nself._workspaces = self.get_payload_section(\"workspaces\")\nself._sap_rfcs = self.get_payload_section(\"sapRFCs\")\nself._web_reports = self.get_payload_section(\"webReports\")\nself._web_reports_post = self.get_payload_section(\"webReportsPost\")\nself._cs_applications = self.get_payload_section(\"csApplications\")\nself._admin_settings_post = self.get_payload_section(\"adminSettingsPost\")\nself._additional_group_members = self.get_payload_section(\n\"additionalGroupMemberships\"\n)\nself._additional_access_role_members = self.get_payload_section(\n\"additionalAccessRoleMemberships\"\n)\nself._renamings = self.get_payload_section(\"renamings\")\nself._items = self.get_payload_section(\"items\")\nself._items_post = self.get_payload_section(\"itemsPost\")\nself._permissions = self.get_payload_section(\"permissions\")\nself._permissions_post = self.get_payload_section(\"permissionsPost\")\nself._assignments = self.get_payload_section(\"assignments\")\nself._security_clearances = self.get_payload_section(\"securityClearances\")\nself._supplemental_markings = self.get_payload_section(\"supplementalMarkings\")\nself._records_management_settings = self.get_payload_section(\n\"recordsManagementSettings\"\n)\nself._holds = self.get_payload_section(\"holds\")\nself._doc_generators = self.get_payload_section(\"documentGenerators\")\nself._browser_automations = self.get_payload_section(\"browserAutomations\")\nreturn self._payload\n# end method definition\ndef get_payload_section(self, payload_section_name: str) -&gt; list:\n\"\"\"Get a defined section of the payload. The section is delivered as a list of settings.\n        It deliveres an empty list if this payload section is disabled by the corresponding\n        payload switch (this is read from the payloadSections dictionary of the payload)\n        Args:\n            payload_section_name (str): name of the dict element in the payload structure\n        Returns:\n            list: section of the payload as a Python list. Empty list if section does not exist\n            or section is disabled by the corresponding payload switch.\n        \"\"\"\nif not isinstance(self._payload, dict):\nreturn []\n# if the secton is not in the payload we return an empty list:\nif not self._payload.get(payload_section_name):\nreturn []\n# Check if the payload section is either enabled\n# or the struct for payloadSection enabling is not in the payload:\nsections = self._payload.get(\"payloadSections\")\nif sections:\nsection = next(\n(item for item in sections if item[\"name\"] == payload_section_name),\nNone,\n)\nif not section or not section[\"enabled\"]:\nreturn []\nreturn self._payload[payload_section_name]\n# end method definition\ndef get_all_group_names(self) -&gt; list:\n\"\"\"Construct a list of all group name\n        Returns:\n            list: list of all group names\n        \"\"\"\nreturn [group.get(\"name\") for group in self._groups]\n# end method definition\ndef check_status_file(\nself, payload_section_name: str, payload_specific: bool = True\n) -&gt; bool:\n\"\"\"Check if the payload section has been processed before. This is\n           done by checking the existance of a text file in the Admin Personal\n           workspace in Extended ECM with the name of the payload section.\n        Args:\n            payload_section_name (str): name of the payload section. This\n                                        is used to construct the file name\n            payload_specific (bool): whether or not the success should be specific for\n                                     each payload file or if success is \"global\" - like for the deletion\n                                     of the existing M365 teams (which we don't want to execute per\n                                     payload file)\n        Returns:\n            bool: True if the payload has been processed successfully before, False otherwise\n        \"\"\"\nlogger.info(\n\"Check if payload section -&gt; %s has been processed successfully before...\",\npayload_section_name,\n)\nresponse = self._otcs.get_node_by_volume_and_path(\n142\n)  # write to Personal Workspace of Admin\ntarget_folder_id = self._otcs.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2004  # use Personal Workspace of Admin as fallback\n# Some sections are actually not payload specific like teamsM365Cleanup\n# we don't want external payload runs to re-apply this processing:\nif payload_specific:\nfile_name = os.path.basename(self._payload_source)  # remove directories\n# Split once at the first occurance of a dot\n# as the _payload_source may have multiple suffixes\n# such as .yml.gz.b64:\nfile_name = file_name.split(\".\", 1)[0]\nfile_name = \"success_\" + file_name + \"_\" + payload_section_name + \".json\"\nelse:\nfile_name = \"success_\" + payload_section_name + \".json\"\nstatus_document = self._otcs.get_node_by_parent_and_name(\nparent_id=int(target_folder_id), name=file_name, show_error=False\n)\nif status_document and status_document[\"results\"]:\nname = self._otcs.get_result_value(status_document, \"name\")\nif name == file_name:\nlogger.info(\n\"Payload section -&gt; %s has been processed successfully before. Skipping...\",\npayload_section_name,\n)\nreturn True\nlogger.info(\n\"Payload section -&gt; %s has not been processed successfully before. Processing...\",\npayload_section_name,\n)\nreturn False\n# end method definition\ndef write_status_file(\nself,\nsuccess: bool,\npayload_section_name: str,\npayload_section: list,\npayload_specific: bool = True,\n) -&gt; bool:\n\"\"\"Write a status file into the Admin Personal Workspace in Extended ECM\n           to indicate that the payload section has been deployed successfully.\n           This speeds up the customizing process in case the customizer pod\n           is restarted.\n        Args:\n            success (bool): True if the section was processed successful, False otherwise.\n            payload_section_name (str): name of the payload section\n            payload_section (list): payload section content - this is written as JSon into the file\n            payload_specific (bool): whether or not the success should be specific for\n                                     each payload file or if success is \"global\" - like for the deletion\n                                     of the existing M365 teams (which we don't want to execute per\n                                     payload file)\n        Returns:\n            bool: True if the status file as been upladed to Extended ECM successfully, False otherwise\n        \"\"\"\nif success:\nlogger.info(\n\"Payload section -&gt; %s has been completed successfully!\",\npayload_section_name,\n)\nprefix = \"success_\"\nelse:\nlogger.error(\n\"Payload section -&gt; %s had failures!\",\npayload_section_name,\n)\nprefix = \"failure_\"\nresponse = self._otcs.get_node_by_volume_and_path(\n142\n)  # write to Personal Workspace of Admin (with Volume Type ID = 142)\ntarget_folder_id = self._otcs.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2004  # use Personal Workspace of Admin as fallback\n# Some sections are actually not payload specific like teamsM365Cleanup\n# and we don't want external payload runs to re-process these:\nif payload_specific:\nfile_name = os.path.basename(self._payload_source)  # remove directories\n# Split once at the first occurance of a dot\n# as the _payload_source may have multiple suffixes\n# such as .yml.gz.b64:\nfile_name = file_name.split(\".\", 1)[0]\nfile_name = prefix + file_name + \"_\" + payload_section_name + \".json\"\nelse:\nfile_name = prefix + payload_section_name + \".json\"\nfull_path = \"/tmp/\" + file_name\nwith open(full_path, mode=\"w\", encoding=\"utf-8\") as localfile:\nlocalfile.write(json.dumps(payload_section, indent=2))\n# Check if the status file has been uploaded before.\n# This can happen if we re-run the python container.\n# In this case we add a version to the existing document:\nresponse = self._otcs.get_node_by_parent_and_name(\nparent_id=int(target_folder_id), name=file_name, show_error=False\n)\ntarget_document_id = self._otcs.get_result_value(response, \"id\")\nif target_document_id:\nresponse = self._otcs.add_document_version(\nnode_id=int(target_document_id),\nfile_url=full_path,\nfile_name=file_name,\nmime_type=\"text/plain\",\ndescription=\"Updated status file after re-run of customization\",\n)\nelse:\nresponse = self._otcs.upload_file_to_parent(\nfile_url=full_path,\nfile_name=file_name,\nmime_type=\"text/plain\",\nparent_id=int(target_folder_id),\n)\nif response:\nlogger.info(\n\"Status file -&gt; %s has been written to Personal Workspace of admin user\",\nfile_name,\n)\nreturn True\nlogger.error(\n\"Failed to write status file -&gt; %s to Personal Workspace of admin user\",\nfile_name,\n)\nreturn False\n# end method definition\ndef get_status_file(\nself, payload_section_name: str, payload_specific: bool = True\n) -&gt; list | None:\n\"\"\"Get the status file and read it into a dictionary.\n        Args:\n            payload_section_name (str): name of the payload section. This\n                                        is used to construct the file name\n            payload_specific (bool): whether or not the success should be specific for\n                                     each payload file or if success is \"global\" - like for the deletion\n                                     of the existing M365 teams (which we don't want to execute per\n                                     payload file)\n        Returns:\n            dict: content of the status file as a dictionary or None in case of an error\n        \"\"\"\nlogger.info(\n\"Get the status file of the payload section -&gt; %s...\",\npayload_section_name,\n)\nresponse = self._otcs.get_node_by_volume_and_path(\n142\n)  # read from Personal Workspace of Admin\nsource_folder_id = self._otcs.get_result_value(response, \"id\")\nif not source_folder_id:\nsource_folder_id = 2004  # use Personal Workspace of Admin as fallback\n# Some sections are actually not payload specific like teamsM365Cleanup\n# we don't want external payload runs to re-apply this processing:\nif payload_specific:\nfile_name = os.path.basename(self._payload_source)  # remove directories\n# Split once at the first occurance of a dot\n# as the _payload_source may have multiple suffixes\n# such as .yml.gz.b64:\nfile_name = file_name.split(\".\", 1)[0]\nfile_name = \"success_\" + file_name + \"_\" + payload_section_name + \".json\"\nelse:\nfile_name = \"success_\" + payload_section_name + \".json\"\nstatus_document = self._otcs.get_node_by_parent_and_name(\nparent_id=int(source_folder_id), name=file_name, show_error=True\n)\nstatus_file_id = self._otcs.get_result_value(status_document, \"id\")\nif not status_file_id:\nlogger.error(\"Cannot find status file -&gt; %s\", file_name)\nreturn None\ncontent = self._otcs.get_document_content(status_file_id)\ntry:\njson_data = json.loads(content.decode(\"utf-8\"))\nif isinstance(json_data, list):\nreturn json_data\nelse:\nlogger.error(\"File content is in JSON format but not a list.\")\nreturn None\nexcept json.JSONDecodeError as e:\nlogger.error(\"File content is not in valid JSON format; error -&gt; %s\", e)\nreturn None\n# end method definition\ndef determine_group_id(self, group: dict) -&gt; int:\n\"\"\"Determine the id of a group - either from payload or from OTCS.\n           If the group is found in OTCS write back the ID into the payload.\n        Args:\n            group (dict): group payload element\n        Returns:\n            int: group ID\n        Side Effects:\n            the group items are modified by adding an \"id\" dict element that\n            includes the technical ID of the group in Extended ECM\n        \"\"\"\n# Is the ID already known in payload? (if determined before)\nif \"id\" in group:\nreturn group[\"id\"]\nif not \"name\" in group:\nlogger.error(\"Group needs a name to lookup the ID.\")\nreturn 0\ngroup_name = group[\"name\"]\nexisting_groups = self._otcs.get_group(name=group_name)\n# We use the lookup method here as get_group() could deliver more\n# then 1 result element (in edge cases):\ngroup_id = self._otcs.lookup_result_value(\nresponse=existing_groups, key=\"name\", value=group_name, return_key=\"id\"\n)\n# Have we found an exact match?\nif group_id:\n# Write ID back into the payload:\ngroup[\"id\"] = group_id\nreturn group[\"id\"]\nelse:\nlogger.info(\"Did not find an existing group with name -&gt; %s\", group_name)\nreturn 0\n# end method definition\ndef determine_user_id(self, user: dict) -&gt; int:\n\"\"\"Determine the id of a user - either from payload or from OTCS\n           If the user is found in OTCS write back the ID into the payload.\n        Args:\n            user (dict): user payload element\n        Returns:\n            int: user ID\n        Side Effects:\n            the user items are modified by adding an \"id\" dict element that\n            includes the technical ID of the user in Extended ECM\n        \"\"\"\n# Is the ID already known in payload? (if determined before)\nif \"id\" in user:\nreturn user[\"id\"]\nif not \"name\" in user:\nlogger.error(\"User needs a login name to lookup the ID.\")\nreturn 0\nuser_name = user[\"name\"]\nresponse = self._otcs.get_user(name=user_name)\n# We use the lookup method here as get_user() could deliver more\n# then 1 result element (in edge cases):\nuser_id = self._otcs.lookup_result_value(\nresponse=response, key=\"name\", value=user_name, return_key=\"id\"\n)\n# Have we found an exact match?\nif user_id:\n# Write ID back into the payload\nuser[\"id\"] = user_id\nreturn user[\"id\"]\nelse:\nlogger.info(\"Did not find an existing user with name -&gt; %s\", user_name)\nreturn 0\n# end method definition\ndef determine_user_id_m365(self, user: dict) -&gt; int:\n\"\"\"Determine the id of a M365 user - either from payload or from M365 via Graph API\n           If the user is found in M365 write back the M365 user ID into the payload.\n        Args:\n            user (dict): user payload element\n        Returns:\n            int: M365 user ID or 0 if the user is not found.\n        Side Effects:\n            the user items are modified by adding an \"m365_id\" dict element that\n            includes the technical ID of the user in Microsoft 365\n        \"\"\"\n# is the payload already updated with the M365 user ID?\nif \"m365_id\" in user:\nreturn user[\"m365_id\"]\nif not \"name\" in user:\nlogger.error(\"User needs a login name to lookup the M365 user ID.\")\nreturn 0\nuser_name = user[\"name\"]\nm365_user_name = user_name + \"@\" + self._m365.config()[\"domain\"]\nexisting_user = self._m365.get_user(m365_user_name)\nif existing_user:\nlogger.info(\n\"Found existing Microsoft 365 user -&gt; %s (%s) with ID -&gt; %s. Update m365_id in payload...\",\nexisting_user[\"displayName\"],\nexisting_user[\"userPrincipalName\"],\nexisting_user[\"id\"],\n)\n# write back the M365 user ID into the payload\nuser[\"m365_id\"] = existing_user[\"id\"]\nreturn user[\"m365_id\"]\nelse:\nlogger.info(\"Did not find an existing M365 user with name -&gt; %s\", user_name)\nreturn 0\n# end method definition\ndef determine_workspace_id(self, workspace: dict) -&gt; int:\n\"\"\"Determine the nodeID of a workspace - either from payload or from OTCS\n        Args:\n            workspace (dict): workspace payload element\n        Returns:\n            int: workspace Node ID\n        Side Effects:\n            the workspace items are modified by adding an \"nodeId\" dict element that\n            includes the node ID of the workspace in Extended ECM\n        \"\"\"\nif \"nodeId\" in workspace:\nreturn workspace[\"nodeId\"]\nresponse = self._otcs.get_workspace_by_type_and_name(\ntype_name=workspace[\"type_name\"], name=workspace[\"name\"]\n)\nworkspace_id = self._otcs.get_result_value(response, \"id\")\nif workspace_id:\n# Write nodeID back into the payload\nworkspace[\"nodeId\"] = workspace_id\nreturn workspace_id\nelse:\nlogger.info(\n\"Workspace of type -&gt; %s and name -&gt; %s does not yet exist.\",\nworkspace[\"type_name\"],\nworkspace[\"name\"],\n)\nreturn 0\n# end method definition\ndef process_payload(self):\n\"\"\"Main method to process a payload file.\n        Args:\n            None\n        Returns:\n            None\n        \"\"\"\nif not self._payload_sections:\nreturn None\nfor payload_section in self._payload_sections:\nmatch payload_section[\"name\"]:\ncase \"webHooks\":\nself._log_header_callback(\"Process Web Hooks\")\nself.process_web_hooks(self._webhooks)\ncase \"webHooksPost\":\nself._log_header_callback(\"Process Web Hooks (post)\")\nself.process_web_hooks(self._webhooks_post, \"webHooksPost\")\ncase \"partitions\":\nself._log_header_callback(\"Process OTDS Partitions\")\nself.process_partitions()\nself._log_header_callback(\"Assign OTCS Licenses to Partitions\")\nself.process_partition_licenses()\ncase \"oauthClients\":\nself._log_header_callback(\"Process OTDS OAuth Clients\")\nself.process_oauth_clients()\ncase \"authHandlers\":\nself._log_header_callback(\"Process OTDS Auth Handlers\")\nself.process_auth_handlers()\ncase \"trustedSites\":\nself._log_header_callback(\"Process OTDS Trusted Sites\")\nself.process_trusted_sites()\ncase \"systemAttributes\":\nself._log_header_callback(\"Process OTDS System Attributes\")\nself.process_system_attributes()\ncase \"groups\":\nself._log_header_callback(\"Process OTCS Groups\")\nself.process_groups()\n# Add all groups with ID the a lookup dict for placeholder replacements\n# in adminSetting. This also updates the payload with group IDs from OTCS\n# if the group already exists in Extended ECM. This is important especially\n# if the customizer pod is restarted / run multiple times:\nself.process_group_placeholders()\nif self._m365 and isinstance(self._m365, M365):\nself._log_header_callback(\"Cleanup existing MS Teams\")\nself.cleanup_all_teams_m365()\nself._log_header_callback(\"Process M365 Groups\")\nself.process_groups_m365()\ncase \"users\":\nself._log_header_callback(\"Process OTCS Users\")\nself.process_users()\n# Add all users with ID the a lookup dict for placeholder replacements\n# in adminSetting. This also updates the payload with user IDs from OTCS\n# if the user already exists in Extended ECM. This is important especially\n# if the cutomizer pod is restarted / run multiple times:\nself.process_user_placeholders()\nself._log_header_callback(\"Assign OTCS Licenses to Users\")\nself.process_user_licenses(\nresource_name=self._otcs.config()[\"resource\"],\nlicense_feature=self._otcs.config()[\"license\"],\nlicense_name=\"EXTENDED_ECM\",\nuser_specific_payload_field=\"licenses\",\n)\nself._log_header_callback(\"Assign OTIV Licenses to Users\")\nif (\nisinstance(self._otiv, OTIV)  # can be None in 24.1 or newer\nand self._otiv.config()\nand self._otiv.config()[\"resource\"]\nand self._otiv.config()[\"license\"]\n):\nself.process_user_licenses(\nresource_name=self._otiv.config()[\"resource\"],\nlicense_feature=self._otiv.config()[\"license\"],\nlicense_name=\"INTELLIGENT_VIEWING\",\nuser_specific_payload_field=\"\",\nsection_name=\"userLicensesViewing\",  # we need a specific name here for OTIV\n)\nelse:\nlogger.info(\"Processing of OTIV licenses is disabled.\")\nself._log_header_callback(\"Process User Settings\")\nself.process_user_settings()\nif self._m365 and isinstance(self._m365, M365):\nself._log_header_callback(\"Process M365 Users\")\nself.process_users_m365()\n# We need to do the MS Teams creation after the creation of\n# the M365 users as we require Group Owners to create teams\nself._log_header_callback(\"Process M365 Teams\")\nself.process_teams_m365()\ncase \"adminSettings\":\nself._log_header_callback(\"Process Administration Settings\")\nrestart_required = self.process_admin_settings(self._admin_settings)\nif restart_required:\nlogger.info(\n\"Admin Settings require a restart of OTCS services...\",\n)\n# Restart OTCS frontend and backend pods:\nself._otcs_restart_callback(self._otcs_backend)\ncase \"adminSettingsPost\":\nself._log_header_callback(\"Process Administration Settings (post)\")\nrestart_required = self.process_admin_settings(\nself._admin_settings_post, \"adminSettingsPost\"\n)\nif restart_required:\nlogger.info(\n\"Admin Settings (Post) require a restart of OTCS services...\",\n)\n# Restart OTCS frontend and backend pods:\nself._otcs_restart_callback(self._otcs_backend)\ncase \"execPodCommands\":\nself._log_header_callback(\"Process Pod Commands\")\nself.process_exec_pod_commands()\ncase \"csApplications\":\nself._log_header_callback(\"Process CS Apps (backend)\")\nself.process_cs_applications(\nself._otcs_backend, section_name=\"csApplicationsBackend\"\n)\nself._log_header_callback(\"Process CS Apps (frontend)\")\nself.process_cs_applications(\nself._otcs_frontend, section_name=\"csApplicationsFrontend\"\n)\ncase \"externalSystems\":\nself._log_header_callback(\"Process External System Connections\")\nself.process_external_systems()\ncase \"transportPackages\":\nself._log_header_callback(\"Process Transport Packages\")\nself.process_transport_packages(self._transport_packages)\n# Right after the transport that create the workspace types\n# we extract them and put them in a generated payload list:\nself._log_header_callback(\"Process Workspace Types\")\nself.process_workspace_types()\nif self._m365 and isinstance(self._m365, M365):\n# Right after the transport that creates the top level folders\n# we can add the M365 Teams apps for Extended ECM as its own tab:\nself._log_header_callback(\"Process M365 Teams apps\")\nself.process_teams_m365_apps()\ncase \"contentTransportPackages\":\nself._log_header_callback(\"Process Content Transport Packages\")\nself.process_transport_packages(\nself._content_transport_packages, \"contentTransportPackages\"\n)\ncase \"transportPackagesPost\":\nself._log_header_callback(\"Process Transport Packages (post)\")\nself.process_transport_packages(\nself._transport_packages_post, \"transportPackagesPost\"\n)\ncase \"workspaceTemplates\":\nself._log_header_callback(\n\"Process Workspace Templates (Template Role Assignments)\"\n)\nself.process_workspace_templates()\ncase \"workspaces\":\nself._log_header_callback(\"Process Workspaces\")\nself.process_workspaces()\nself._log_header_callback(\"Process Workspace Relationships\")\nself.process_workspace_relationships()\nself._log_header_callback(\"Process Workspace Memberships\")\nself.process_workspace_members()\n# This has to run after the processing of webReports that are\n# used to enable Content Aviator in KINI database table:\nif self._aviator_enabled:\nself._log_header_callback(\"Process Workspace Aviators\")\nself.process_workspace_aviators()\ncase \"sapRFCs\":\nself._log_header_callback(\"Process SAP RFCs\")\nsap_external_system = {}\nif self._external_systems:\nsap_external_system = next(\n(\nitem\nfor item in self._external_systems\nif item.get(\"external_system_type\")\nand item[\"external_system_type\"] == \"SAP\"\n),\n{},\n)\nif not sap_external_system:\nlogger.warning(\n\"SAP RFC in payload but SAP external system is configured. RFCs will not be processed.\"\n)\nelif not sap_external_system.get(\"enabled\"):\nlogger.warning(\n\"SAP RFC in payload but SAP external system is disabled. RFCs will not be processed.\"\n)\n# if the external system is not marked reachable we check it once more as this could be fooled\n# by customizer pod restarts\nelif not sap_external_system.get(\n\"reachable\"\n) and not self.check_external_system(sap_external_system):\nlogger.warning(\n\"SAP RFC in payload but SAP external system is not reachable. RFCs will not be processed.\"\n)\nelse:\nsap = self.init_sap(sap_external_system)\nif sap:\nself.process_sap_rfcs(sap)\nself._log_header_callback(\"Process SAP Users\")\nself.process_users_sap(sap)\ncase \"webReports\":\nself._log_header_callback(\"Process Web Reports\")\nself.process_web_reports(self._web_reports)\ncase \"webReportsPost\":\nself._log_header_callback(\"Process Web Reports (post)\")\nself.process_web_reports(self._web_reports_post, \"webReportsPost\")\ncase \"additionalGroupMemberships\":\nself._log_header_callback(\n\"Process additional group members for OTDS\"\n)\nself.process_additional_group_members()\ncase \"additionalAccessRoleMemberships\":\nself._log_header_callback(\n\"Process additional access role members for OTDS\"\n)\nself.process_additional_access_role_members()\ncase \"renamings\":\nself._log_header_callback(\"Process Node Renamings\")\nself.process_renamings()\ncase \"items\":\nself._log_header_callback(\"Process Items\")\nself.process_items(self._items)\ncase \"itemsPost\":\nself._log_header_callback(\"Process Items (post)\")\nself.process_items(self._items_post, \"itemsPost\")\ncase \"permissions\":\nself._log_header_callback(\"Process Permissions\")\nself.process_permissions(self._permissions)\ncase \"permissionsPost\":\nself._log_header_callback(\"Process Permissions (post)\")\nself.process_permissions(self._permissions_post, \"permissionsPost\")\ncase \"assignments\":\nself._log_header_callback(\"Process Assignments\")\nself.process_assignments()\ncase \"securityClearances\":\nself._log_header_callback(\"Process Security Clearances\")\nself.process_security_clearances()\ncase \"supplementalMarkings\":\nself._log_header_callback(\"Process Supplemental Markings\")\nself.process_supplemental_markings()\ncase \"recordsManagementSettings\":\nself._log_header_callback(\"Process Records Management Settings\")\nself.process_records_management_settings()\ncase \"holds\":\nself._log_header_callback(\"Process Records Management Holds\")\nself.process_holds()\ncase \"documentGenerators\":\nself._log_header_callback(\"Process Document Generators\")\nself.process_document_generators()\ncase \"browserAutomations\":\nself._log_header_callback(\"Process Browser Automations\")\nself.process_browser_automations()\ncase _:\nlogger.error(\n\"Illegal payload section name -&gt; %s in payloadSections!\",\npayload_section[\"name\"],\n)\npayload_section_restart = payload_section.get(\"restart\", False)\nif payload_section_restart:\nlogger.info(\n\"Payload section -&gt; %s requests a restart of OTCS services...\",\npayload_section[\"name\"],\n)\n# Restart OTCS frontend and backend pods:\nself._otcs_restart_callback(self._otcs_backend)\nelse:\nlogger.info(\n\"Payload section -&gt; %s does not require a restart of OTCS services\",\npayload_section[\"name\"],\n)\nif self._users:\nself._log_header_callback(\"Process User Profile Photos\")\nself.process_user_photos()\nif self._m365 and isinstance(self._m365, M365):\nself._log_header_callback(\"Process M365 User Profile Photos\")\nself.process_user_photos_m365()\nself._log_header_callback(\"Process User Favorites and Profiles\")\nself.process_user_favorites_and_profiles()\nself._log_header_callback(\"Process User Security\")\nself.process_user_security()\n# end method definition\ndef process_web_hooks(self, webhooks: list, section_name: str = \"webHooks\") -&gt; bool:\n\"\"\"Process Web Hooks in payload and do HTTP requests.\n        Args:\n            webhooks (list): list of web hook payload settings\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not webhooks:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\n# WE LET THIS RUN EACH TIME!\n#        if self.check_status_file(section_name):\n#            return True\nsuccess: bool = True\nfor webhook in webhooks:\nurl = webhook.get(\"url\")\nif not url:\nlogger.info(\"Web Hook does not have a url. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in webhook and not webhook[\"enabled\"]:\nlogger.info(\"Payload for Web Hook -&gt; %s is disabled. Skipping...\", url)\ncontinue\ndescription = webhook.get(\"description\")\nmethod = webhook.get(\"method\", \"POST\")\npayload = webhook.get(\"payload\", {})\nheaders = webhook.get(\"headers\", {})\nif description:\nlogger.info(\"Calling Web Hook -&gt; %s: %s (%s)\", method, url, description)\nelse:\nlogger.info(\"Calling Web Hook -&gt; %s: %s\", method, url)\nresponse = self._http_object.http_request(url, method, payload, headers)\nif not response or not response.ok:\nsuccess = False\nself.write_status_file(success, section_name, webhooks)\nreturn success\n# end method definition\ndef process_partitions(self, section_name: str = \"partitions\") -&gt; bool:\n\"\"\"Process OTDS partitions in payload and create them in OTDS.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections). This\n                                          name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._partitions:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor partition in self._partitions:\npartition_name = partition.get(\"name\")\nif not partition_name:\nlogger.error(\"Partition does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in partition and not partition[\"enabled\"]:\nlogger.info(\n\"Payload for Partition -&gt; %s is disabled. Skipping...\",\npartition_name,\n)\ncontinue\npartition_description = partition.get(\"description\")\n# Check if Partition does already exist\n# (in an attempt to make the code idem-potent)\nlogger.info(\n\"Check if OTDS partition -&gt; %s does already exist...\", partition_name\n)\nresponse = self._otds.get_partition(partition_name, show_error=False)\nif response:\nlogger.info(\n\"Partition -&gt; %s does already exist. Skipping...\", partition_name\n)\ncontinue\n# Only continue if Partition does not exist already\nlogger.info(\"Partition -&gt; %s does not exist. Creating...\", partition_name)\nresponse = self._otds.add_partition(partition_name, partition_description)\nif response:\nlogger.info(\"Added OTDS partition -&gt; %s\", partition_name)\nelse:\nlogger.error(\"Failed to add OTDS partition -&gt; %s\", partition_name)\nsuccess = False\ncontinue\naccess_role = partition.get(\"access_role\")\nif access_role:\nresponse = self._otds.add_partition_to_access_role(\naccess_role, partition_name\n)\nif response:\nlogger.info(\n\"Added OTDS partition -&gt; %s to access role -&gt; %s\",\npartition_name,\naccess_role,\n)\nelse:\nlogger.error(\n\"Failed to add OTDS partition -&gt; %s to access role -&gt; %s\",\npartition_name,\naccess_role,\n)\nsuccess = False\ncontinue\n# Partions may have an optional list of licenses in\n# the payload. Assign the partition to all these licenses:\npartition_specific_licenses = partition.get(\"licenses\")\nif partition_specific_licenses:\n# We assume these licenses are Extended ECM licenses!\notcs_resource_name = self._otcs.config()[\"resource\"]\notcs_resource = self._otds.get_resource(otcs_resource_name)\nif not otcs_resource:\nlogger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\nsuccess = False\ncontinue\notcs_resource_id = otcs_resource[\"resourceID\"]\nlicense_name = \"EXTENDED_ECM\"\nfor license_feature in partition_specific_licenses:\nassigned_license = self._otds.assign_partition_to_license(\npartition_name,\notcs_resource_id,\nlicense_feature,\nlicense_name,\n)\nif not assigned_license:\nlogger.error(\n\"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nself.write_status_file(success, section_name, self._partitions)\nreturn success\n# end method definition\ndef process_partition_licenses(\nself, section_name: str = \"partitionLicenses\"\n) -&gt; bool:\n\"\"\"Process the licenses that should be assigned to OTDS partitions\n           (this includes existing partitions).\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._partitions:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor partition in self._partitions:\npartition_name = partition.get(\"name\")\nif not partition_name:\nlogger.error(\"Partition does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in partition and not partition[\"enabled\"]:\nlogger.info(\n\"Payload for Partition -&gt; %s is disabled. Skipping...\",\npartition_name,\n)\ncontinue\nresponse = self._otds.get_partition(partition_name, show_error=True)\nif not response:\nlogger.error(\n\"Partition -&gt; %s does not exist. Skipping...\", partition_name\n)\nsuccess = False\ncontinue\n# Partions may have an optional list of licenses in\n# the payload. Assign the partition to all these licenses:\npartition_specific_licenses = partition.get(\"licenses\")\nif partition_specific_licenses:\n# We assume these licenses are Extended ECM licenses!\notcs_resource_name = self._otcs.config()[\"resource\"]\notcs_resource = self._otds.get_resource(otcs_resource_name)\nif not otcs_resource:\nlogger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\nsuccess = False\ncontinue\notcs_resource_id = otcs_resource[\"resourceID\"]\nlicense_name = \"EXTENDED_ECM\"\nfor license_feature in partition_specific_licenses:\nif self._otds.is_partition_licensed(\npartition_name=partition_name,\nresource_id=otcs_resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n):\nlogger.info(\n\"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\npartition_name,\nlicense_name,\nlicense_feature,\n)\ncontinue\nassigned_license = self._otds.assign_partition_to_license(\npartition_name,\notcs_resource_id,\nlicense_feature,\nlicense_name,\n)\nif not assigned_license:\nlogger.error(\n\"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nself.write_status_file(success, section_name, self._partitions)\nreturn success\n# end method definition\ndef process_oauth_clients(self, section_name: str = \"oauthClients\") -&gt; bool:\n\"\"\"Process OTDS OAuth clients in payload and create them in OTDS.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._oauth_clients:\nlogger.info(\"Payload section -&gt; % is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor oauth_client in self._oauth_clients:\nclient_name = oauth_client.get(\"name\")\nif not client_name:\nlogger.error(\"OAuth client does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in oauth_client and not oauth_client[\"enabled\"]:\nlogger.info(\n\"Payload for OAuthClient -&gt; %s is disabled. Skipping...\",\nclient_name,\n)\ncontinue\nclient_description = oauth_client.get(\"description\")\nclient_confidential = oauth_client.get(\"confidential\")\nclient_partition = oauth_client.get(\"partition\")\nif client_partition == \"Global\":\nclient_partition = []\nclient_redirect_urls = oauth_client.get(\"redirect_urls\")\nclient_permission_scopes = oauth_client.get(\"permission_scopes\")\nclient_default_scopes = oauth_client.get(\"default_scopes\")\nclient_allow_impersonation = oauth_client.get(\"allow_impersonation\")\nclient_secret = oauth_client.get(\"secret\", \"\")\n# Check if OAuth client does already exist\n# (in an attempt to make the code idem-potent)\nlogger.info(\n\"Check if OTDS OAuth Client -&gt; %s does already exist...\", client_name\n)\nresponse = self._otds.get_oauth_client(client_name, show_error=False)\nif response:\nlogger.info(\n\"OAuth Client -&gt; %s does already exist. Skipping...\", client_name\n)\ncontinue\nelse:\nlogger.info(\n\"OAuth Client -&gt; %s does not exist. Creating...\", client_name\n)\nresponse = self._otds.add_oauth_client(\nclient_id=client_name,\ndescription=client_description,\nredirect_urls=client_redirect_urls,\nallow_impersonation=client_allow_impersonation,\nconfidential=client_confidential,\nauth_scopes=client_partition,\nallowed_scopes=client_permission_scopes,\ndefault_scopes=client_default_scopes,\nsecret=client_secret,\n)\nif response:\nlogger.info(\"Added OTDS OAuth client -&gt; %s\", client_name)\nelse:\nlogger.error(\"Failed to add OTDS OAuth client -&gt; %s\", client_name)\nsuccess = False\ncontinue\n# in case the secret has not been provided in the payload we retrieve\n# the automatically created secret:\nclient_secret = response.get(\"secret\")\nif not client_secret:\nlogger.error(\"OAuth client -&gt; %s does not have a secret!\", client_name)\ncontinue\nclient_description += \" Client Secret: \" + str(client_secret)\nresponse = self._otds.update_oauth_client(\nclient_name, {\"description\": client_description}\n)\n# Write the secret back into the payload\noauth_client[\"secret\"] = client_secret\nself.write_status_file(success, section_name, self._oauth_clients)\nreturn success\n#        self._otds.add_oauth_clients_to_access_role()\n# end method definition\ndef process_auth_handlers(self, section_name: str = \"authHandlers\") -&gt; bool:\n\"\"\"Process OTDS authorization handlers in payload and create them in OTDS.\n           An authorization handler defined the connection to an Identity Provider (IdP).\n            The payload section is a list of dicts with these items:\n            {\n                enabled: True or False to enable or disable the payload item\n                name: Name of the authorization handler. This is shown in the first\n                      column of the Auth Handler list in OTDS.\n                description: Description of the handler. This is shown in the second\n                             column of the Auth Handler\n                type: type of the handler. Possible values are SALM, SAP, OAUTH\n                priority: a numeric value to order different handlers in OTDS by priority\n                active_by_default: Whether to activate this handler for any request to the\n                                   OTDS login page. If True, any login request to the OTDS\n                                   login page will be redirected to the IdP. If false, the\n                                   user has to select the provider on the login page.\n                provider_name: The name of the identity provider. This should be a single word\n                               since it will be part of the metadata URL. This is what is\n                               shown as a button on the OTDS login page.\n                auth_principal_attributes: Authentication principal attributes (list)\n                nameid_format: Specifies which NameID format supported by the identity provider\n                               contains the desired user identifier. The value in this identifier\n                               must correspond to the value of the user attribute specified for the\n                               authentication principal attribute.\n                saml_url: Required for SAML Authentication Handler. The URL for the IdP's federation metadata.\n                otds_sp_endpoint: Used for SAML Authentication Handler. Specifies the service provider URL that will\n                                  be used to identify OTDS to the identity provider.\n                certificate_file: Required for SAP Authentication Handler (SAPSSOEXT).\n                                  Fully qualified file name (with path) to the certificate file (URI)\n                certificate_password: Required for SAP Authentication Handler (SAPSSOEXT).\n                                      Password of the certificate file.\n                client_id: Client ID. Required for OAUTH authentication handler.\n                client_secret: Client Secret. Required for OAUTH authentication handler.\n                authorization_endpoint: Required for OAUTH authentication handler.\n                                        The URL to redirect the browser to for authentication.\n                                        It is used to retrieve the authorization code or an OIDC id_token.\n                token_endpoint: Used for OAUTH authentication handler. The URL from which to retrieve the access token.\n                                Not strictly required with OpenID Connect if using the implicit flow.\n                scope_string: Used for OAUTH authentication handler. Space delimited scope values to send.\n                              Include 'openid' to use OpenID Connect.\n            }\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._auth_handlers:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor auth_handler in self._auth_handlers:\nhandler_name = auth_handler.get(\"name\")\nif not handler_name:\nlogger.error(\"Auth handler does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if Auth Handler does already exist (e.g. after a restart of\n# the customizer pod):\nif self._otds.get_auth_handler(handler_name, show_error=False):\nlogger.info(\"Auth handler -&gt; %s does already exist. Skipping...\")\ncontinue\nhandler_description = auth_handler.get(\"description\")\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in auth_handler and not auth_handler[\"enabled\"]:\nlogger.info(\n\"Payload for OTDS Authorization Handler -&gt; %s is disabled. Skipping...\",\nhandler_name,\n)\ncontinue\nhandler_scope = auth_handler.get(\"scope\")\nif not handler_scope:\n# Make sure to pass None also if scope is empty string\nhandler_scope = None\nhandler_type = auth_handler.get(\"type\")\nif not handler_type:\nlogger.error(\n\"OTDS Authorization handler does not have a type. Skipping...\"\n)\nsuccess = False\ncontinue\npriority = auth_handler.get(\"priority\")\nactive_by_default = auth_handler.get(\"active_by_default\")\nif not active_by_default:\nactive_by_default = False\nmatch handler_type:\ncase \"SAML\":\nprovider_name = auth_handler.get(\"provider_name\")\nif not provider_name:\nlogger.error(\n\"SAML Authorization handler needs a provider. Skipping...\"\n)\nsuccess = False\ncontinue\nsaml_url = auth_handler.get(\"saml_url\")\nif not saml_url:\nlogger.error(\n\"SAML Authorization handler needs a SAML URL. Skipping...\"\n)\nsuccess = False\ncontinue\notds_sp_endpoint = auth_handler.get(\"otds_sp_endpoint\")\nif not otds_sp_endpoint:\nlogger.error(\n\"SAML Authorization handler needs a OTDS SP Endpoint. Skipping...\"\n)\nsuccess = False\ncontinue\nauth_principal_attributes = auth_handler.get(\n\"auth_principal_attributes\"\n)\nnameid_format = auth_handler.get(\"nameid_format\")\nresponse = self._otds.add_auth_handler_saml(\nname=handler_name,\ndescription=handler_description,\nscope=handler_scope,\nprovider_name=provider_name,\nsaml_url=saml_url,\notds_sp_endpoint=otds_sp_endpoint,\npriority=priority,\nactive_by_default=active_by_default,\nauth_principal_attributes=auth_principal_attributes,\nnameid_format=nameid_format,\n)\ncase \"SAP\":\ncertificate_file = auth_handler.get(\"certificate_file\")\nif not certificate_file:\nlogger.error(\n\"SAP Authorization handler -&gt; %s (%s) requires a certificate file name. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\ncertificate_password = auth_handler.get(\"certificate_password\")\nif not certificate_password:\n# This is not an error - we canhave this key with empty string!\nlogger.info(\n\"SAP Authorization handler -&gt; %s (%s) does not have a certificate password - this can be OK.\",\nhandler_name,\nhandler_type,\n)\nresponse = self._otds.add_auth_handler_sap(\nname=handler_name,\ndescription=handler_description,\nscope=handler_scope,\ncertificate_file=certificate_file,\ncertificate_password=certificate_password,\npriority=priority,\n)\ncase \"OAUTH\":\nprovider_name = auth_handler.get(\"provider_name\")\nif not provider_name:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a provider name. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\nclient_id = auth_handler.get(\"client_id\")\nif not client_id:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a client ID. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\nclient_secret = auth_handler.get(\"client_secret\")\nif not client_secret:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a client secret. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\nauthorization_endpoint = auth_handler.get(\"authorization_endpoint\")\nif not authorization_endpoint:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a authorization endpoint. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\ntoken_endpoint = auth_handler.get(\"token_endpoint\")\nif not token_endpoint:\nlogger.warning(\n\"OAUTH Authorization handler -&gt; %s (%s) does not have a token endpoint.\",\nhandler_name,\nhandler_type,\n)\nscope_string = auth_handler.get(\"scope_string\")\nresponse = self._otds.add_auth_handler_oauth(\nname=handler_name,\ndescription=handler_description,\nscope=handler_scope,\nprovider_name=provider_name,\nclient_id=client_id,\nclient_secret=client_secret,\npriority=priority,\nactive_by_default=active_by_default,\nauthorization_endpoint=authorization_endpoint,\ntoken_endpoint=token_endpoint,\nscope_string=scope_string,\n)\ncase _:\nlogger.error(\n\"Unsupported authorization handler type -&gt; %s\", handler_type\n)\nreturn False\nif response:\nlogger.info(\n\"Successfully added OTDS authorization handler -&gt; %s (%s)\",\nhandler_name,\nhandler_type,\n)\nelse:\nlogger.error(\n\"Failed to add OTDS authorization handler -&gt; %s (%s)\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._auth_handlers)\nreturn success\n# end method definition\ndef process_trusted_sites(self, section_name: str = \"trustedSites\") -&gt; bool:\n\"\"\"Process OTDS trusted sites in payload and create them in OTDS.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._trusted_sites:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor trusted_site in self._trusted_sites:\n# old payload may still have trusted sites as list of string\n# we changed also the trusted sites to dict with 23.3\n# We want to be backwards compatible so we handle both cases:\nif isinstance(trusted_site, dict):\nurl = trusted_site.get(\"url\")\nelif isinstance(trusted_site, str):\nurl = trusted_site\nif not url:\nlogger.error(\"OTDS Trusted site does not have a URL. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif (\nisinstance(trusted_site, dict)\nand \"enabled\" in trusted_site\nand not trusted_site[\"enabled\"]\n):\nlogger.info(\n\"Payload for OTDS Trusted Site -&gt; %s is disabled. Skipping...\",\nurl,\n)\ncontinue\nresponse = self._otds.add_trusted_site(url)\nif response:\nlogger.info(\"Added OTDS trusted site -&gt; %s\", trusted_site)\nelse:\nlogger.error(\"Failed to add trusted site -&gt; %s\", trusted_site)\nsuccess = False\nself.write_status_file(success, section_name, self._trusted_sites)\nreturn success\n# end method definition\ndef process_system_attributes(self, section_name: str = \"systemAttributes\") -&gt; bool:\n\"\"\"Process OTDS system attributes in payload and create them in OTDS.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._system_attributes:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor system_attribute in self._system_attributes:\n# Check if there's a matching formal parameter defined on the Web Report node:\nif not system_attribute.get(\"name\"):\nlogger.error(\"OTDS System Attribute needs a name. Skipping...\")\nsuccess = False\ncontinue\nattribute_name = system_attribute[\"name\"]\nif \"enabled\" in system_attribute and not system_attribute[\"enabled\"]:\nlogger.info(\n\"Payload for OTDS System Attribute -&gt; %s is disabled. Skipping...\",\nattribute_name,\n)\ncontinue\nif not system_attribute.get(\"value\"):\nlogger.error(\"OTDS System Attribute needs a value. Skipping...\")\ncontinue\nattribute_value = system_attribute[\"value\"]\nattribute_description = system_attribute.get(\"description\")\nresponse = self._otds.add_system_attribute(\nattribute_name, attribute_value, attribute_description\n)\nif response:\nlogger.info(\n\"Added OTDS system attribute -&gt; %s with value -&gt; %s\",\nattribute_name,\nattribute_value,\n)\nelse:\nlogger.error(\n\"Failed to add OTDS system attribute -&gt; %s with value -&gt; %s\",\nattribute_name,\nattribute_value,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._system_attributes)\nreturn success\n# end method definition\ndef process_group_placeholders(self):\n\"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n        with the actual ID of the Extended ECM group. For this we prepare a lookup dict.\n        The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n        OTDS resource IDs (see main.py)\n        \"\"\"\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\n\"Group needs a name for placeholder definition. Skipping...\"\n)\ncontinue\ngroup_name = group[\"name\"]\n# Check if group has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\n# Now we determine the ID. Either it is in the payload section from\n# the current customizer run or we try to look it up in the system.\n# The latter case may happen if the customizer pod got restarted.\ngroup_id = self.determine_group_id(group)\nif not group_id:\nlogger.warning(\n\"Group needs an ID for placeholder definition. Skipping...\"\n)\ncontinue\n# Add Group with its ID to the dict self._placeholder_values:\nself._placeholder_values[\n\"OTCS_GROUP_ID_\"\n+ group_name.upper().replace(\" &amp; \", \"_\").replace(\" \", \"_\")\n] = str(group_id)\nlogger.debug(\n\"Placeholder values after group processing = %s\", self._placeholder_values\n)\n# end method definition\ndef process_user_placeholders(self):\n\"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n        with the actual ID of the Extended ECM user. For this we prepare a lookup dict.\n        The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n        OTDS resource IDs (see customizer.py)\n        \"\"\"\nfor user in self._users:\nif not \"name\" in user:\nlogger.error(\n\"User needs a name for placeholder definition. Skipping...\"\n)\ncontinue\nuser_name = user[\"name\"]\n# Check if user has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Now we determine the ID. Either it is in the payload section from\n# the current customizer run or we try to look it up in the system.\n# The latter case may happen if the customizer pod got restarted.\nuser_id = self.determine_user_id(user)\nif not user_id:\nlogger.warning(\n\"User needs an ID for placeholder definition. Skipping...\"\n)\ncontinue\n# Add user with its ID to the dict self._placeholder_values:\nself._placeholder_values[\"OTCS_USER_ID_%s\", user_name.upper()] = str(\nuser_id\n)\nlogger.debug(\n\"Placeholder values after user processing = %s\", self._placeholder_values\n)\n# end method definition\ndef process_groups(self, section_name: str = \"groups\") -&gt; bool:\n\"\"\"Process groups in payload and create them in Extended ECM.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            the group items are modified by adding an \"id\" dict element that\n            includes the technical ID of the group in Extended ECM\n        \"\"\"\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# First run through groups: create all groups in payload\n# and store the IDs of the created groups:\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Group needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\n# Check if the group does already exist (e.g. if job is restarted)\n# as this is a pattern search it could return multiple groups:\ngroup_id = self.determine_group_id(group)\nif group_id:\nlogger.info(\n\"Found existing group -&gt; %s (%s). Skipping to next group...\",\ngroup_name,\ngroup_id,\n)\ncontinue\nlogger.info(\"Did not find an existing group - creating a new group...\")\n# Now we know it is a new group...\nnew_group = self._otcs.add_group(group_name)\nif new_group:\nnew_group_id = self._otcs.get_result_value(new_group, \"id\")\nlogger.debug(\"New group -&gt; %s\", new_group)\ngroup[\"id\"] = new_group_id\nelse:\nlogger.error(\"Failed to create group -&gt; %s\", group_name)\nsuccess = False\ncontinue\nlogger.debug(\"Groups = %s\", self._groups)\n# Second run through groups: create all group memberships\n# (nested groups) based on the IDs created in first run:\nfor group in self._groups:\nif not \"id\" in group:\nlogger.error(\"Group -&gt; %s does not have an ID.\", group[\"name\"])\nsuccess = False\ncontinue\nparent_group_names = group[\"parent_groups\"]\nfor parent_group_name in parent_group_names:\n# First, try to find parent group in payload by parent group name:\nparent_group = next(\n(\nitem\nfor item in self._groups\nif item[\"name\"] == parent_group_name\n),\nNone,\n)\nif parent_group is None:\n# If this didn't work, try to get the parent group from OTCS. This covers\n# cases where the parent group is system generated or part\n# of a former payload processing run:\nparent_group = self._otcs.get_group(parent_group_name)\nparent_group_id = self._otcs.get_result_value(parent_group, \"id\")\nif not parent_group_id:\nlogger.error(\n\"Parent Group -&gt; %s not found. Skipping...\",\nparent_group_name,\n)\nsuccess = False\ncontinue\nelif not \"id\" in parent_group:\nlogger.error(\n\"Parent Group -&gt; %s does not have an ID. Cannot establish group nesting. Skipping...\",\nparent_group[\"name\"],\n)\nsuccess = False\ncontinue\nelse:  # we can read the ID from the\nparent_group_id = parent_group[\"id\"]\n# retrieve all members of the parent group (1 = get only groups)\n# to check if the current group is already a member in the parent group:\nmembers = self._otcs.get_group_members(parent_group_id, 1)\nif self._otcs.exist_result_item(members, \"id\", group[\"id\"]):\nlogger.info(\n\"Group -&gt; %s (%s) is already a member of parent group -&gt; %s (%s). Skipping to next parent group...\",\ngroup[\"name\"],\ngroup[\"id\"],\nparent_group_name,\nparent_group_id,\n)\nelse:\nlogger.info(\n\"Add group -&gt; %s (%s) to parent group -&gt; %s (%s)\",\ngroup[\"name\"],\ngroup[\"id\"],\nparent_group_name,\nparent_group_id,\n)\nself._otcs.add_group_member(group[\"id\"], parent_group_id)\nself.write_status_file(success, section_name, self._groups)\nreturn success\n# end method definition\ndef process_groups_m365(self, section_name: str = \"groupsM365\") -&gt; bool:\n\"\"\"Process groups in payload and create them in Microsoft 365.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section %s...\",\nsection_name,\n)\nreturn False\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# First run through groups: create all groups in payload\n# and store the IDs of the created groups:\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Group needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\nif not \"enable_o365\" in group or not group[\"enable_o365\"]:\nlogger.info(\n\"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\ngroup_name,\n)\ncontinue\n# Check if the group does already exist (e.g. if job is restarted)\n# as this is a pattern search it could return multiple groups:\nexisting_groups = self._m365.get_group(group_name)\nif existing_groups and existing_groups[\"value\"]:\nlogger.debug(\n\"Found existing Microsoft 365 groups -&gt; %s\",\nexisting_groups[\"value\"],\n)\n# Get list of all matching groups:\nexisting_groups_list = existing_groups[\"value\"]\n# Find the group with the exact match of the name:\nexisting_group = next(\n(\nitem\nfor item in existing_groups_list\nif item[\"displayName\"] == group_name\n),\nNone,\n)\n# Have we found an exact match?\nif existing_group is not None:\nlogger.info(\n\"Found existing Microsoft 365 group -&gt; %s (%s) - skip creation of group...\",\nexisting_group[\"displayName\"],\nexisting_group[\"id\"],\n)\n# Write M365 group ID back into the payload (for the success file)\ngroup[\"m365_id\"] = existing_group[\"id\"]\ncontinue\nlogger.info(\n\"Did not find an exact match for the group - creating a new Microsoft 365 group...\"\n)\nelse:\nlogger.info(\n\"Did not find any matching group - creating a new Microsoft 365 group...\"\n)\n# Now we know it is a new group...\nnew_group = self._m365.add_group(group_name)\nif new_group is not None:\n# Store the Microsoft 365 group ID in payload:\ngroup[\"m365_id\"] = new_group[\"id\"]\nlogger.info(\n\"New Microsoft 365 group -&gt; %s with ID -&gt; %s has been created\",\ngroup_name,\ngroup[\"m365_id\"],\n)\nelse:\nsuccess = False\nself.write_status_file(success, section_name, self._groups)\nreturn success\n# end method definition\ndef process_users(self, section_name: str = \"users\") -&gt; bool:\n\"\"\"Process users in payload and create them in Extended ECM.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            the user items are modified by adding an \"id\" dict element that\n            includes the technical ID of the user in Extended ECM\n        \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\n#        if self.check_status_file(section_name):\n#            return True\nsuccess: bool = True\n# Add all users in payload and establish membership in\n# specified groups:\nfor user in self._users:\n# Sanity checks:\nif not \"name\" in user:\nlogger.error(\"User is missing a login. Skipping to next user...\")\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Sanity checks:\nif (\nnot \"password\" in user\nor user[\"password\"] is None\nor user[\"password\"] == \"\"\n):\nlogger.info(\n\"User -&gt; %s no password defined in payload, generating random password...\",\nuser_name,\n)\nuser[\"password\"] = self.generate_password(\nlength=10, use_special_chars=True\n)\ndescription_attribue = {\n\"name\": \"description\",\n\"value\": \"initial password: \" + user[\"password\"],\n}\ntry:\nuser[\"extra_attributes\"].append(description_attribue)\nexcept KeyError:\nuser[\"extra_attributes\"] = [description_attribue]\n# Sanity checks:\nif not \"base_group\" in user:\nlogger.warning(\n\"User -&gt; %s is missing a base group - setting to default group\",\nuser_name,\n)\nuser[\"base_group\"] = \"DefaultGroup\"\n# Check if the user does already exist (e.g. if job is restarted)\n# determine_user_id() also writes back the user ID into the payload\n# if it has gathered it from OTCS.\nuser_id = self.determine_user_id(user)\nif user_id:\nlogger.info(\n\"Found existing user -&gt; %s (%s). Skipping to next user...\",\nuser_name,\nuser_id,\n)\ncontinue\nlogger.info(\"Did not find an existing user - creating a new user...\")\n# Find the base group of the user. Assume 'Default Group' (= 1001) if not found:\nbase_group = next(\n(\nitem[\"id\"]\nfor item in self._groups\nif item[\"name\"] == user[\"base_group\"] and item.get(\"id\")\n),\n1001,\n)\n# Now we know it is a new user...\nnew_user = self._otcs.add_user(\nname=user_name,\npassword=user[\"password\"],\nfirst_name=user.get(\"firstname\", \"\"),  # be careful - can be empty\nlast_name=user.get(\"lastname\", \"\"),  # be careful - can be empty\nemail=user.get(\"email\", \"\"),  # be careful - can be empty\nbase_group=base_group,\nprivileges=user.get(\"privileges\", [\"Login\", \"Public Access\"]),\n)\n# Process group memberships of new user:\nif new_user is not None:\nnew_user_id = self._otcs.get_result_value(new_user, \"id\")\nlogger.info(\n\"New user -&gt; %s with ID -&gt; %s has been created\",\nuser_name,\nnew_user_id,\n)\n# Write back user ID into payload\nuser[\"id\"] = new_user_id\nuser_groups = user[\"groups\"]  # list of groups the user is in\nfor user_group in user_groups:\n# Try to find the group dictionary item in the payload\n# for user group name:\ngroup = next(\n(item for item in self._groups if item[\"name\"] == user_group),\nNone,\n)\nif group:\ngroup_id = group.get(\"id\")  # Careful ID may not exist\ngroup_name = group[\"name\"]\nelse:\n# if group is not in payload try to find group in OTCS\n# in case it is a pre-existing group:\ngroup = self._otcs.get_group(user_group)\ngroup_id = self._otcs.get_result_value(group, \"id\")\nif group_id is None:\nlogger.error(\n\"Group -&gt; %s not found. Skipping...\", user_group\n)\nsuccess = False\ncontinue\ngroup_name = self._otcs.get_result_value(group, \"name\")\nif group_id is None:\nlogger.error(\n\"Group -&gt; %s does not have an ID. Cannot add user -&gt; %s to this group. Skipping...\",\ngroup_name,\nuser[\"name\"],\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Add user -&gt; %s (%s) to group -&gt; %s (%s)\",\nuser[\"name\"],\nuser[\"id\"],\ngroup_name,\ngroup_id,\n)\nresponse = self._otcs.add_group_member(user[\"id\"], group_id)\nif not response:\nsuccess = False\n# for some unclear reason the user is not added to its base group in OTDS\n# so we do this explicitly:\nresponse = self._otds.add_user_to_group(\nuser[\"name\"], user[\"base_group\"]\n)\nif not response:\nsuccess = False\n# Extra OTDS attributes for the user can be provided in \"extra_attributes\"\n# as part of the user payload.\nif \"extra_attributes\" in user:\nextra_attributes = user[\"extra_attributes\"]\nfor extra_attribute in extra_attributes:\nattribute_name = extra_attribute.get(\"name\")\nattribute_value = extra_attribute.get(\"value\")\nif not attribute_name or not attribute_value:\nlogger.error(\n\"User attribute is missing a name or value. Skipping...\"\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Set user attribute -&gt; %s to -&gt; %s\",\nattribute_name,\nattribute_value,\n)\nuser_partition = self._otcs.config()[\"partition\"]\nif not user_partition:\nlogger.error(\"User partition not found!\")\nsuccess = False\ncontinue\nself._otds.update_user(\nuser_partition,\nuser[\"name\"],\nattribute_name,\nattribute_value,\n)\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_users_sap(\nself, sap_object: SAP, section_name: str = \"usersSAP\"\n) -&gt; bool:\n\"\"\"Process users in payload and sync them with SAP (passwords for now).\n        Args:\n            sap_object (SAP): SAP object\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            the user items are modified by adding an \"id\" dict element that\n            includes the technical ID of the user in Extended ECM\n        \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nrfc_name = \"ZFM_TERRA_RFC_CHNG_USR_PW\"\nrfc_description = \"RFC to update the SAP user password\"\nrfc_call_options = ()\n# Add all users in payload and establish membership in\n# specified groups:\nfor user in self._users:\n# Sanity checks:\nif not \"name\" in user:\nlogger.error(\"User is missing a login. Skipping to next user...\")\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Check if the user is enabled for SAP:\nif not \"enable_sap\" in user or not user[\"enable_sap\"]:\nlogger.info(\"User -&gt; %s is not enabled for SAP. Skipping...\", user_name)\ncontinue\n# Sanity checks:\nif not \"password\" in user:\nlogger.error(\n\"User -&gt; %s is missing a password. Cannot sync with SAP. Skipping to next user...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser_password = user[\"password\"]\nrfc_params = {\n\"USERNAME\": user_name,\n\"PASSWORD\": user_password,\n}\nlogger.info(\n\"Updating password of user -&gt; %s in SAP. Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\nuser_name,\nrfc_name,\nrfc_description,\nrfc_params,\n)\nresult = sap_object.call(rfc_name, rfc_call_options, rfc_params)\nif result is None:\nlogger.error(\n\"Failed to call SAP RFC -&gt; %s to update password of user -&gt; %s\",\nrfc_name,\nuser_name,\n)\nsuccess = False\nelif result.get(\"RESULT\") != \"OK\":\nlogger.error(\n\"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\nrfc_name,\nstr(result.get(\"FAILED\")),\nstr(result),\n)\nsuccess = False\n# Save result for status file content\nuser[\"sap_sync_result\"] = result\nelse:\nlogger.info(\n\"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n)\n# Save result for status file content\nuser[\"sap_sync_result\"] = result\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_users_m365(self, section_name: str = \"usersM365\") -&gt; bool:\n\"\"\"Process users in payload and create them in Microsoft 365 via MS Graph API.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# Add all users in payload and establish membership in\n# specified groups:\nfor user in self._users:\n# Sanity checks:\nif not \"name\" in user:\nlogger.error(\"User is missing a login. Skipping to next user...\")\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif not \"enable_o365\" in user or not user[\"enable_o365\"]:\nlogger.info(\n\"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\nuser_name,\n)\ncontinue\n# Sanity checks:\nif not \"password\" in user:\nlogger.error(\n\"User -&gt; %s is missing a password. Skipping to next user...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser_password = user[\"password\"]\n# be careful with the following fields - they could be empty\nuser_department = user.get(\"base_group\", \"\")\nuser_first_name = user.get(\"firstname\", \"\")\nuser_last_name = user.get(\"lastname\", \"\")\nuser_location = user.get(\"location\", \"US\")\nuser_email = user.get(\"email\", user_name)\n# Check if the user does already exist in M365 (e.g. if job is restarted)\nm365_user_id = self.determine_user_id_m365(user)\nif not m365_user_id:\nlogger.info(\n\"Did not find existing Micosoft 365 user - creating user %s...\",\nuser_email,\n)\n# Now we know it is a new user...\nnew_user = self._m365.add_user(\nemail=user_email,\npassword=user_password,\nfirst_name=user_first_name,\nlast_name=user_last_name,\nlocation=user_location,\ndepartment=user_department,\n)\nif new_user is not None:\n# Store the Microsoft 365 user ID in payload:\nuser[\"m365_id\"] = new_user[\"id\"]\nlogger.info(\n\"New Microsoft 365 user -&gt; %s with ID -&gt; %s has been created\",\nuser_name,\nuser[\"m365_id\"],\n)\nelse:\nlogger.error(\n\"Failed to create new Microsoft 365 user -&gt; %s. Skipping...\",\nuser_name,\n)\nsuccess = False\ncontinue\n# Now we assign a license to the new M365 user.\n# First we see if there's a M365 SKU list in user\n# payload - if not we wrap the default SKU configured\n# for the m365 object into a single item list:\nexisting_user_licenses = self._m365.get_user_licenses(user[\"m365_id\"])\nsku_list = user.get(\"m365_skus\", [self._m365.config()[\"skuId\"]])\nfor sku_id in sku_list:\n# Check if the M365 user already has this license:\nif not self._m365.exist_result_item(\nexisting_user_licenses, \"skuId\", sku_id\n):\nresponse = self._m365.assign_license_to_user(\nuser[\"m365_id\"], sku_id\n)\nif not response:\nlogger.error(\n\"Failed to assign license -&gt; %s to Microsoft 365 user -&gt; %s\",\nsku_id,\nuser_name,\n)\nsuccess = False\nelse:\nif (\nnot \"m365_skus\" in user\n):  # this is only True if the default license from the m365 object is taken\nuser[\"m365_skus\"] = [sku_id]\nlogger.info(\n\"License -&gt; %s has been assigned to Microsoft 365 user -&gt; %s\",\nsku_id,\nuser_name,\n)\nelse:\nlogger.info(\n\"Microsoft 365 user -&gt; %s already has the license -&gt; %s\",\nuser_name,\nsku_id,\n)\n# Now we assign the Extended ECM Teams App to the new M365 user.\n# First we check if the app is already assigned to the user.\n# If not we install / assign the app. If the user already has\n# the Extended ECM app we try to uprade it:\napp_name = self._m365.config()[\"teamsAppName\"]\nresponse = self._m365.get_teams_apps_of_user(\nuser[\"m365_id\"],\nf\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n)\nif self._m365.exist_result_item(\nresponse, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n):\nlogger.info(\n\"App -&gt; %s is already installed for M365 user -&gt; %s (%s). Trying to upgrade app...\",\napp_name,\nuser_name,\nuser[\"m365_id\"],\n)\nresponse = self._m365.upgrade_teams_app_of_user(\nuser[\"m365_id\"], app_name\n)\nelse:\nlogger.info(\n\"Install M365 Teams app -&gt; %s for M365 user -&gt; %s\",\napp_name,\nuser_name,\n)\nresponse = self._m365.assign_teams_app_to_user(\nuser[\"m365_id\"], app_name\n)\nif not response:\nlogger.error(\n\"Failed to install the App -&gt; %s for M365 user -&gt; %s\",\napp_name,\nuser_name,\n)\nsuccess = False\ncontinue\n# Process Microsoft 365 group memberships of new user:\nif \"m365_id\" in user:\nuser_id = user[\"m365_id\"]\n# don't forget the base group (department) !\ngroup_names = user[\"groups\"]\nif user_department:\ngroup_names.append(user_department)\nlogger.info(\n\"User -&gt; %s has these groups in payload -&gt; %s (including base group -&gt; %s). Checking if they are Microsoft 365 Groups...\",\nuser_name,\ngroup_names,\nuser_department,\n)\n# Go through all group names:\nfor group_name in group_names:\n# Find the group payload item to the parent group name:\ngroup = next(\n(item for item in self._groups if item[\"name\"] == group_name),\nNone,\n)\nif not group:\n# if group is not in payload then this membership\n# is not relevant for Microsoft 365. This could be system generated\n# groups like \"PageEdit\" or \"Business Administrators\".\n# In this case we do \"continue\" as we can't process parent groups\n# either:\nlogger.info(\n\"No payload found for Group -&gt; %s. Skipping...\", group_name\n)\ncontinue\nelif not \"enable_o365\" in group or not group[\"enable_o365\"]:\n# If Microsoft 365 is not enabled for this group in\n# the payload we don't create a M365 but we do NOT continue\n# as there may still be parent groups that are M365 enabled\n# we want to put the user in (see below):\nlogger.info(\n\"Payload Group -&gt; %s is not enabled for M365.\", group_name\n)\nelse:\nresponse = self._m365.get_group(group_name)\nif (\nresponse is None\nor not \"value\" in response\nor not response[\"value\"]\n):\nlogger.error(\n\"Microsoft 365 Group -&gt; %s not found. Skipping...\",\ngroup_name,\n)\nsuccess = False\nelse:\ngroup_id = response[\"value\"][0][\"id\"]\n# Check if user is already a member. We don't want\n# to throw an error if the user is not found as a member\n# so we pass show_error=False:\nif self._m365.is_member(\ngroup_id, user_id, show_error=False\n):\nlogger.info(\n\"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nelse:\nlogger.info(\n\"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nresponse = self._m365.add_group_member(\ngroup_id, user_id\n)\nif not response:\nlogger.error(\n\"Failed to add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nsuccess = False\n# As each group should have at least one owner in M365\n# we set all users also as owners for now. Later we\n# may want to configure this via payload:\nlogger.info(\n\"Make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nresponse = self._m365.add_group_owner(group_id, user_id)\nif not response:\nlogger.error(\n\"Failed to make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nsuccess = False\n# As M365 groups are flat (not nested) we also add the\n# user as member to the parent groups of the current group\n# if the parent group is enabled for M365:\nparent_group_names = group.get(\"parent_groups\")\nlogger.info(\n\"Group -&gt; %s has the following parent groups -&gt; %s\",\ngroup_name,\nparent_group_names,\n)\nfor parent_group_name in parent_group_names:\n# Find the group dictionary item to the parent group name:\nparent_group = next(\n(\nitem\nfor item in self._groups\nif item[\"name\"] == parent_group_name\n),\nNone,\n)\nif (\nparent_group is None\nor not \"enable_o365\" in parent_group\nor not parent_group[\"enable_o365\"]\n):\n# if parent group is not in payload then this membership\n# is not relevant for Microsoft 365.\n# If Office 365 is not enabled for this parent group in\n# the payload we can also skip:\nlogger.info(\n\"Parent Group -&gt; %s is not enabled for M365. Skipping...\",\ngroup_name,\n)\ncontinue\nresponse = self._m365.get_group(parent_group_name)\nif (\nresponse is None\nor not \"value\" in response\nor not response[\"value\"]\n):\nlogger.error(\n\"Microsoft 365 Group -&gt; %s not found. Skipping...\",\ngroup_name,\n)\nsuccess = False\ncontinue\nparent_group_id = response[\"value\"][0][\"id\"]\n# Check if user is already a member. We don't want\n# to throw an error if the user is not found as a member:\nif self._m365.is_member(\nparent_group_id, user_id, show_error=False\n):\nlogger.info(\n\"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\nparent_group_name,\nparent_group_id,\n)\ncontinue\nlogger.info(\n\"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\nparent_group_name,\nparent_group_id,\n)\nself._m365.add_group_member(parent_group_id, user_id)\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_teams_m365(self, section_name: str = \"teamsM365\") -&gt; bool:\n\"\"\"Process groups in payload and create matching Teams in Microsoft 365.\n           We need to do this after the creation of the M365 users as wie require\n           Group Owners to create teams.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Team needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\nif not \"enable_o365\" in group or not group[\"enable_o365\"]:\nlogger.info(\n\"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\ngroup_name,\n)\ncontinue\n# Check if the M365 group does not exist (this should actually never happen at this point)\nif not \"m365_id\" in group:\n# The \"m365_id\" value is set by the method process_groups_m365()\nlogger.error(\n\"No M365 Group exist for group -&gt; %s (M365 Group creation may have failed). Skipping...\",\ngroup_name,\n)\nsuccess = False\ncontinue\nif self._m365.has_team(group_name):\nlogger.info(\n\"M365 group -&gt; %s already has an MS Team connected. Skipping...\",\ngroup_name,\n)\ncontinue\nlogger.info(\n\"Create M365 Team -&gt; %s for existing M365 Group -&gt; %s...\",\ngroup_name,\ngroup_name,\n)\n# Now \"upgrading\" this group to a MS Team:\nnew_team = self._m365.add_team(group_name)\nif not new_team:\nsuccess = False\ncontinue\nself.write_status_file(success, section_name, self._groups)\nreturn success\n# end method definition\ndef process_teams_m365_apps(\nself, section_name: str = \"teamsM365Apps\", tab_name: str = \"Extended ECM\"\n) -&gt; bool:\n\"\"\"Process groups in payload and configure Extended ECM Teams Apps\n           as a tab called \"Extended ECM\".\n           We need to do this after the transport as we need top level folders\n           we can point the Extended ECM teams app to.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n            tab_name (str, optional): Name of the Extended ECM tab. Default is \"Extended ECM\".\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# Determine the ID of the Extended ECM App:\napp_name = self._m365.config()[\"teamsAppName\"]\nresponse = self._m365.get_teams_apps(f\"contains(displayName, '{app_name}')\")\n# Get the App catalog ID:\napp_catalog_id = self._m365.get_result_value(response, \"id\", 0)\nif not app_catalog_id:\nlogger.error(\"M365 App -&gt; %s not found in catalog!\", app_name)\nreturn False\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Team needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\nif not \"enable_o365\" in group or not group[\"enable_o365\"]:\nlogger.info(\n\"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\ngroup_name,\n)\ncontinue\n#\n# Now we create a tab in the \"General\" channel for the Extended ECM Teams App\n#\n# 1. Check if the tab is already assigned to the General channel.\n# This determines if we need to create or update the tab / app:\napp_name = self._m365.config()[\"teamsAppName\"]\nresponse = self._m365.get_team_channel_tabs(\nteam_name=group_name, channel_name=\"General\"\n)\n# Check if tab is already there:\nif self._m365.exist_result_item(response, \"displayName\", tab_name):\nlogger.info(\n\"M365 Teams app -&gt; %s is already configured for M365 Team -&gt; %s. Updating it with new URLs and IDs...\",\napp_name,\ntab_name,\n)\nupdate = True  # update existing tab\nelse:\nlogger.info(\n\"Add tab -&gt; %s to channel -&gt; General of M365 Team -&gt; %s for app -&gt; %s\",\ntab_name,\ngroup_name,\napp_name,\n)\nupdate = False  # create new tab\n# 2. Determine the M365 Team ID. If the team is not found then skip:\nresponse = self._m365.get_team(group_name)\nteam_id = self._m365.get_result_value(response, \"id\", 0)\nif not team_id:\nlogger.error(\"M365 Team -&gt; %s not found!\", group_name)\nsuccess = False\ncontinue\n# 3. Install the App for the particular M365 Team (if it is not yet installed):\nresponse = self._m365.get_teams_apps_of_team(\nteam_id,\nf\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n)\nif self._m365.exist_result_item(\nresponse, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n):\nlogger.info(\n\"App -&gt; %s is already installed for M365 Team -&gt; %s (%s). Trying to upgrade app...\",\napp_name,\ngroup_name,\nteam_id,\n)\nresponse = self._m365.upgrade_teams_app_of_team(team_id, app_name)\nif not response:\nlogger.error(\n\"Failed to upgrade the existing app -&gt; %s for the M365 Team -&gt; %s\",\napp_name,\ngroup_name,\n)\nsuccess = False\ncontinue\nelse:\nlogger.info(\n\"Install M365 Teams app -&gt; %s for M365 team -&gt; %s\",\napp_name,\ngroup_name,\n)\nresponse = self._m365.assign_teams_app_to_team(\nteam_id=team_id, app_id=app_catalog_id\n)\nif not response:\nlogger.error(\n\"Failed to install App -&gt; %s (%s) for M365 Team -&gt; %s\",\napp_name,\napp_catalog_id,\ngroup_name,\n)\nsuccess = False\ncontinue\n# 4. Create a Tab in the \"General\" channel of the M365 Team:\nif group_name == \"Innovate\":\n# Use the Enterprise Workspace for the\n# top-level group \"Innovate\":\nnode_id = 2000\nelse:\n# We assume the departmental group names are identical to\n# top-level folders in the Enterprise volume\nnode = self._otcs.get_node_by_parent_and_name(2000, group_name)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.warning(\n\"Cannot find a top-level container for group -&gt; %s. Cannot configure M365 Teams app. Skipping...\",\ngroup_name,\n)\ncontinue\napp_url = (\nself._otcs_frontend.cs_support_public_url()\n)  # it is important to use the frontend pod URL here\napp_url += \"/xecmoffice/teamsapp.html?nodeId=\"\napp_url += (\nstr(node_id) + \"&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=\"\n)\napp_url += self._otcs_frontend.cs_public_url()\napp_url += \"&amp;appId=\" + app_catalog_id\nif update:\n# App / Tab exist but needs to be updated with new\n# IDs for the new deployment of Extended ECM\n# as the M365 Teams survive between Terrarium deployments:\nlogger.info(\n\"Updating tab -&gt; %s of M365 Team channel -&gt; General for app -&gt; %s (%s) with new URLs and node IDs\",\ntab_name,\napp_name,\napp_catalog_id,\n)\nresponse = self._m365.update_teams_app_of_channel(\nteam_name=group_name,\nchannel_name=\"General\",\ntab_name=tab_name,\napp_url=app_url,\ncs_node_id=node_id,\n)\nelse:\n# Tab does not exist in \"General\" channel so we\n# add / configure it freshly:\nlogger.info(\n\"Adding tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\ntab_name,\napp_name,\napp_catalog_id,\n)\nresponse = self._m365.add_teams_app_to_channel(\nteam_name=group_name,\nchannel_name=\"General\",\napp_id=app_catalog_id,\ntab_name=tab_name,\napp_url=app_url,\ncs_node_id=node_id,\n)\nif not response:\nlogger.error(\n\"Failed to add tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\ntab_name,\napp_name,\napp_catalog_id,\n)\nself.write_status_file(success, section_name, self._groups)\nreturn success\n# end method definition\ndef cleanup_stale_teams_m365(self, workspace_types: list) -&gt; bool:\n\"\"\"Delete Microsoft Teams that are left-overs from former deployments.\n           This method is currently not used.\n        Args:\n            workspace_types (list): list of all workspace types\n        Returns:\n            bool: True if successful, False otherwise\n        \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping cleanup...\",\n)\nreturn False\nif workspace_types == []:\nlogger.error(\"Empty workspace type list!\")\nreturn False\nfor workspace_type in workspace_types:\nif not \"name\" in workspace_type:\nlogger.error(\n\"Workspace type -&gt; %s does not have a name. Skipping...\",\nworkspace_type,\n)\ncontinue\nresponse = self._otcs.get_workspace_instances(workspace_type[\"name\"])\nworkspace_instances = response[\"results\"]\nif not workspace_instances:\nlogger.info(\n\"Workspace type -&gt; %s does not have any instances!\",\nworkspace_type[\"name\"],\n)\ncontinue\nfor workspace_instance in workspace_instances:\nworkspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\nlogger.info(\n\"Check if stale Microsoft 365 Teams with name -&gt; %s exist...\",\nworkspace_name,\n)\nresponse = self._m365.delete_teams(workspace_name)\nreturn True\n# end method definition\ndef cleanup_all_teams_m365(self, section_name: str = \"teamsM365Cleanup\") -&gt; bool:\n\"\"\"Delete Microsoft Teams that are left-overs from former deployments\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if teams have been deleted, False otherwise\n        \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\n# We want this cleanup to only run once even if we have\n# multiple payload files - so we pass payload_specific=False here:\nif self.check_status_file(\npayload_section_name=section_name, payload_specific=False\n):\nlogger.info(\n\"Payload section -&gt; %s has been processed successfully before. Skip cleanup of M365 teams...\",\nsection_name,\n)\nreturn True\nlogger.info(\"Processing payload section -&gt; %s...\", section_name)\n# We don't want to delete MS Teams that are matching the regular OTCS Group Names (like \"Sales\")\nexception_list = self.get_all_group_names()\n# These are the patterns that each MS Teams needs to match at least one of to be deleted\n# Pattern 1: all MS teams with a name that has a number in brackets, line \"(1234)\"\n# Pattern 2: all MS Teams with a name that starts with a number followed by a space,\n#            followed by a \"-\" and followed by another space\n# Pattern 3: all MS Teams with a name that starts with \"WS\" and a 1-4 digit number\n#            (these are the workspaces for Purchase Contracts generated for Intelligent Filing)\n# Pattern 4: all MS Teams with a name that ends with a 1-2 character + a number in brackets, like (US-1000)\n#            this is a specialization of pattern 1\n# Pattern 5: remove the teams that are created for the dummy copy&amp;paste template for the\n#            Intelligent Filing workspaces\npattern_list = [\nr\"\\(\\d+\\)\",\nr\"\\d+\\s-\\s\",\nr\"^WS\\d{1,4}$\",\nr\"^.+?\\s\\(.{1,2}-\\d+\\)$\",\nr\"Purchase\\sContract\\s\\(Template\\sfor\\sIntelligent\\sFiling\\)\",\n]\nresult = self._m365.delete_all_teams(exception_list, pattern_list)\n# We want this cleanup to only run once even if we have\n# multiple payload files - so we pass payload_specific=False here:\nself.write_status_file(\nsuccess=True,\npayload_section_name=section_name,\npayload_section=exception_list + pattern_list,\npayload_specific=False,\n)\nreturn result\n# end method definition\ndef process_admin_settings(\nself, admin_settings: list, section_name: str = \"adminSettings\"\n) -&gt; bool:\n\"\"\"Process admin settings in payload and import them to Extended ECM.\n            The payload section is a list of dicts with these items:\n            {\n                enabled: True or False to enable or disable the payload item\n                filename: The filename of the XML file with admin settings.\n                          It needs to be the plain filename like \"admin.xml\".\n                          The files reside inside the container in /settings root\n                          directory. They are placed there by the Terraform automation\n                          and are taken from the ./settings/payload directory.\n                description: Some description about the purpose of the settings.\n                             Just for information and optional.\n            }\n        Args:\n            admin_settings (list): list of admin settings. We need this parameter\n                                   as we process two different lists.\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"adminSettingsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if a restart of the OTCS pods is required. False otherwise.\n        \"\"\"\nif not admin_settings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn False  # important to return False here as otherwise we are triggering a restart of services!!\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn False  # important to return False here as otherwise we are triggering a restart of services!!\nrestart_required: bool = False\nsuccess: bool = True\nfor admin_setting in admin_settings:\n# Sanity checks:\nif not \"filename\" in admin_setting:\nlogger.error(\"Filename is missing. Skipping to next admin setting...\")\ncontinue\nfilename = admin_setting[\"filename\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in admin_setting and not admin_setting[\"enabled\"]:\nlogger.info(\n\"Payload for setting file -&gt; %s is disabled. Skipping...\", filename\n)\ncontinue\nsettings_file = self._custom_settings_dir + filename\nif os.path.exists(settings_file):\ndescription = admin_setting.get(\"description\")\nif description:\nlogger.info(description)\n# Read the config file:\nwith open(settings_file, \"r\", encoding=\"utf-8\") as file:\nfile_content = file.read()\nlogger.debug(\n\"Replace Placeholder -&gt; %s in file -&gt; %s\",\nself._placeholder_values,\nfile_content,\n)\nfile_content = self.replace_placeholders(file_content)\n# Write the updated config file:\ntmpfile = \"/tmp/\" + os.path.basename(settings_file)\nwith open(tmpfile, \"w\", encoding=\"utf-8\") as file:\nfile.write(file_content)\nresponse = self._otcs.apply_config(tmpfile)\nif response and response[\"results\"][\"data\"][\"restart\"]:\nlogger.info(\"A restart of Extended ECM service is required.\")\nrestart_required = True\nelse:\nlogger.error(\"Admin settings file -&gt; %s not found.\", settings_file)\nsuccess = False\nself.write_status_file(success, section_name, admin_settings)\nreturn restart_required\n# end method definition\ndef check_external_system(self, external_system: dict) -&gt; bool:\n\"\"\"Check if external system is reachable\n        Args:\n            external_system (dict): payload data structure of external system.\n                                    We assume here that sanity check for\n                                    valid data is already done before.\n        Returns:\n            bool: True = system is reachable, False otherwise\n        \"\"\"\nas_url = external_system[\"as_url\"]\n# Extract the hostname:\nexternal_system_hostname = urlparse(as_url).hostname\n# Write this information back into the data structure:\nexternal_system[\"external_system_hostname\"] = external_system_hostname\n# Extract the port:\nexternal_system_port = urlparse(as_url).port if urlparse(as_url).port else 80\n# Write this information back into the data structure:\nexternal_system[\"external_system_port\"] = external_system_port\nif self._http_object.check_host_reachable(\nexternal_system_hostname, external_system_port\n):\nlogger.info(\n\"Mark external system -&gt; %s as reachable for later workspace creation and SAP RFC processing...\",\nexternal_system[\"external_system_name\"],\n)\nexternal_system[\"reachable\"] = True\nreturn True\nelse:\nexternal_system[\"reachable\"] = False\nreturn False\ndef process_external_systems(self, section_name: str = \"externalSystems\") -&gt; bool:\n\"\"\"Process external systems in payload and create them in Extended ECM.\n            The payload section is a list of dicts (each representing one external\n            system) with these items:\n            {\n                enabled: True or False to enable or disable the payload item\n                external_system_name: Name of the external systen.\n                external_system_type: Type of the external system.\n                                      Possible values are\n                                      * SAP\n                                      * SuccessFactors\n                                      * Salesforce\n                                      * AppWorks Platform\n                base_url: Base URL of the external system\n                as_url: Application Server URL of the external system\n                username: (Technical) User Name for the connection\n                password: Passord of the (technical) user\n                oauth_client_id: OAuth client ID\n                oauth_client_secret: OAuth client secret\n                archive_logical_name: Logical name of Archive for SAP\n                archive_certificate_file: Path and filename to certificate file.\n                                          This file is inside the customizer\n                                          pof file system.\n            }\n            If OAuth Client ID and Client Secret are provided then username\n            and password are no longer used.\n            In the payload for SAP external systems there are additional\n            items \"client\", \"destination\" that are processed by init_sap()\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            - based on system_type different other settings in the dict are set\n            - reachability is tested and a flag is set in the payload dict\n        \"\"\"\nif not self._external_systems:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\n# if self.check_status_file(section_name):\n#   return True\nsuccess: bool = True\nfor external_system in self._external_systems:\n#\n# 1: Do sanity checks for the payload:\n#\nif not \"external_system_name\" in external_system:\nlogger.error(\n\"External System connection needs a logical system name! Skipping to next external system...\"\n)\nsuccess = False\ncontinue\nsystem_name = external_system[\"external_system_name\"]\nif not \"external_system_type\" in external_system:\nlogger.error(\n\"External System connection -&gt; %s needs a type (SAP, Salesfoce, SuccessFactors, AppWorks Platform)! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\nsystem_type = external_system[\"external_system_type\"]\nif \"enabled\" in external_system and not external_system[\"enabled\"]:\nlogger.info(\n\"Payload for External System -&gt; %s (%s) is disabled. Skipping...\",\nsystem_name,\nsystem_type,\n)\ncontinue\n# Possible Connection Types for external systems:\n# \"Business Scenario Sample\" (Business Scenarios Sample Adapter)\n# \"ot.sap.c4c.SpiAdapter\" (SAP C4C SPI Adapter)\n# \"ot.sap.c4c.SpiAdapterV2\" (C4C SPI Adapter V2)\n# \"HTTP\" (Default WebService Adapter)\n# \"ot.sap.S4HANAAdapter\" (S/4HANA SPI Adapter)\n# \"SF\" (SalesForce Adapter)\n# \"SFInstance\" (SFWebService)\n# Set the default settings for the different system types:\nmatch system_type:\n# Check if we have a SuccessFactors system:\ncase \"SuccessFactors\":\nconnection_type = \"SFInstance\"\nauth_method = \"OAUTH\"\nusername = None\npassword = None\ncase \"SAP\":\nconnection_type = \"HTTP\"\nauth_method = \"BASIC\"\noauth_client_id = None\noauth_client_secret = None\ncase \"Salesforce\":\nconnection_type = \"SF\"\nauth_method = \"OAUTH\"\nusername = None\npassword = None\ncase \"AppWorks Platform\":\nconnection_type = \"HTTP\"\nauth_method = \"BASIC\"\noauth_client_id = None\noauth_client_secret = None\ncase \"Business Scenario Sample\":\nconnection_type = \"Business Scenario Sample\"\nauth_method = \"BASIC\"\noauth_client_id = None\noauth_client_secret = None\ncase _:\nlogger.error(\"Unsupported system_type defined -&gt; %s\", system_type)\nreturn False\nif not \"base_url\" in external_system:\nbase_url = \"\"  # baseUrl is optional\nelse:\nbase_url = external_system[\"base_url\"]\nif not \"as_url\" in external_system:\nlogger.warning(\n\"External System connection -&gt; %s needs an Application Server URL! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\nas_url = external_system[\"as_url\"]\n# Check if external system is reachable and\n# update the payload dict with a \"reachable\" key/value pair:\nself.check_external_system(external_system)\n# Read either username/password (BASIC) or client ID / secret (OAuth)\nmatch auth_method:\ncase \"BASIC\":\nif not \"username\" in external_system:\nlogger.warning(\n\"External System connection -&gt; %s needs a user name for BASIC authentication! Skipping to next external system...\",\nsystem_name,\n)\ncontinue\nif not \"password\" in external_system:\nlogger.warning(\n\"External System connection -&gt; %s needs a password for BASIC authentication! Skipping to next external system...\",\nsystem_name,\n)\ncontinue\nusername = external_system[\"username\"]\npassword = external_system[\"password\"]\noauth_client_id = \"\"\noauth_client_secret = \"\"\ncase \"OAUTH\":\nif not \"oauth_client_id\" in external_system:\nlogger.error(\n\"External System connection -&gt; %s is missing OAuth client ID! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\nif not \"oauth_client_secret\" in external_system:\nlogger.error(\n\"External System connection -&gt; %s is missing OAuth client secret! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\noauth_client_id = external_system[\"oauth_client_id\"]\noauth_client_secret = external_system[\"oauth_client_secret\"]\n# For backward compatibility we also read username/password\n# with OAuth settings:\nusername = (\nexternal_system[\"username\"]\nif external_system.get(\"username\")\nelse None\n)\npassword = (\nexternal_system[\"password\"]\nif external_system.get(\"password\")\nelse None\n)\ncase _:\nlogger.error(\n\"Unsupported authorization method specified (%s) , Skipping ... \",\nauth_method,\n)\nreturn False\n# We do this existance test late in this function to make sure the payload\n# datastructure is properly updated for debugging purposes.\nlogger.info(\n\"Test if external system -&gt; %s does already exist...\", system_name\n)\nif self._otcs.get_external_system_connection(system_name):\nlogger.info(\n\"External System connection -&gt; %s already exists! Skipping to next external system...\",\nsystem_name,\n)\ncontinue\n#\n# Create External System:\n#\nlogger.info(\n\"Create external system -&gt; %s; type -&gt; %s\", system_name, connection_type\n)\nresponse = self._otcs.add_external_system_connection(\nconnection_name=system_name,\nconnection_type=connection_type,\nas_url=as_url,\nbase_url=base_url,\nusername=str(username),\npassword=str(password),\nauthentication_method=auth_method,\nclient_id=oauth_client_id,\nclient_secret=oauth_client_secret,\n)\nif response is None:\nlogger.error(\n\"Failed to create external system -&gt; %s; type -&gt; %s\",\nsystem_name,\nconnection_type,\n)\nsuccess = False\nelse:\nlogger.info(\"Successfully created external system -&gt; %s\", system_name)\n#\n# In case of an SAP external system we also do some Archiving config:\n#\nif system_type == \"SAP\":\nif (\n\"archive_logical_name\" in external_system\nand \"archive_certificate_file\" in external_system\nand self._otac\n):\nlogger.info(\n\"Put certificate file -&gt; %s for logical archive -&gt; %s into Archive Center\",\nexternal_system[\"archive_certificate_file\"],\nexternal_system[\"archive_logical_name\"],\n)\nresponse = self._otac.put_cert(\nexternal_system[\"external_system_name\"],\nexternal_system[\"archive_logical_name\"],\nexternal_system[\"archive_certificate_file\"],\n)\nlogger.info(\n\"Enable certificate file -&gt; %s for logical archive -&gt; %s\",\nexternal_system[\"archive_certificate_file\"],\nexternal_system[\"archive_logical_name\"],\n)\nresponse = self._otac.enable_cert(\nexternal_system[\"external_system_name\"],\nexternal_system[\"archive_logical_name\"],\nTrue,\n)\nself.write_status_file(success, section_name, self._external_systems)\nreturn success\n# end method definition\ndef process_transport_packages(\nself, transport_packages: list, section_name: str = \"transportPackages\"\n) -&gt; bool:\n\"\"\"Process transport packages in payload and import them to Extended ECM.\n        Args:\n            transport_packages (list): list of transport packages. As we\n                                       have three different lists (transport,\n                                       content_transport, transport_post) so\n                                       we need a parameter\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"transportPackagesPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not transport_packages:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor transport_package in transport_packages:\nif not \"name\" in transport_package:\nlogger.error(\n\"Transport Package needs a name! Skipping to next transport...\"\n)\nsuccess = False\ncontinue\nname = transport_package[\"name\"]\nif \"enabled\" in transport_package and not transport_package[\"enabled\"]:\nlogger.info(\n\"Payload for Transport Package -&gt; %s is disabled. Skipping...\", name\n)\ncontinue\nif not \"url\" in transport_package:\nlogger.error(\n\"Transport Package -&gt; %s needs a URL! Skipping to next transport...\",\nname,\n)\nsuccess = False\ncontinue\nif not \"description\" in transport_package:\nlogger.warning(\"Transport Package -&gt; %s is missing a description\", name)\nurl = transport_package[\"url\"]\ndescription = transport_package[\"description\"]\n# For some transports there can be string replacements\n# configured:\nif \"replacements\" in transport_package:\nreplacements = transport_package[\"replacements\"]\nlogger.info(\n\"Deploy transport -&gt; %s with replacements -&gt; %s; URL -&gt; %s\",\ndescription,\nurl,\nreplacements,\n)\nresponse = self._otcs.deploy_transport(\nurl, name, description, replacements\n)\nelse:\nlogger.info(\"Deploy transport -&gt; %s; URL -&gt; %s\", description, url)\nresponse = self._otcs.deploy_transport(url, name, description)\nif response is None:\nlogger.error(\"Failed to deploy transport -&gt; %s; URL -&gt; %s\", name, url)\nsuccess = False\nif self._stop_on_error:\nbreak\nelse:\nlogger.info(\"Successfully deployed transport -&gt; %s\", name)\nself.write_status_file(success, section_name, transport_packages)\nreturn success\n# end method definition\ndef process_user_photos(self, section_name: str = \"userPhotos\") -&gt; bool:\n\"\"\"Process user photos in payload and assign them to Extended ECM users.\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# we assume the nickname of the photo item equals the login name of the user\n# we also assume that the photos have been uploaded / transported into the target system\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif not \"id\" in user:\nlogger.error(\n\"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser_id = user[\"id\"]\nresponse = self._otcs.get_node_from_nickname(user_name)\nif response is None:\nlogger.warning(\n\"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\nuser_name,\n)\ncontinue\nphoto_id = self._otcs.get_result_value(response, \"id\")\nresponse = self._otcs.update_user_photo(user_id, photo_id)\nif not response:\nlogger.error(\"Failed to add photo for user -&gt; %s\", user_name)\nsuccess = False\nelse:\nlogger.info(\"Successfully added photo for user -&gt; %s\", user_name)\n# Check if Admin has a photo as well (nickname needs to be \"admin\"):\nresponse = self._otcs.get_node_from_nickname(\"admin\")\nif response is None:\nlogger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\nelse:\nphoto_id = self._otcs.get_result_value(response, \"id\")\nresponse = self._otcs.update_user_photo(1000, photo_id)\nif response is None:\nlogger.warning(\"Failed to add photo for admin\")\nelse:\nlogger.info(\"Successfully added photo for admin\")\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_user_photos_m365(self, section_name: str = \"userPhotosM365\") -&gt; bool:\n\"\"\"Process user photos in payload and assign them to Microsoft 365 users.\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# we assume the nickname of the photo item equals the login name of the user\n# we also assume that the photos have been uploaded / transported into the target system\nfor user in self._users:\nuser_name = user[\"name\"]\nif not \"id\" in user:\nlogger.error(\n\"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\nuser_name,\n)\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif not \"enable_o365\" in user or not user[\"enable_o365\"]:\nlogger.info(\n\"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\nuser_name,\n)\ncontinue\n# If the customizer pod is restarted it may be that\n# the M365 user exists even if the M365 user ID is\n# not yet written back into the payload. So we use the\n# determine_user_id_m365() method that handles both cases\n# and updates the payload if the user exists in M365 already.\nuser_m365_id = self.determine_user_id_m365(user)\nif not user_m365_id:\nlogger.error(\"M365 user -&gt; %s does not exist. Skipping...\", user_name)\nsuccess = False\ncontinue\nif self._m365.get_user_photo(user_m365_id, show_error=False):\nlogger.info(\n\"User -&gt; %s (%s) has already a photo in Microsoft 365. Skipping...\",\nuser_name,\nuser_m365_id,\n)\ncontinue\nelse:\nlogger.info(\n\"User -&gt; %s (%s) has not yet a photo in Microsoft 365. Uploading...\",\nuser_name,\nuser_m365_id,\n)\nresponse = self._otcs.get_node_from_nickname(user_name)\nif response is None:\nlogger.warning(\n\"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\nuser_name,\n)\ncontinue\nphoto_id = self._otcs.get_result_value(response, \"id\")\nphoto_name = self._otcs.get_result_value(response, \"name\")\nphoto_path = \"/tmp/\" + str(photo_name)\nresponse = self._otcs.download_document(photo_id, photo_path)\nif response is None:\nlogger.warning(\n\"Failed to download photo for user -&gt; %s from Extended ECM\",\nuser_name,\n)\nsuccess = False\ncontinue\nelse:\nlogger.info(\n\"Successfully downloaded photo for user -&gt; %s from Extended ECM to file -&gt; %s\",\nuser_name,\nphoto_path,\n)\n# Upload photo to M365:\nresponse = self._m365.update_user_photo(user_m365_id, photo_path)\nif response is None:\nlogger.error(\n\"Failed to upload photo for user -&gt; %s to Microsoft 365\", user_name\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully uploaded photo for user -&gt; %s to Microsoft 365\",\nuser_name,\n)\n# Check if Admin has a photo as well (nickname needs to be \"admin\")\n# Then we want this to be applied in M365 as well:\nresponse = self._otcs.get_node_from_nickname(\"admin\")\nif response is None:\nlogger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\nelse:\nphoto_id = self._otcs.get_result_value(response, \"id\")\nphoto_name = self._otcs.get_result_value(response, \"name\")\nphoto_path = \"/tmp/\" + str(photo_name)\nresponse = self._otcs.download_document(photo_id, photo_path)\nif response is None:\nlogger.warning(\n\"Failed to download photo for admin user from Extended ECM\",\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully downloaded photo for admin from Extended ECM to file -&gt; %s\",\nphoto_path,\n)\nm365_admin_email = \"admin@\" + self._m365.config()[\"domain\"]\nresponse = self._m365.update_user_photo(m365_admin_email, photo_path)\nif response is None:\nlogger.warning(\"Failed to add photo for %s\", m365_admin_email)\nelse:\nlogger.info(\"Successfully added photo for %s\", m365_admin_email)\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_workspace_types(self, section_name: str = \"workspaceTypes\") -&gt; list:\n\"\"\"Create a data structure for all workspace types in the Extended ECM system.\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            list: list of workspace types. Each list element is a dict with these values:\n                - id (str)\n                - name (str)\n                - templates (list)\n                    + name (str)\n                    + id\n        \"\"\"\n# If this payload section has been processed successfully before we\n# still need to read the data structure from the status file and\n# initialize self._workspace_types:\nif self.check_status_file(section_name):\n# read the list from the json file in admin Home\n# this is important for restart of customizer pod\n# as this data structure is used later on for workspace processing\nlogger.info(\"Re-Initialize workspace types list for later use...\")\nself._workspace_types = self.get_status_file(section_name)\nreturn self._workspace_types\n# get all workspace types (these have been created by the transports and are not in the payload!):\nresponse = self._otcs.get_workspace_types()\nif response is None:\nlogger.error(\"No workspace types found!\")\nself._workspace_types = []\nelse:\nself._workspace_types = response[\"results\"]\n# now we enrich the workspace_type list elments (which are dicts)\n# with additional dict elements for further processing:\nfor workspace_type in self._workspace_types:\nworkspace_type_id = workspace_type[\"data\"][\"properties\"][\"wksp_type_id\"]\nlogger.info(\"Workspace Types ID -&gt; %s\", workspace_type_id)\nworkspace_type[\"id\"] = workspace_type_id\nworkspace_type_name = workspace_type[\"data\"][\"properties\"][\"wksp_type_name\"]\nlogger.info(\"Workspace Types Name -&gt; %s\", workspace_type_name)\nworkspace_type[\"name\"] = workspace_type_name\nworkspace_templates = workspace_type[\"data\"][\"properties\"][\"templates\"]\n# Create empty lists of dicts with template names and node IDs:\nworkspace_type[\"templates\"] = []\nif workspace_templates:\n# Determine available templates per workspace type (there can be multiple!)\nfor workspace_template in workspace_templates:\nworkspace_template_id = workspace_template[\"id\"]\nworkspace_template_name = workspace_template[\"name\"]\nlogger.info(\n\"Found template with name -&gt; %s and ID -&gt; %s\",\nworkspace_template_name,\nworkspace_template_id,\n)\ntemplate = {\n\"name\": workspace_template_name,\n\"id\": workspace_template_id,\n}\nworkspace_type[\"templates\"].append(template)\n# Workaround for problem with workspace role inheritance\n# which may be related to Transport or REST API: to work-around this we\n# push down the workspace roles to the workspace folders explicitly:\nresponse = self._otcs.get_workspace_roles(workspace_template_id)\nfor roles in response[\"results\"]:\nrole_name = roles[\"data\"][\"properties\"][\"name\"]\nrole_id = roles[\"data\"][\"properties\"][\"id\"]\npermissions = roles[\"data\"][\"properties\"][\"perms\"]\n# as get_workspace_roles() delivers permissions as a value (bit encoded)\n# we need to convert it to a permissions string list:\npermission_string_list = (\nself._otcs.convert_permission_value_to_permission_string(\npermissions\n)\n)\nlogger.info(\n\"Inherit permissions of workspace template -&gt; %s and role -&gt; %s to workspace folders...\",\nworkspace_template_name,\nrole_name,\n)\n# Inherit permissions to folders of workspace template:\nresponse = self._otcs.assign_workspace_permissions(\nworkspace_template_id,\nrole_id,\npermission_string_list,\n1,  # Only sub items - workspace node itself is OK\n)\nelse:\nlogger.warning(\n\"Workspace Types Name -&gt; %s has no templates!\", workspace_type_name\n)\ncontinue\nself.write_status_file(True, section_name, self._workspace_types)\nreturn self._workspace_types\n# end method definition\ndef process_workspace_templates(\nself, section_name: str = \"workspaceTemplates\"\n) -&gt; bool:\n\"\"\"Process Workspace Template playload. This allows to define role members on\n           template basis. This avoids having to \"pollute\" workspace template templates\n           with user or group information and instead controls this via payload.\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace_template in self._workspace_templates:\n# Read Workspace Type Name from payload:\nif not \"type_name\" in workspace_template:\nlogger.error(\n\"Workspace template needs a type name! Skipping to next workspace template...\",\n)\nsuccess = False\ncontinue\ntype_name = workspace_template[\"type_name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace_template and not workspace_template[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace Template -&gt; %s is disabled. Skipping to next workspace template...\",\ntype_name,\n)\ncontinue\n# Read Workspace Template Name from payload:\nif not \"template_name\" in workspace_template:\nlogger.error(\n\"Workspace Template for Workspace Type -&gt; %s needs a template name! Skipping to next workspace template...\",\ntype_name,\n)\nsuccess = False\ncontinue\ntemplate_name = workspace_template[\"template_name\"]\n# Read members from payload:\nif not \"members\" in workspace_template:\nlogger.info(\n\"Workspace template with type -&gt; %s and name -&gt; %s has no members in payload. Skipping to next workspace...\",\ntype_name,\ntemplate_name,\n)\ncontinue\nmembers = workspace_template[\"members\"]\n# Find the workspace type with the name given in the _workspace_types\n# datastructure that has been generated by process_workspace_type() method before:\nworkspace_type = next(\n(item for item in self._workspace_types if item[\"name\"] == type_name),\nNone,\n)\nif workspace_type is None:\nlogger.error(\n\"Workspace Type -&gt; %s not found. Skipping to next workspace template...\",\ntype_name,\n)\nsuccess = False\ncontinue\nif workspace_type[\"templates\"] == []:\nlogger.error(\n\"Workspace Type -&gt; %s does not have templates. Skipping to next workspace template...\",\ntype_name,\n)\nsuccess = False\ncontinue\nworkspace_template = next(\n(\nitem\nfor item in workspace_type[\"templates\"]\nif item[\"name\"] == template_name\n),\nNone,\n)\nif workspace_template:  # does this template exist?\nlogger.info(\n\"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\ntemplate_name,\n)\nelse:\nlogger.error(\n\"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\ntemplate_name,\n)\nlogger.error(\n\"Workspace Type -&gt; %s has only these templates -&gt; %s\",\ntype_name,\nworkspace_type[\"templates\"],\n)\nsuccess = False\ncontinue\ntemplate_id = workspace_template[\"id\"]\nworkspace_roles = self._otcs.get_workspace_roles(template_id)\nif workspace_roles is None:\nlogger.info(\n\"Workspace Template %s with node Id -&gt; %s has no roles. Skipping to next workspace...\",\ntemplate_name,\ntemplate_id,\n)\ncontinue\nfor member in members:\n# read user list and role name from payload:\nmember_users = (\nmember[\"users\"] if member.get(\"users\") else []\n)  # be careful to avoid key errors as users are optional\nmember_groups = (\nmember[\"groups\"] if member.get(\"groups\") else []\n)  # be careful to avoid key errors as groups are optional\nmember_role_name = member[\"role\"]\nif member_role_name == \"\":  # role name is required\nlogger.error(\n\"Members of workspace template -&gt; %s is missing the role name.\",\ntemplate_name,\n)\nsuccess = False\ncontinue\nif (\nmember_users == [] and member_groups == []\n):  # we either need users or groups (or both)\nlogger.warning(\n\"Role -&gt; %s of workspace template -&gt; %s does not have any members (no users nor groups).\",\nmember_role_name,\ntemplate_name,\n)\ncontinue\nrole_id = self._otcs.lookup_result_value(\nworkspace_roles, \"name\", member_role_name, \"id\"\n)\nif role_id is None:\n#    if member_role is None:\nlogger.error(\n\"Workspace template -&gt; %s does not have a role with name -&gt; %s\",\ntemplate_name,\nmember_role_name,\n)\nsuccess = False\ncontinue\nlogger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n# Process users as workspace template members:\nfor member_user in member_users:\n# find member user in current payload:\nmember_user_id = next(\n(item for item in self._users if item[\"name\"] == member_user),\n{},\n)\nif member_user_id:\nuser_id = member_user_id[\"id\"]\nelse:\n# If this didn't work, try to get the member user from OTCS. This covers\n# cases where the user is system generated or part\n# of a former payload processing (thus not in the current payload):\nlogger.info(\n\"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\nmember_user,\n)\nresponse = self._otcs.get_user(member_user)\nuser_id = self._otcs.lookup_result_value(\nresponse, key=\"name\", value=member_user, return_key=\"id\"\n)\nif not user_id:\nlogger.error(\n\"Cannot find member user with login -&gt; %s. Skipping...\",\nmember_user,\n)\nsuccess = False\ncontinue\n# Add member if it does not yet exists - suppress warning\n# message if user is already in role:\nresponse = self._otcs.add_member_to_workspace(\ntemplate_id, int(role_id), user_id, False\n)\nif response is None:\nlogger.error(\n\"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_user,\nuser_id,\nmember_role_name,\ntemplate_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_user,\nuser_id,\nmember_role_name,\ntemplate_name,\n)\n# Process groups as workspace template members:\nfor member_group in member_groups:\nmember_group_id = next(\n(item for item in self._groups if item[\"name\"] == member_group),\nNone,\n)\nif member_group_id is None:\nlogger.error(\"Cannot find group with name -&gt; %s\", member_group)\nsuccess = False\ncontinue\ngroup_id = member_group_id[\"id\"]\nresponse = self._otcs.add_member_to_workspace(\ntemplate_id, int(role_id), group_id\n)\nif response is None:\nlogger.error(\n\"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\ntemplate_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\ntemplate_name,\n)\nself.write_status_file(success, section_name, self._workspace_types)\nreturn success\n# end method definition\ndef process_workspaces(self, section_name: str = \"workspaces\") -&gt; bool:\n\"\"\"Process workspaces in payload and create them in Extended ECM.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"workspacesPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        Side Effects:\n            Set workspace[\"nodeId] to the node ID of the created workspace\n        \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload:\nif not \"name\" in workspace:\nlogger.error(\"Workspace needs a name! Skipping to next workspace...\")\nsuccess = False\ncontinue\nname = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n)\ncontinue\n# Read Type Name from payload:\nif not \"type_name\" in workspace:\nlogger.error(\n\"Workspace -&gt; %s needs a type name! Skipping to next workspace...\",\nname,\n)\nsuccess = False\ncontinue\ntype_name = workspace[\"type_name\"]\n# check if the workspace has been created before (effort to make the customizing code idem-potent)\nlogger.info(\n\"Check if workspace -&gt; %s of type -&gt; %s does already exist...\",\nname,\ntype_name,\n)\n# Check if workspace does already exist\n# In case the workspace exists, determine_workspace_id()\n# also stores the node ID into workspace[\"nodeId\"]\nworkspace_id = self.determine_workspace_id(workspace)\nif workspace_id:\nlogger.info(\n\"Workspace -&gt; %s of type -&gt; %s does already exist and has ID -&gt; %s! Skipping to next workspace...\",\nname,\ntype_name,\nworkspace_id,\n)\ncontinue\nlogger.info(\n\"Creating new Workspace -&gt; %s; Workspace Type -&gt; %s...\", name, type_name\n)\n# Read optional description from payload:\nif not \"description\" in workspace:\ndescription = \"\"\nelse:\ndescription = workspace[\"description\"]\n# Parent ID is optional and only required if workspace type does not specify a create location.\n# This is typically the case if it is a nested workspace or workspaces of the same type can be created\n# in different locations in the Enterprise Workspace:\nparent_id = workspace[\"parent_id\"] if workspace.get(\"parent_id\") else None\nif parent_id is not None:\nparent_workspace = next(\n(item for item in self._workspaces if item[\"id\"] == parent_id), None\n)\nif parent_workspace is None:\nlogger.error(\n\"Parent Workspace with logical ID -&gt; %s not found.\", parent_id\n)\nsuccess = False\ncontinue\nparent_workspace_node_id = self.determine_workspace_id(parent_workspace)\nif not parent_workspace_node_id:\nlogger.warning(\n\"Parent Workspace without node ID (parent workspace creation may have failed). Skipping to next workspace...\"\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Parent Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\nparent_id,\nparent_workspace_node_id,\n)\nelse:\n# if no parent_id is specified the workspace location is determined by the workspace type definition\n# and we pass None as parent ID to the get_workspace_create_form and create_workspace methods below:\nparent_workspace_node_id = None\n# Find the workspace type with the name given in the payload:\nworkspace_type = next(\n(item for item in self._workspace_types if item[\"name\"] == type_name),\nNone,\n)\nif workspace_type is None:\nlogger.error(\n\"Workspace Type -&gt; %s not found. Skipping to next workspace...\",\ntype_name,\n)\nsuccess = False\ncontinue\nif workspace_type[\"templates\"] == []:\nlogger.error(\n\"Workspace Type -&gt; %s does not have templates. Skipping to next workspace...\",\ntype_name,\n)\nsuccess = False\ncontinue\n# check if the template to be used is specified in the payload:\nif \"template_name\" in workspace:\ntemplate_name = workspace[\"template_name\"]\nworkspace_template = next(\n(\nitem\nfor item in workspace_type[\"templates\"]\nif item[\"name\"] == template_name\n),\nNone,\n)\nif workspace_template:  # does this template exist?\nlogger.info(\n\"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\ntemplate_name,\n)\nelse:\nlogger.error(\n\"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\ntemplate_name,\n)\nlogger.error(\n\"Workspace Type -&gt; %s has only these templates -&gt; %s\",\ntype_name,\nworkspace_type[\"templates\"],\n)\nsuccess = False\ncontinue\n# template to be used is NOT specified in the payload - then we just take the first one:\nelse:\nworkspace_template = workspace_type[\"templates\"][0]\nlogger.info(\n\"Workspace Template has not been specified in payload - we just take the first one (%s)\",\nworkspace_template,\n)\ntemplate_id = workspace_template[\"id\"]\ntemplate_name = workspace_template[\"name\"]\nworkspace_type_id = workspace_type[\"id\"]\nlogger.info(\n\"Create Workspace -&gt; %s (type -&gt; %s) from workspace template -&gt; %s (ID -&gt; %s)\",\nname,\ntype_name,\ntemplate_name,\ntemplate_id,\n)\n# Read business object data from workspace payload:\next_system_id = None\nbo_type = None\nbo_id = None\n# Check if business objects are in workspace payload and list is not empty:\nif \"business_objects\" in workspace and workspace[\"business_objects\"]:\n# Currently we can only process one business object (workspaces connected to multiple leading systems are not support yet)\nbusiness_object_data = workspace[\"business_objects\"][0]\n# business_object_data is a dict with 3 elements:\nif \"external_system\" in business_object_data:\next_system_id = business_object_data[\"external_system\"]\nif \"bo_type\" in business_object_data:\nbo_type = business_object_data[\"bo_type\"]\nif \"bo_id\" in business_object_data:\nbo_id = business_object_data[\"bo_id\"]\nlogger.info(\n\"Workspace -&gt; %s has business object information -&gt; (%s, %s, %s)\",\nname,\next_system_id,\nbo_type,\nbo_id,\n)\n# Check if external system has been declared in payload:\nexternal_system = next(\n(\nitem\nfor item in self._external_systems\nif (item[\"external_system_name\"] == ext_system_id)\n),\nNone,\n)\nif not external_system:\nlogger.warning(\n\"External System -&gt; %s does not exist. Cannot connect workspace -&gt; %s to -&gt; %s. Create workspace without connection.\",\next_system_id,\nname,\next_system_id,\n)\n# we remove the Business Object information to avoid communication\n# errors during workspace create form and workspace creation\next_system_id = None\nbo_type = None\nbo_id = None\nelif not external_system.get(\"reachable\"):\nlogger.warning(\n\"External System -&gt; %s is not reachable. Cannot connect workspace -&gt; %s to -&gt; (%s, %s, %s). Create workspace without connection...\",\next_system_id,\nname,\next_system_id,\nbo_type,\nbo_id,\n)\n# we remove the Business Object information to avoid communication\n# errors during workspace create form and workspace creation\next_system_id = None\nbo_type = None\nbo_id = None\nelse:\nlogger.info(\n\"Workspace -&gt; %s will be connected with external system -&gt; %s (%s, %s)\",\nname,\next_system_id,\nbo_type,\nbo_id,\n)\n# Read categories from payload:\nif not \"categories\" in workspace:\nlogger.info(\n\"Workspace payload has no category data! Will leave category attributes empty...\"\n)\ncategory_create_data = {}\nelse:\ncategories = workspace[\"categories\"]\ncategory_create_data = {\"categories\": {}}\nresponse = self._otcs.get_workspace_create_form(\ntemplate_id, ext_system_id, bo_type, bo_id, parent_workspace_node_id\n)\nif response is None:\nlogger.error(\n\"Failed to retrieve create information for template -&gt; %s\",\ntemplate_id,\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Successfully retrieved create information for template -&gt; %s\",\ntemplate_id,\n)\n# Process category information\nforms = response[\"forms\"]\ncategories_form = {}\n# Typically the the create workspace form delivers 3 forms:\n# 1. Form for System Attributes (has no role name)\n# 2. Form for Category Data (role name = \"categories\")\n# 3. Form for Classifications (role name = \"classifications\")\n# First we extract these 3 forms:\nfor form in forms:\nif \"role_name\" in form and form[\"role_name\"] == \"categories\":\ncategories_form = form\nlogger.debug(\"Found Categories form -&gt; %s\", form)\ncontinue\nif \"role_name\" in form and form[\"role_name\"] == \"classifications\":\nlogger.debug(\"Found Classification form -&gt; %s\", form)\ncontinue\n# the remaining option is that this form is the system attributes form:\nlogger.debug(\"Found System Attributes form -&gt; %s\", form)\n# We are just interested in the single category data set (role_name = \"categories\"):\ndata = categories_form[\"data\"]\nlogger.debug(\"Categories data found -&gt; %s\", data)\nschema = categories_form[\"schema\"][\"properties\"]\nlogger.debug(\"Categories schema found -&gt; %s\", schema)\n# parallel loop over category data and schema\nfor cat_data, cat_schema in zip(data, schema):\nlogger.info(\"Category ID -&gt; %s\", cat_data)\ndata_attributes = data[cat_data]\nlogger.debug(\"Data Attributes -&gt; %s\", data_attributes)\nschema_attributes = schema[cat_schema][\"properties\"]\nlogger.debug(\"Schema Attributes -&gt; %s\", schema_attributes)\ncat_name = schema[cat_schema][\"title\"]\nlogger.info(\"Category name -&gt; %s\", cat_name)\n# parallel loop over attribute data and schema\n# Sets with one (fixed) row have type = object\n# Multi-value Sets with (multiple) rows have type = array and \"properties\" in \"items\" schema\n# Multi-value attributes have also type = array but NO \"properties\" in \"items\" schema\nfor attr_data, attr_schema in zip(\ndata_attributes, schema_attributes\n):\nlogger.debug(\"Attribute ID -&gt; %s\", attr_data)\nlogger.debug(\"Attribute Data -&gt; %s\", data_attributes[attr_data])\nlogger.debug(\n\"Attribute Schema -&gt; %s\", schema_attributes[attr_schema]\n)\nattr_type = schema_attributes[attr_schema][\"type\"]\nlogger.debug(\"Attribute Type -&gt; %s\", attr_type)\nif not \"title\" in schema_attributes[attr_schema]:\nlogger.debug(\"Attribute has no title. Skipping...\")\ncontinue\n# Check if it is an multi-line set:\nif attr_type == \"array\" and (\n\"properties\" in schema_attributes[attr_schema][\"items\"]\n):\nset_name = schema_attributes[attr_schema][\"title\"]\nlogger.info(\"Multi-line Set -&gt; %s\", set_name)\nset_data_attributes = data_attributes[\nattr_data\n]  # this is a list []\nlogger.debug(\n\"Set Data Attributes -&gt; %s\", set_data_attributes\n)\nset_schema_attributes = schema_attributes[attr_schema][\n\"items\"\n][\"properties\"]\nlogger.debug(\n\"Set Schema Attributes -&gt; %s\", set_schema_attributes\n)\nset_schema_max_rows = schema_attributes[attr_schema][\n\"items\"\n][\"maxItems\"]\nlogger.debug(\n\"Set Schema Max Rows -&gt; %s\", set_schema_max_rows\n)\nset_data_max_rows = len(set_data_attributes)\nlogger.debug(\"Set Data Max Rows -&gt; %s\", set_data_max_rows)\nrow = 1\n# it can happen that the payload contains more rows than the\n# initial rows in the set data structure. In this case we use\n# a copy of the data structure from row 0 as template...\nfirst_row = dict(set_data_attributes[0])\n# We don't know upfront how many rows of data we will find in payload\n# but we at max process the maxItems specified in the schema:\nwhile row &lt;= set_schema_max_rows:\n# Test if we have any payload for this row:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand \"set\"\nin item  # not all items may have a \"set\" key\nand item[\"set\"] == set_name\nand \"row\"\nin item  # not all items may have a \"row\" key\nand item[\"row\"] == row\n)\n),\nNone,\n)\n# stop if there's no payload for the row:\nif attribute is None:\nlogger.info(\n\"No payload found for set -&gt; %s, row -&gt; %s\",\nset_name,\nrow,\n)\n# we assume that if there's no payload for row n there will be no payload for rows &gt; n\n# and break the while loop:\nbreak\n# do we need to create a new row in the data set?\nelif row &gt; set_data_max_rows:\n# use the row we stored above to create a new empty row:\nlogger.info(\n\"Found payload for row -&gt; %s, we need a new data row for it\",\nrow,\n)\nlogger.info(\n\"Adding an additional row -&gt; %s to set data -&gt; %s\",\nrow,\nset_name,\n)\n# add the empty dict to the list:\nset_data_attributes.append(dict(first_row))\nset_data_max_rows += 1\nelse:\nlogger.info(\n\"Found payload for row -&gt; %s %s we can store in existing data row\",\nrow,\nset_name,\n)\n# traverse all attributes in a single row:\nfor set_attr_schema in set_schema_attributes:\nlogger.debug(\n\"Set Attribute ID -&gt; %s (row -&gt; %s)\",\nset_attr_schema,\nrow,\n)\nlogger.debug(\n\"Set Attribute Schema -&gt; %s (row -&gt; %s)\",\nset_schema_attributes[set_attr_schema],\nrow,\n)\nset_attr_type = set_schema_attributes[\nset_attr_schema\n][\"type\"]\nlogger.debug(\n\"Set Attribute Type -&gt; %s (row -&gt; %s)\",\nset_attr_type,\nrow,\n)\nset_attr_name = set_schema_attributes[\nset_attr_schema\n][\"title\"]\nlogger.debug(\n\"Set Attribute Name -&gt; %s (row -&gt; %s)\",\nset_attr_name,\nrow,\n)\n# Lookup the attribute with the right category, set, attribute name, and row number in payload:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand \"set\"\nin item  # not all items may have a \"set\" key\nand item[\"set\"] == set_name\nand item[\"attribute\"] == set_attr_name\nand \"row\"\nin item  # not all items may have a \"row\" key\nand item[\"row\"] == row\n)\n),\nNone,\n)\nif attribute is None:\nlogger.warning(\n\"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s not found in payload.\",\nset_name,\nset_attr_name,\nrow,\n)\n# need to use row - 1 as index starts with 0 but payload rows start with 1\nset_data_attributes[row - 1][\nset_attr_schema\n] = \"\"\nelse:\nlogger.info(\n\"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s found in payload, value -&gt; %s\",\nset_name,\nset_attr_name,\nrow,\nattribute[\"value\"],\n)\n# Put the value from the payload into data structure\n# need to use row - 1 as index starts with 0 but payload rows start with 1\nset_data_attributes[row - 1][\nset_attr_schema\n] = attribute[\"value\"]\nrow += 1  # continue the while loop with the next row\n# Check if it is single-line set:\nelif attr_type == \"object\":\nset_name = schema_attributes[attr_schema][\"title\"]\nlogger.info(\"Single-line Set -&gt; %s\", set_name)\nset_data_attributes = data_attributes[attr_data]\nlogger.debug(\n\"Set Data Attributes -&gt; %s\", set_data_attributes\n)\nset_schema_attributes = schema_attributes[attr_schema][\n\"properties\"\n]\nlogger.debug(\n\"Set Schema Attributes -&gt; %s\", set_schema_attributes\n)\nfor set_attr_data, set_attr_schema in zip(\nset_data_attributes, set_schema_attributes\n):\nlogger.debug(\"Set Attribute ID -&gt; %s\", set_attr_data)\nlogger.debug(\n\"Set Attribute Data -&gt; %s\",\nset_data_attributes[set_attr_data],\n)\nlogger.debug(\n\"Set Attribute Schema -&gt; %s\",\nset_schema_attributes[set_attr_schema],\n)\nset_attr_type = set_schema_attributes[set_attr_schema][\n\"type\"\n]\nlogger.debug(\"Set Attribute Type -&gt; %s\", set_attr_type)\nset_attr_name = set_schema_attributes[set_attr_schema][\n\"title\"\n]\nlogger.debug(\"Set Attribute Name -&gt; %s\", set_attr_name)\n# Lookup the attribute with the right category, set and attribute name in payload:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand \"set\"\nin item  # not all items may have a \"set\" key\nand item[\"set\"] == set_name\nand item[\"attribute\"] == set_attr_name\n)\n),\nNone,\n)\nif attribute is None:\nlogger.warning(\n\"Set -&gt; %s, Attribute -&gt; %s not found in payload.\",\nset_name,\nset_attr_name,\n)\nset_data_attributes[set_attr_data] = \"\"\nelse:\nlogger.info(\n\"Set -&gt; %s, Attribute -&gt; %s found in payload, value -&gt; %s\",\nset_name,\nset_attr_name,\nattribute[\"value\"],\n)\n# Put the value from the payload into data structure\nset_data_attributes[set_attr_data] = attribute[\n\"value\"\n]\n# It is a plain attribute (not inside a set) or it is a multi-value attribute (not inside a set):\nelse:\nattr_name = schema_attributes[attr_schema][\"title\"]\nlogger.debug(\"Attribute Name -&gt; %s\", attr_name)\n# Lookup the attribute with the right category and attribute name in payload:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand item[\"attribute\"] == attr_name\n)\n),\nNone,\n)\nif attribute is None:\nlogger.warning(\n\"Attribute -&gt; %s not found in payload.\", attr_name\n)\ndata_attributes[attr_data] = \"\"\nelse:\nlogger.info(\n\"Attribute -&gt; %s found in payload, value -&gt; %s\",\nattr_name,\nattribute[\"value\"],\n)\n# We need to handle a very special case here for Extended ECM for Government\n# which has an attribute type \"Organizational Unit\" (OU). This is referring to a group ID\n# which is not stable across deployments. So we need to lookup the Group ID and add it\n# to the data structure. This expects that the payload has the Group Name and not the Group ID\nif attr_type == str(11480):\nlogger.info(\n\"Attribute -&gt; %s is is of type -&gt; Organizational Unit (%s). Looking up group ID for group name -&gt; %s\",\nattr_name,\nattr_type,\nattribute[\"value\"],\n)\ngroup = self._otcs.get_group(attribute[\"value\"])\ngroup_id = self._otcs.lookup_result_value(\ngroup, \"name\", attribute[\"value\"], \"id\"\n)\nif group_id:\nlogger.info(\n\"Group for Organizational Unit -&gt; %s has ID -&gt; %s\",\nattribute[\"value\"],\ngroup_id,\n)\n# Put the group ID into data structure\ndata_attributes[attr_data] = str(group_id)\nelse:\nlogger.error(\n\"Group for Organizational Unit -&gt; %s does not exist!\",\nattribute[\"value\"],\n)\n# Clear the value to avoid workspace create failure\ndata_attributes[attr_data] = \"\"\n# handle special case where attribute type is a user picker.\n# we expect that the payload includes the login name for this\n# (as user IDs are not stable across systems) but then we need\n# to lookup the real user ID here:\nelif attr_type == \"otcs_user_picker\":\nlogger.info(\n\"Attribute -&gt; %s is is of type -&gt; User Picker (%s). Looking up user ID for user login name -&gt; %s\",\nattr_name,\nattr_type,\nattribute[\"value\"],\n)\nuser = self._otcs.get_user(attribute[\"value\"])\nuser_id = self._otcs.lookup_result_value(\nresponse=user,\nkey=\"name\",\nvalue=attribute[\"value\"],\nreturn_key=\"id\",\n)\nif user_id:\n# User has been found - determine ID:\nlogger.info(\n\"User -&gt; %s has ID -&gt; %s\",\nattribute[\"value\"],\nuser_id,\n)\n# Put the user ID into data structure\ndata_attributes[attr_data] = str(user_id)\nelse:\nlogger.error(\n\"User with login name -&gt; %s does not exist!\",\nattribute[\"value\"],\n)\n# Clear the value to avoid workspace create failure\ndata_attributes[attr_data] = \"\"\nelse:\n# Put the value from the payload into data structure\ndata_attributes[attr_data] = attribute[\"value\"]\ncategory_create_data[\"categories\"][cat_data] = data_attributes\nlogger.debug(\"Category Create Data -&gt; %s\", category_create_data)\n# Create the workspace with all provided information:\nresponse = self._otcs.create_workspace(\ntemplate_id,\nname,\ndescription,\nworkspace_type_id,\ncategory_create_data,\next_system_id,\nbo_type,\nbo_id,\nparent_workspace_node_id,\n)\nif response is None:\nlogger.error(\"Failed to create workspace -&gt; %s\", name)\nsuccess = False\ncontinue\n# Now we add the node ID of the new workspace to the payload data structure\n# This will be reused when creating the workspace relationships!\nworkspace[\"nodeId\"] = self._otcs.get_result_value(response, \"id\")\n# We also get the name the workspace was finally created with.\n# This can be different form the name in the payload as additional\n# naming conventions from the Workspace Type definitions may apply.\n# This is important to make the python container idem-potent.\nresponse = self._otcs.get_workspace(workspace[\"nodeId\"])\nworkspace[\"name\"] = self._otcs.get_result_value(response, \"name\")\nlogger.info(\n\"Successfully created workspace with final name -&gt; %s and node ID -&gt; %s\",\nworkspace[\"name\"],\nworkspace[\"nodeId\"],\n)\n# Check if there's an workspace icon/image configured:\nif \"image_nickname\" in workspace:\nimage_nickname = workspace[\"image_nickname\"]\nresponse = self._otcs.get_node_from_nickname(image_nickname)\nnode_id = self._otcs.get_result_value(response, \"id\")\nif node_id:\nmime_type = self._otcs.get_result_value(response, \"mime_type\")\nif not mime_type:\nlogger.warning(\n\"Missing mime type information - assuming image/png\"\n)\nmime_type = \"image/png\"\nfile_path = \"/tmp/\" + image_nickname\nself._otcs.download_document(node_id=node_id, file_path=file_path)\nresponse = self._otcs.update_workspace_icon(\nworkspace_id=workspace[\"nodeId\"],\nfile_path=file_path,\nfile_mimetype=mime_type,\n)\nif not response:\nlogger.error(\n\"Failed to assign icon -&gt; %s to workspace -&gt; %s from file -&gt; %s \",\nimage_nickname,\nname,\nfile_path,\n)\nelse:\nlogger.error(\n\"Cannot find workspace image with nickname -&gt; %s for workspace -&gt; %s\",\nimage_nickname,\nname,\n)\n# Check if an RM classification is specified for the workspace:\n# RM Classification is specified as list of path elements (top-down)\nif (\n\"rm_classification_path\" in workspace\nand workspace[\"rm_classification_path\"] != []\n):\nrm_class_node = self._otcs.get_node_by_volume_and_path(\n198, workspace[\"rm_classification_path\"]\n)\nrm_class_node_id = self._otcs.get_result_value(rm_class_node, \"id\")\nif rm_class_node_id:\nresponse = self._otcs.assign_rm_classification(\nworkspace[\"nodeId\"], rm_class_node_id, False\n)\nif response is None:\nlogger.error(\n\"Failed to assign RM classification -&gt; %s (%s) to workspace -&gt; %s\",\nworkspace[\"rm_classification_path\"][-1],\nrm_class_node_id,\nname,\n)\nelse:\nlogger.info(\n\"Assigned RM Classification -&gt; %s to workspace -&gt; %s\",\nworkspace[\"rm_classification_path\"][-1],\nname,\n)\n# Check if one or multiple classifications are specified for the workspace\n# Classifications are specified as list of path elements (top-down)\nif (\n\"classification_pathes\" in workspace\nand workspace[\"classification_pathes\"] != []\n):\nfor classification_path in workspace[\"classification_pathes\"]:\nclass_node = self._otcs.get_node_by_volume_and_path(\n198, classification_path\n)\nclass_node_id = self._otcs.get_result_value(class_node, \"id\")\nif class_node_id:\nresponse = self._otcs.assign_classification(\nworkspace[\"nodeId\"], [class_node_id], False\n)\nif response is None:\nlogger.error(\n\"Failed to assign classification -&gt; %s to workspace -&gt; %s\",\nclass_node_id,\nname,\n)\nelse:\nlogger.info(\n\"Assigned Classification -&gt; %s to workspace -&gt; %s\",\nclassification_path[-1],\nname,\n)\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n# end method definition\ndef process_workspace_relationships(\nself, section_name: str = \"workspaceRelationships\"\n) -&gt; bool:\n\"\"\"Process workspaces relationships in payload and create them in Extended ECM.\n        Relationships can only be created if all workspaces have been created before.\n        Once a workspace got created, the node ID of that workspaces has been added\n        to the payload[\"workspaces\"] data structure (see process_workspaces())\n        Relationships are created between the node IDs of two business workspaces\n        (and not the logical IDs in the inital payload specification)\n        Args:\n            section_name (str, optional): name of the section.\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload:\nif not \"name\" in workspace:\ncontinue\nname = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n)\ncontinue\n# Read relationships from payload:\nif not \"relationships\" in workspace:\nlogger.info(\n\"Workspace -&gt; %s has no relationships. Skipping to next workspace...\",\nname,\n)\ncontinue\n# Check that workspaces actually have a logical ID -\n# otherwise we cannot establish the relationship:\nif not \"id\" in workspace:\nlogger.warning(\n\"Workspace without ID cannot have a relationship. Skipping to next workspace...\"\n)\ncontinue\nworkspace_id = workspace[\"id\"]\nlogger.info(\"Workspace -&gt; %s has relationships - creating...\", name)\nworkspace_node_id = self.determine_workspace_id(workspace)\nif not workspace_node_id:\nlogger.warning(\n\"Workspace without node ID cannot have a relationship (workspace creation may have failed). Skipping to next workspace...\"\n)\ncontinue\n# now determine the actual node IDs of the workspaces (have been created above):\nlogger.info(\n\"Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\nworkspace_id,\nworkspace_node_id,\n)\nfor related_workspace_id in workspace[\"relationships\"]:\n# Find the workspace type with the name given in the payload:\nrelated_workspace = next(\n(\nitem\nfor item in self._workspaces\nif item[\"id\"] == related_workspace_id\n),\nNone,\n)\nif related_workspace is None:\nlogger.error(\n\"Related Workspace with logical ID -&gt; %s not found.\",\nrelated_workspace_id,\n)\nsuccess = False\ncontinue\nif \"enabled\" in related_workspace and not related_workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Related Workspace -&gt; %s is disabled. Skipping...\",\nrelated_workspace[\"name\"],\n)\ncontinue\nrelated_workspace_node_id = self.determine_workspace_id(\nrelated_workspace\n)\nif not related_workspace_node_id:\nlogger.warning(\n\"Related Workspace without node ID (workspaces creation may have failed). Skipping to next workspace...\"\n)\ncontinue\nlogger.info(\n\"Related Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\nrelated_workspace_id,\nrelated_workspace_node_id,\n)\nlogger.info(\n\"Create Workspace Relationship between workspace node ID -&gt; %s and workspace node ID -&gt; %s\",\nworkspace_node_id,\nrelated_workspace_node_id,\n)\n# Check if relationship does already exists:\nresponse = self._otcs.get_workspace_relationships(workspace_node_id)\nexisting_workspace_relationship = self._otcs.exist_result_item(\nresponse, \"id\", related_workspace_node_id\n)\nif existing_workspace_relationship:\nlogger.info(\n\"Workspace relationship between workspace ID -&gt; %s and related workspace ID -&gt; %s does already exist. Skipping...\",\nworkspace_node_id,\nrelated_workspace_node_id,\n)\ncontinue\nresponse = self._otcs.create_workspace_relationship(\nworkspace_node_id, related_workspace_node_id\n)\nif not response:\nlogger.error(\"Failed to create workspace relationship.\")\nsuccess = False\nelse:\nlogger.info(\"Successfully created workspace relationship.\")\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n# end method definition\ndef process_workspace_members(self, section_name: str = \"workspaceMembers\") -&gt; bool:\n\"\"\"Process workspaces members in payload and create them in Extended ECM.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload (just for logging):\nif not \"name\" in workspace:\ncontinue\nworkspace_name = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\",\nworkspace_name,\n)\ncontinue\n# Read members from payload:\nif not \"members\" in workspace:\nlogger.info(\n\"Workspace -&gt; %s has no members in payload. Skipping to next workspace...\",\nworkspace_name,\n)\ncontinue\nmembers = workspace[\"members\"]\nworkspace_id = workspace[\"id\"]\nlogger.info(\n\"Workspace -&gt; %s has memberships in payload - establishing...\",\nworkspace_name,\n)\nworkspace_node_id = int(self.determine_workspace_id(workspace))\nif not workspace_node_id:\nlogger.warning(\n\"Workspace without node ID cannot have members (workspaces creation may have failed). Skipping to next workspace...\"\n)\ncontinue\n# now determine the actual node IDs of the workspaces (have been created by process_workspaces()):\nworkspace_node = self._otcs.get_node(workspace_node_id)\nworkspace_owner_id = self._otcs.get_result_value(\nworkspace_node, \"owner_user_id\"\n)\nworkspace_owner_name = self._otcs.get_result_value(workspace_node, \"owner\")\nworkspace_roles = self._otcs.get_workspace_roles(workspace_node_id)\nif workspace_roles is None:\nlogger.info(\n\"Workspace with ID -&gt; %s and node Id -&gt; %s has no roles. Skipping to next workspace...\",\nworkspace_id,\nworkspace_node_id,\n)\ncontinue\n# We don't want the workspace creator to be in the leader role\n# of automatically created workspaces - this can happen because the\n# creator gets added to the leader role automatically:\nleader_role_id = self._otcs.lookup_result_value(\nworkspace_roles, \"leader\", True, \"id\"\n)\nif leader_role_id:\nleader_role_name = self._otcs.lookup_result_value(\nworkspace_roles, \"leader\", True, \"name\"\n)\nresponse = self._otcs.remove_member_from_workspace(\nworkspace_node_id, leader_role_id, workspace_owner_id, False\n)\nif response:\nlogger.info(\n\"Removed creator user -&gt; %s (%s) from leader role -&gt; {%s (%s) of workspace -&gt; %s\",\nworkspace_owner_name,\nworkspace_owner_id,\nleader_role_name,\nleader_role_id,\nworkspace_name,\n)\nlogger.info(\n\"Adding members to workspace with ID -&gt; %s and node ID -&gt; %s defined in payload...\",\nworkspace_id,\nworkspace_node_id,\n)\nfor member in members:\n# read user list and role name from payload:\nmember_users = (\nmember[\"users\"] if member.get(\"users\") else []\n)  # be careful to avoid key errors as users are optional\nmember_groups = (\nmember[\"groups\"] if member.get(\"groups\") else []\n)  # be careful to avoid key errors as groups are optional\nmember_role_name = member[\"role\"]\nif member_role_name == \"\":  # role name is required\nlogger.error(\n\"Members of workspace -&gt; %s is missing the role name.\",\nworkspace_name,\n)\nsuccess = False\ncontinue\nif (\nmember_users == [] and member_groups == []\n):  # we either need users or groups (or both)\nlogger.warning(\n\"Role -&gt; %s of workspace -&gt; %s does not have any members (no users nor groups).\",\nmember_role_name,\nworkspace_name,\n)\ncontinue\nrole_id = self._otcs.lookup_result_value(\nworkspace_roles, \"name\", member_role_name, \"id\"\n)\nif role_id is None:\n#    if member_role is None:\nlogger.error(\n\"Workspace -&gt; %s does not have a role with name -&gt; %s\",\nworkspace_name,\nmember_role_name,\n)\nsuccess = False\ncontinue\nlogger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n# Process users as workspaces members:\nfor member_user in member_users:\n# find member user in current payload:\nmember_user_id = next(\n(item for item in self._users if item[\"name\"] == member_user),\n{},\n)\nif member_user_id:\nuser_id = member_user_id[\"id\"]\nelse:\n# If this didn't work, try to get the member user from OTCS. This covers\n# cases where the user is system generated or part\n# of a former payload processing (thus not in the current payload):\nlogger.info(\n\"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\nmember_user,\n)\nresponse = self._otcs.get_user(member_user)\nuser_id = self._otcs.lookup_result_value(\nresponse, key=\"name\", value=member_user, return_key=\"id\"\n)\nif not user_id:\nlogger.error(\n\"Cannot find member user with login -&gt; %s. Skipping...\",\nmember_user,\n)\ncontinue\n# Add member if it does not yet exists - suppress warning\n# message if user is already in role:\nresponse = self._otcs.add_member_to_workspace(\nworkspace_node_id, int(role_id), user_id, False\n)\nif response is None:\nlogger.error(\n\"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_user,\nuser_id,\nmember_role_name,\nworkspace_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_user,  # member_user_id[\"name\"],\nuser_id,\nmember_role_name,\nworkspace_name,\n)\n# Process groups as workspaces members:\nfor member_group in member_groups:\nmember_group_id = next(\n(item for item in self._groups if item[\"name\"] == member_group),\nNone,\n)\nif member_group_id is None:\nlogger.error(\"Cannot find group with name -&gt; %s\", member_group)\nsuccess = False\ncontinue\ngroup_id = member_group_id[\"id\"]\nresponse = self._otcs.add_member_to_workspace(\nworkspace_node_id, int(role_id), group_id\n)\nif response is None:\nlogger.error(\n\"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\nworkspace_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\nworkspace_name,\n)\n# Optionally the payload may have a permission list for the role\n# to change the default permission from the workspace template\n# to something more specific:\nmember_permissions = member.get(\"permissions\", [])\nif member_permissions == []:\nlogger.info(\n\"No permission change for workspace -&gt; %s and role -&gt; %s.\",\nworkspace_name,\nmember_role_name,\n)\ncontinue\nlogger.info(\n\"Update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s\",\nworkspace_name,\nstr(workspace_node_id),\nmember_role_name,\nstr(member_permissions),\n)\nresponse = self._otcs.assign_permission(\nnode_id=workspace_node_id,\nassignee_type=\"custom\",\nassignee=role_id,\npermissions=member_permissions,\napply_to=2,\n)\nif not response:\nlogger.error(\n\"Failed to update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s.\",\nworkspace_name,\nstr(workspace_node_id),\nmember_role_name,\nstr(member_permissions),\n)\nsuccess = False\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n# end method definition\ndef process_workspace_aviators(\nself, section_name: str = \"workspaceAviators\"\n) -&gt; bool:\n\"\"\"Process workspaces Content Aviator settings in payload and enable Aviator for selected workspaces.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload (just for logging):\nif not \"name\" in workspace:\ncontinue\nworkspace_name = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\",\nworkspace_name,\n)\ncontinue\n# Read Aviator setting from payload:\nif not \"enable_aviator\" in workspace or not workspace[\"enable_aviator\"]:\nlogger.info(\n\"Aviator is not enabled for Workspace -&gt; %s. Skipping to next workspace...\",\nworkspace_name,\n)\ncontinue\n# We cannot just lookup with workspace.get(\"nodeId\") as the customizer\n# may have been restarted inbetween - so we use our proper determine_workspace_id\n# here...\nworkspace_id = self.determine_workspace_id(workspace)\nif not workspace_id:\nlogger.error(\n\"Cannot find node ID for workspace -&gt; %s. Workspace creation may have failed. Skipping to next workspace...\",\nworkspace_name,\n)\nsuccess = False\ncontinue\n# Make code idem-potent and check if Aviator is already enabled\n# for this workspace:\nif self._otcs.check_workspace_aviator(workspace_id=workspace_id):\nlogger.info(\n\"Skip workspace -&gt; %s (%s) as Aviator is already enabled...\",\nworkspace_name,\nworkspace_id,\n)\ncontinue\n# Now enable the Content Aviator for the workspace:\nresponse = self._otcs.update_workspace_aviator(workspace_id, True)\nif not response:\nlogger.error(\n\"Failed to enable Content Aviator for workspace -&gt; %s (%s)\",\nworkspace_name,\nworkspace_id,\n)\nsuccess = False\ncontinue\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n# end method definition\ndef process_web_reports(\nself, web_reports: list, section_name: str = \"webReports\"\n) -&gt; bool:\n\"\"\"Process web reports in payload and run them in Extended ECM.\n        Args:\n            web_reports (list): list of web reports. As we have two different list (pre and post)\n                                we need to pass the actual list as parameter.\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"webReportsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not web_reports:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor web_report in web_reports:\nnick_name = web_report[\"nickname\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in web_report and not web_report[\"enabled\"]:\nlogger.info(\n\"Payload for Web Report -&gt; %s is disabled. Skipping...\", nick_name\n)\ncontinue\ndescription = web_report[\"description\"]\nif not self._otcs.get_node_from_nickname(nick_name):\nlogger.error(\n\"Web Report with nickname -&gt; %s does not exist! Skipping...\",\nnick_name,\n)\nsuccess = False\ncontinue\n# be careful to avoid key errors as Web Report parameters are optional:\nactual_params = (\nweb_report[\"parameters\"] if web_report.get(\"parameters\") else {}\n)\nformal_params = self._otcs.get_web_report_parameters(nick_name)\nif actual_params:\nlogger.info(\n\"Running Web Report -&gt; %s (%s) with parameters -&gt; %s ...\",\nnick_name,\ndescription,\nactual_params,\n)\n# Do some sanity checks to see if the formal and actual parameters are matching...\n# Check 1: are there formal parameters at all?\nif not formal_params:\nlogger.error(\n\"Web Report -&gt; %s is called with actual parameters but it does not expect parameters! Skipping...\",\nnick_name,\n)\nsuccess = False\ncontinue\nlets_continue = False\n# Check 2: Iterate through the actual parameters given in the payload\n# and see if there's a matching formal parameter expected by the Web Report:\nfor key, value in actual_params.items():\n# Check if there's a matching formal parameter defined on the Web Report node:\nformal_param = next(\n(item for item in formal_params if item[\"parm_name\"] == key),\nNone,\n)\nif formal_param is None:\nlogger.error(\n\"Web Report -&gt; %s is called with parameter -&gt; %s that is not expected! Value: %s) Skipping...\",\nnick_name,\nkey,\nvalue,\n)\nsuccess = False\nlets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n# Check 3: Iterate through the formal parameters and validate there's a matching\n# actual parameter defined in the payload for each mandatory formal parameter\n# that does not have a default value:\nfor formal_param in formal_params:\nif (\n(formal_param[\"mandatory\"] is True)\nand (formal_param[\"default_value\"] is None)\nand not actual_params.get(formal_param[\"parm_name\"])\n):\nlogger.error(\n\"Web Report -&gt; %s is called without mandatory parameter -&gt; %s! Skipping...\",\nnick_name,\nformal_param[\"parm_name\"],\n)\nsuccess = False\nlets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n# Did any of the checks fail?\nif lets_continue:\ncontinue\n# Actual parameters are validated, we can run the Web Report:\nresponse = self._otcs.run_web_report(nick_name, actual_params)\nelse:\nlogger.info(\n\"Running Web Report -&gt; %s (%s) without parameters...\",\nnick_name,\ndescription,\n)\n# Check if there's a formal parameter that is mandatory but\n# does not have a default value:\nif formal_params:\nrequired_param = next(\n(\nitem\nfor item in formal_params\nif (item[\"mandatory\"] is True)\nand (not item[\"default_value\"])\n),\nNone,\n)\nif required_param:\nlogger.error(\n\"Web Report -&gt; %s is called without parameters but has a mandatory parameter -&gt; %s without a default value! Skipping...\",\nnick_name,\nrequired_param[\"parm_name\"],\n)\nsuccess = False\ncontinue\nelse:  # we are good to proceed!\nlogger.debug(\n\"Web Report -&gt; %s does not have a mandatory parameter without a default value!\",\nnick_name,\n)\nresponse = self._otcs.run_web_report(nick_name)\nif response is None:\nlogger.error(\"Failed to run web report -&gt; %s\", nick_name)\nsuccess = False\nself.write_status_file(success, section_name, web_reports)\nreturn success\n# end method definition\ndef process_cs_applications(\nself, otcs_object: OTCS, section_name: str = \"csApplications\"\n) -&gt; bool:\n\"\"\"Process CS applications in payload and install them in Extended ECM.\n        The CS Applications need to be installed in all frontend and backends.\n        Args:\n            otcs_object (object): this can either be the OTCS frontend or OTCS backend. If None\n                                  then the otcs_backend is used.\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._cs_applications:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# OTCS backend is the default:\nif not otcs_object:\notcs_object = self._otcs_backend\nfor cs_application in self._cs_applications:\napplication_name = cs_application[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in cs_application and not cs_application[\"enabled\"]:\nlogger.info(\n\"Payload for CS Application -&gt; %s is disabled. Skipping...\",\napplication_name,\n)\ncontinue\napplication_description = cs_application[\"description\"]\nlogger.info(\n\"Install CS Application -&gt; %s (%s)...\",\napplication_name,\napplication_description,\n)\nresponse = otcs_object.install_cs_application(application_name)\nif response is None:\nlogger.error(\n\"Failed to install CS Application -&gt; %s!\", application_name\n)\nsuccess = False\nself.write_status_file(success, section_name, self._cs_applications)\nreturn success\n# end method definition\ndef process_user_settings(self, section_name: str = \"userSettings\") -&gt; bool:\n\"\"\"Process user settings in payload and apply themin OTDS.\n           This includes password settings and user display settings.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nuser_partition = self._otcs.config()[\"partition\"]\nif not user_partition:\nlogger.error(\"User partition not found!\")\nsuccess = False\ncontinue\n# Set the OTDS display name. Extended ECM does not use this but\n# it makes AppWorks display users correctly (and it doesn't hurt)\n# We only set this if firstname _and_ last name are in the payload:\nif \"firstname\" in user and \"lastname\" in user:\nuser_display_name = user[\"firstname\"] + \" \" + user[\"lastname\"]\nresponse = self._otds.update_user(\nuser_partition, user_name, \"displayName\", user_display_name\n)\nif response:\nlogger.info(\n\"Display name for user -&gt; %s has been updated to -&gt; %s\",\nuser_name,\nuser_display_name,\n)\nelse:\nlogger.error(\n\"Display name for user -&gt; %s could not be updated to -&gt; %s\",\nuser_name,\nuser_display_name,\n)\nsuccess = False\n# Don't enforce the user to reset password at first login (settings in OTDS):\nlogger.info(\"Don't enforce password change for user -&gt; %s...\", user_name)\nresponse = self._otds.update_user(\nuser_partition, user_name, \"UserMustChangePasswordAtNextSignIn\", \"False\"\n)\nif not response:\nsuccess = False\nresponse = self._otds.update_user(\nuser_partition, user_name, \"UserCannotChangePassword\", \"True\"\n)\nif not response:\nsuccess = False\n# Set user password to never expire\nresponse = self._otds.update_user(\nuser_partition, user_name, \"PasswordNeverExpires\", \"True\"\n)\nif not response:\nsuccess = False\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_user_favorites_and_profiles(\nself, section_name: str = \"userFavoritesAndProfiles\"\n) -&gt; bool:\n\"\"\"Process user favorites in payload and create them in Extended ECM.\n           This method also simulates browsing the favorites to populate the\n           widgets on the landing pages and sets personal preferences.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# We can only set favorites if we impersonate / authenticate as the user.\n# The following code (for loop) will change the authenticated user - we need to\n# switch it back to admin user later so we safe the admin credentials for this:\nif self._users:\n# save admin credentials for later switch back to admin user:\nadmin_credentials = self._otcs.credentials()\nelse:\nadmin_credentials = {}\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nuser_password = user[\"password\"]\n# we change the otcs credentials to the user:\nself._otcs.set_credentials(user_name, user_password)\n# we re-authenticate as the user:\nlogger.info(\"Authenticate user -&gt; %s...\", user_name)\n# True = force new login with new user\ncookie = self._otcs.authenticate(\nrevalidate=True, force_user_password_login=True\n)\nif not cookie:\nlogger.error(\"Couldn't authenticate user -&gt; %s\", user_name)\nsuccess = False\ncontinue\n# we update the user profile to activate responsive (dynamic) containers:\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for user -&gt; %s couldn't be updated with responsive container mode'!\",\nuser_name,\n)\nelse:\nlogger.info(\n\"Profile for user -&gt; %s has been updated to enable responsive container mode.\",\nuser_name,\n)\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMessageMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for user -&gt; %s couldn't be updated with responsive container message mode'!\",\nuser_name,\n)\nelse:\nlogger.info(\n\"Profile for user -&gt; %s has been updated to enable messages for responsive container mode.\",\nuser_name,\n)\n# we work through the list of favorites defined for the user:\nfavorites = user[\"favorites\"]\nfor favorite in favorites:\n# check if favorite is a logical workspace name\nfavorite_item = next(\n(item for item in self._workspaces if item[\"id\"] == favorite), None\n)\nis_workspace = False\nif favorite_item:\nlogger.info(\n\"Found favorite item (workspace) in payload -&gt; %s\",\nfavorite_item[\"name\"],\n)\nfavorite_id = self.determine_workspace_id(favorite_item)\nif not favorite_id:\nlogger.warning(\n\"Workspace of type -&gt; %s and name -&gt; %s does not exist. Cannot create favorite. Skipping...\",\nfavorite_item[\"type_name\"],\nfavorite_item[\"name\"],\n)\ncontinue\nis_workspace = True\nelse:\n# alternatively try to find the item as a nickname:\nfavorite_item = self._otcs.get_node_from_nickname(favorite)\nfavorite_id = self._otcs.get_result_value(favorite_item, \"id\")\n#                    if favorite_item is None:\nif favorite_id is None:\nlogger.warning(\n\"Favorite -&gt; %s neither found as workspace ID nor as nickname. Skipping to next favorite...\",\nfavorite,\n)\ncontinue\nresponse = self._otcs.add_favorite(favorite_id)\nif response is None:\nlogger.warning(\n\"Favorite ID -&gt; %s couldn't be added for user -&gt; %s!\",\nfavorite_id,\nuser_name,\n)\nelse:\nlogger.info(\n\"Added favorite for user -&gt; %s, node ID -&gt; %s.\",\nuser_name,\nfavorite_id,\n)\nlogger.info(\n\"Simulate user -&gt; %s browsing node ID -&gt; %s.\",\nuser_name,\nfavorite_id,\n)\n# simulate a browse by the user to populate recently accessed items\nif is_workspace:\nresponse = self._otcs.get_workspace(favorite_id)\nelse:\nresponse = self._otcs.get_node(favorite_id)\n# we work through the list of proxies defined for the user\n# (we need to consider that not all users have the proxies element):\nproxies = user[\"proxies\"] if user.get(\"proxies\") else []\nfor proxy in proxies:\nproxy_user = next(\n(item for item in self._users if item[\"name\"] == proxy),\nNone,\n)\nif not proxy_user or not \"id\" in proxy_user:\nlogger.error(\n\"The proxy -&gt; %s for user -&gt; %s does not exist! Skipping proxy...\",\nproxy,\nuser_name,\n)\nsuccess = False\ncontinue\nproxy_user_id = proxy_user[\"id\"]\n# Check if the proxy is already set:\nif not self._otcs.is_proxy(proxy):\nlogger.info(\n\"Set user -&gt; %s (%s) as proxy for user -&gt; %s.\",\nproxy,\nproxy_user_id,\nuser_name,\n)\n# set the user proxy - currently we don't support time based proxies in payload.\n# The called method is ready to support this.\nresponse = self._otcs.add_user_proxy(proxy_user_id)\nelse:\nlogger.info(\n\"User -&gt; %s (%s) is already proxy for user -&gt; %s. Skipping...\",\nproxy,\nproxy_user_id,\nuser_name,\n)\nif self._users:\n# Set back admin credentials:\nself._otcs.set_credentials(\nadmin_credentials[\"username\"], admin_credentials[\"password\"]\n)\n# we re-authenticate as the admin user:\nlogger.info(\n\"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\n# Also for the admin user we want to update the user profile to activate responsive (dynamic) containers:\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for admin user couldn't be updated with responsive container mode'!\",\n)\nelse:\nlogger.info(\n\"Profile for admin user has been updated to enable responsive container mode.\",\n)\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMessageMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for admin user couldn't be updated with responsive container message mode'!\",\n)\nelse:\nlogger.info(\n\"Profile for admin user has been updated to enable messages for responsive container mode.\",\n)\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_security_clearances(\nself, section_name: str = \"securityClearances\"\n) -&gt; bool:\n\"\"\"Process Security Clearances for Extended ECM.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._security_clearances:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor security_clearance in self._security_clearances:\nclearance_level = security_clearance.get(\"level\")\nclearance_name = security_clearance.get(\"name\")\nif \"enabled\" in security_clearance and not security_clearance[\"enabled\"]:\nlogger.info(\n\"Payload for Security Clearance -&gt; %s is disabled. Skipping...\",\nclearance_name,\n)\ncontinue\nclearance_description = security_clearance.get(\"description\")\nif not clearance_description:\nclearance_description = \"\"\nif clearance_level and clearance_name:\nlogger.info(\n\"Creating Security Clearance -&gt; %s : %s\",\nclearance_level,\nclearance_name,\n)\nself._otcs.run_web_report(\n\"web_report_security_clearance\", security_clearance\n)\nelse:\nlogger.error(\n\"Cannot create Security Clearance - either level or name is missing!\"\n)\nsuccess = False\nself.write_status_file(success, section_name, self._security_clearances)\nreturn success\n# end method definition\ndef process_supplemental_markings(\nself, section_name: str = \"supplementalMarkings\"\n) -&gt; bool:\n\"\"\"Process Supplemental Markings for Extended ECM.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._supplemental_markings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor supplemental_marking in self._supplemental_markings:\ncode = supplemental_marking.get(\"code\")\nif (\n\"enabled\" in supplemental_marking\nand not supplemental_marking[\"enabled\"]\n):\nlogger.info(\n\"Payload for Supplemental Marking -&gt; %s is disabled. Skipping...\",\ncode,\n)\ncontinue\ndescription = supplemental_marking.get(\"description\")\nif not description:\ndescription = \"\"\nif code:\nlogger.info(\n\"Creating Supplemental Marking -&gt; %s : %s\", code, description\n)\nself._otcs.run_web_report(\n\"web_report_supplemental_marking\", supplemental_marking\n)\nelse:\nlogger.error(\n\"Cannot create Supplemental Marking - either code or description is missing!\"\n)\nsuccess = False\nself.write_status_file(success, section_name, self._supplemental_markings)\nreturn success\n# end method definition\ndef process_user_security(self, section_name: str = \"userSecurity\"):\n\"\"\"Process Security Clearance and Supplemental Markings for Extended ECM users.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor user in self._users:\nuser_id = user.get(\"id\")\nuser_name = user.get(\"name\")\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Read security clearance from user payload (it is optional!)\nuser_security_clearance = user.get(\"security_clearance\")\nif user_id and user_security_clearance:\nself._otcs.assign_user_security_clearance(\nuser_id, user_security_clearance\n)\n# Read supplemental markings from user payload (it is optional!)\nuser_supplemental_markings = user.get(\"supplemental_markings\")\nif user_id and user_supplemental_markings:\nself._otcs.assign_user_supplemental_markings(\nuser_id, user_supplemental_markings\n)\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_records_management_settings(\nself, section_name: str = \"recordsManagementSettings\"\n) -&gt; bool:\n\"\"\"Process Records Management Settings for Extended ECM.\n        The setting files need to be placed in the OTCS file system file via\n        a transport into the Support Asset Volume.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._records_management_settings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nif (\n\"records_management_system_settings\" in self._records_management_settings\nand self._records_management_settings[\"records_management_system_settings\"]\n!= \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\n\"records_management_system_settings\"\n]\n)\nresponse = self._otcs.import_records_management_settings(filename)\nif not response:\nsuccess = False\nif (\n\"records_management_codes\" in self._records_management_settings\nand self._records_management_settings[\"records_management_codes\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"records_management_codes\"]\n)\nresponse = self._otcs.import_records_management_codes(filename)\nif not response:\nsuccess = False\nif (\n\"records_management_rsis\" in self._records_management_settings\nand self._records_management_settings[\"records_management_rsis\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"records_management_rsis\"]\n)\nresponse = self._otcs.import_records_management_rsis(filename)\nif not response:\nsuccess = False\nif (\n\"physical_objects_system_settings\" in self._records_management_settings\nand self._records_management_settings[\"physical_objects_system_settings\"]\n!= \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"physical_objects_system_settings\"]\n)\nresponse = self._otcs.import_physical_objects_settings(filename)\nif not response:\nsuccess = False\nif (\n\"physical_objects_codes\" in self._records_management_settings\nand self._records_management_settings[\"physical_objects_codes\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"physical_objects_codes\"]\n)\nresponse = self._otcs.import_physical_objects_codes(filename)\nif not response:\nsuccess = False\nif (\n\"physical_objects_locators\" in self._records_management_settings\nand self._records_management_settings[\"physical_objects_locators\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"physical_objects_locators\"]\n)\nresponse = self._otcs.import_physical_objects_locators(filename)\nif not response:\nsuccess = False\nif (\n\"security_clearance_codes\" in self._records_management_settings\nand self._records_management_settings[\"security_clearance_codes\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"security_clearance_codes\"]\n)\nresponse = self._otcs.import_security_clearance_codes(filename)\nif not response:\nsuccess = False\nself.write_status_file(success, section_name, self._records_management_settings)\nreturn success\n# end method definition\ndef process_holds(self, section_name: str = \"holds\") -&gt; bool:\n\"\"\"Process Records Management Holds for Extended ECM users.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._holds:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor hold in self._holds:\nif not \"name\" in hold:\nlogger.error(\"Cannot create Hold without a name! Skipping...\")\ncontinue\nhold_name = hold[\"name\"]\nif not \"type\" in hold:\nlogger.error(\n\"Cannot create Hold -&gt; %s without a type! Skipping...\", hold_name\n)\nsuccess = False\ncontinue\nhold_type = hold[\"type\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in hold and not hold[\"enabled\"]:\nlogger.info(\n\"Payload for Hold -&gt; %s is disabled. Skipping...\", hold_name\n)\ncontinue\nhold_group = hold.get(\"group\")\nhold_comment = hold.get(\"comment\")\nhold_alternate_id = hold.get(\"alternate_id\")\nhold_date_applied = hold.get(\"date_applied\")\nhold_date_suspend = hold.get(\"date_to_remove\")\n# 550 is the RM Volume\nresponse = self._otcs.get_node_by_volume_and_path(550, [\"Hold Maintenance\"])\nif not response:\nlogger.error(\"Cannot find Records Management Volume!\")\ncontinue\nholds_maintenance_id = self._otcs.get_result_value(response, \"id\")\nif not holds_maintenance_id:\nlogger.error(\n\"Cannot find Holds Maintenance folder in Records Management Volume!\"\n)\ncontinue\nif hold_group:\n# Check if the Hold Group (folder) does already exist.\nresponse = self._otcs.get_node_by_parent_and_name(\nholds_maintenance_id, hold_group\n)\nparent_id = self._otcs.get_result_value(response, \"id\")\nif not parent_id:\nresponse = self._otcs.create_item(\nholds_maintenance_id, \"833\", hold_group\n)\nparent_id = self._otcs.get_result_value(response, \"id\")\nif not parent_id:\nlogger.error(\"Failed to create hold group -&gt; %s\", hold_group)\ncontinue\nelse:\nparent_id = holds_maintenance_id\n# Holds are special - they ahve folders that cannot be traversed\n# in the normal way - we need to get the whole list of holds and use\n# specialparameters for the exist_result_items() method as the REST\n# API calls delivers a results-&gt;data-&gt;holds structure (not properties)\nresponse = self._otcs.get_records_management_holds()\nif self._otcs.exist_result_item(\nresponse, \"HoldName\", hold_name, property_name=\"holds\"\n):\nlogger.info(\"Hold -&gt; %s does already exist. Skipping...\", hold_name)\ncontinue\nhold = self._otcs.create_records_management_hold(\nhold_type,\nhold_name,\nhold_comment,\nhold_alternate_id,\nint(parent_id),\nhold_date_applied,\nhold_date_suspend,\n)\nif hold and hold[\"holdID\"]:\nlogger.info(\n\"Successfully created hold -&gt; %s with ID -&gt; %s\",\nhold_name,\nhold[\"holdID\"],\n)\nelse:\nsuccess = False\nself.write_status_file(success, section_name, self._holds)\nreturn success\n# end method definition\ndef process_additional_group_members(\nself, section_name: str = \"additionalGroupMemberships\"\n) -&gt; bool:\n\"\"\"Process additional groups memberships we want to have in OTDS.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._additional_group_members:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor additional_group_member in self._additional_group_members:\nif not \"parent_group\" in additional_group_member:\nlogger.error(\"Missing parent_group! Skipping...\")\ncontinue\nparent_group = additional_group_member[\"parent_group\"]\nif (\n\"enabled\" in additional_group_member\nand not additional_group_member[\"enabled\"]\n):\nlogger.info(\n\"Payload for Additional Group Member with Parent Group -&gt; %s is disabled. Skipping...\",\nparent_group,\n)\ncontinue\nif (not \"user_name\" in additional_group_member) and (\nnot \"group_name\" in additional_group_member\n):\nlogger.error(\n\"Either group_name or user_name need to be specified! Skipping...\"\n)\nsuccess = False\ncontinue\nif \"group_name\" in additional_group_member:\ngroup_name = additional_group_member[\"group_name\"]\nlogger.info(\n\"Adding group -&gt; %s to parent group -&gt; %s in OTDS.\",\ngroup_name,\nparent_group,\n)\nresponse = self._otds.add_group_to_parent_group(\ngroup_name, parent_group\n)\nif not response:\nlogger.error(\n\"Failed to add group -&gt; %s to parent group -&gt; %s in OTDS.\",\ngroup_name,\nparent_group,\n)\nsuccess = False\nelif \"user_name\" in additional_group_member:\nuser_name = additional_group_member[\"user_name\"]\nlogger.info(\n\"Adding user -&gt; %s to group -&gt; %s in OTDS.\", user_name, parent_group\n)\nresponse = self._otds.add_user_to_group(user_name, parent_group)\nif not response:\nlogger.error(\n\"Failed to add user -&gt; %s to group -&gt; %s in OTDS.\",\nuser_name,\nparent_group,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._additional_group_members)\nreturn success\n# end method definition\ndef process_additional_access_role_members(\nself, section_name: str = \"additionalAccessRoleMemberships\"\n) -&gt; bool:\n\"\"\"Process additional access role memberships we want to have in OTDS.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._additional_access_role_members:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor additional_access_role_member in self._additional_access_role_members:\nif not \"access_role\" in additional_access_role_member:\nlogger.error(\"Missing access_role! Skipping...\")\ncontinue\naccess_role = additional_access_role_member[\"access_role\"]\nif (\n\"enabled\" in additional_access_role_member\nand not additional_access_role_member[\"enabled\"]\n):\nlogger.info(\n\"Payload for Additional Member for AccessRole -&gt; %s is disabled. Skipping...\",\naccess_role,\n)\ncontinue\nif (\n(not \"user_name\" in additional_access_role_member)\nand (not \"group_name\" in additional_access_role_member)\nand (not \"partition_name\" in additional_access_role_member)\n):\nlogger.error(\n\"Either group_name or user_name need to be specified! Skipping...\"\n)\nsuccess = False\ncontinue\nif \"group_name\" in additional_access_role_member:\ngroup_name = additional_access_role_member[\"group_name\"]\nlogger.info(\n\"Adding group -&gt; %s to access role -&gt; %s in OTDS.\",\ngroup_name,\naccess_role,\n)\nresponse = self._otds.add_group_to_access_role(access_role, group_name)\nif not response:\nlogger.error(\n\"Failed to add group -&gt; %s to access role -&gt; %s in OTDS.\",\ngroup_name,\naccess_role,\n)\nsuccess = False\nelif \"user_name\" in additional_access_role_member:\nuser_name = additional_access_role_member[\"user_name\"]\nlogger.info(\n\"Adding user -&gt; %s to access role -&gt; %s in OTDS.\",\nuser_name,\naccess_role,\n)\nresponse = self._otds.add_user_to_access_role(access_role, user_name)\nif not response:\nlogger.error(\n\"Failed to add user -&gt; %s to access role -&gt; %s in OTDS.\",\nuser_name,\naccess_role,\n)\nsuccess = False\nelif \"partition_name\" in additional_access_role_member:\npartition_name = additional_access_role_member[\"partition_name\"]\nlogger.info(\n\"Adding partition -&gt; %s to access role -&gt; %s in OTDS.\",\npartition_name,\naccess_role,\n)\nresponse = self._otds.add_partition_to_access_role(\naccess_role, partition_name\n)\nif not response:\nlogger.error(\n\"Failed to add partition -&gt; %s to access role -&gt; %s in OTDS.\",\npartition_name,\naccess_role,\n)\nsuccess = False\nself.write_status_file(\nsuccess, section_name, self._additional_access_role_members\n)\nreturn success\n# end method definition\ndef process_renamings(self, section_name: str = \"renamings\") -&gt; bool:\n\"\"\"Process renamings specified in payload and rename existing Extended ECM items.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._renamings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor renaming in self._renamings:\nif not \"nodeid\" in renaming:\nif not \"volume\" in renaming:\nlogger.error(\n\"Renamings require either a node ID or a volume! Skipping to next renaming...\"\n)\ncontinue\n# Determine object ID of volume:\nvolume = self._otcs.get_volume(renaming[\"volume\"])\nnode_id = self._otcs.get_result_value(volume, \"id\")\nelse:\nnode_id = renaming[\"nodeid\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in renaming and not renaming[\"enabled\"]:\nlogger.info(\"Payload for Renaming is disabled. Skipping...\")\ncontinue\nresponse = self._otcs.rename_node(\nint(node_id), renaming[\"name\"], renaming[\"description\"]\n)\nif not response:\nlogger.error(\n\"Failed to rename node ID -&gt; %s to new name -&gt; %s.\",\nnode_id,\nrenaming[\"name\"],\n)\nsuccess = False\nself.write_status_file(success, section_name, self._renamings)\nreturn success\n# end method definition\ndef process_items(self, items: list, section_name: str = \"items\") -&gt; bool:\n\"\"\"Process items specified in payload and create them in Extended ECM.\n        Args:\n            items (list): list of items to create (need this as parameter as we\n                          have multiple lists)\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"itemsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not items:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor item in items:\nif not \"name\" in item:\nlogger.error(\"Item needs a name. Skipping...\")\ncontinue\nitem_name = item[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in item and not item[\"enabled\"]:\nlogger.info(\n\"Payload for Item -&gt; %s is disabled. Skipping...\", item_name\n)\ncontinue\nif not \"description\" in item:\nitem_description = \"\"\nelse:\nitem_description = item[\"description\"]\nparent_nickname = item.get(\"parent_nickname\")\nparent_path = item.get(\"parent_path\")\nif parent_nickname:\nparent_node = self._otcs.get_node_from_nickname(parent_nickname)\nparent_id = self._otcs.get_result_value(parent_node, \"id\")\n# if not parent_node:\nif not parent_id:\nlogger.error(\n\"Item -&gt; %s has a parent nickname -&gt; %s that does not exist. Skipping...\",\nitem_name,\nparent_nickname,\n)\nsuccess = False\ncontinue\nelse:  # use parent_path and Enterprise Volume\nparent_node = self._otcs.get_node_by_volume_and_path(141, parent_path)\nparent_id = self._otcs.get_result_value(parent_node, \"id\")\nif not parent_id:\n# if not parent_node:\nlogger.error(\n\"Item -&gt; %s has a parent path that does not exist. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\noriginal_nickname = item.get(\"original_nickname\")\noriginal_path = item.get(\"original_path\")\nif original_nickname:\noriginal_node = self._otcs.get_node_from_nickname(original_nickname)\noriginal_id = self._otcs.get_result_value(original_node, \"id\")\nif not original_id:\n# if not original_node:\nlogger.error(\n\"Item -&gt; %s has a original nickname -&gt; %s that does not exist. Skipping...\",\nitem_name,\noriginal_nickname,\n)\nsuccess = False\ncontinue\nelif original_path:\noriginal_node = self._otcs.get_node_by_volume_and_path(\n141, original_path\n)\noriginal_id = self._otcs.get_result_value(original_node, \"id\")\nif not original_id:\n# if not original_node:\nlogger.error(\n\"Item -&gt; %s has a original path that does not exist. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\nelse:\noriginal_id = 0\nif not \"type\" in item:\nlogger.error(\"Item -&gt; %s needs a type. Skipping...\", item_name)\nsuccess = False\ncontinue\nitem_type = item.get(\"type\")\nitem_url = item.get(\"url\")\n# check that we have the required information\n# for the given item type:\nmatch item_type:\ncase 140:  # URL\nif item_url == \"\":\nlogger.error(\n\"Item -&gt; %s has type URL but the URL is not in the payload. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\ncase 1:  # Shortcut\nif original_id == 0:\nlogger.error(\n\"Item -&gt; %s has type Shortcut but the original item is not in the payload. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\n# Check if an item with the same name does already exist.\n# This can also be the case if the python container runs a 2nd time.\n# For this reason we are also not issuing an error but just an info (False):\nresponse = self._otcs.get_node_by_parent_and_name(\nint(parent_id), item_name, show_error=False\n)\nif self._otcs.get_result_value(response, \"name\") == item_name:\nlogger.info(\n\"Item with name -&gt; %s does already exist in parent folder with ID -&gt; %s\",\nitem_name,\nparent_id,\n)\ncontinue\nresponse = self._otcs.create_item(\nint(parent_id),\nstr(item_type),\nitem_name,\nitem_description,\nitem_url,\nint(original_id),\n)\nif not response:\nlogger.error(\"Failed to create item -&gt; %s.\", item_name)\nsuccess = False\nself.write_status_file(success, section_name, items)\nreturn success\n# end method definition\ndef process_permissions(\nself, permissions: list, section_name: str = \"permissions\"\n) -&gt; bool:\n\"\"\"Process items specified in payload and upadate permissions.\n        Args:\n            permissions (list): list of items to apply permissions to.\n                         Each list item in the payload is a dict with this structure:\n                            {\n                                nodeid = \"...\"\n                                volume = \"...\"\n                                nickname = \"...\"\n                                public_access_permissions = [\"see\", \"see_content\", ...]\n                                owner_permissions = []\n                                owner_group_permissions = []\n                                groups = [\n                                {\n                                    name = \"...\"\n                                    permissions = []\n                                }\n                                ]\n                                users = [\n                                {\n                                    name = \"...\"\n                                    permissions = []\n                                }\n                                ]\n                                apply_to = 2\n                            }\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections like \"permissionsPost\")\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not permissions:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor permission in permissions:\nif (\nnot \"path\" in permission\nand not \"volume\" in permission\nand not \"nickname\" in permission\n):\nlogger.error(\n\"Item to change permission is not specified (needs path, volume, or nickname). Skipping...\"\n)\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in permission and not permission[\"enabled\"]:\nlogger.info(\"Payload for Permission is disabled. Skipping...\")\ncontinue\nnode_id = 0\n# Check if \"volume\" is in payload and not empty string\n# we try to get the node ID from the volume type:\nif \"volume\" in permission and permission[\"volume\"]:\nvolume_type = permission[\"volume\"]\nlogger.info(\n\"Found volume type -&gt; %s in permission definition. Determine volume ID...\",\nvolume_type,\n)\nnode = self._otcs.get_volume(volume_type)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.error(\n\"Illegal volume -&gt; %s in permission specification. Skipping...\",\nvolume_type,\n)\nsuccess = False\ncontinue\nelse:\n# the following path block requires\n# a value for the volume - if it is\n# not specified we take the Enterprise Workspace (141):\nvolume_type = 141\n# Check if \"path\" is in payload and not empty list\n# (path can be combined with volume so we need to take volume into account):\nif \"path\" in permission and permission[\"path\"]:\npath = permission[\"path\"]\nlogger.info(\n\"Found path -&gt; %s in permission definition. Determine node ID...\",\npath,\n)\nnode = self._otcs.get_node_by_volume_and_path(volume_type, path)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.error(\"Path -&gt; %s does not exist. Skipping...\", path)\nsuccess = False\ncontinue\n# Check if \"nickname\" is in payload and not empty string:\nif \"nickname\" in permission and permission[\"nickname\"]:\nnickname = permission[\"nickname\"]\nlogger.info(\n\"Found nickname -&gt; %s in permission definition. Determine node ID...\",\nnickname,\n)\nnode = self._otcs.get_node_from_nickname(nickname)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.error(\"Nickname -&gt; {} does not exist. Skipping...\")\nsuccess = False\ncontinue\n# Now we should have a value for node_id:\nif not node_id:\nlogger.error(\"No node ID found! Skipping permission...\")\nsuccess = False\ncontinue\nnode_name = self._otcs.get_result_value(node, \"name\")\nlogger.info(\n\"Found node -&gt; %s with ID -&gt; %s to apply permission to.\",\nnode_name,\nnode_id,\n)\n# write node information back into payload\n# for better debugging\npermission[\"node_name\"] = node_name\npermission[\"node_id\"] = node_id\nif \"apply_to\" in permission:\napply_to = permission[\"apply_to\"]\nelse:\napply_to = 2  # make item + sub-items the default\n# 1. Process Owner Permissions (list canbe empty!)\nif \"owner_permissions\" in permission:\nowner_permissions = permission[\"owner_permissions\"]\nlogger.info(\n\"Update owner permissions for item -&gt; %s (%s) to -&gt; %s\",\nnode_name,\nstr(node_id),\nstr(owner_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"owner\", 0, owner_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update owner permissions for item -&gt; %s (%s).\",\nnode_name,\nstr(node_id),\n)\nsuccess = False\n# 2. Process Owner Group Permissions\nif \"owner_group_permissions\" in permission:\nowner_group_permissions = permission[\"owner_group_permissions\"]\nlogger.info(\n\"Update owner group permissions for item -&gt; %s (%s) to -&gt; %s\",\nnode_name,\nstr(node_id),\nstr(owner_group_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"group\", 0, owner_group_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update group permissions for item -&gt; %s (%s).\",\nnode_name,\nstr(node_id),\n)\nsuccess = False\n# 3. Process Public Permissions\nif \"public_permissions\" in permission:\npublic_permissions = permission[\"public_permissions\"]\nlogger.info(\n\"Update public permissions for item -&gt; %s (%s) to -&gt; %s\",\nnode_name,\nstr(node_id),\nstr(public_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"public\", 0, public_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update public permissions for item -&gt; %s (%s).\",\nstr(node_id),\nnode_name,\n)\nsuccess = False\ncontinue\n# 4. Process Assigned User Permissions (if specified and not empty)\nif \"users\" in permission and permission[\"users\"]:\nusers = permission[\"users\"]\nfor user in users:\nif not \"name\" in user or not \"permissions\" in user:\nlogger.error(\n\"Missing user name or permissions in user permission specificiation. Cannot set user permissions. Skipping...\"\n)\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\nuser_permissions = user[\"permissions\"]\nresponse = self._otcs.get_user(user_name, True)\nuser_id = self._otcs.get_result_value(response=response, key=\"id\")\nif not user_id:\nlogger.error(\n\"Cannot find user with name -&gt; %s; cannot set user permissions. Skipping user...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser[\"id\"] = user_id  # write ID back into payload\nlogger.info(\n\"Update permission of user -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\nuser_name,\nnode_name,\nstr(node_id),\nstr(user_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"custom\", user_id, user_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update assigned user permissions for item -&gt; %s.\",\nnode_id,\n)\nsuccess = False\n# 5. Process Assigned Group Permissions (if specified and not empty)\nif \"groups\" in permission and permission[\"groups\"]:\ngroups = permission[\"groups\"]\nfor group in groups:\nif not \"name\" in group or not \"permissions\" in group:\nlogger.error(\n\"Missing group name or permissions in group permission specificiation. Cannot set group permissions. Skipping...\"\n)\ncontinue\ngroup_name = group[\"name\"]\ngroup_permissions = group[\"permissions\"]\nlogger.info(\n\"Update permissions of group -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\ngroup_name,\nnode_name,\nstr(node_id),\nstr(group_permissions),\n)\notcs_group = self._otcs.get_group(group_name, True)\ngroup_id = self._otcs.get_result_value(otcs_group, \"id\")\nif not group_id:\nlogger.error(\n\"Cannot find group with name -&gt; %s; cannot set group permissions. Skipping group...\",\ngroup_name,\n)\nsuccess = False\ncontinue\ngroup[\"id\"] = group_id  # write ID back into payload\nresponse = self._otcs.assign_permission(\nint(node_id), \"custom\", group_id, group_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update assigned group permissions for item -&gt; %s (%s).\",\nnode_name,\nstr(node_id),\n)\nsuccess = False\nself.write_status_file(success, section_name, permissions)\nreturn success\n# end method definition\ndef process_assignments(self, section_name: str = \"assignments\") -&gt; bool:\n\"\"\"Process assignments specified in payload and assign items (such as workspaces and\n        items withnicknames) to users or groups.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._assignments:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor assignment in self._assignments:\n# Sanity check: we need a subject - it's mandatory:\nif not \"subject\" in assignment:\nlogger.error(\"Assignment needs a subject! Skipping assignment...\")\nsuccess = False\ncontinue\nsubject = assignment[\"subject\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in assignment and not assignment[\"enabled\"]:\nlogger.info(\n\"Payload for Assignment -&gt; %s is disabled. Skipping...\", subject\n)\ncontinue\n# instruction is optional but we give a warning if they are missing:\nif not \"instruction\" in assignment:\nlogger.warning(\"Assignment -&gt; %s should have an instruction!\", subject)\ninstruction = \"\"\nelse:\ninstruction = assignment[\"instruction\"]\n# Sanity check: we either need users or groups (or both):\nif not \"groups\" in assignment and not \"users\" in assignment:\nlogger.error(\n\"Assignment -&gt; %s needs groups or users! Skipping assignment...\",\nsubject,\n)\nsuccess = False\ncontinue\n# Check if a workspace is specified for the assignment and check it does exist:\nif \"workspace\" in assignment and assignment[\"workspace\"]:\nworkspace = next(\n(\nitem\nfor item in self._workspaces\nif item[\"id\"] == assignment[\"workspace\"]\n),\nNone,\n)\nif not workspace:\nlogger.error(\n\"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\nsubject,\nassignment[\"workspace\"],\n)\nsuccess = False\ncontinue\nnode_id = self.determine_workspace_id(workspace)\nif not node_id:\nlogger.error(\n\"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\nsubject,\nassignment[\"workspace\"],\n)\nsuccess = False\ncontinue\n# If we don't have a workspace then check if a nickname is specified for the assignment:\nelif \"nickname\" in assignment:\nresponse = self._otcs.get_node_from_nickname(assignment[\"nickname\"])\nnode_id = self._otcs.get_result_value(response, \"id\")\nif not node_id:\n# if response == None:\nlogger.error(\n\"Assignment item with nickname -&gt; %s not found\",\nassignment[\"nickname\"],\n)\nsuccess = False\ncontinue\nelse:\nlogger.error(\n\"Assignment -&gt; %s needs a workspace or nickname! Skipping assignment...\",\nsubject,\n)\nsuccess = False\ncontinue\nassignees = []\nif \"groups\" in assignment:\ngroup_assignees = assignment[\"groups\"]\nfor group_assignee in group_assignees:\n# find the group in the group list\ngroup = next(\n(\nitem\nfor item in self._groups\nif item[\"name\"] == group_assignee\n),\nNone,\n)\nif not group:\nlogger.error(\n\"Assignment group -&gt; %s does not exist! Skipping group...\",\ngroup_assignee,\n)\nsuccess = False\ncontinue\nif not \"id\" in group:\nlogger.error(\n\"Assignment group -&gt; %s does not have an ID. Skipping group...\",\ngroup_assignee,\n)\nsuccess = False\ncontinue\ngroup_id = group[\"id\"]\n# add the group ID to the assignee list:\nassignees.append(group_id)\nif \"users\" in assignment:\nuser_assignees = assignment[\"users\"]\nfor user_assignee in user_assignees:\n# find the user in the user list\nuser = next(\n(item for item in self._users if item[\"name\"] == user_assignee),\nNone,\n)\nif not user:\nlogger.error(\n\"Assignment user -&gt; %s does not exist! Skipping user...\",\nuser_assignee,\n)\nsuccess = False\ncontinue\nif not \"id\" in user:\nlogger.error(\n\"Assignment user -&gt; %s does not have an ID. Skipping user...\",\nuser_assignee,\n)\nsuccess = False\ncontinue\nuser_id = user[\"id\"]\n# add the group ID to the assignee list:\nassignees.append(user_id)\nif not assignees:\nlogger.error(\n\"Cannot add assignment -&gt; %s for node ID -&gt; %s because no assignee was found.\",\nsubject,\nnode_id,\n)\nsuccess = False\ncontinue\nresponse = self._otcs.assign_item_to_user_group(\nint(node_id), subject, instruction, assignees\n)\nif not response:\nlogger.error(\n\"Failed to add assignment -&gt; %s for node ID -&gt; %s with assignees -&gt; %s.\",\nsubject,\nnode_id,\nassignees,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._assignments)\nreturn success\n# end method definition\ndef process_user_licenses(\nself,\nresource_name: str,\nlicense_feature: str,\nlicense_name: str,\nuser_specific_payload_field: str = \"licenses\",\nsection_name: str = \"userLicenses\",\n) -&gt; bool:\n\"\"\"Assign a specific OTDS license feature to all Extended ECM users.\n           This method is used for OTIV and Extended ECM licenses.\n        Args:\n            resource_name (str): name of the OTDS resource\n            license_feature (str): license feature to assign to the user (product specific)\n            license_name (str): Name of the license Key (e.g. \"EXTENDED_ECM\" or \"INTELLIGENT_VIEWING\")\n            user_specific_payload_field (str, optional): name of the user specific field in payload\n                                                         (if empty it will be ignored)\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\notds_resource = self._otds.get_resource(resource_name)\nif not otds_resource:\nlogger.error(\n\"OTDS Resource -&gt; {} not found. Cannot assign licenses to users.\"\n)\nreturn False\nuser_partition = self._otcs.config()[\"partition\"]\nif not user_partition:\nlogger.error(\"OTCS user partition not found in OTDS!\")\nreturn False\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif user_specific_payload_field and user_specific_payload_field in user:\nlogger.info(\n\"Found specific license feature -&gt; %s for User -&gt; %s. Overwriting default license feature -&gt; %s\",\nuser[user_specific_payload_field],\nuser_name,\nlicense_feature,\n)\nuser_license_feature = user[user_specific_payload_field]\nelse:  # use the default feature from the actual parameter\nuser_license_feature = [license_feature]\nfor license_feature in user_license_feature:\nif self._otds.is_user_licensed(\nuser_name=user_name,\nresource_id=otds_resource[\"resourceID\"],\nlicense_feature=license_feature,\nlicense_name=license_name,\n):\nlogger.info(\n\"User -&gt; %s is already licensed for -&gt; %s (%s)\",\nuser_name,\nlicense_name,\nlicense_feature,\n)\ncontinue\nassigned_license = self._otds.assign_user_to_license(\nuser_partition,\nuser_name,  # we want the plain login name here\notds_resource[\"resourceID\"],\nlicense_feature,\nlicense_name,\n)\nif not assigned_license:\nlogger.error(\n\"Failed to assign license feature -&gt; %s to user -&gt; %s!\",\nlicense_feature,\nuser_name,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._users)\nreturn success\n# end method definition\ndef process_exec_pod_commands(self, section_name: str = \"execPodCommands\") -&gt; bool:\n\"\"\"Process commands that should be executed in the Kubernetes pods.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not isinstance(self._k8s, K8s):\nlogger.error(\"K8s not setup properly -&gt; Skipping %s...\", section_name)\nreturn False\nif not self._exec_pod_commands:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor exec_pod_command in self._exec_pod_commands:\nif not \"pod_name\" in exec_pod_command:\nlogger.error(\n\"To execute a command in a pod the pod name needs to be specified in the payload! Skipping to next pod command...\"\n)\nsuccess = False\ncontinue\npod_name = exec_pod_command[\"pod_name\"]\nif not \"command\" in exec_pod_command or not exec_pod_command.get(\"command\"):\nlogger.error(\n\"Pod command is not specified for pod -&gt; %s! It needs to be a non-empty list! Skipping to next pod command...\",\npod_name,\n)\nsuccess = False\ncontinue\ncommand = exec_pod_command[\"command\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in exec_pod_command and not exec_pod_command[\"enabled\"]:\nlogger.info(\n\"Payload for Exec Pod Command in pod -&gt; %s is disabled. Skipping...\",\npod_name,\n)\ncontinue\nif not \"description\" in exec_pod_command:\nlogger.info(\"Executing command -&gt; %s in pod -&gt; %s\", command, pod_name)\nelse:\ndescription = exec_pod_command[\"description\"]\nlogger.info(\n\"Executing command -&gt; %s in pod -&gt; %s (%s)\",\ncommand,\npod_name,\ndescription,\n)\nif (\nnot \"interactive\" in exec_pod_command\nor exec_pod_command[\"interactive\"] is False\n):\nresult = self._k8s.exec_pod_command(pod_name, command)\nelse:\nif not \"timeout\" in exec_pod_command:\nresult = self._k8s.exec_pod_command_interactive(pod_name, command)\nelse:\ntimeout = exec_pod_command[\"timeout\"]\nresult = self._k8s.exec_pod_command_interactive(\npod_name, command, timeout\n)\n# we need to differentiate 3 cases here:\n# 1. result = None is returned - this is an error (exception)\n# 2. result is empty string - this is OK\n# 3. result is a non-empty string - this is OK - print it to log\nif result is None:\nlogger.error(\n\"Execution of command -&gt; %s in pod -&gt; %s failed\",\ncommand,\npod_name,\n)\nsuccess = False\nelif result != \"\":\nlogger.info(\n\"Execution of command -&gt; %s in pod -&gt; %s returned result -&gt; %s\",\ncommand,\npod_name,\nresult,\n)\nelse:\n# It is not an error if no result is returned. It depends on the nature of the command\n# if a result is written to stdout or stderr.\nlogger.info(\n\"Execution of command -&gt; %s in pod -&gt; %s did not return a result\",\ncommand,\npod_name,\n)\nself.write_status_file(success, section_name, self._exec_pod_commands)\nreturn success\n# end method definition\ndef process_document_generators(\nself, section_name: str = \"documentGenerators\"\n) -&gt; bool:\n\"\"\"Generate documents for a defined workspace type based on template\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._doc_generators:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# save admin credentials for later switch back to admin user:\nadmin_credentials = self._otcs.credentials()\nauthenticated_user = \"admin\"\nfor doc_generator in self._doc_generators:\nif not \"workspace_type\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces the workspace type needs to be specified in the payload! Skipping to next document generator...\"\n)\nsuccess = False\ncontinue\nworkspace_type = doc_generator[\"workspace_type\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in doc_generator and not doc_generator[\"enabled\"]:\nlogger.info(\n\"Payload for document generator of workspace type -&gt; %s is disabled. Skipping...\",\nworkspace_type,\n)\ncontinue\nif not \"template_path\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces of type -&gt; %s the path to the document template needs to be specified in the payload! Skipping to next document generator...\",\nworkspace_type,\n)\nsuccess = False\ncontinue\ntemplate_path = doc_generator[\"template_path\"]\n# 20541 is the ID of the Document Template Volume which\n# (we hope) is stable:\ntemplate = self._otcs.get_node_by_volume_and_path(20541, template_path)\nif not template:\nlogger.error(\n\"Cannot find document template in path -&gt; %s. Skipping to next document generator...\",\ntemplate_path,\n)\nsuccess = False\ncontinue\ntemplate_id = self._otcs.get_result_value(template, \"id\")\ntemplate_name = self._otcs.get_result_value(template, \"name\")\nif not \"classification_path\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces of type -&gt; %s the path to the document classification needs to be specified in the payload! Skipping to next document generator...\",\nworkspace_type,\n)\nsuccess = False\ncontinue\nclassification_path = doc_generator[\"classification_path\"]\nclassification = self._otcs.get_node_by_volume_and_path(\n198, classification_path\n)\nif not classification:\nlogger.error(\n\"Cannot find document classification in path -&gt; %s. Skipping to next document generator...\",\nclassification_path,\n)\nsuccess = False\ncontinue\nclassification_id = self._otcs.get_result_value(classification, \"id\")\n# \"category_name\" is optional. But if it is specified\n# then also \"attributes\" needs to be specified:\nif not \"category_name\" in doc_generator:\nlogger.info(\n\"No metadata (category name) specified in the payload for this document generator.\",\n)\ncategory_name = \"\"\nattributes = {}\ncategory_data = {}\nelse:\ncategory_name = doc_generator[\"category_name\"]\nif not \"attributes\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces of type -&gt; %s with metadata, the attributes needs to be specified in the payload! Skipping to next document generator...\",\nworkspace_type,\n)\nsuccess = False\ncontinue\nattributes = doc_generator[\"attributes\"]\n# The following method returns two values: the category ID and\n# a dict of the attributes. If the category is not found\n# on the document template it returns -1 for the category ID\n# and an empty dict for the attribute definitions:\n(\ncategory_id,\nattribute_definitions,\n) = self._otcs.get_node_category_definition(template_id, category_name)\nif category_id == -1:\nlogger.error(\n\"The document template -&gt; %s does not have the specified category -&gt; %s. Skipping to next document generator...\",\ntemplate_name,\ncategory_name,\n)\nsuccess = False\ncontinue\ncategory_data = {str(category_id): {}}\n# now we fill the prepared (but empty) category_data\n# with the actual attribute values from the payload:\nfor attribute in attributes:\nattribute_name = attribute[\"name\"]\nattribute_value = attribute[\"value\"]\nattribute_type = attribute_definitions[attribute_name][\"type\"]\nattribute_id = attribute_definitions[attribute_name][\"id\"]\n# Special treatment for type user: determine the ID for the login name.\n# the ID is the actual value we have to put in the attribute:\nif attribute_type == \"user\":\nuser = self._otcs.get_user(attribute_value, show_error=True)\nuser_id = self._otcs.get_result_value(response=user, key=\"id\")\nif not user_id:\nlogger.error(\n\"Cannot find user with login name -&gt; %s. Skipping...\",\nattribute_value,\n)\nsuccess = False\ncontinue\nattribute_value = user_id\ncategory_data[str(category_id)][attribute_id] = attribute_value\nif not \"workspace_folder_path\" in doc_generator:\nlogger.info(\n\"No workspace folder path defined for workspaces of type -&gt; %s. Documents will be stored in workspace root.\",\nworkspace_type,\n)\nworkspace_folder_path = []\nelse:\nworkspace_folder_path = doc_generator[\"workspace_folder_path\"]\nif \"exec_as_user\" in doc_generator:\nexec_as_user = doc_generator[\"exec_as_user\"]\n# Find the user in the users payload:\nexec_user = next(\n(item for item in self._users if item[\"name\"] == exec_as_user),\nNone,\n)\n# Have we found the user in the payload?\nif exec_user is not None:\nlogger.info(\n\"Executing document generator with user -&gt; %s\", exec_as_user\n)\n# we change the otcs credentials to the user:\nself._otcs.set_credentials(exec_user[\"name\"], exec_user[\"password\"])\n# we re-authenticate as the user:\nlogger.info(\"Authenticate user -&gt; %s...\", exec_as_user)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\nif not cookie:\nlogger.error(\"Couldn't authenticate user -&gt; %s\", exec_as_user)\ncontinue\nadmin_context = False\nauthenticated_user = exec_as_user\nelse:\nlogger.error(\n\"Cannot find user with login name -&gt; %s for executing. Executing as admin...\",\nexec_as_user,\n)\nadmin_context = True\nsuccess = False\nelse:\nadmin_context = True\nexec_as_user = \"admin\"\nif admin_context and authenticated_user != \"admin\":\n# Set back admin credentials:\nself._otcs.set_credentials(\nadmin_credentials[\"username\"], admin_credentials[\"password\"]\n)\n# we re-authenticate as the admin user:\nlogger.info(\n\"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\nauthenticated_user = \"admin\"\nif category_data:\nlogger.info(\n\"Generate documents for workspace type -&gt; %s based on template -&gt; %s with metadata -&gt; %s...\",\nworkspace_type,\ntemplate_name,\ncategory_data,\n)\nelse:\nlogger.info(\n\"Generate documents for workspace type -&gt; %s based on template -&gt; %s without metadata...\",\nworkspace_type,\ntemplate_name,\n)\n# Find the workspace type with the name given in the _workspace_types\n# datastructure that has been generated by process_workspace_type() method before:\nworkspace_type_id = next(\n(\nitem[\"id\"]\nfor item in self._workspace_types\nif item[\"name\"] == workspace_type\n),\nNone,\n)\nworkspace_instances = self._otcs.get_workspace_instances(\ntype_name=workspace_type, type_id=workspace_type_id\n)\nif not workspace_instances or not workspace_instances[\"results\"]:\nlogger.warning(\n\"No workspace instances found for workspace type -&gt; %s (%s)\",\nworkspace_type,\nworkspace_type_id,\n)\nfor workspace_instance in workspace_instances[\"results\"]:\nworkspace_id = workspace_instance[\"data\"][\"properties\"][\"id\"]\nworkspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\nif workspace_folder_path:\nworkspace_folder = self._otcs.get_node_by_workspace_and_path(\nworkspace_id, workspace_folder_path\n)\nif workspace_folder:\nworkspace_folder_id = self._otcs.get_result_value(\nworkspace_folder, \"id\"\n)\nelse:\n# If the workspace template is not matching\n# the path we may have an error here. Then\n# we fall back to workspace root level.\nlogger.warning(\n\"Folder path does not exist in workspace -&gt; %s. Using workspace root level instead...\",\nworkspace_name,\n)\nworkspace_folder_id = workspace_id\nelse:\nworkspace_folder_id = workspace_id\ndocument_name = workspace_name + \" - \" + template_name\nlogger.info(\"Generate document -&gt; %s\", document_name)\nresponse = self._otcs.check_node_name(\nint(workspace_folder_id), document_name\n)\nif response[\"results\"]:\nlogger.warning(\n\"Node with name -&gt; %s does already exist in workspace folder with ID -&gt; %s\",\ndocument_name,\nworkspace_folder_id,\n)\ncontinue\nresponse = self._otcs.create_document_from_template(\nint(template_id),\nint(workspace_folder_id),\nint(classification_id),\ncategory_data,\ndocument_name,\n\"This document has been auto-generated by Terrarium\",\n)\nif not response:\nlogger.error(\n\"Failed to generate document -&gt; %s in workspace -&gt; %s (%s) as user -&gt; %s\",\ndocument_name,\nworkspace_name,\nworkspace_id,\nexec_as_user,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully generated document -&gt; %s in workspace -&gt; %s\",\ndocument_name,\nworkspace_name,\n)\nif authenticated_user != \"admin\":\n# Set back admin credentials:\nself._otcs.set_credentials(\nadmin_credentials[\"username\"], admin_credentials[\"password\"]\n)\n# we authenticate back as the admin user:\nlogger.info(\n\"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\nself.write_status_file(success, section_name, self._doc_generators)\nreturn success\n# end method definition\ndef process_browser_automations(\nself, section_name: str = \"browserAutomations\", check_status: bool = True\n) -&gt; bool:\n\"\"\"Process Selenium-based browser automations.\n        Args:\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not self._browser_automations:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif check_status and self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor browser_automation in self._browser_automations:\ndescription = browser_automation.get(\"description\", \"\")\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in browser_automation and not browser_automation[\"enabled\"]:\nlogger.info(\n\"Payload for Browser Automation -&gt; %s is disabled. Skipping...\",\ndescription,\n)\ncontinue\nif not \"base_url\" in browser_automation:\nlogger.error(\"Browser automation is missing base_url. Skipping...\")\nsuccess = False\ncontinue\nbase_url = browser_automation.get(\"base_url\")\nif not \"user_name\" in browser_automation:\nlogger.info(\"Browser automation is not having user name.\")\nuser_name = browser_automation.get(\"user_name\", \"\")\nif not \"password\" in browser_automation:\nlogger.info(\"Browser automation is not having password.\")\npassword = browser_automation.get(\"password\", \"\")\nif not \"automations\" in browser_automation:\nlogger.error(\n\"Browser automation is missing list of automations. Skipping...\"\n)\nsuccess = False\ncontinue\nautomations = browser_automation.get(\"automations\", [])\n# Create Selenium Browser Automation:\nlogger.info(\"Browser Automation URL -&gt; %s\", base_url)\nlogger.info(\"Browser Automation User -&gt; %s\", user_name)\nlogger.debug(\"Browser Automation Password -&gt; %s\", password)\nbrowser_automation_object = BrowserAutomation(\nbase_url=base_url,\nuser_name=user_name,\nuser_password=password,\n)\nfor automation in automations:\nif not \"type\" in automation:\nlogger.error(\"Browser automation step is missing type. Skipping...\")\nsuccess = False\nbreak\nautomation_type = automation.get(\"type\", \"\")\nmatch automation_type:\ncase \"login\":\npage = automation.get(\"page\", \"\")\nlogger.info(\n\"Login to -&gt; %s as user -&gt; %s\", base_url + page, user_name\n)\nuser_field = automation.get(\"user_field\", \"otds_username\")\npassword_field = automation.get(\n\"password_field\", \"otds_password\"\n)\nlogin_button = automation.get(\"login_button\", \"loginbutton\")\nif not browser_automation_object.run_login(\nuser_field=user_field,\npassword_field=password_field,\nlogin_button=login_button,\n):\nlogger.error(\n\"Cannot log into -&gt; %s. Stopping automation.\",\nbase_url + page,\n)\nsuccess = False\nbreak\nelse:\nlogger.info(\n\"Successfuly logged into page -&gt; %s.\", base_url + page\n)\ncase \"get_page\":\npage = automation.get(\"page\", \"\")\nif not page:\nlogger.error(\n\"Automation type -&gt; %s requires page parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\nlogger.info(\"Get page -&gt; %s\", base_url + page)\nif not browser_automation_object.get_page(url=page):\nlogger.error(\n\"Cannot get page -&gt; %s. Stopping automation.\",\npage,\n)\nsuccess = False\nbreak\nelse:\nbrowser_automation_object.implict_wait(15.0)\nlogger.info(\n\"Successfuly loaded page -&gt; %s.\", base_url + page\n)\ncase \"click_elem\":\nelem = automation.get(\"elem\", \"\")\nif not elem:\nlogger.error(\n\"Automation type -&gt; %s requires elem parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\nfind = automation.get(\"find\", \"id\")\nif not browser_automation_object.find_elem_and_click(\nfind_elem=elem, find_method=find\n):\nlogger.error(\n\"Cannot find clickable element -&gt; %s on current page. Stopping automation.\",\nelem,\n)\nsuccess = False\nbreak\nelse:\nbrowser_automation_object.implict_wait(15.0)\nlogger.info(\"Successfuly clicked element -&gt; %s.\", elem)\ncase \"set_elem\":\nelem = automation.get(\"elem\", \"\")\nif not elem:\nlogger.error(\n\"Automation type -&gt; %s requires elem parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\nfind = automation.get(\"find\", \"id\")\nvalue = automation.get(\"value\", \"\")\nif not value:\nlogger.error(\n\"Automation type -&gt; %s requires value parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\n# we also support replacing placeholders that are\n# enclosed in double % characters like %%OTCS_RESOURCE_ID%%:\nvalue = self.replace_placeholders(value)\nif not browser_automation_object.find_elem_and_set(\nfind_elem=elem, elem_value=value, find_method=find\n):\nlogger.error(\n\"Cannot find element -&gt; %s on current page to set value -&gt; %s. Stopping automation.\",\nelem,\nvalue,\n)\nsuccess = False\nbreak\nelse:\nlogger.info(\n\"Successfuly set element -&gt; %s to set value -&gt; %s.\",\nelem,\nvalue,\n)\ncase _:\nlogger.error(\n\"Illegal automation step type -&gt; %s in browser automation!\",\nautomation_type,\n)\nsuccess = False\nbreak\nif check_status:\nself.write_status_file(success, section_name, self._browser_automations)\nreturn success\n# end method definition\ndef init_sap(\nself, sap_external_system: dict, direct_application_server_login: bool = True\n) -&gt; SAP | None:\n\"\"\"Initialize SAP object for RFC communication with SAP S/4HANA.\n        Args:\n            sap_external_system (dict): SAP external system created before\n            direct_application_server_login (bool): flag to control wether we comminicate directly with\n                                                    SAP application server or via a load balancer\n        Returns:\n            SAP: SAP object\n        \"\"\"\nif not sap_external_system:\nreturn None\nusername = sap_external_system[\"username\"]\npassword = sap_external_system[\"password\"]\n# \"external_system_hostname\" is extracted from as_url in process_external_systems()\nhost = sap_external_system[\"external_system_hostname\"]\nclient = sap_external_system.get(\"client\", \"100\")\nsystem_number = sap_external_system.get(\"external_system_number\", \"00\")\nsystem_id = sap_external_system[\"external_system_name\"]\ngroup = sap_external_system.get(\"group\", \"PUBLIC\")\ndestination = sap_external_system.get(\"destination\", \"\")\nlogger.info(\"Connection parameters SAP:\")\nlogger.info(\"SAP Hostname             = %s\", host)\nlogger.info(\"SAP Client               = %s\", client)\nlogger.info(\"SAP System Number        = %s\", system_number)\nlogger.info(\"SAP System ID            = %s\", system_id)\nlogger.info(\"SAP User Name            = %s\", username)\nif not direct_application_server_login:\nlogger.info(\"SAP Group Name (for RFC) = %s\", group)\nif destination:\nlogger.info(\"SAP Destination          = %s\", destination)\nif direct_application_server_login:\nlogger.info(\"SAP Login                = Direct Application Server (ashost)\")\nsap_object = SAP(\nusername=username,\npassword=password,\nashost=host,\nclient=client,\nsystem_number=system_number,\nsystem_id=system_id,\ndestination=destination,\n)\nelse:\nlogger.info(\"SAP Login                = Logon with load balancing (mshost)\")\nsap_object = SAP(\nusername=username,\npassword=password,\nmshost=host,\ngroup=group,\nclient=client,\nsystem_number=system_number,\nsystem_id=system_id,\ndestination=destination,\n)\nreturn sap_object\n# end method definition\ndef process_sap_rfcs(self, sap_object: SAP, section_name: str = \"sapRFCs\") -&gt; bool:\n\"\"\"Process SAP RFCs in payload and run them in SAP S/4HANA.\n        Args:\n            sap_object (SAP): SAP object\n            section_name (str, optional): name of the section. It can be overridden\n                                          for cases where multiple sections of same type\n                                          are used (e.g. the \"Post\" sections)\n                                          This name is also used for the \"success\" status\n                                          files written to the Admin Personal Workspace\n        Returns:\n            bool: True if payload has been processed without errors, False otherwise\n        \"\"\"\nif not sap_object:\nlogger.info(\"SAP object is undefined. Cannot call RFCs. Bailing out.\")\nreturn False\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor sap_rfc in self._sap_rfcs:\nrfc_name = sap_rfc[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in sap_rfc and not sap_rfc[\"enabled\"]:\nlogger.info(\n\"Payload for SAP RFC -&gt; %s is disabled. Skipping...\", rfc_name\n)\ncontinue\nrfc_description = (\nsap_rfc[\"description\"] if sap_rfc.get(\"description\") else \"\"\n)\n# be careful to avoid key errors as SAP RFC parameters are optional:\nrfc_params = sap_rfc[\"parameters\"] if sap_rfc.get(\"parameters\") else {}\nif rfc_params:\nlogger.info(\n\"Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\nrfc_name,\nrfc_description,\nrfc_params,\n)\nelse:\nlogger.info(\n\"Calling SAP RFC -&gt; %s (%s) without parameters...\",\nrfc_name,\nrfc_description,\n)\n# be careful to avoid key errors as SAP RFC parameters are optional:\nrfc_call_options = (\nsap_rfc[\"call_options\"] if sap_rfc.get(\"call_options\") else {}\n)\nif rfc_call_options:\nlogger.debug(\"Using call options -&gt; %s ...\", rfc_call_options)\nresult = sap_object.call(rfc_name, rfc_call_options, rfc_params)\nif result is None:\nlogger.error(\"Failed to call SAP RFC -&gt; %s\", rfc_name)\nsuccess = False\nelif result.get(\"RESULT\") != \"OK\":\nlogger.error(\n\"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\nrfc_name,\nstr(result.get(\"FAILED\")),\nstr(result),\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n)\n# Save result for status file content\nsap_rfc[\"result\"] = result\nself.write_status_file(success, section_name, self._sap_rfcs)\nreturn success\n# end method definition\ndef get_payload(self) -&gt; dict:\n\"\"\"Get the Payload\"\"\"\nreturn self._payload\ndef get_users(self) -&gt; list:\n\"\"\"Get all useres\"\"\"\nreturn self._users\ndef get_groups(self) -&gt; list:\n\"\"\"Get all groups\"\"\"\nreturn self._groups\ndef get_workspaces(self) -&gt; list:\n\"\"\"Get all workspaces\"\"\"\nreturn self._workspaces\ndef get_otcs_frontend(self) -&gt; object:\n\"\"\"Get OTCS Frontend oject\"\"\"\nreturn self._otcs_frontend\ndef get_otcs_backend(self) -&gt; object:\n\"\"\"Get OTCS Backend object\"\"\"\nreturn self._otcs_backend\ndef get_otds(self) -&gt; object:\n\"\"\"Get OTDS object\"\"\"\nreturn self._otds\ndef get_k8s(self) -&gt; object:\n\"\"\"Get K8s object\"\"\"\nreturn self._k8s\ndef getM365(self) -&gt; object:\n\"\"\"Get M365 object\"\"\"\nreturn self._m365\ndef generate_password(\nself,\nlength: int,\nuse_special_chars: bool = False,\nmin_special: int = 1,\nmin_numerical: int = 1,\nmin_upper: int = 1,\nmin_lower: int = 1,\noverride_special: str = None,\n):\n\"\"\"Function to generate random passwords with a given specification\n        Args:\n            length (int): Define password length\n            use_special_chars (bool, optional): Define if special characters should be used. Defaults to False.\n            min_special (int, optional): Define min amount of special characters. Defaults to 1.\n            min_numerical (int, optional): Define if numbers should be used. Defaults to 1.\n            min_upper (int, optional): Define mininum number of upper case letters. Defaults to 1.\n            min_lower (int, optional): Define minimum number of lower case letters. Defaults to 1.\n            override_special (string | None, optional): Define special characters to be used, if not set: !@#$%^&amp;*()_-+=&lt;&gt;?/{}[]. Defaults to None.\n        Raises:\n            ValueError: _description_\n        Returns:\n            _type_: _description_\n        \"\"\"\n# Define character sets\nlowercase_letters = string.ascii_lowercase\nuppercase_letters = string.ascii_uppercase\nnumerical_digits = string.digits\nspecial_characters = \"!@#$%^&amp;*()_-+=&lt;&gt;?/{}[]\"\nif override_special:\nspecial_characters = override_special\n# Ensure minimum requirements are met\nif min_special + min_numerical + min_upper + min_lower &gt; length:\nraise ValueError(\"Minimum requirements exceed password length\")\n# Initialize the password\npassword = []\n# Add required characters\npassword.extend(random.sample(lowercase_letters, min_lower))\npassword.extend(random.sample(uppercase_letters, min_upper))\npassword.extend(random.sample(numerical_digits, min_numerical))\nif use_special_chars:\npassword.extend(random.sample(special_characters, min_special))\n# Fill the rest of the password with random characters\nremaining_length = length - len(password)\nall_chars = lowercase_letters + uppercase_letters + numerical_digits\nif use_special_chars:\nall_chars += special_characters\npassword.extend(random.choices(all_chars, k=remaining_length))\n# Shuffle the password to ensure randomness\nrandom.shuffle(password)\n# Convert the password list to a string\nfinal_password = \"\".join(password)\nreturn final_password\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.__init__","title":"<code>__init__(payload_source, custom_settings_dir, k8s_object, otds_object, otac_object, otcs_backend_object, otcs_frontend_object, otcs_restart_callback, otiv_object, m365_object, browser_automation_object, placeholder_values, log_header_callback, stop_on_error=False, aviator_enabled=False)</code>","text":"<p>Initialize the Payload object</p> <p>Parameters:</p> Name Type Description Default <code>payload_source</code> <code>str</code> <p>path or URL to payload source file</p> required <code>k8s_object</code> <code>object</code> <p>Kubernetes object</p> required <code>otds_object</code> <code>OTDS</code> <p>OTDS object</p> required <code>otac_object</code> <code>OTAC</code> <p>OTAC object</p> required <code>otcs_backend_object</code> <code>OTCS</code> <p>OTCS backend object</p> required <code>otcs_frontend_object</code> <code>OTCS</code> <p>OTCS frontend object</p> required <code>otcs_restart_callback</code> <code>Callable</code> <p>function to call if OTCS service needs a restart</p> required <code>otiv_object</code> <code>object</code> <p>OTIV object</p> required <code>m365_object</code> <code>object</code> <p>M365 object to talk to Microsoft Graph API</p> required <code>browser_automation_object</code> <code>object</code> <p>BrowserAutomation object to automate things which don't have a REST API</p> required <code>placeholder_values</code> <code>dict</code> <p>dictionary of placeholder values                        to be replaced in admin settings</p> required <code>log_header_callback</code> <code>Callable</code> <p>prints a section break / header line into the log</p> required <code>stop_on_error</code> <code>bool</code> <p>controls if transport deployment should stop                   if one transport fails</p> <code>False</code> <code>aviator_enabled</code> <code>bool</code> <p>whether or not the Content Aviator is enabled</p> <code>False</code> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def __init__(\nself,\npayload_source: str,\ncustom_settings_dir: str,\nk8s_object: K8s | None,\notds_object: OTDS,\notac_object: OTAC | None,\notcs_backend_object: OTCS,\notcs_frontend_object: OTCS,\notcs_restart_callback: Callable,\notiv_object: OTIV | None,\nm365_object: M365 | None,\nbrowser_automation_object: BrowserAutomation | None,\nplaceholder_values: dict,\nlog_header_callback: Callable,\nstop_on_error: bool = False,\naviator_enabled: bool = False,\n):\n\"\"\"Initialize the Payload object\n    Args:\n        payload_source (str): path or URL to payload source file\n        k8s_object (object): Kubernetes object\n        otds_object (OTDS): OTDS object\n        otac_object (OTAC): OTAC object\n        otcs_backend_object (OTCS): OTCS backend object\n        otcs_frontend_object (OTCS): OTCS frontend object\n        otcs_restart_callback (Callable): function to call if OTCS service needs a restart\n        otiv_object (object): OTIV object\n        m365_object (object): M365 object to talk to Microsoft Graph API\n        browser_automation_object (object): BrowserAutomation object to automate things which don't have a REST API\n        placeholder_values (dict): dictionary of placeholder values\n                                   to be replaced in admin settings\n        log_header_callback: prints a section break / header line into the log\n        stop_on_error (bool): controls if transport deployment should stop\n                              if one transport fails\n        aviator_enabled (bool): whether or not the Content Aviator is enabled\n    \"\"\"\nself._stop_on_error = stop_on_error\nself._payload_source = payload_source\nself._k8s = k8s_object\nself._otds = otds_object\nself._otac = otac_object\nself._otcs = otcs_backend_object\nself._otcs_backend = otcs_backend_object\nself._otcs_frontend = otcs_frontend_object\nself._otiv = otiv_object\nself._m365 = m365_object\nself._browser_automation = browser_automation_object\nself._custom_settings_dir = custom_settings_dir\nself._placeholder_values = placeholder_values\nself._otcs_restart_callback = otcs_restart_callback\nself._log_header_callback = log_header_callback\nself._aviator_enabled = aviator_enabled\nself._http_object = HTTP()\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.check_external_system","title":"<code>check_external_system(external_system)</code>","text":"<p>Check if external system is reachable</p> <p>Parameters:</p> Name Type Description Default <code>external_system</code> <code>dict</code> <p>payload data structure of external system.                     We assume here that sanity check for                     valid data is already done before.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True = system is reachable, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def check_external_system(self, external_system: dict) -&gt; bool:\n\"\"\"Check if external system is reachable\n    Args:\n        external_system (dict): payload data structure of external system.\n                                We assume here that sanity check for\n                                valid data is already done before.\n    Returns:\n        bool: True = system is reachable, False otherwise\n    \"\"\"\nas_url = external_system[\"as_url\"]\n# Extract the hostname:\nexternal_system_hostname = urlparse(as_url).hostname\n# Write this information back into the data structure:\nexternal_system[\"external_system_hostname\"] = external_system_hostname\n# Extract the port:\nexternal_system_port = urlparse(as_url).port if urlparse(as_url).port else 80\n# Write this information back into the data structure:\nexternal_system[\"external_system_port\"] = external_system_port\nif self._http_object.check_host_reachable(\nexternal_system_hostname, external_system_port\n):\nlogger.info(\n\"Mark external system -&gt; %s as reachable for later workspace creation and SAP RFC processing...\",\nexternal_system[\"external_system_name\"],\n)\nexternal_system[\"reachable\"] = True\nreturn True\nelse:\nexternal_system[\"reachable\"] = False\nreturn False\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.check_status_file","title":"<code>check_status_file(payload_section_name, payload_specific=True)</code>","text":"<p>Check if the payload section has been processed before. This is    done by checking the existance of a text file in the Admin Personal    workspace in Extended ECM with the name of the payload section.</p> <p>Parameters:</p> Name Type Description Default <code>payload_section_name</code> <code>str</code> <p>name of the payload section. This                         is used to construct the file name</p> required <code>payload_specific</code> <code>bool</code> <p>whether or not the success should be specific for                      each payload file or if success is \"global\" - like for the deletion                      of the existing M365 teams (which we don't want to execute per                      payload file)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the payload has been processed successfully before, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def check_status_file(\nself, payload_section_name: str, payload_specific: bool = True\n) -&gt; bool:\n\"\"\"Check if the payload section has been processed before. This is\n       done by checking the existance of a text file in the Admin Personal\n       workspace in Extended ECM with the name of the payload section.\n    Args:\n        payload_section_name (str): name of the payload section. This\n                                    is used to construct the file name\n        payload_specific (bool): whether or not the success should be specific for\n                                 each payload file or if success is \"global\" - like for the deletion\n                                 of the existing M365 teams (which we don't want to execute per\n                                 payload file)\n    Returns:\n        bool: True if the payload has been processed successfully before, False otherwise\n    \"\"\"\nlogger.info(\n\"Check if payload section -&gt; %s has been processed successfully before...\",\npayload_section_name,\n)\nresponse = self._otcs.get_node_by_volume_and_path(\n142\n)  # write to Personal Workspace of Admin\ntarget_folder_id = self._otcs.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2004  # use Personal Workspace of Admin as fallback\n# Some sections are actually not payload specific like teamsM365Cleanup\n# we don't want external payload runs to re-apply this processing:\nif payload_specific:\nfile_name = os.path.basename(self._payload_source)  # remove directories\n# Split once at the first occurance of a dot\n# as the _payload_source may have multiple suffixes\n# such as .yml.gz.b64:\nfile_name = file_name.split(\".\", 1)[0]\nfile_name = \"success_\" + file_name + \"_\" + payload_section_name + \".json\"\nelse:\nfile_name = \"success_\" + payload_section_name + \".json\"\nstatus_document = self._otcs.get_node_by_parent_and_name(\nparent_id=int(target_folder_id), name=file_name, show_error=False\n)\nif status_document and status_document[\"results\"]:\nname = self._otcs.get_result_value(status_document, \"name\")\nif name == file_name:\nlogger.info(\n\"Payload section -&gt; %s has been processed successfully before. Skipping...\",\npayload_section_name,\n)\nreturn True\nlogger.info(\n\"Payload section -&gt; %s has not been processed successfully before. Processing...\",\npayload_section_name,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.cleanup_all_teams_m365","title":"<code>cleanup_all_teams_m365(section_name='teamsM365Cleanup')</code>","text":"<p>Delete Microsoft Teams that are left-overs from former deployments</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'teamsM365Cleanup'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if teams have been deleted, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def cleanup_all_teams_m365(self, section_name: str = \"teamsM365Cleanup\") -&gt; bool:\n\"\"\"Delete Microsoft Teams that are left-overs from former deployments\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if teams have been deleted, False otherwise\n    \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\n# We want this cleanup to only run once even if we have\n# multiple payload files - so we pass payload_specific=False here:\nif self.check_status_file(\npayload_section_name=section_name, payload_specific=False\n):\nlogger.info(\n\"Payload section -&gt; %s has been processed successfully before. Skip cleanup of M365 teams...\",\nsection_name,\n)\nreturn True\nlogger.info(\"Processing payload section -&gt; %s...\", section_name)\n# We don't want to delete MS Teams that are matching the regular OTCS Group Names (like \"Sales\")\nexception_list = self.get_all_group_names()\n# These are the patterns that each MS Teams needs to match at least one of to be deleted\n# Pattern 1: all MS teams with a name that has a number in brackets, line \"(1234)\"\n# Pattern 2: all MS Teams with a name that starts with a number followed by a space,\n#            followed by a \"-\" and followed by another space\n# Pattern 3: all MS Teams with a name that starts with \"WS\" and a 1-4 digit number\n#            (these are the workspaces for Purchase Contracts generated for Intelligent Filing)\n# Pattern 4: all MS Teams with a name that ends with a 1-2 character + a number in brackets, like (US-1000)\n#            this is a specialization of pattern 1\n# Pattern 5: remove the teams that are created for the dummy copy&amp;paste template for the\n#            Intelligent Filing workspaces\npattern_list = [\nr\"\\(\\d+\\)\",\nr\"\\d+\\s-\\s\",\nr\"^WS\\d{1,4}$\",\nr\"^.+?\\s\\(.{1,2}-\\d+\\)$\",\nr\"Purchase\\sContract\\s\\(Template\\sfor\\sIntelligent\\sFiling\\)\",\n]\nresult = self._m365.delete_all_teams(exception_list, pattern_list)\n# We want this cleanup to only run once even if we have\n# multiple payload files - so we pass payload_specific=False here:\nself.write_status_file(\nsuccess=True,\npayload_section_name=section_name,\npayload_section=exception_list + pattern_list,\npayload_specific=False,\n)\nreturn result\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.cleanup_stale_teams_m365","title":"<code>cleanup_stale_teams_m365(workspace_types)</code>","text":"<p>Delete Microsoft Teams that are left-overs from former deployments.    This method is currently not used.</p> <p>Parameters:</p> Name Type Description Default <code>workspace_types</code> <code>list</code> <p>list of all workspace types</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def cleanup_stale_teams_m365(self, workspace_types: list) -&gt; bool:\n\"\"\"Delete Microsoft Teams that are left-overs from former deployments.\n       This method is currently not used.\n    Args:\n        workspace_types (list): list of all workspace types\n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping cleanup...\",\n)\nreturn False\nif workspace_types == []:\nlogger.error(\"Empty workspace type list!\")\nreturn False\nfor workspace_type in workspace_types:\nif not \"name\" in workspace_type:\nlogger.error(\n\"Workspace type -&gt; %s does not have a name. Skipping...\",\nworkspace_type,\n)\ncontinue\nresponse = self._otcs.get_workspace_instances(workspace_type[\"name\"])\nworkspace_instances = response[\"results\"]\nif not workspace_instances:\nlogger.info(\n\"Workspace type -&gt; %s does not have any instances!\",\nworkspace_type[\"name\"],\n)\ncontinue\nfor workspace_instance in workspace_instances:\nworkspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\nlogger.info(\n\"Check if stale Microsoft 365 Teams with name -&gt; %s exist...\",\nworkspace_name,\n)\nresponse = self._m365.delete_teams(workspace_name)\nreturn True\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_group_id","title":"<code>determine_group_id(group)</code>","text":"<p>Determine the id of a group - either from payload or from OTCS.    If the group is found in OTCS write back the ID into the payload.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>dict</code> <p>group payload element</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>group ID</p> Side Effects <p>the group items are modified by adding an \"id\" dict element that includes the technical ID of the group in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_group_id(self, group: dict) -&gt; int:\n\"\"\"Determine the id of a group - either from payload or from OTCS.\n       If the group is found in OTCS write back the ID into the payload.\n    Args:\n        group (dict): group payload element\n    Returns:\n        int: group ID\n    Side Effects:\n        the group items are modified by adding an \"id\" dict element that\n        includes the technical ID of the group in Extended ECM\n    \"\"\"\n# Is the ID already known in payload? (if determined before)\nif \"id\" in group:\nreturn group[\"id\"]\nif not \"name\" in group:\nlogger.error(\"Group needs a name to lookup the ID.\")\nreturn 0\ngroup_name = group[\"name\"]\nexisting_groups = self._otcs.get_group(name=group_name)\n# We use the lookup method here as get_group() could deliver more\n# then 1 result element (in edge cases):\ngroup_id = self._otcs.lookup_result_value(\nresponse=existing_groups, key=\"name\", value=group_name, return_key=\"id\"\n)\n# Have we found an exact match?\nif group_id:\n# Write ID back into the payload:\ngroup[\"id\"] = group_id\nreturn group[\"id\"]\nelse:\nlogger.info(\"Did not find an existing group with name -&gt; %s\", group_name)\nreturn 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_user_id","title":"<code>determine_user_id(user)</code>","text":"<p>Determine the id of a user - either from payload or from OTCS    If the user is found in OTCS write back the ID into the payload.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>dict</code> <p>user payload element</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>user ID</p> Side Effects <p>the user items are modified by adding an \"id\" dict element that includes the technical ID of the user in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_user_id(self, user: dict) -&gt; int:\n\"\"\"Determine the id of a user - either from payload or from OTCS\n       If the user is found in OTCS write back the ID into the payload.\n    Args:\n        user (dict): user payload element\n    Returns:\n        int: user ID\n    Side Effects:\n        the user items are modified by adding an \"id\" dict element that\n        includes the technical ID of the user in Extended ECM\n    \"\"\"\n# Is the ID already known in payload? (if determined before)\nif \"id\" in user:\nreturn user[\"id\"]\nif not \"name\" in user:\nlogger.error(\"User needs a login name to lookup the ID.\")\nreturn 0\nuser_name = user[\"name\"]\nresponse = self._otcs.get_user(name=user_name)\n# We use the lookup method here as get_user() could deliver more\n# then 1 result element (in edge cases):\nuser_id = self._otcs.lookup_result_value(\nresponse=response, key=\"name\", value=user_name, return_key=\"id\"\n)\n# Have we found an exact match?\nif user_id:\n# Write ID back into the payload\nuser[\"id\"] = user_id\nreturn user[\"id\"]\nelse:\nlogger.info(\"Did not find an existing user with name -&gt; %s\", user_name)\nreturn 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_user_id_m365","title":"<code>determine_user_id_m365(user)</code>","text":"<p>Determine the id of a M365 user - either from payload or from M365 via Graph API    If the user is found in M365 write back the M365 user ID into the payload.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>dict</code> <p>user payload element</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>M365 user ID or 0 if the user is not found.</p> Side Effects <p>the user items are modified by adding an \"m365_id\" dict element that includes the technical ID of the user in Microsoft 365</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_user_id_m365(self, user: dict) -&gt; int:\n\"\"\"Determine the id of a M365 user - either from payload or from M365 via Graph API\n       If the user is found in M365 write back the M365 user ID into the payload.\n    Args:\n        user (dict): user payload element\n    Returns:\n        int: M365 user ID or 0 if the user is not found.\n    Side Effects:\n        the user items are modified by adding an \"m365_id\" dict element that\n        includes the technical ID of the user in Microsoft 365\n    \"\"\"\n# is the payload already updated with the M365 user ID?\nif \"m365_id\" in user:\nreturn user[\"m365_id\"]\nif not \"name\" in user:\nlogger.error(\"User needs a login name to lookup the M365 user ID.\")\nreturn 0\nuser_name = user[\"name\"]\nm365_user_name = user_name + \"@\" + self._m365.config()[\"domain\"]\nexisting_user = self._m365.get_user(m365_user_name)\nif existing_user:\nlogger.info(\n\"Found existing Microsoft 365 user -&gt; %s (%s) with ID -&gt; %s. Update m365_id in payload...\",\nexisting_user[\"displayName\"],\nexisting_user[\"userPrincipalName\"],\nexisting_user[\"id\"],\n)\n# write back the M365 user ID into the payload\nuser[\"m365_id\"] = existing_user[\"id\"]\nreturn user[\"m365_id\"]\nelse:\nlogger.info(\"Did not find an existing M365 user with name -&gt; %s\", user_name)\nreturn 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.determine_workspace_id","title":"<code>determine_workspace_id(workspace)</code>","text":"<p>Determine the nodeID of a workspace - either from payload or from OTCS</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>dict</code> <p>workspace payload element</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>workspace Node ID</p> Side Effects <p>the workspace items are modified by adding an \"nodeId\" dict element that includes the node ID of the workspace in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def determine_workspace_id(self, workspace: dict) -&gt; int:\n\"\"\"Determine the nodeID of a workspace - either from payload or from OTCS\n    Args:\n        workspace (dict): workspace payload element\n    Returns:\n        int: workspace Node ID\n    Side Effects:\n        the workspace items are modified by adding an \"nodeId\" dict element that\n        includes the node ID of the workspace in Extended ECM\n    \"\"\"\nif \"nodeId\" in workspace:\nreturn workspace[\"nodeId\"]\nresponse = self._otcs.get_workspace_by_type_and_name(\ntype_name=workspace[\"type_name\"], name=workspace[\"name\"]\n)\nworkspace_id = self._otcs.get_result_value(response, \"id\")\nif workspace_id:\n# Write nodeID back into the payload\nworkspace[\"nodeId\"] = workspace_id\nreturn workspace_id\nelse:\nlogger.info(\n\"Workspace of type -&gt; %s and name -&gt; %s does not yet exist.\",\nworkspace[\"type_name\"],\nworkspace[\"name\"],\n)\nreturn 0\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.generate_password","title":"<code>generate_password(length, use_special_chars=False, min_special=1, min_numerical=1, min_upper=1, min_lower=1, override_special=None)</code>","text":"<p>Function to generate random passwords with a given specification</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Define password length</p> required <code>use_special_chars</code> <code>bool</code> <p>Define if special characters should be used. Defaults to False.</p> <code>False</code> <code>min_special</code> <code>int</code> <p>Define min amount of special characters. Defaults to 1.</p> <code>1</code> <code>min_numerical</code> <code>int</code> <p>Define if numbers should be used. Defaults to 1.</p> <code>1</code> <code>min_upper</code> <code>int</code> <p>Define mininum number of upper case letters. Defaults to 1.</p> <code>1</code> <code>min_lower</code> <code>int</code> <p>Define minimum number of lower case letters. Defaults to 1.</p> <code>1</code> <code>override_special</code> <code>string | None</code> <p>Define special characters to be used, if not set: !@#$%^&amp;*()_-+=&lt;&gt;?/{}[]. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def generate_password(\nself,\nlength: int,\nuse_special_chars: bool = False,\nmin_special: int = 1,\nmin_numerical: int = 1,\nmin_upper: int = 1,\nmin_lower: int = 1,\noverride_special: str = None,\n):\n\"\"\"Function to generate random passwords with a given specification\n    Args:\n        length (int): Define password length\n        use_special_chars (bool, optional): Define if special characters should be used. Defaults to False.\n        min_special (int, optional): Define min amount of special characters. Defaults to 1.\n        min_numerical (int, optional): Define if numbers should be used. Defaults to 1.\n        min_upper (int, optional): Define mininum number of upper case letters. Defaults to 1.\n        min_lower (int, optional): Define minimum number of lower case letters. Defaults to 1.\n        override_special (string | None, optional): Define special characters to be used, if not set: !@#$%^&amp;*()_-+=&lt;&gt;?/{}[]. Defaults to None.\n    Raises:\n        ValueError: _description_\n    Returns:\n        _type_: _description_\n    \"\"\"\n# Define character sets\nlowercase_letters = string.ascii_lowercase\nuppercase_letters = string.ascii_uppercase\nnumerical_digits = string.digits\nspecial_characters = \"!@#$%^&amp;*()_-+=&lt;&gt;?/{}[]\"\nif override_special:\nspecial_characters = override_special\n# Ensure minimum requirements are met\nif min_special + min_numerical + min_upper + min_lower &gt; length:\nraise ValueError(\"Minimum requirements exceed password length\")\n# Initialize the password\npassword = []\n# Add required characters\npassword.extend(random.sample(lowercase_letters, min_lower))\npassword.extend(random.sample(uppercase_letters, min_upper))\npassword.extend(random.sample(numerical_digits, min_numerical))\nif use_special_chars:\npassword.extend(random.sample(special_characters, min_special))\n# Fill the rest of the password with random characters\nremaining_length = length - len(password)\nall_chars = lowercase_letters + uppercase_letters + numerical_digits\nif use_special_chars:\nall_chars += special_characters\npassword.extend(random.choices(all_chars, k=remaining_length))\n# Shuffle the password to ensure randomness\nrandom.shuffle(password)\n# Convert the password list to a string\nfinal_password = \"\".join(password)\nreturn final_password\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.getM365","title":"<code>getM365()</code>","text":"<p>Get M365 object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def getM365(self) -&gt; object:\n\"\"\"Get M365 object\"\"\"\nreturn self._m365\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_all_group_names","title":"<code>get_all_group_names()</code>","text":"<p>Construct a list of all group name</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of all group names</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_all_group_names(self) -&gt; list:\n\"\"\"Construct a list of all group name\n    Returns:\n        list: list of all group names\n    \"\"\"\nreturn [group.get(\"name\") for group in self._groups]\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_groups","title":"<code>get_groups()</code>","text":"<p>Get all groups</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_groups(self) -&gt; list:\n\"\"\"Get all groups\"\"\"\nreturn self._groups\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_k8s","title":"<code>get_k8s()</code>","text":"<p>Get K8s object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_k8s(self) -&gt; object:\n\"\"\"Get K8s object\"\"\"\nreturn self._k8s\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_otcs_backend","title":"<code>get_otcs_backend()</code>","text":"<p>Get OTCS Backend object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_otcs_backend(self) -&gt; object:\n\"\"\"Get OTCS Backend object\"\"\"\nreturn self._otcs_backend\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_otcs_frontend","title":"<code>get_otcs_frontend()</code>","text":"<p>Get OTCS Frontend oject</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_otcs_frontend(self) -&gt; object:\n\"\"\"Get OTCS Frontend oject\"\"\"\nreturn self._otcs_frontend\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_otds","title":"<code>get_otds()</code>","text":"<p>Get OTDS object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_otds(self) -&gt; object:\n\"\"\"Get OTDS object\"\"\"\nreturn self._otds\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_payload","title":"<code>get_payload()</code>","text":"<p>Get the Payload</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_payload(self) -&gt; dict:\n\"\"\"Get the Payload\"\"\"\nreturn self._payload\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_payload_section","title":"<code>get_payload_section(payload_section_name)</code>","text":"<p>Get a defined section of the payload. The section is delivered as a list of settings. It deliveres an empty list if this payload section is disabled by the corresponding payload switch (this is read from the payloadSections dictionary of the payload)</p> <p>Parameters:</p> Name Type Description Default <code>payload_section_name</code> <code>str</code> <p>name of the dict element in the payload structure</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>section of the payload as a Python list. Empty list if section does not exist</p> <code>list</code> <p>or section is disabled by the corresponding payload switch.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_payload_section(self, payload_section_name: str) -&gt; list:\n\"\"\"Get a defined section of the payload. The section is delivered as a list of settings.\n    It deliveres an empty list if this payload section is disabled by the corresponding\n    payload switch (this is read from the payloadSections dictionary of the payload)\n    Args:\n        payload_section_name (str): name of the dict element in the payload structure\n    Returns:\n        list: section of the payload as a Python list. Empty list if section does not exist\n        or section is disabled by the corresponding payload switch.\n    \"\"\"\nif not isinstance(self._payload, dict):\nreturn []\n# if the secton is not in the payload we return an empty list:\nif not self._payload.get(payload_section_name):\nreturn []\n# Check if the payload section is either enabled\n# or the struct for payloadSection enabling is not in the payload:\nsections = self._payload.get(\"payloadSections\")\nif sections:\nsection = next(\n(item for item in sections if item[\"name\"] == payload_section_name),\nNone,\n)\nif not section or not section[\"enabled\"]:\nreturn []\nreturn self._payload[payload_section_name]\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_status_file","title":"<code>get_status_file(payload_section_name, payload_specific=True)</code>","text":"<p>Get the status file and read it into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>payload_section_name</code> <code>str</code> <p>name of the payload section. This                         is used to construct the file name</p> required <code>payload_specific</code> <code>bool</code> <p>whether or not the success should be specific for                      each payload file or if success is \"global\" - like for the deletion                      of the existing M365 teams (which we don't want to execute per                      payload file)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>list | None</code> <p>content of the status file as a dictionary or None in case of an error</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_status_file(\nself, payload_section_name: str, payload_specific: bool = True\n) -&gt; list | None:\n\"\"\"Get the status file and read it into a dictionary.\n    Args:\n        payload_section_name (str): name of the payload section. This\n                                    is used to construct the file name\n        payload_specific (bool): whether or not the success should be specific for\n                                 each payload file or if success is \"global\" - like for the deletion\n                                 of the existing M365 teams (which we don't want to execute per\n                                 payload file)\n    Returns:\n        dict: content of the status file as a dictionary or None in case of an error\n    \"\"\"\nlogger.info(\n\"Get the status file of the payload section -&gt; %s...\",\npayload_section_name,\n)\nresponse = self._otcs.get_node_by_volume_and_path(\n142\n)  # read from Personal Workspace of Admin\nsource_folder_id = self._otcs.get_result_value(response, \"id\")\nif not source_folder_id:\nsource_folder_id = 2004  # use Personal Workspace of Admin as fallback\n# Some sections are actually not payload specific like teamsM365Cleanup\n# we don't want external payload runs to re-apply this processing:\nif payload_specific:\nfile_name = os.path.basename(self._payload_source)  # remove directories\n# Split once at the first occurance of a dot\n# as the _payload_source may have multiple suffixes\n# such as .yml.gz.b64:\nfile_name = file_name.split(\".\", 1)[0]\nfile_name = \"success_\" + file_name + \"_\" + payload_section_name + \".json\"\nelse:\nfile_name = \"success_\" + payload_section_name + \".json\"\nstatus_document = self._otcs.get_node_by_parent_and_name(\nparent_id=int(source_folder_id), name=file_name, show_error=True\n)\nstatus_file_id = self._otcs.get_result_value(status_document, \"id\")\nif not status_file_id:\nlogger.error(\"Cannot find status file -&gt; %s\", file_name)\nreturn None\ncontent = self._otcs.get_document_content(status_file_id)\ntry:\njson_data = json.loads(content.decode(\"utf-8\"))\nif isinstance(json_data, list):\nreturn json_data\nelse:\nlogger.error(\"File content is in JSON format but not a list.\")\nreturn None\nexcept json.JSONDecodeError as e:\nlogger.error(\"File content is not in valid JSON format; error -&gt; %s\", e)\nreturn None\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_users","title":"<code>get_users()</code>","text":"<p>Get all useres</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_users(self) -&gt; list:\n\"\"\"Get all useres\"\"\"\nreturn self._users\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.get_workspaces","title":"<code>get_workspaces()</code>","text":"<p>Get all workspaces</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def get_workspaces(self) -&gt; list:\n\"\"\"Get all workspaces\"\"\"\nreturn self._workspaces\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.init_payload","title":"<code>init_payload()</code>","text":"<p>Read the YAML or Terraform HCL payload file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>payload as a Python dict. Elements are the different payload sections.   None in case the file couldn't be found or read.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def init_payload(self) -&gt; dict | None:\n\"\"\"Read the YAML or Terraform HCL payload file.\n    Args:\n        None\n    Returns:\n        dict: payload as a Python dict. Elements are the different payload sections.\n              None in case the file couldn't be found or read.\n    \"\"\"\nif not os.path.exists(self._payload_source):\nlogger.error(\"Cannot access payload file -&gt; %s\", self._payload_source)\nreturn None\n# Is it a YAML file?\nif self._payload_source.endswith(\".yaml\"):\nlogger.info(\"Open payload from YAML file -&gt; %s\", self._payload_source)\ntry:\nwith open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\npayload_data = stream.read()\nself._payload = yaml.safe_load(payload_data)\nexcept yaml.YAMLError as exception:\nlogger.error(\n\"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\nself._payload_source,\nexception,\n)\nself._payload = {}\n# Or is it a Terraform HCL file?\nelif self._payload_source.endswith(\".tf\"):\nlogger.info(\n\"Open payload from Terraform HCL file -&gt; %s\", self._payload_source\n)\ntry:\nwith open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\nself._payload = hcl2.api.load(stream)\n# If payload is wrapped into \"external_payload\" we unwrap it:\nif self._payload.get(\"external_payload\"):\nself._payload = self._payload[\"external_payload\"]\nexcept FileNotFoundError as exception:\nlogger.error(\n\"Error while reading Terraform HCL payload file -&gt; %s; error -&gt; %s\",\nself._payload_source,\nexception,\n)\nself._payload = {}\nelif self._payload_source.endswith(\".yml.gz.b64\"):\nlogger.info(\n\"Open payload from base64-gz-YAML file -&gt; %s\", self._payload_source\n)\ntry:\nwith open(self._payload_source, \"r\", encoding=\"utf-8\") as stream:\ncontent = base64.b64decode(stream.read())\ndecoded_data = gzip.decompress(content)\nself._payload = yaml.safe_load(decoded_data)\nexcept yaml.YAMLError as exception:\nlogger.error(\n\"Error while reading YAML payload file -&gt; %s; error -&gt; %s\",\nself._payload_source,\nexception,\n)\nself._payload = {}\n# If not, it is an unsupported type:\nelse:\nlogger.error(\n\"File -&gt; %s has unsupported file type\",\nself._payload_source,\n)\nself._payload = {}\nif self._payload is not None:\nself._payload_sections = self._payload[\"payloadSections\"]\nif not self._payload_sections:\nlogger.error(\n\"Sections for payload -&gt; %s are undefined. Skipping...\",\nself._payload_source,\n)\nreturn None\n# Retrieve all the payload sections and store them in lists:\nself._webhooks = self.get_payload_section(\"webHooks\")\nself._webhooks_post = self.get_payload_section(\"webHooksPost\")\nself._partitions = self.get_payload_section(\"partitions\")\nself._oauth_clients = self.get_payload_section(\"oauthClients\")\nself._auth_handlers = self.get_payload_section(\"authHandlers\")\nself._trusted_sites = self.get_payload_section(\"trustedSites\")\nself._system_attributes = self.get_payload_section(\"systemAttributes\")\nself._groups = self.get_payload_section(\"groups\")\nself._users = self.get_payload_section(\"users\")\nself._admin_settings = self.get_payload_section(\"adminSettings\")\nself._exec_pod_commands = self.get_payload_section(\"execPodCommands\")\nself._external_systems = self.get_payload_section(\"externalSystems\")\nself._transport_packages = self.get_payload_section(\"transportPackages\")\nself._content_transport_packages = self.get_payload_section(\n\"contentTransportPackages\"\n)\nself._transport_packages_post = self.get_payload_section(\n\"transportPackagesPost\"\n)\nself._workspace_templates = self.get_payload_section(\"workspaceTemplates\")\nself._workspaces = self.get_payload_section(\"workspaces\")\nself._sap_rfcs = self.get_payload_section(\"sapRFCs\")\nself._web_reports = self.get_payload_section(\"webReports\")\nself._web_reports_post = self.get_payload_section(\"webReportsPost\")\nself._cs_applications = self.get_payload_section(\"csApplications\")\nself._admin_settings_post = self.get_payload_section(\"adminSettingsPost\")\nself._additional_group_members = self.get_payload_section(\n\"additionalGroupMemberships\"\n)\nself._additional_access_role_members = self.get_payload_section(\n\"additionalAccessRoleMemberships\"\n)\nself._renamings = self.get_payload_section(\"renamings\")\nself._items = self.get_payload_section(\"items\")\nself._items_post = self.get_payload_section(\"itemsPost\")\nself._permissions = self.get_payload_section(\"permissions\")\nself._permissions_post = self.get_payload_section(\"permissionsPost\")\nself._assignments = self.get_payload_section(\"assignments\")\nself._security_clearances = self.get_payload_section(\"securityClearances\")\nself._supplemental_markings = self.get_payload_section(\"supplementalMarkings\")\nself._records_management_settings = self.get_payload_section(\n\"recordsManagementSettings\"\n)\nself._holds = self.get_payload_section(\"holds\")\nself._doc_generators = self.get_payload_section(\"documentGenerators\")\nself._browser_automations = self.get_payload_section(\"browserAutomations\")\nreturn self._payload\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.init_sap","title":"<code>init_sap(sap_external_system, direct_application_server_login=True)</code>","text":"<p>Initialize SAP object for RFC communication with SAP S/4HANA.</p> <p>Parameters:</p> Name Type Description Default <code>sap_external_system</code> <code>dict</code> <p>SAP external system created before</p> required <code>direct_application_server_login</code> <code>bool</code> <p>flag to control wether we comminicate directly with                                     SAP application server or via a load balancer</p> <code>True</code> <p>Returns:</p> Name Type Description <code>SAP</code> <code>SAP | None</code> <p>SAP object</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def init_sap(\nself, sap_external_system: dict, direct_application_server_login: bool = True\n) -&gt; SAP | None:\n\"\"\"Initialize SAP object for RFC communication with SAP S/4HANA.\n    Args:\n        sap_external_system (dict): SAP external system created before\n        direct_application_server_login (bool): flag to control wether we comminicate directly with\n                                                SAP application server or via a load balancer\n    Returns:\n        SAP: SAP object\n    \"\"\"\nif not sap_external_system:\nreturn None\nusername = sap_external_system[\"username\"]\npassword = sap_external_system[\"password\"]\n# \"external_system_hostname\" is extracted from as_url in process_external_systems()\nhost = sap_external_system[\"external_system_hostname\"]\nclient = sap_external_system.get(\"client\", \"100\")\nsystem_number = sap_external_system.get(\"external_system_number\", \"00\")\nsystem_id = sap_external_system[\"external_system_name\"]\ngroup = sap_external_system.get(\"group\", \"PUBLIC\")\ndestination = sap_external_system.get(\"destination\", \"\")\nlogger.info(\"Connection parameters SAP:\")\nlogger.info(\"SAP Hostname             = %s\", host)\nlogger.info(\"SAP Client               = %s\", client)\nlogger.info(\"SAP System Number        = %s\", system_number)\nlogger.info(\"SAP System ID            = %s\", system_id)\nlogger.info(\"SAP User Name            = %s\", username)\nif not direct_application_server_login:\nlogger.info(\"SAP Group Name (for RFC) = %s\", group)\nif destination:\nlogger.info(\"SAP Destination          = %s\", destination)\nif direct_application_server_login:\nlogger.info(\"SAP Login                = Direct Application Server (ashost)\")\nsap_object = SAP(\nusername=username,\npassword=password,\nashost=host,\nclient=client,\nsystem_number=system_number,\nsystem_id=system_id,\ndestination=destination,\n)\nelse:\nlogger.info(\"SAP Login                = Logon with load balancing (mshost)\")\nsap_object = SAP(\nusername=username,\npassword=password,\nmshost=host,\ngroup=group,\nclient=client,\nsystem_number=system_number,\nsystem_id=system_id,\ndestination=destination,\n)\nreturn sap_object\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_additional_access_role_members","title":"<code>process_additional_access_role_members(section_name='additionalAccessRoleMemberships')</code>","text":"<p>Process additional access role memberships we want to have in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'additionalAccessRoleMemberships'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_additional_access_role_members(\nself, section_name: str = \"additionalAccessRoleMemberships\"\n) -&gt; bool:\n\"\"\"Process additional access role memberships we want to have in OTDS.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._additional_access_role_members:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor additional_access_role_member in self._additional_access_role_members:\nif not \"access_role\" in additional_access_role_member:\nlogger.error(\"Missing access_role! Skipping...\")\ncontinue\naccess_role = additional_access_role_member[\"access_role\"]\nif (\n\"enabled\" in additional_access_role_member\nand not additional_access_role_member[\"enabled\"]\n):\nlogger.info(\n\"Payload for Additional Member for AccessRole -&gt; %s is disabled. Skipping...\",\naccess_role,\n)\ncontinue\nif (\n(not \"user_name\" in additional_access_role_member)\nand (not \"group_name\" in additional_access_role_member)\nand (not \"partition_name\" in additional_access_role_member)\n):\nlogger.error(\n\"Either group_name or user_name need to be specified! Skipping...\"\n)\nsuccess = False\ncontinue\nif \"group_name\" in additional_access_role_member:\ngroup_name = additional_access_role_member[\"group_name\"]\nlogger.info(\n\"Adding group -&gt; %s to access role -&gt; %s in OTDS.\",\ngroup_name,\naccess_role,\n)\nresponse = self._otds.add_group_to_access_role(access_role, group_name)\nif not response:\nlogger.error(\n\"Failed to add group -&gt; %s to access role -&gt; %s in OTDS.\",\ngroup_name,\naccess_role,\n)\nsuccess = False\nelif \"user_name\" in additional_access_role_member:\nuser_name = additional_access_role_member[\"user_name\"]\nlogger.info(\n\"Adding user -&gt; %s to access role -&gt; %s in OTDS.\",\nuser_name,\naccess_role,\n)\nresponse = self._otds.add_user_to_access_role(access_role, user_name)\nif not response:\nlogger.error(\n\"Failed to add user -&gt; %s to access role -&gt; %s in OTDS.\",\nuser_name,\naccess_role,\n)\nsuccess = False\nelif \"partition_name\" in additional_access_role_member:\npartition_name = additional_access_role_member[\"partition_name\"]\nlogger.info(\n\"Adding partition -&gt; %s to access role -&gt; %s in OTDS.\",\npartition_name,\naccess_role,\n)\nresponse = self._otds.add_partition_to_access_role(\naccess_role, partition_name\n)\nif not response:\nlogger.error(\n\"Failed to add partition -&gt; %s to access role -&gt; %s in OTDS.\",\npartition_name,\naccess_role,\n)\nsuccess = False\nself.write_status_file(\nsuccess, section_name, self._additional_access_role_members\n)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_additional_group_members","title":"<code>process_additional_group_members(section_name='additionalGroupMemberships')</code>","text":"<p>Process additional groups memberships we want to have in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'additionalGroupMemberships'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_additional_group_members(\nself, section_name: str = \"additionalGroupMemberships\"\n) -&gt; bool:\n\"\"\"Process additional groups memberships we want to have in OTDS.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._additional_group_members:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor additional_group_member in self._additional_group_members:\nif not \"parent_group\" in additional_group_member:\nlogger.error(\"Missing parent_group! Skipping...\")\ncontinue\nparent_group = additional_group_member[\"parent_group\"]\nif (\n\"enabled\" in additional_group_member\nand not additional_group_member[\"enabled\"]\n):\nlogger.info(\n\"Payload for Additional Group Member with Parent Group -&gt; %s is disabled. Skipping...\",\nparent_group,\n)\ncontinue\nif (not \"user_name\" in additional_group_member) and (\nnot \"group_name\" in additional_group_member\n):\nlogger.error(\n\"Either group_name or user_name need to be specified! Skipping...\"\n)\nsuccess = False\ncontinue\nif \"group_name\" in additional_group_member:\ngroup_name = additional_group_member[\"group_name\"]\nlogger.info(\n\"Adding group -&gt; %s to parent group -&gt; %s in OTDS.\",\ngroup_name,\nparent_group,\n)\nresponse = self._otds.add_group_to_parent_group(\ngroup_name, parent_group\n)\nif not response:\nlogger.error(\n\"Failed to add group -&gt; %s to parent group -&gt; %s in OTDS.\",\ngroup_name,\nparent_group,\n)\nsuccess = False\nelif \"user_name\" in additional_group_member:\nuser_name = additional_group_member[\"user_name\"]\nlogger.info(\n\"Adding user -&gt; %s to group -&gt; %s in OTDS.\", user_name, parent_group\n)\nresponse = self._otds.add_user_to_group(user_name, parent_group)\nif not response:\nlogger.error(\n\"Failed to add user -&gt; %s to group -&gt; %s in OTDS.\",\nuser_name,\nparent_group,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._additional_group_members)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_admin_settings","title":"<code>process_admin_settings(admin_settings, section_name='adminSettings')</code>","text":"<p>Process admin settings in payload and import them to Extended ECM.</p> <pre><code>The payload section is a list of dicts with these items:\n{\n    enabled: True or False to enable or disable the payload item\n    filename: The filename of the XML file with admin settings.\n              It needs to be the plain filename like \"admin.xml\".\n              The files reside inside the container in /settings root\n              directory. They are placed there by the Terraform automation\n              and are taken from the ./settings/payload directory.\n    description: Some description about the purpose of the settings.\n                 Just for information and optional.\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>admin_settings</code> <code>list</code> <p>list of admin settings. We need this parameter                    as we process two different lists.</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"adminSettingsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'adminSettings'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a restart of the OTCS pods is required. False otherwise.</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_admin_settings(\nself, admin_settings: list, section_name: str = \"adminSettings\"\n) -&gt; bool:\n\"\"\"Process admin settings in payload and import them to Extended ECM.\n        The payload section is a list of dicts with these items:\n        {\n            enabled: True or False to enable or disable the payload item\n            filename: The filename of the XML file with admin settings.\n                      It needs to be the plain filename like \"admin.xml\".\n                      The files reside inside the container in /settings root\n                      directory. They are placed there by the Terraform automation\n                      and are taken from the ./settings/payload directory.\n            description: Some description about the purpose of the settings.\n                         Just for information and optional.\n        }\n    Args:\n        admin_settings (list): list of admin settings. We need this parameter\n                               as we process two different lists.\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"adminSettingsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if a restart of the OTCS pods is required. False otherwise.\n    \"\"\"\nif not admin_settings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn False  # important to return False here as otherwise we are triggering a restart of services!!\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn False  # important to return False here as otherwise we are triggering a restart of services!!\nrestart_required: bool = False\nsuccess: bool = True\nfor admin_setting in admin_settings:\n# Sanity checks:\nif not \"filename\" in admin_setting:\nlogger.error(\"Filename is missing. Skipping to next admin setting...\")\ncontinue\nfilename = admin_setting[\"filename\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in admin_setting and not admin_setting[\"enabled\"]:\nlogger.info(\n\"Payload for setting file -&gt; %s is disabled. Skipping...\", filename\n)\ncontinue\nsettings_file = self._custom_settings_dir + filename\nif os.path.exists(settings_file):\ndescription = admin_setting.get(\"description\")\nif description:\nlogger.info(description)\n# Read the config file:\nwith open(settings_file, \"r\", encoding=\"utf-8\") as file:\nfile_content = file.read()\nlogger.debug(\n\"Replace Placeholder -&gt; %s in file -&gt; %s\",\nself._placeholder_values,\nfile_content,\n)\nfile_content = self.replace_placeholders(file_content)\n# Write the updated config file:\ntmpfile = \"/tmp/\" + os.path.basename(settings_file)\nwith open(tmpfile, \"w\", encoding=\"utf-8\") as file:\nfile.write(file_content)\nresponse = self._otcs.apply_config(tmpfile)\nif response and response[\"results\"][\"data\"][\"restart\"]:\nlogger.info(\"A restart of Extended ECM service is required.\")\nrestart_required = True\nelse:\nlogger.error(\"Admin settings file -&gt; %s not found.\", settings_file)\nsuccess = False\nself.write_status_file(success, section_name, admin_settings)\nreturn restart_required\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_assignments","title":"<code>process_assignments(section_name='assignments')</code>","text":"<p>Process assignments specified in payload and assign items (such as workspaces and items withnicknames) to users or groups.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'assignments'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_assignments(self, section_name: str = \"assignments\") -&gt; bool:\n\"\"\"Process assignments specified in payload and assign items (such as workspaces and\n    items withnicknames) to users or groups.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._assignments:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor assignment in self._assignments:\n# Sanity check: we need a subject - it's mandatory:\nif not \"subject\" in assignment:\nlogger.error(\"Assignment needs a subject! Skipping assignment...\")\nsuccess = False\ncontinue\nsubject = assignment[\"subject\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in assignment and not assignment[\"enabled\"]:\nlogger.info(\n\"Payload for Assignment -&gt; %s is disabled. Skipping...\", subject\n)\ncontinue\n# instruction is optional but we give a warning if they are missing:\nif not \"instruction\" in assignment:\nlogger.warning(\"Assignment -&gt; %s should have an instruction!\", subject)\ninstruction = \"\"\nelse:\ninstruction = assignment[\"instruction\"]\n# Sanity check: we either need users or groups (or both):\nif not \"groups\" in assignment and not \"users\" in assignment:\nlogger.error(\n\"Assignment -&gt; %s needs groups or users! Skipping assignment...\",\nsubject,\n)\nsuccess = False\ncontinue\n# Check if a workspace is specified for the assignment and check it does exist:\nif \"workspace\" in assignment and assignment[\"workspace\"]:\nworkspace = next(\n(\nitem\nfor item in self._workspaces\nif item[\"id\"] == assignment[\"workspace\"]\n),\nNone,\n)\nif not workspace:\nlogger.error(\n\"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\nsubject,\nassignment[\"workspace\"],\n)\nsuccess = False\ncontinue\nnode_id = self.determine_workspace_id(workspace)\nif not node_id:\nlogger.error(\n\"Assignment -&gt; %s has specified a not existing workspace -&gt; %s! Skipping assignment...\",\nsubject,\nassignment[\"workspace\"],\n)\nsuccess = False\ncontinue\n# If we don't have a workspace then check if a nickname is specified for the assignment:\nelif \"nickname\" in assignment:\nresponse = self._otcs.get_node_from_nickname(assignment[\"nickname\"])\nnode_id = self._otcs.get_result_value(response, \"id\")\nif not node_id:\n# if response == None:\nlogger.error(\n\"Assignment item with nickname -&gt; %s not found\",\nassignment[\"nickname\"],\n)\nsuccess = False\ncontinue\nelse:\nlogger.error(\n\"Assignment -&gt; %s needs a workspace or nickname! Skipping assignment...\",\nsubject,\n)\nsuccess = False\ncontinue\nassignees = []\nif \"groups\" in assignment:\ngroup_assignees = assignment[\"groups\"]\nfor group_assignee in group_assignees:\n# find the group in the group list\ngroup = next(\n(\nitem\nfor item in self._groups\nif item[\"name\"] == group_assignee\n),\nNone,\n)\nif not group:\nlogger.error(\n\"Assignment group -&gt; %s does not exist! Skipping group...\",\ngroup_assignee,\n)\nsuccess = False\ncontinue\nif not \"id\" in group:\nlogger.error(\n\"Assignment group -&gt; %s does not have an ID. Skipping group...\",\ngroup_assignee,\n)\nsuccess = False\ncontinue\ngroup_id = group[\"id\"]\n# add the group ID to the assignee list:\nassignees.append(group_id)\nif \"users\" in assignment:\nuser_assignees = assignment[\"users\"]\nfor user_assignee in user_assignees:\n# find the user in the user list\nuser = next(\n(item for item in self._users if item[\"name\"] == user_assignee),\nNone,\n)\nif not user:\nlogger.error(\n\"Assignment user -&gt; %s does not exist! Skipping user...\",\nuser_assignee,\n)\nsuccess = False\ncontinue\nif not \"id\" in user:\nlogger.error(\n\"Assignment user -&gt; %s does not have an ID. Skipping user...\",\nuser_assignee,\n)\nsuccess = False\ncontinue\nuser_id = user[\"id\"]\n# add the group ID to the assignee list:\nassignees.append(user_id)\nif not assignees:\nlogger.error(\n\"Cannot add assignment -&gt; %s for node ID -&gt; %s because no assignee was found.\",\nsubject,\nnode_id,\n)\nsuccess = False\ncontinue\nresponse = self._otcs.assign_item_to_user_group(\nint(node_id), subject, instruction, assignees\n)\nif not response:\nlogger.error(\n\"Failed to add assignment -&gt; %s for node ID -&gt; %s with assignees -&gt; %s.\",\nsubject,\nnode_id,\nassignees,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._assignments)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_auth_handlers","title":"<code>process_auth_handlers(section_name='authHandlers')</code>","text":"<p>Process OTDS authorization handlers in payload and create them in OTDS.    An authorization handler defined the connection to an Identity Provider (IdP).</p> <pre><code>The payload section is a list of dicts with these items:\n{\n    enabled: True or False to enable or disable the payload item\n    name: Name of the authorization handler. This is shown in the first\n          column of the Auth Handler list in OTDS.\n    description: Description of the handler. This is shown in the second\n                 column of the Auth Handler\n    type: type of the handler. Possible values are SALM, SAP, OAUTH\n    priority: a numeric value to order different handlers in OTDS by priority\n    active_by_default: Whether to activate this handler for any request to the\n                       OTDS login page. If True, any login request to the OTDS\n                       login page will be redirected to the IdP. If false, the\n                       user has to select the provider on the login page.\n    provider_name: The name of the identity provider. This should be a single word\n                   since it will be part of the metadata URL. This is what is\n                   shown as a button on the OTDS login page.\n    auth_principal_attributes: Authentication principal attributes (list)\n    nameid_format: Specifies which NameID format supported by the identity provider\n                   contains the desired user identifier. The value in this identifier\n                   must correspond to the value of the user attribute specified for the\n                   authentication principal attribute.\n    saml_url: Required for SAML Authentication Handler. The URL for the IdP's federation metadata.\n    otds_sp_endpoint: Used for SAML Authentication Handler. Specifies the service provider URL that will\n                      be used to identify OTDS to the identity provider.\n    certificate_file: Required for SAP Authentication Handler (SAPSSOEXT).\n                      Fully qualified file name (with path) to the certificate file (URI)\n    certificate_password: Required for SAP Authentication Handler (SAPSSOEXT).\n                          Password of the certificate file.\n    client_id: Client ID. Required for OAUTH authentication handler.\n    client_secret: Client Secret. Required for OAUTH authentication handler.\n    authorization_endpoint: Required for OAUTH authentication handler.\n                            The URL to redirect the browser to for authentication.\n                            It is used to retrieve the authorization code or an OIDC id_token.\n    token_endpoint: Used for OAUTH authentication handler. The URL from which to retrieve the access token.\n                    Not strictly required with OpenID Connect if using the implicit flow.\n    scope_string: Used for OAUTH authentication handler. Space delimited scope values to send.\n                  Include 'openid' to use OpenID Connect.\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'authHandlers'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_auth_handlers(self, section_name: str = \"authHandlers\") -&gt; bool:\n\"\"\"Process OTDS authorization handlers in payload and create them in OTDS.\n       An authorization handler defined the connection to an Identity Provider (IdP).\n        The payload section is a list of dicts with these items:\n        {\n            enabled: True or False to enable or disable the payload item\n            name: Name of the authorization handler. This is shown in the first\n                  column of the Auth Handler list in OTDS.\n            description: Description of the handler. This is shown in the second\n                         column of the Auth Handler\n            type: type of the handler. Possible values are SALM, SAP, OAUTH\n            priority: a numeric value to order different handlers in OTDS by priority\n            active_by_default: Whether to activate this handler for any request to the\n                               OTDS login page. If True, any login request to the OTDS\n                               login page will be redirected to the IdP. If false, the\n                               user has to select the provider on the login page.\n            provider_name: The name of the identity provider. This should be a single word\n                           since it will be part of the metadata URL. This is what is\n                           shown as a button on the OTDS login page.\n            auth_principal_attributes: Authentication principal attributes (list)\n            nameid_format: Specifies which NameID format supported by the identity provider\n                           contains the desired user identifier. The value in this identifier\n                           must correspond to the value of the user attribute specified for the\n                           authentication principal attribute.\n            saml_url: Required for SAML Authentication Handler. The URL for the IdP's federation metadata.\n            otds_sp_endpoint: Used for SAML Authentication Handler. Specifies the service provider URL that will\n                              be used to identify OTDS to the identity provider.\n            certificate_file: Required for SAP Authentication Handler (SAPSSOEXT).\n                              Fully qualified file name (with path) to the certificate file (URI)\n            certificate_password: Required for SAP Authentication Handler (SAPSSOEXT).\n                                  Password of the certificate file.\n            client_id: Client ID. Required for OAUTH authentication handler.\n            client_secret: Client Secret. Required for OAUTH authentication handler.\n            authorization_endpoint: Required for OAUTH authentication handler.\n                                    The URL to redirect the browser to for authentication.\n                                    It is used to retrieve the authorization code or an OIDC id_token.\n            token_endpoint: Used for OAUTH authentication handler. The URL from which to retrieve the access token.\n                            Not strictly required with OpenID Connect if using the implicit flow.\n            scope_string: Used for OAUTH authentication handler. Space delimited scope values to send.\n                          Include 'openid' to use OpenID Connect.\n        }\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._auth_handlers:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor auth_handler in self._auth_handlers:\nhandler_name = auth_handler.get(\"name\")\nif not handler_name:\nlogger.error(\"Auth handler does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if Auth Handler does already exist (e.g. after a restart of\n# the customizer pod):\nif self._otds.get_auth_handler(handler_name, show_error=False):\nlogger.info(\"Auth handler -&gt; %s does already exist. Skipping...\")\ncontinue\nhandler_description = auth_handler.get(\"description\")\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in auth_handler and not auth_handler[\"enabled\"]:\nlogger.info(\n\"Payload for OTDS Authorization Handler -&gt; %s is disabled. Skipping...\",\nhandler_name,\n)\ncontinue\nhandler_scope = auth_handler.get(\"scope\")\nif not handler_scope:\n# Make sure to pass None also if scope is empty string\nhandler_scope = None\nhandler_type = auth_handler.get(\"type\")\nif not handler_type:\nlogger.error(\n\"OTDS Authorization handler does not have a type. Skipping...\"\n)\nsuccess = False\ncontinue\npriority = auth_handler.get(\"priority\")\nactive_by_default = auth_handler.get(\"active_by_default\")\nif not active_by_default:\nactive_by_default = False\nmatch handler_type:\ncase \"SAML\":\nprovider_name = auth_handler.get(\"provider_name\")\nif not provider_name:\nlogger.error(\n\"SAML Authorization handler needs a provider. Skipping...\"\n)\nsuccess = False\ncontinue\nsaml_url = auth_handler.get(\"saml_url\")\nif not saml_url:\nlogger.error(\n\"SAML Authorization handler needs a SAML URL. Skipping...\"\n)\nsuccess = False\ncontinue\notds_sp_endpoint = auth_handler.get(\"otds_sp_endpoint\")\nif not otds_sp_endpoint:\nlogger.error(\n\"SAML Authorization handler needs a OTDS SP Endpoint. Skipping...\"\n)\nsuccess = False\ncontinue\nauth_principal_attributes = auth_handler.get(\n\"auth_principal_attributes\"\n)\nnameid_format = auth_handler.get(\"nameid_format\")\nresponse = self._otds.add_auth_handler_saml(\nname=handler_name,\ndescription=handler_description,\nscope=handler_scope,\nprovider_name=provider_name,\nsaml_url=saml_url,\notds_sp_endpoint=otds_sp_endpoint,\npriority=priority,\nactive_by_default=active_by_default,\nauth_principal_attributes=auth_principal_attributes,\nnameid_format=nameid_format,\n)\ncase \"SAP\":\ncertificate_file = auth_handler.get(\"certificate_file\")\nif not certificate_file:\nlogger.error(\n\"SAP Authorization handler -&gt; %s (%s) requires a certificate file name. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\ncertificate_password = auth_handler.get(\"certificate_password\")\nif not certificate_password:\n# This is not an error - we canhave this key with empty string!\nlogger.info(\n\"SAP Authorization handler -&gt; %s (%s) does not have a certificate password - this can be OK.\",\nhandler_name,\nhandler_type,\n)\nresponse = self._otds.add_auth_handler_sap(\nname=handler_name,\ndescription=handler_description,\nscope=handler_scope,\ncertificate_file=certificate_file,\ncertificate_password=certificate_password,\npriority=priority,\n)\ncase \"OAUTH\":\nprovider_name = auth_handler.get(\"provider_name\")\nif not provider_name:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a provider name. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\nclient_id = auth_handler.get(\"client_id\")\nif not client_id:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a client ID. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\nclient_secret = auth_handler.get(\"client_secret\")\nif not client_secret:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a client secret. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\nauthorization_endpoint = auth_handler.get(\"authorization_endpoint\")\nif not authorization_endpoint:\nlogger.error(\n\"OAUTH Authorization handler -&gt; %s (%s) requires a authorization endpoint. Skipping...\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\ncontinue\ntoken_endpoint = auth_handler.get(\"token_endpoint\")\nif not token_endpoint:\nlogger.warning(\n\"OAUTH Authorization handler -&gt; %s (%s) does not have a token endpoint.\",\nhandler_name,\nhandler_type,\n)\nscope_string = auth_handler.get(\"scope_string\")\nresponse = self._otds.add_auth_handler_oauth(\nname=handler_name,\ndescription=handler_description,\nscope=handler_scope,\nprovider_name=provider_name,\nclient_id=client_id,\nclient_secret=client_secret,\npriority=priority,\nactive_by_default=active_by_default,\nauthorization_endpoint=authorization_endpoint,\ntoken_endpoint=token_endpoint,\nscope_string=scope_string,\n)\ncase _:\nlogger.error(\n\"Unsupported authorization handler type -&gt; %s\", handler_type\n)\nreturn False\nif response:\nlogger.info(\n\"Successfully added OTDS authorization handler -&gt; %s (%s)\",\nhandler_name,\nhandler_type,\n)\nelse:\nlogger.error(\n\"Failed to add OTDS authorization handler -&gt; %s (%s)\",\nhandler_name,\nhandler_type,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._auth_handlers)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_browser_automations","title":"<code>process_browser_automations(section_name='browserAutomations', check_status=True)</code>","text":"<p>Process Selenium-based browser automations.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'browserAutomations'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_browser_automations(\nself, section_name: str = \"browserAutomations\", check_status: bool = True\n) -&gt; bool:\n\"\"\"Process Selenium-based browser automations.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._browser_automations:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif check_status and self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor browser_automation in self._browser_automations:\ndescription = browser_automation.get(\"description\", \"\")\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in browser_automation and not browser_automation[\"enabled\"]:\nlogger.info(\n\"Payload for Browser Automation -&gt; %s is disabled. Skipping...\",\ndescription,\n)\ncontinue\nif not \"base_url\" in browser_automation:\nlogger.error(\"Browser automation is missing base_url. Skipping...\")\nsuccess = False\ncontinue\nbase_url = browser_automation.get(\"base_url\")\nif not \"user_name\" in browser_automation:\nlogger.info(\"Browser automation is not having user name.\")\nuser_name = browser_automation.get(\"user_name\", \"\")\nif not \"password\" in browser_automation:\nlogger.info(\"Browser automation is not having password.\")\npassword = browser_automation.get(\"password\", \"\")\nif not \"automations\" in browser_automation:\nlogger.error(\n\"Browser automation is missing list of automations. Skipping...\"\n)\nsuccess = False\ncontinue\nautomations = browser_automation.get(\"automations\", [])\n# Create Selenium Browser Automation:\nlogger.info(\"Browser Automation URL -&gt; %s\", base_url)\nlogger.info(\"Browser Automation User -&gt; %s\", user_name)\nlogger.debug(\"Browser Automation Password -&gt; %s\", password)\nbrowser_automation_object = BrowserAutomation(\nbase_url=base_url,\nuser_name=user_name,\nuser_password=password,\n)\nfor automation in automations:\nif not \"type\" in automation:\nlogger.error(\"Browser automation step is missing type. Skipping...\")\nsuccess = False\nbreak\nautomation_type = automation.get(\"type\", \"\")\nmatch automation_type:\ncase \"login\":\npage = automation.get(\"page\", \"\")\nlogger.info(\n\"Login to -&gt; %s as user -&gt; %s\", base_url + page, user_name\n)\nuser_field = automation.get(\"user_field\", \"otds_username\")\npassword_field = automation.get(\n\"password_field\", \"otds_password\"\n)\nlogin_button = automation.get(\"login_button\", \"loginbutton\")\nif not browser_automation_object.run_login(\nuser_field=user_field,\npassword_field=password_field,\nlogin_button=login_button,\n):\nlogger.error(\n\"Cannot log into -&gt; %s. Stopping automation.\",\nbase_url + page,\n)\nsuccess = False\nbreak\nelse:\nlogger.info(\n\"Successfuly logged into page -&gt; %s.\", base_url + page\n)\ncase \"get_page\":\npage = automation.get(\"page\", \"\")\nif not page:\nlogger.error(\n\"Automation type -&gt; %s requires page parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\nlogger.info(\"Get page -&gt; %s\", base_url + page)\nif not browser_automation_object.get_page(url=page):\nlogger.error(\n\"Cannot get page -&gt; %s. Stopping automation.\",\npage,\n)\nsuccess = False\nbreak\nelse:\nbrowser_automation_object.implict_wait(15.0)\nlogger.info(\n\"Successfuly loaded page -&gt; %s.\", base_url + page\n)\ncase \"click_elem\":\nelem = automation.get(\"elem\", \"\")\nif not elem:\nlogger.error(\n\"Automation type -&gt; %s requires elem parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\nfind = automation.get(\"find\", \"id\")\nif not browser_automation_object.find_elem_and_click(\nfind_elem=elem, find_method=find\n):\nlogger.error(\n\"Cannot find clickable element -&gt; %s on current page. Stopping automation.\",\nelem,\n)\nsuccess = False\nbreak\nelse:\nbrowser_automation_object.implict_wait(15.0)\nlogger.info(\"Successfuly clicked element -&gt; %s.\", elem)\ncase \"set_elem\":\nelem = automation.get(\"elem\", \"\")\nif not elem:\nlogger.error(\n\"Automation type -&gt; %s requires elem parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\nfind = automation.get(\"find\", \"id\")\nvalue = automation.get(\"value\", \"\")\nif not value:\nlogger.error(\n\"Automation type -&gt; %s requires value parameter\",\nautomation_type,\n)\nsuccess = False\nbreak\n# we also support replacing placeholders that are\n# enclosed in double % characters like %%OTCS_RESOURCE_ID%%:\nvalue = self.replace_placeholders(value)\nif not browser_automation_object.find_elem_and_set(\nfind_elem=elem, elem_value=value, find_method=find\n):\nlogger.error(\n\"Cannot find element -&gt; %s on current page to set value -&gt; %s. Stopping automation.\",\nelem,\nvalue,\n)\nsuccess = False\nbreak\nelse:\nlogger.info(\n\"Successfuly set element -&gt; %s to set value -&gt; %s.\",\nelem,\nvalue,\n)\ncase _:\nlogger.error(\n\"Illegal automation step type -&gt; %s in browser automation!\",\nautomation_type,\n)\nsuccess = False\nbreak\nif check_status:\nself.write_status_file(success, section_name, self._browser_automations)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_cs_applications","title":"<code>process_cs_applications(otcs_object, section_name='csApplications')</code>","text":"<p>Process CS applications in payload and install them in Extended ECM. The CS Applications need to be installed in all frontend and backends.</p> <p>Parameters:</p> Name Type Description Default <code>otcs_object</code> <code>object</code> <p>this can either be the OTCS frontend or OTCS backend. If None                   then the otcs_backend is used.</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'csApplications'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_cs_applications(\nself, otcs_object: OTCS, section_name: str = \"csApplications\"\n) -&gt; bool:\n\"\"\"Process CS applications in payload and install them in Extended ECM.\n    The CS Applications need to be installed in all frontend and backends.\n    Args:\n        otcs_object (object): this can either be the OTCS frontend or OTCS backend. If None\n                              then the otcs_backend is used.\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._cs_applications:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# OTCS backend is the default:\nif not otcs_object:\notcs_object = self._otcs_backend\nfor cs_application in self._cs_applications:\napplication_name = cs_application[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in cs_application and not cs_application[\"enabled\"]:\nlogger.info(\n\"Payload for CS Application -&gt; %s is disabled. Skipping...\",\napplication_name,\n)\ncontinue\napplication_description = cs_application[\"description\"]\nlogger.info(\n\"Install CS Application -&gt; %s (%s)...\",\napplication_name,\napplication_description,\n)\nresponse = otcs_object.install_cs_application(application_name)\nif response is None:\nlogger.error(\n\"Failed to install CS Application -&gt; %s!\", application_name\n)\nsuccess = False\nself.write_status_file(success, section_name, self._cs_applications)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_document_generators","title":"<code>process_document_generators(section_name='documentGenerators')</code>","text":"<p>Generate documents for a defined workspace type based on template</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'documentGenerators'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_document_generators(\nself, section_name: str = \"documentGenerators\"\n) -&gt; bool:\n\"\"\"Generate documents for a defined workspace type based on template\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._doc_generators:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# save admin credentials for later switch back to admin user:\nadmin_credentials = self._otcs.credentials()\nauthenticated_user = \"admin\"\nfor doc_generator in self._doc_generators:\nif not \"workspace_type\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces the workspace type needs to be specified in the payload! Skipping to next document generator...\"\n)\nsuccess = False\ncontinue\nworkspace_type = doc_generator[\"workspace_type\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in doc_generator and not doc_generator[\"enabled\"]:\nlogger.info(\n\"Payload for document generator of workspace type -&gt; %s is disabled. Skipping...\",\nworkspace_type,\n)\ncontinue\nif not \"template_path\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces of type -&gt; %s the path to the document template needs to be specified in the payload! Skipping to next document generator...\",\nworkspace_type,\n)\nsuccess = False\ncontinue\ntemplate_path = doc_generator[\"template_path\"]\n# 20541 is the ID of the Document Template Volume which\n# (we hope) is stable:\ntemplate = self._otcs.get_node_by_volume_and_path(20541, template_path)\nif not template:\nlogger.error(\n\"Cannot find document template in path -&gt; %s. Skipping to next document generator...\",\ntemplate_path,\n)\nsuccess = False\ncontinue\ntemplate_id = self._otcs.get_result_value(template, \"id\")\ntemplate_name = self._otcs.get_result_value(template, \"name\")\nif not \"classification_path\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces of type -&gt; %s the path to the document classification needs to be specified in the payload! Skipping to next document generator...\",\nworkspace_type,\n)\nsuccess = False\ncontinue\nclassification_path = doc_generator[\"classification_path\"]\nclassification = self._otcs.get_node_by_volume_and_path(\n198, classification_path\n)\nif not classification:\nlogger.error(\n\"Cannot find document classification in path -&gt; %s. Skipping to next document generator...\",\nclassification_path,\n)\nsuccess = False\ncontinue\nclassification_id = self._otcs.get_result_value(classification, \"id\")\n# \"category_name\" is optional. But if it is specified\n# then also \"attributes\" needs to be specified:\nif not \"category_name\" in doc_generator:\nlogger.info(\n\"No metadata (category name) specified in the payload for this document generator.\",\n)\ncategory_name = \"\"\nattributes = {}\ncategory_data = {}\nelse:\ncategory_name = doc_generator[\"category_name\"]\nif not \"attributes\" in doc_generator:\nlogger.error(\n\"To generate documents for workspaces of type -&gt; %s with metadata, the attributes needs to be specified in the payload! Skipping to next document generator...\",\nworkspace_type,\n)\nsuccess = False\ncontinue\nattributes = doc_generator[\"attributes\"]\n# The following method returns two values: the category ID and\n# a dict of the attributes. If the category is not found\n# on the document template it returns -1 for the category ID\n# and an empty dict for the attribute definitions:\n(\ncategory_id,\nattribute_definitions,\n) = self._otcs.get_node_category_definition(template_id, category_name)\nif category_id == -1:\nlogger.error(\n\"The document template -&gt; %s does not have the specified category -&gt; %s. Skipping to next document generator...\",\ntemplate_name,\ncategory_name,\n)\nsuccess = False\ncontinue\ncategory_data = {str(category_id): {}}\n# now we fill the prepared (but empty) category_data\n# with the actual attribute values from the payload:\nfor attribute in attributes:\nattribute_name = attribute[\"name\"]\nattribute_value = attribute[\"value\"]\nattribute_type = attribute_definitions[attribute_name][\"type\"]\nattribute_id = attribute_definitions[attribute_name][\"id\"]\n# Special treatment for type user: determine the ID for the login name.\n# the ID is the actual value we have to put in the attribute:\nif attribute_type == \"user\":\nuser = self._otcs.get_user(attribute_value, show_error=True)\nuser_id = self._otcs.get_result_value(response=user, key=\"id\")\nif not user_id:\nlogger.error(\n\"Cannot find user with login name -&gt; %s. Skipping...\",\nattribute_value,\n)\nsuccess = False\ncontinue\nattribute_value = user_id\ncategory_data[str(category_id)][attribute_id] = attribute_value\nif not \"workspace_folder_path\" in doc_generator:\nlogger.info(\n\"No workspace folder path defined for workspaces of type -&gt; %s. Documents will be stored in workspace root.\",\nworkspace_type,\n)\nworkspace_folder_path = []\nelse:\nworkspace_folder_path = doc_generator[\"workspace_folder_path\"]\nif \"exec_as_user\" in doc_generator:\nexec_as_user = doc_generator[\"exec_as_user\"]\n# Find the user in the users payload:\nexec_user = next(\n(item for item in self._users if item[\"name\"] == exec_as_user),\nNone,\n)\n# Have we found the user in the payload?\nif exec_user is not None:\nlogger.info(\n\"Executing document generator with user -&gt; %s\", exec_as_user\n)\n# we change the otcs credentials to the user:\nself._otcs.set_credentials(exec_user[\"name\"], exec_user[\"password\"])\n# we re-authenticate as the user:\nlogger.info(\"Authenticate user -&gt; %s...\", exec_as_user)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\nif not cookie:\nlogger.error(\"Couldn't authenticate user -&gt; %s\", exec_as_user)\ncontinue\nadmin_context = False\nauthenticated_user = exec_as_user\nelse:\nlogger.error(\n\"Cannot find user with login name -&gt; %s for executing. Executing as admin...\",\nexec_as_user,\n)\nadmin_context = True\nsuccess = False\nelse:\nadmin_context = True\nexec_as_user = \"admin\"\nif admin_context and authenticated_user != \"admin\":\n# Set back admin credentials:\nself._otcs.set_credentials(\nadmin_credentials[\"username\"], admin_credentials[\"password\"]\n)\n# we re-authenticate as the admin user:\nlogger.info(\n\"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\nauthenticated_user = \"admin\"\nif category_data:\nlogger.info(\n\"Generate documents for workspace type -&gt; %s based on template -&gt; %s with metadata -&gt; %s...\",\nworkspace_type,\ntemplate_name,\ncategory_data,\n)\nelse:\nlogger.info(\n\"Generate documents for workspace type -&gt; %s based on template -&gt; %s without metadata...\",\nworkspace_type,\ntemplate_name,\n)\n# Find the workspace type with the name given in the _workspace_types\n# datastructure that has been generated by process_workspace_type() method before:\nworkspace_type_id = next(\n(\nitem[\"id\"]\nfor item in self._workspace_types\nif item[\"name\"] == workspace_type\n),\nNone,\n)\nworkspace_instances = self._otcs.get_workspace_instances(\ntype_name=workspace_type, type_id=workspace_type_id\n)\nif not workspace_instances or not workspace_instances[\"results\"]:\nlogger.warning(\n\"No workspace instances found for workspace type -&gt; %s (%s)\",\nworkspace_type,\nworkspace_type_id,\n)\nfor workspace_instance in workspace_instances[\"results\"]:\nworkspace_id = workspace_instance[\"data\"][\"properties\"][\"id\"]\nworkspace_name = workspace_instance[\"data\"][\"properties\"][\"name\"]\nif workspace_folder_path:\nworkspace_folder = self._otcs.get_node_by_workspace_and_path(\nworkspace_id, workspace_folder_path\n)\nif workspace_folder:\nworkspace_folder_id = self._otcs.get_result_value(\nworkspace_folder, \"id\"\n)\nelse:\n# If the workspace template is not matching\n# the path we may have an error here. Then\n# we fall back to workspace root level.\nlogger.warning(\n\"Folder path does not exist in workspace -&gt; %s. Using workspace root level instead...\",\nworkspace_name,\n)\nworkspace_folder_id = workspace_id\nelse:\nworkspace_folder_id = workspace_id\ndocument_name = workspace_name + \" - \" + template_name\nlogger.info(\"Generate document -&gt; %s\", document_name)\nresponse = self._otcs.check_node_name(\nint(workspace_folder_id), document_name\n)\nif response[\"results\"]:\nlogger.warning(\n\"Node with name -&gt; %s does already exist in workspace folder with ID -&gt; %s\",\ndocument_name,\nworkspace_folder_id,\n)\ncontinue\nresponse = self._otcs.create_document_from_template(\nint(template_id),\nint(workspace_folder_id),\nint(classification_id),\ncategory_data,\ndocument_name,\n\"This document has been auto-generated by Terrarium\",\n)\nif not response:\nlogger.error(\n\"Failed to generate document -&gt; %s in workspace -&gt; %s (%s) as user -&gt; %s\",\ndocument_name,\nworkspace_name,\nworkspace_id,\nexec_as_user,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully generated document -&gt; %s in workspace -&gt; %s\",\ndocument_name,\nworkspace_name,\n)\nif authenticated_user != \"admin\":\n# Set back admin credentials:\nself._otcs.set_credentials(\nadmin_credentials[\"username\"], admin_credentials[\"password\"]\n)\n# we authenticate back as the admin user:\nlogger.info(\n\"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\nself.write_status_file(success, section_name, self._doc_generators)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_exec_pod_commands","title":"<code>process_exec_pod_commands(section_name='execPodCommands')</code>","text":"<p>Process commands that should be executed in the Kubernetes pods.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'execPodCommands'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_exec_pod_commands(self, section_name: str = \"execPodCommands\") -&gt; bool:\n\"\"\"Process commands that should be executed in the Kubernetes pods.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not isinstance(self._k8s, K8s):\nlogger.error(\"K8s not setup properly -&gt; Skipping %s...\", section_name)\nreturn False\nif not self._exec_pod_commands:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor exec_pod_command in self._exec_pod_commands:\nif not \"pod_name\" in exec_pod_command:\nlogger.error(\n\"To execute a command in a pod the pod name needs to be specified in the payload! Skipping to next pod command...\"\n)\nsuccess = False\ncontinue\npod_name = exec_pod_command[\"pod_name\"]\nif not \"command\" in exec_pod_command or not exec_pod_command.get(\"command\"):\nlogger.error(\n\"Pod command is not specified for pod -&gt; %s! It needs to be a non-empty list! Skipping to next pod command...\",\npod_name,\n)\nsuccess = False\ncontinue\ncommand = exec_pod_command[\"command\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in exec_pod_command and not exec_pod_command[\"enabled\"]:\nlogger.info(\n\"Payload for Exec Pod Command in pod -&gt; %s is disabled. Skipping...\",\npod_name,\n)\ncontinue\nif not \"description\" in exec_pod_command:\nlogger.info(\"Executing command -&gt; %s in pod -&gt; %s\", command, pod_name)\nelse:\ndescription = exec_pod_command[\"description\"]\nlogger.info(\n\"Executing command -&gt; %s in pod -&gt; %s (%s)\",\ncommand,\npod_name,\ndescription,\n)\nif (\nnot \"interactive\" in exec_pod_command\nor exec_pod_command[\"interactive\"] is False\n):\nresult = self._k8s.exec_pod_command(pod_name, command)\nelse:\nif not \"timeout\" in exec_pod_command:\nresult = self._k8s.exec_pod_command_interactive(pod_name, command)\nelse:\ntimeout = exec_pod_command[\"timeout\"]\nresult = self._k8s.exec_pod_command_interactive(\npod_name, command, timeout\n)\n# we need to differentiate 3 cases here:\n# 1. result = None is returned - this is an error (exception)\n# 2. result is empty string - this is OK\n# 3. result is a non-empty string - this is OK - print it to log\nif result is None:\nlogger.error(\n\"Execution of command -&gt; %s in pod -&gt; %s failed\",\ncommand,\npod_name,\n)\nsuccess = False\nelif result != \"\":\nlogger.info(\n\"Execution of command -&gt; %s in pod -&gt; %s returned result -&gt; %s\",\ncommand,\npod_name,\nresult,\n)\nelse:\n# It is not an error if no result is returned. It depends on the nature of the command\n# if a result is written to stdout or stderr.\nlogger.info(\n\"Execution of command -&gt; %s in pod -&gt; %s did not return a result\",\ncommand,\npod_name,\n)\nself.write_status_file(success, section_name, self._exec_pod_commands)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_external_systems","title":"<code>process_external_systems(section_name='externalSystems')</code>","text":"<p>Process external systems in payload and create them in Extended ECM.</p> <pre><code>The payload section is a list of dicts (each representing one external\nsystem) with these items:\n{\n    enabled: True or False to enable or disable the payload item\n    external_system_name: Name of the external systen.\n    external_system_type: Type of the external system.\n                          Possible values are\n                          * SAP\n                          * SuccessFactors\n                          * Salesforce\n                          * AppWorks Platform\n    base_url: Base URL of the external system\n    as_url: Application Server URL of the external system\n    username: (Technical) User Name for the connection\n    password: Passord of the (technical) user\n    oauth_client_id: OAuth client ID\n    oauth_client_secret: OAuth client secret\n    archive_logical_name: Logical name of Archive for SAP\n    archive_certificate_file: Path and filename to certificate file.\n                              This file is inside the customizer\n                              pof file system.\n}\nIf OAuth Client ID and Client Secret are provided then username\nand password are no longer used.\n\nIn the payload for SAP external systems there are additional\nitems \"client\", \"destination\" that are processed by init_sap()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'externalSystems'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Side Effects <ul> <li>based on system_type different other settings in the dict are set</li> <li>reachability is tested and a flag is set in the payload dict</li> </ul> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_external_systems(self, section_name: str = \"externalSystems\") -&gt; bool:\n\"\"\"Process external systems in payload and create them in Extended ECM.\n        The payload section is a list of dicts (each representing one external\n        system) with these items:\n        {\n            enabled: True or False to enable or disable the payload item\n            external_system_name: Name of the external systen.\n            external_system_type: Type of the external system.\n                                  Possible values are\n                                  * SAP\n                                  * SuccessFactors\n                                  * Salesforce\n                                  * AppWorks Platform\n            base_url: Base URL of the external system\n            as_url: Application Server URL of the external system\n            username: (Technical) User Name for the connection\n            password: Passord of the (technical) user\n            oauth_client_id: OAuth client ID\n            oauth_client_secret: OAuth client secret\n            archive_logical_name: Logical name of Archive for SAP\n            archive_certificate_file: Path and filename to certificate file.\n                                      This file is inside the customizer\n                                      pof file system.\n        }\n        If OAuth Client ID and Client Secret are provided then username\n        and password are no longer used.\n        In the payload for SAP external systems there are additional\n        items \"client\", \"destination\" that are processed by init_sap()\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        - based on system_type different other settings in the dict are set\n        - reachability is tested and a flag is set in the payload dict\n    \"\"\"\nif not self._external_systems:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\n# if self.check_status_file(section_name):\n#   return True\nsuccess: bool = True\nfor external_system in self._external_systems:\n#\n# 1: Do sanity checks for the payload:\n#\nif not \"external_system_name\" in external_system:\nlogger.error(\n\"External System connection needs a logical system name! Skipping to next external system...\"\n)\nsuccess = False\ncontinue\nsystem_name = external_system[\"external_system_name\"]\nif not \"external_system_type\" in external_system:\nlogger.error(\n\"External System connection -&gt; %s needs a type (SAP, Salesfoce, SuccessFactors, AppWorks Platform)! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\nsystem_type = external_system[\"external_system_type\"]\nif \"enabled\" in external_system and not external_system[\"enabled\"]:\nlogger.info(\n\"Payload for External System -&gt; %s (%s) is disabled. Skipping...\",\nsystem_name,\nsystem_type,\n)\ncontinue\n# Possible Connection Types for external systems:\n# \"Business Scenario Sample\" (Business Scenarios Sample Adapter)\n# \"ot.sap.c4c.SpiAdapter\" (SAP C4C SPI Adapter)\n# \"ot.sap.c4c.SpiAdapterV2\" (C4C SPI Adapter V2)\n# \"HTTP\" (Default WebService Adapter)\n# \"ot.sap.S4HANAAdapter\" (S/4HANA SPI Adapter)\n# \"SF\" (SalesForce Adapter)\n# \"SFInstance\" (SFWebService)\n# Set the default settings for the different system types:\nmatch system_type:\n# Check if we have a SuccessFactors system:\ncase \"SuccessFactors\":\nconnection_type = \"SFInstance\"\nauth_method = \"OAUTH\"\nusername = None\npassword = None\ncase \"SAP\":\nconnection_type = \"HTTP\"\nauth_method = \"BASIC\"\noauth_client_id = None\noauth_client_secret = None\ncase \"Salesforce\":\nconnection_type = \"SF\"\nauth_method = \"OAUTH\"\nusername = None\npassword = None\ncase \"AppWorks Platform\":\nconnection_type = \"HTTP\"\nauth_method = \"BASIC\"\noauth_client_id = None\noauth_client_secret = None\ncase \"Business Scenario Sample\":\nconnection_type = \"Business Scenario Sample\"\nauth_method = \"BASIC\"\noauth_client_id = None\noauth_client_secret = None\ncase _:\nlogger.error(\"Unsupported system_type defined -&gt; %s\", system_type)\nreturn False\nif not \"base_url\" in external_system:\nbase_url = \"\"  # baseUrl is optional\nelse:\nbase_url = external_system[\"base_url\"]\nif not \"as_url\" in external_system:\nlogger.warning(\n\"External System connection -&gt; %s needs an Application Server URL! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\nas_url = external_system[\"as_url\"]\n# Check if external system is reachable and\n# update the payload dict with a \"reachable\" key/value pair:\nself.check_external_system(external_system)\n# Read either username/password (BASIC) or client ID / secret (OAuth)\nmatch auth_method:\ncase \"BASIC\":\nif not \"username\" in external_system:\nlogger.warning(\n\"External System connection -&gt; %s needs a user name for BASIC authentication! Skipping to next external system...\",\nsystem_name,\n)\ncontinue\nif not \"password\" in external_system:\nlogger.warning(\n\"External System connection -&gt; %s needs a password for BASIC authentication! Skipping to next external system...\",\nsystem_name,\n)\ncontinue\nusername = external_system[\"username\"]\npassword = external_system[\"password\"]\noauth_client_id = \"\"\noauth_client_secret = \"\"\ncase \"OAUTH\":\nif not \"oauth_client_id\" in external_system:\nlogger.error(\n\"External System connection -&gt; %s is missing OAuth client ID! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\nif not \"oauth_client_secret\" in external_system:\nlogger.error(\n\"External System connection -&gt; %s is missing OAuth client secret! Skipping to next external system...\",\nsystem_name,\n)\nsuccess = False\ncontinue\noauth_client_id = external_system[\"oauth_client_id\"]\noauth_client_secret = external_system[\"oauth_client_secret\"]\n# For backward compatibility we also read username/password\n# with OAuth settings:\nusername = (\nexternal_system[\"username\"]\nif external_system.get(\"username\")\nelse None\n)\npassword = (\nexternal_system[\"password\"]\nif external_system.get(\"password\")\nelse None\n)\ncase _:\nlogger.error(\n\"Unsupported authorization method specified (%s) , Skipping ... \",\nauth_method,\n)\nreturn False\n# We do this existance test late in this function to make sure the payload\n# datastructure is properly updated for debugging purposes.\nlogger.info(\n\"Test if external system -&gt; %s does already exist...\", system_name\n)\nif self._otcs.get_external_system_connection(system_name):\nlogger.info(\n\"External System connection -&gt; %s already exists! Skipping to next external system...\",\nsystem_name,\n)\ncontinue\n#\n# Create External System:\n#\nlogger.info(\n\"Create external system -&gt; %s; type -&gt; %s\", system_name, connection_type\n)\nresponse = self._otcs.add_external_system_connection(\nconnection_name=system_name,\nconnection_type=connection_type,\nas_url=as_url,\nbase_url=base_url,\nusername=str(username),\npassword=str(password),\nauthentication_method=auth_method,\nclient_id=oauth_client_id,\nclient_secret=oauth_client_secret,\n)\nif response is None:\nlogger.error(\n\"Failed to create external system -&gt; %s; type -&gt; %s\",\nsystem_name,\nconnection_type,\n)\nsuccess = False\nelse:\nlogger.info(\"Successfully created external system -&gt; %s\", system_name)\n#\n# In case of an SAP external system we also do some Archiving config:\n#\nif system_type == \"SAP\":\nif (\n\"archive_logical_name\" in external_system\nand \"archive_certificate_file\" in external_system\nand self._otac\n):\nlogger.info(\n\"Put certificate file -&gt; %s for logical archive -&gt; %s into Archive Center\",\nexternal_system[\"archive_certificate_file\"],\nexternal_system[\"archive_logical_name\"],\n)\nresponse = self._otac.put_cert(\nexternal_system[\"external_system_name\"],\nexternal_system[\"archive_logical_name\"],\nexternal_system[\"archive_certificate_file\"],\n)\nlogger.info(\n\"Enable certificate file -&gt; %s for logical archive -&gt; %s\",\nexternal_system[\"archive_certificate_file\"],\nexternal_system[\"archive_logical_name\"],\n)\nresponse = self._otac.enable_cert(\nexternal_system[\"external_system_name\"],\nexternal_system[\"archive_logical_name\"],\nTrue,\n)\nself.write_status_file(success, section_name, self._external_systems)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_group_placeholders","title":"<code>process_group_placeholders()</code>","text":"<p>For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%) with the actual ID of the Extended ECM group. For this we prepare a lookup dict. The dict self._placeholder_values already includes lookups for the OTCS and OTAWP OTDS resource IDs (see main.py)</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_group_placeholders(self):\n\"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n    with the actual ID of the Extended ECM group. For this we prepare a lookup dict.\n    The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n    OTDS resource IDs (see main.py)\n    \"\"\"\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\n\"Group needs a name for placeholder definition. Skipping...\"\n)\ncontinue\ngroup_name = group[\"name\"]\n# Check if group has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\n# Now we determine the ID. Either it is in the payload section from\n# the current customizer run or we try to look it up in the system.\n# The latter case may happen if the customizer pod got restarted.\ngroup_id = self.determine_group_id(group)\nif not group_id:\nlogger.warning(\n\"Group needs an ID for placeholder definition. Skipping...\"\n)\ncontinue\n# Add Group with its ID to the dict self._placeholder_values:\nself._placeholder_values[\n\"OTCS_GROUP_ID_\"\n+ group_name.upper().replace(\" &amp; \", \"_\").replace(\" \", \"_\")\n] = str(group_id)\nlogger.debug(\n\"Placeholder values after group processing = %s\", self._placeholder_values\n)\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_groups","title":"<code>process_groups(section_name='groups')</code>","text":"<p>Process groups in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'groups'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Side Effects <p>the group items are modified by adding an \"id\" dict element that includes the technical ID of the group in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_groups(self, section_name: str = \"groups\") -&gt; bool:\n\"\"\"Process groups in payload and create them in Extended ECM.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        the group items are modified by adding an \"id\" dict element that\n        includes the technical ID of the group in Extended ECM\n    \"\"\"\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# First run through groups: create all groups in payload\n# and store the IDs of the created groups:\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Group needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\n# Check if the group does already exist (e.g. if job is restarted)\n# as this is a pattern search it could return multiple groups:\ngroup_id = self.determine_group_id(group)\nif group_id:\nlogger.info(\n\"Found existing group -&gt; %s (%s). Skipping to next group...\",\ngroup_name,\ngroup_id,\n)\ncontinue\nlogger.info(\"Did not find an existing group - creating a new group...\")\n# Now we know it is a new group...\nnew_group = self._otcs.add_group(group_name)\nif new_group:\nnew_group_id = self._otcs.get_result_value(new_group, \"id\")\nlogger.debug(\"New group -&gt; %s\", new_group)\ngroup[\"id\"] = new_group_id\nelse:\nlogger.error(\"Failed to create group -&gt; %s\", group_name)\nsuccess = False\ncontinue\nlogger.debug(\"Groups = %s\", self._groups)\n# Second run through groups: create all group memberships\n# (nested groups) based on the IDs created in first run:\nfor group in self._groups:\nif not \"id\" in group:\nlogger.error(\"Group -&gt; %s does not have an ID.\", group[\"name\"])\nsuccess = False\ncontinue\nparent_group_names = group[\"parent_groups\"]\nfor parent_group_name in parent_group_names:\n# First, try to find parent group in payload by parent group name:\nparent_group = next(\n(\nitem\nfor item in self._groups\nif item[\"name\"] == parent_group_name\n),\nNone,\n)\nif parent_group is None:\n# If this didn't work, try to get the parent group from OTCS. This covers\n# cases where the parent group is system generated or part\n# of a former payload processing run:\nparent_group = self._otcs.get_group(parent_group_name)\nparent_group_id = self._otcs.get_result_value(parent_group, \"id\")\nif not parent_group_id:\nlogger.error(\n\"Parent Group -&gt; %s not found. Skipping...\",\nparent_group_name,\n)\nsuccess = False\ncontinue\nelif not \"id\" in parent_group:\nlogger.error(\n\"Parent Group -&gt; %s does not have an ID. Cannot establish group nesting. Skipping...\",\nparent_group[\"name\"],\n)\nsuccess = False\ncontinue\nelse:  # we can read the ID from the\nparent_group_id = parent_group[\"id\"]\n# retrieve all members of the parent group (1 = get only groups)\n# to check if the current group is already a member in the parent group:\nmembers = self._otcs.get_group_members(parent_group_id, 1)\nif self._otcs.exist_result_item(members, \"id\", group[\"id\"]):\nlogger.info(\n\"Group -&gt; %s (%s) is already a member of parent group -&gt; %s (%s). Skipping to next parent group...\",\ngroup[\"name\"],\ngroup[\"id\"],\nparent_group_name,\nparent_group_id,\n)\nelse:\nlogger.info(\n\"Add group -&gt; %s (%s) to parent group -&gt; %s (%s)\",\ngroup[\"name\"],\ngroup[\"id\"],\nparent_group_name,\nparent_group_id,\n)\nself._otcs.add_group_member(group[\"id\"], parent_group_id)\nself.write_status_file(success, section_name, self._groups)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_groups_m365","title":"<code>process_groups_m365(section_name='groupsM365')</code>","text":"<p>Process groups in payload and create them in Microsoft 365.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'groupsM365'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_groups_m365(self, section_name: str = \"groupsM365\") -&gt; bool:\n\"\"\"Process groups in payload and create them in Microsoft 365.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section %s...\",\nsection_name,\n)\nreturn False\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# First run through groups: create all groups in payload\n# and store the IDs of the created groups:\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Group needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\nif not \"enable_o365\" in group or not group[\"enable_o365\"]:\nlogger.info(\n\"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\ngroup_name,\n)\ncontinue\n# Check if the group does already exist (e.g. if job is restarted)\n# as this is a pattern search it could return multiple groups:\nexisting_groups = self._m365.get_group(group_name)\nif existing_groups and existing_groups[\"value\"]:\nlogger.debug(\n\"Found existing Microsoft 365 groups -&gt; %s\",\nexisting_groups[\"value\"],\n)\n# Get list of all matching groups:\nexisting_groups_list = existing_groups[\"value\"]\n# Find the group with the exact match of the name:\nexisting_group = next(\n(\nitem\nfor item in existing_groups_list\nif item[\"displayName\"] == group_name\n),\nNone,\n)\n# Have we found an exact match?\nif existing_group is not None:\nlogger.info(\n\"Found existing Microsoft 365 group -&gt; %s (%s) - skip creation of group...\",\nexisting_group[\"displayName\"],\nexisting_group[\"id\"],\n)\n# Write M365 group ID back into the payload (for the success file)\ngroup[\"m365_id\"] = existing_group[\"id\"]\ncontinue\nlogger.info(\n\"Did not find an exact match for the group - creating a new Microsoft 365 group...\"\n)\nelse:\nlogger.info(\n\"Did not find any matching group - creating a new Microsoft 365 group...\"\n)\n# Now we know it is a new group...\nnew_group = self._m365.add_group(group_name)\nif new_group is not None:\n# Store the Microsoft 365 group ID in payload:\ngroup[\"m365_id\"] = new_group[\"id\"]\nlogger.info(\n\"New Microsoft 365 group -&gt; %s with ID -&gt; %s has been created\",\ngroup_name,\ngroup[\"m365_id\"],\n)\nelse:\nsuccess = False\nself.write_status_file(success, section_name, self._groups)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_holds","title":"<code>process_holds(section_name='holds')</code>","text":"<p>Process Records Management Holds for Extended ECM users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'holds'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_holds(self, section_name: str = \"holds\") -&gt; bool:\n\"\"\"Process Records Management Holds for Extended ECM users.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._holds:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor hold in self._holds:\nif not \"name\" in hold:\nlogger.error(\"Cannot create Hold without a name! Skipping...\")\ncontinue\nhold_name = hold[\"name\"]\nif not \"type\" in hold:\nlogger.error(\n\"Cannot create Hold -&gt; %s without a type! Skipping...\", hold_name\n)\nsuccess = False\ncontinue\nhold_type = hold[\"type\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in hold and not hold[\"enabled\"]:\nlogger.info(\n\"Payload for Hold -&gt; %s is disabled. Skipping...\", hold_name\n)\ncontinue\nhold_group = hold.get(\"group\")\nhold_comment = hold.get(\"comment\")\nhold_alternate_id = hold.get(\"alternate_id\")\nhold_date_applied = hold.get(\"date_applied\")\nhold_date_suspend = hold.get(\"date_to_remove\")\n# 550 is the RM Volume\nresponse = self._otcs.get_node_by_volume_and_path(550, [\"Hold Maintenance\"])\nif not response:\nlogger.error(\"Cannot find Records Management Volume!\")\ncontinue\nholds_maintenance_id = self._otcs.get_result_value(response, \"id\")\nif not holds_maintenance_id:\nlogger.error(\n\"Cannot find Holds Maintenance folder in Records Management Volume!\"\n)\ncontinue\nif hold_group:\n# Check if the Hold Group (folder) does already exist.\nresponse = self._otcs.get_node_by_parent_and_name(\nholds_maintenance_id, hold_group\n)\nparent_id = self._otcs.get_result_value(response, \"id\")\nif not parent_id:\nresponse = self._otcs.create_item(\nholds_maintenance_id, \"833\", hold_group\n)\nparent_id = self._otcs.get_result_value(response, \"id\")\nif not parent_id:\nlogger.error(\"Failed to create hold group -&gt; %s\", hold_group)\ncontinue\nelse:\nparent_id = holds_maintenance_id\n# Holds are special - they ahve folders that cannot be traversed\n# in the normal way - we need to get the whole list of holds and use\n# specialparameters for the exist_result_items() method as the REST\n# API calls delivers a results-&gt;data-&gt;holds structure (not properties)\nresponse = self._otcs.get_records_management_holds()\nif self._otcs.exist_result_item(\nresponse, \"HoldName\", hold_name, property_name=\"holds\"\n):\nlogger.info(\"Hold -&gt; %s does already exist. Skipping...\", hold_name)\ncontinue\nhold = self._otcs.create_records_management_hold(\nhold_type,\nhold_name,\nhold_comment,\nhold_alternate_id,\nint(parent_id),\nhold_date_applied,\nhold_date_suspend,\n)\nif hold and hold[\"holdID\"]:\nlogger.info(\n\"Successfully created hold -&gt; %s with ID -&gt; %s\",\nhold_name,\nhold[\"holdID\"],\n)\nelse:\nsuccess = False\nself.write_status_file(success, section_name, self._holds)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_items","title":"<code>process_items(items, section_name='items')</code>","text":"<p>Process items specified in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list</code> <p>list of items to create (need this as parameter as we           have multiple lists)</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"itemsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'items'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_items(self, items: list, section_name: str = \"items\") -&gt; bool:\n\"\"\"Process items specified in payload and create them in Extended ECM.\n    Args:\n        items (list): list of items to create (need this as parameter as we\n                      have multiple lists)\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"itemsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not items:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor item in items:\nif not \"name\" in item:\nlogger.error(\"Item needs a name. Skipping...\")\ncontinue\nitem_name = item[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in item and not item[\"enabled\"]:\nlogger.info(\n\"Payload for Item -&gt; %s is disabled. Skipping...\", item_name\n)\ncontinue\nif not \"description\" in item:\nitem_description = \"\"\nelse:\nitem_description = item[\"description\"]\nparent_nickname = item.get(\"parent_nickname\")\nparent_path = item.get(\"parent_path\")\nif parent_nickname:\nparent_node = self._otcs.get_node_from_nickname(parent_nickname)\nparent_id = self._otcs.get_result_value(parent_node, \"id\")\n# if not parent_node:\nif not parent_id:\nlogger.error(\n\"Item -&gt; %s has a parent nickname -&gt; %s that does not exist. Skipping...\",\nitem_name,\nparent_nickname,\n)\nsuccess = False\ncontinue\nelse:  # use parent_path and Enterprise Volume\nparent_node = self._otcs.get_node_by_volume_and_path(141, parent_path)\nparent_id = self._otcs.get_result_value(parent_node, \"id\")\nif not parent_id:\n# if not parent_node:\nlogger.error(\n\"Item -&gt; %s has a parent path that does not exist. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\noriginal_nickname = item.get(\"original_nickname\")\noriginal_path = item.get(\"original_path\")\nif original_nickname:\noriginal_node = self._otcs.get_node_from_nickname(original_nickname)\noriginal_id = self._otcs.get_result_value(original_node, \"id\")\nif not original_id:\n# if not original_node:\nlogger.error(\n\"Item -&gt; %s has a original nickname -&gt; %s that does not exist. Skipping...\",\nitem_name,\noriginal_nickname,\n)\nsuccess = False\ncontinue\nelif original_path:\noriginal_node = self._otcs.get_node_by_volume_and_path(\n141, original_path\n)\noriginal_id = self._otcs.get_result_value(original_node, \"id\")\nif not original_id:\n# if not original_node:\nlogger.error(\n\"Item -&gt; %s has a original path that does not exist. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\nelse:\noriginal_id = 0\nif not \"type\" in item:\nlogger.error(\"Item -&gt; %s needs a type. Skipping...\", item_name)\nsuccess = False\ncontinue\nitem_type = item.get(\"type\")\nitem_url = item.get(\"url\")\n# check that we have the required information\n# for the given item type:\nmatch item_type:\ncase 140:  # URL\nif item_url == \"\":\nlogger.error(\n\"Item -&gt; %s has type URL but the URL is not in the payload. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\ncase 1:  # Shortcut\nif original_id == 0:\nlogger.error(\n\"Item -&gt; %s has type Shortcut but the original item is not in the payload. Skipping...\",\nitem_name,\n)\nsuccess = False\ncontinue\n# Check if an item with the same name does already exist.\n# This can also be the case if the python container runs a 2nd time.\n# For this reason we are also not issuing an error but just an info (False):\nresponse = self._otcs.get_node_by_parent_and_name(\nint(parent_id), item_name, show_error=False\n)\nif self._otcs.get_result_value(response, \"name\") == item_name:\nlogger.info(\n\"Item with name -&gt; %s does already exist in parent folder with ID -&gt; %s\",\nitem_name,\nparent_id,\n)\ncontinue\nresponse = self._otcs.create_item(\nint(parent_id),\nstr(item_type),\nitem_name,\nitem_description,\nitem_url,\nint(original_id),\n)\nif not response:\nlogger.error(\"Failed to create item -&gt; %s.\", item_name)\nsuccess = False\nself.write_status_file(success, section_name, items)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_oauth_clients","title":"<code>process_oauth_clients(section_name='oauthClients')</code>","text":"<p>Process OTDS OAuth clients in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'oauthClients'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_oauth_clients(self, section_name: str = \"oauthClients\") -&gt; bool:\n\"\"\"Process OTDS OAuth clients in payload and create them in OTDS.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._oauth_clients:\nlogger.info(\"Payload section -&gt; % is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor oauth_client in self._oauth_clients:\nclient_name = oauth_client.get(\"name\")\nif not client_name:\nlogger.error(\"OAuth client does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in oauth_client and not oauth_client[\"enabled\"]:\nlogger.info(\n\"Payload for OAuthClient -&gt; %s is disabled. Skipping...\",\nclient_name,\n)\ncontinue\nclient_description = oauth_client.get(\"description\")\nclient_confidential = oauth_client.get(\"confidential\")\nclient_partition = oauth_client.get(\"partition\")\nif client_partition == \"Global\":\nclient_partition = []\nclient_redirect_urls = oauth_client.get(\"redirect_urls\")\nclient_permission_scopes = oauth_client.get(\"permission_scopes\")\nclient_default_scopes = oauth_client.get(\"default_scopes\")\nclient_allow_impersonation = oauth_client.get(\"allow_impersonation\")\nclient_secret = oauth_client.get(\"secret\", \"\")\n# Check if OAuth client does already exist\n# (in an attempt to make the code idem-potent)\nlogger.info(\n\"Check if OTDS OAuth Client -&gt; %s does already exist...\", client_name\n)\nresponse = self._otds.get_oauth_client(client_name, show_error=False)\nif response:\nlogger.info(\n\"OAuth Client -&gt; %s does already exist. Skipping...\", client_name\n)\ncontinue\nelse:\nlogger.info(\n\"OAuth Client -&gt; %s does not exist. Creating...\", client_name\n)\nresponse = self._otds.add_oauth_client(\nclient_id=client_name,\ndescription=client_description,\nredirect_urls=client_redirect_urls,\nallow_impersonation=client_allow_impersonation,\nconfidential=client_confidential,\nauth_scopes=client_partition,\nallowed_scopes=client_permission_scopes,\ndefault_scopes=client_default_scopes,\nsecret=client_secret,\n)\nif response:\nlogger.info(\"Added OTDS OAuth client -&gt; %s\", client_name)\nelse:\nlogger.error(\"Failed to add OTDS OAuth client -&gt; %s\", client_name)\nsuccess = False\ncontinue\n# in case the secret has not been provided in the payload we retrieve\n# the automatically created secret:\nclient_secret = response.get(\"secret\")\nif not client_secret:\nlogger.error(\"OAuth client -&gt; %s does not have a secret!\", client_name)\ncontinue\nclient_description += \" Client Secret: \" + str(client_secret)\nresponse = self._otds.update_oauth_client(\nclient_name, {\"description\": client_description}\n)\n# Write the secret back into the payload\noauth_client[\"secret\"] = client_secret\nself.write_status_file(success, section_name, self._oauth_clients)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_partition_licenses","title":"<code>process_partition_licenses(section_name='partitionLicenses')</code>","text":"<p>Process the licenses that should be assigned to OTDS partitions    (this includes existing partitions).</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'partitionLicenses'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_partition_licenses(\nself, section_name: str = \"partitionLicenses\"\n) -&gt; bool:\n\"\"\"Process the licenses that should be assigned to OTDS partitions\n       (this includes existing partitions).\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._partitions:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor partition in self._partitions:\npartition_name = partition.get(\"name\")\nif not partition_name:\nlogger.error(\"Partition does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in partition and not partition[\"enabled\"]:\nlogger.info(\n\"Payload for Partition -&gt; %s is disabled. Skipping...\",\npartition_name,\n)\ncontinue\nresponse = self._otds.get_partition(partition_name, show_error=True)\nif not response:\nlogger.error(\n\"Partition -&gt; %s does not exist. Skipping...\", partition_name\n)\nsuccess = False\ncontinue\n# Partions may have an optional list of licenses in\n# the payload. Assign the partition to all these licenses:\npartition_specific_licenses = partition.get(\"licenses\")\nif partition_specific_licenses:\n# We assume these licenses are Extended ECM licenses!\notcs_resource_name = self._otcs.config()[\"resource\"]\notcs_resource = self._otds.get_resource(otcs_resource_name)\nif not otcs_resource:\nlogger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\nsuccess = False\ncontinue\notcs_resource_id = otcs_resource[\"resourceID\"]\nlicense_name = \"EXTENDED_ECM\"\nfor license_feature in partition_specific_licenses:\nif self._otds.is_partition_licensed(\npartition_name=partition_name,\nresource_id=otcs_resource_id,\nlicense_feature=license_feature,\nlicense_name=license_name,\n):\nlogger.info(\n\"Partition -&gt; %s is already licensed for -&gt; %s (%s)\",\npartition_name,\nlicense_name,\nlicense_feature,\n)\ncontinue\nassigned_license = self._otds.assign_partition_to_license(\npartition_name,\notcs_resource_id,\nlicense_feature,\nlicense_name,\n)\nif not assigned_license:\nlogger.error(\n\"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nself.write_status_file(success, section_name, self._partitions)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_partitions","title":"<code>process_partitions(section_name='partitions')</code>","text":"<p>Process OTDS partitions in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections). This                           name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'partitions'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_partitions(self, section_name: str = \"partitions\") -&gt; bool:\n\"\"\"Process OTDS partitions in payload and create them in OTDS.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections). This\n                                      name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._partitions:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor partition in self._partitions:\npartition_name = partition.get(\"name\")\nif not partition_name:\nlogger.error(\"Partition does not have a name. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in partition and not partition[\"enabled\"]:\nlogger.info(\n\"Payload for Partition -&gt; %s is disabled. Skipping...\",\npartition_name,\n)\ncontinue\npartition_description = partition.get(\"description\")\n# Check if Partition does already exist\n# (in an attempt to make the code idem-potent)\nlogger.info(\n\"Check if OTDS partition -&gt; %s does already exist...\", partition_name\n)\nresponse = self._otds.get_partition(partition_name, show_error=False)\nif response:\nlogger.info(\n\"Partition -&gt; %s does already exist. Skipping...\", partition_name\n)\ncontinue\n# Only continue if Partition does not exist already\nlogger.info(\"Partition -&gt; %s does not exist. Creating...\", partition_name)\nresponse = self._otds.add_partition(partition_name, partition_description)\nif response:\nlogger.info(\"Added OTDS partition -&gt; %s\", partition_name)\nelse:\nlogger.error(\"Failed to add OTDS partition -&gt; %s\", partition_name)\nsuccess = False\ncontinue\naccess_role = partition.get(\"access_role\")\nif access_role:\nresponse = self._otds.add_partition_to_access_role(\naccess_role, partition_name\n)\nif response:\nlogger.info(\n\"Added OTDS partition -&gt; %s to access role -&gt; %s\",\npartition_name,\naccess_role,\n)\nelse:\nlogger.error(\n\"Failed to add OTDS partition -&gt; %s to access role -&gt; %s\",\npartition_name,\naccess_role,\n)\nsuccess = False\ncontinue\n# Partions may have an optional list of licenses in\n# the payload. Assign the partition to all these licenses:\npartition_specific_licenses = partition.get(\"licenses\")\nif partition_specific_licenses:\n# We assume these licenses are Extended ECM licenses!\notcs_resource_name = self._otcs.config()[\"resource\"]\notcs_resource = self._otds.get_resource(otcs_resource_name)\nif not otcs_resource:\nlogger.error(\"Cannot find OTCS resource -&gt; %s\", otcs_resource_name)\nsuccess = False\ncontinue\notcs_resource_id = otcs_resource[\"resourceID\"]\nlicense_name = \"EXTENDED_ECM\"\nfor license_feature in partition_specific_licenses:\nassigned_license = self._otds.assign_partition_to_license(\npartition_name,\notcs_resource_id,\nlicense_feature,\nlicense_name,\n)\nif not assigned_license:\nlogger.error(\n\"Failed to assign partition -&gt; %s to license feature -&gt; %s of license -&gt; %s!\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully assigned partition -&gt; %s to license feature -&gt; %s of license -&gt; %s\",\npartition_name,\nlicense_feature,\nlicense_name,\n)\nself.write_status_file(success, section_name, self._partitions)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_payload","title":"<code>process_payload()</code>","text":"<p>Main method to process a payload file.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_payload(self):\n\"\"\"Main method to process a payload file.\n    Args:\n        None\n    Returns:\n        None\n    \"\"\"\nif not self._payload_sections:\nreturn None\nfor payload_section in self._payload_sections:\nmatch payload_section[\"name\"]:\ncase \"webHooks\":\nself._log_header_callback(\"Process Web Hooks\")\nself.process_web_hooks(self._webhooks)\ncase \"webHooksPost\":\nself._log_header_callback(\"Process Web Hooks (post)\")\nself.process_web_hooks(self._webhooks_post, \"webHooksPost\")\ncase \"partitions\":\nself._log_header_callback(\"Process OTDS Partitions\")\nself.process_partitions()\nself._log_header_callback(\"Assign OTCS Licenses to Partitions\")\nself.process_partition_licenses()\ncase \"oauthClients\":\nself._log_header_callback(\"Process OTDS OAuth Clients\")\nself.process_oauth_clients()\ncase \"authHandlers\":\nself._log_header_callback(\"Process OTDS Auth Handlers\")\nself.process_auth_handlers()\ncase \"trustedSites\":\nself._log_header_callback(\"Process OTDS Trusted Sites\")\nself.process_trusted_sites()\ncase \"systemAttributes\":\nself._log_header_callback(\"Process OTDS System Attributes\")\nself.process_system_attributes()\ncase \"groups\":\nself._log_header_callback(\"Process OTCS Groups\")\nself.process_groups()\n# Add all groups with ID the a lookup dict for placeholder replacements\n# in adminSetting. This also updates the payload with group IDs from OTCS\n# if the group already exists in Extended ECM. This is important especially\n# if the customizer pod is restarted / run multiple times:\nself.process_group_placeholders()\nif self._m365 and isinstance(self._m365, M365):\nself._log_header_callback(\"Cleanup existing MS Teams\")\nself.cleanup_all_teams_m365()\nself._log_header_callback(\"Process M365 Groups\")\nself.process_groups_m365()\ncase \"users\":\nself._log_header_callback(\"Process OTCS Users\")\nself.process_users()\n# Add all users with ID the a lookup dict for placeholder replacements\n# in adminSetting. This also updates the payload with user IDs from OTCS\n# if the user already exists in Extended ECM. This is important especially\n# if the cutomizer pod is restarted / run multiple times:\nself.process_user_placeholders()\nself._log_header_callback(\"Assign OTCS Licenses to Users\")\nself.process_user_licenses(\nresource_name=self._otcs.config()[\"resource\"],\nlicense_feature=self._otcs.config()[\"license\"],\nlicense_name=\"EXTENDED_ECM\",\nuser_specific_payload_field=\"licenses\",\n)\nself._log_header_callback(\"Assign OTIV Licenses to Users\")\nif (\nisinstance(self._otiv, OTIV)  # can be None in 24.1 or newer\nand self._otiv.config()\nand self._otiv.config()[\"resource\"]\nand self._otiv.config()[\"license\"]\n):\nself.process_user_licenses(\nresource_name=self._otiv.config()[\"resource\"],\nlicense_feature=self._otiv.config()[\"license\"],\nlicense_name=\"INTELLIGENT_VIEWING\",\nuser_specific_payload_field=\"\",\nsection_name=\"userLicensesViewing\",  # we need a specific name here for OTIV\n)\nelse:\nlogger.info(\"Processing of OTIV licenses is disabled.\")\nself._log_header_callback(\"Process User Settings\")\nself.process_user_settings()\nif self._m365 and isinstance(self._m365, M365):\nself._log_header_callback(\"Process M365 Users\")\nself.process_users_m365()\n# We need to do the MS Teams creation after the creation of\n# the M365 users as we require Group Owners to create teams\nself._log_header_callback(\"Process M365 Teams\")\nself.process_teams_m365()\ncase \"adminSettings\":\nself._log_header_callback(\"Process Administration Settings\")\nrestart_required = self.process_admin_settings(self._admin_settings)\nif restart_required:\nlogger.info(\n\"Admin Settings require a restart of OTCS services...\",\n)\n# Restart OTCS frontend and backend pods:\nself._otcs_restart_callback(self._otcs_backend)\ncase \"adminSettingsPost\":\nself._log_header_callback(\"Process Administration Settings (post)\")\nrestart_required = self.process_admin_settings(\nself._admin_settings_post, \"adminSettingsPost\"\n)\nif restart_required:\nlogger.info(\n\"Admin Settings (Post) require a restart of OTCS services...\",\n)\n# Restart OTCS frontend and backend pods:\nself._otcs_restart_callback(self._otcs_backend)\ncase \"execPodCommands\":\nself._log_header_callback(\"Process Pod Commands\")\nself.process_exec_pod_commands()\ncase \"csApplications\":\nself._log_header_callback(\"Process CS Apps (backend)\")\nself.process_cs_applications(\nself._otcs_backend, section_name=\"csApplicationsBackend\"\n)\nself._log_header_callback(\"Process CS Apps (frontend)\")\nself.process_cs_applications(\nself._otcs_frontend, section_name=\"csApplicationsFrontend\"\n)\ncase \"externalSystems\":\nself._log_header_callback(\"Process External System Connections\")\nself.process_external_systems()\ncase \"transportPackages\":\nself._log_header_callback(\"Process Transport Packages\")\nself.process_transport_packages(self._transport_packages)\n# Right after the transport that create the workspace types\n# we extract them and put them in a generated payload list:\nself._log_header_callback(\"Process Workspace Types\")\nself.process_workspace_types()\nif self._m365 and isinstance(self._m365, M365):\n# Right after the transport that creates the top level folders\n# we can add the M365 Teams apps for Extended ECM as its own tab:\nself._log_header_callback(\"Process M365 Teams apps\")\nself.process_teams_m365_apps()\ncase \"contentTransportPackages\":\nself._log_header_callback(\"Process Content Transport Packages\")\nself.process_transport_packages(\nself._content_transport_packages, \"contentTransportPackages\"\n)\ncase \"transportPackagesPost\":\nself._log_header_callback(\"Process Transport Packages (post)\")\nself.process_transport_packages(\nself._transport_packages_post, \"transportPackagesPost\"\n)\ncase \"workspaceTemplates\":\nself._log_header_callback(\n\"Process Workspace Templates (Template Role Assignments)\"\n)\nself.process_workspace_templates()\ncase \"workspaces\":\nself._log_header_callback(\"Process Workspaces\")\nself.process_workspaces()\nself._log_header_callback(\"Process Workspace Relationships\")\nself.process_workspace_relationships()\nself._log_header_callback(\"Process Workspace Memberships\")\nself.process_workspace_members()\n# This has to run after the processing of webReports that are\n# used to enable Content Aviator in KINI database table:\nif self._aviator_enabled:\nself._log_header_callback(\"Process Workspace Aviators\")\nself.process_workspace_aviators()\ncase \"sapRFCs\":\nself._log_header_callback(\"Process SAP RFCs\")\nsap_external_system = {}\nif self._external_systems:\nsap_external_system = next(\n(\nitem\nfor item in self._external_systems\nif item.get(\"external_system_type\")\nand item[\"external_system_type\"] == \"SAP\"\n),\n{},\n)\nif not sap_external_system:\nlogger.warning(\n\"SAP RFC in payload but SAP external system is configured. RFCs will not be processed.\"\n)\nelif not sap_external_system.get(\"enabled\"):\nlogger.warning(\n\"SAP RFC in payload but SAP external system is disabled. RFCs will not be processed.\"\n)\n# if the external system is not marked reachable we check it once more as this could be fooled\n# by customizer pod restarts\nelif not sap_external_system.get(\n\"reachable\"\n) and not self.check_external_system(sap_external_system):\nlogger.warning(\n\"SAP RFC in payload but SAP external system is not reachable. RFCs will not be processed.\"\n)\nelse:\nsap = self.init_sap(sap_external_system)\nif sap:\nself.process_sap_rfcs(sap)\nself._log_header_callback(\"Process SAP Users\")\nself.process_users_sap(sap)\ncase \"webReports\":\nself._log_header_callback(\"Process Web Reports\")\nself.process_web_reports(self._web_reports)\ncase \"webReportsPost\":\nself._log_header_callback(\"Process Web Reports (post)\")\nself.process_web_reports(self._web_reports_post, \"webReportsPost\")\ncase \"additionalGroupMemberships\":\nself._log_header_callback(\n\"Process additional group members for OTDS\"\n)\nself.process_additional_group_members()\ncase \"additionalAccessRoleMemberships\":\nself._log_header_callback(\n\"Process additional access role members for OTDS\"\n)\nself.process_additional_access_role_members()\ncase \"renamings\":\nself._log_header_callback(\"Process Node Renamings\")\nself.process_renamings()\ncase \"items\":\nself._log_header_callback(\"Process Items\")\nself.process_items(self._items)\ncase \"itemsPost\":\nself._log_header_callback(\"Process Items (post)\")\nself.process_items(self._items_post, \"itemsPost\")\ncase \"permissions\":\nself._log_header_callback(\"Process Permissions\")\nself.process_permissions(self._permissions)\ncase \"permissionsPost\":\nself._log_header_callback(\"Process Permissions (post)\")\nself.process_permissions(self._permissions_post, \"permissionsPost\")\ncase \"assignments\":\nself._log_header_callback(\"Process Assignments\")\nself.process_assignments()\ncase \"securityClearances\":\nself._log_header_callback(\"Process Security Clearances\")\nself.process_security_clearances()\ncase \"supplementalMarkings\":\nself._log_header_callback(\"Process Supplemental Markings\")\nself.process_supplemental_markings()\ncase \"recordsManagementSettings\":\nself._log_header_callback(\"Process Records Management Settings\")\nself.process_records_management_settings()\ncase \"holds\":\nself._log_header_callback(\"Process Records Management Holds\")\nself.process_holds()\ncase \"documentGenerators\":\nself._log_header_callback(\"Process Document Generators\")\nself.process_document_generators()\ncase \"browserAutomations\":\nself._log_header_callback(\"Process Browser Automations\")\nself.process_browser_automations()\ncase _:\nlogger.error(\n\"Illegal payload section name -&gt; %s in payloadSections!\",\npayload_section[\"name\"],\n)\npayload_section_restart = payload_section.get(\"restart\", False)\nif payload_section_restart:\nlogger.info(\n\"Payload section -&gt; %s requests a restart of OTCS services...\",\npayload_section[\"name\"],\n)\n# Restart OTCS frontend and backend pods:\nself._otcs_restart_callback(self._otcs_backend)\nelse:\nlogger.info(\n\"Payload section -&gt; %s does not require a restart of OTCS services\",\npayload_section[\"name\"],\n)\nif self._users:\nself._log_header_callback(\"Process User Profile Photos\")\nself.process_user_photos()\nif self._m365 and isinstance(self._m365, M365):\nself._log_header_callback(\"Process M365 User Profile Photos\")\nself.process_user_photos_m365()\nself._log_header_callback(\"Process User Favorites and Profiles\")\nself.process_user_favorites_and_profiles()\nself._log_header_callback(\"Process User Security\")\nself.process_user_security()\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_permissions","title":"<code>process_permissions(permissions, section_name='permissions')</code>","text":"<p>Process items specified in payload and upadate permissions.</p> <p>Parameters:</p> Name Type Description Default <code>permissions</code> <code>list</code> <p>list of items to apply permissions to.          Each list item in the payload is a dict with this structure:             {                 nodeid = \"...\"                 volume = \"...\"                 nickname = \"...\"                 public_access_permissions = [\"see\", \"see_content\", ...]                 owner_permissions = []                 owner_group_permissions = []                 groups = [                 {                     name = \"...\"                     permissions = []                 }                 ]                 users = [                 {                     name = \"...\"                     permissions = []                 }                 ]                 apply_to = 2             }</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"permissionsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'permissions'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_permissions(\nself, permissions: list, section_name: str = \"permissions\"\n) -&gt; bool:\n\"\"\"Process items specified in payload and upadate permissions.\n    Args:\n        permissions (list): list of items to apply permissions to.\n                     Each list item in the payload is a dict with this structure:\n                        {\n                            nodeid = \"...\"\n                            volume = \"...\"\n                            nickname = \"...\"\n                            public_access_permissions = [\"see\", \"see_content\", ...]\n                            owner_permissions = []\n                            owner_group_permissions = []\n                            groups = [\n                            {\n                                name = \"...\"\n                                permissions = []\n                            }\n                            ]\n                            users = [\n                            {\n                                name = \"...\"\n                                permissions = []\n                            }\n                            ]\n                            apply_to = 2\n                        }\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"permissionsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not permissions:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor permission in permissions:\nif (\nnot \"path\" in permission\nand not \"volume\" in permission\nand not \"nickname\" in permission\n):\nlogger.error(\n\"Item to change permission is not specified (needs path, volume, or nickname). Skipping...\"\n)\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in permission and not permission[\"enabled\"]:\nlogger.info(\"Payload for Permission is disabled. Skipping...\")\ncontinue\nnode_id = 0\n# Check if \"volume\" is in payload and not empty string\n# we try to get the node ID from the volume type:\nif \"volume\" in permission and permission[\"volume\"]:\nvolume_type = permission[\"volume\"]\nlogger.info(\n\"Found volume type -&gt; %s in permission definition. Determine volume ID...\",\nvolume_type,\n)\nnode = self._otcs.get_volume(volume_type)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.error(\n\"Illegal volume -&gt; %s in permission specification. Skipping...\",\nvolume_type,\n)\nsuccess = False\ncontinue\nelse:\n# the following path block requires\n# a value for the volume - if it is\n# not specified we take the Enterprise Workspace (141):\nvolume_type = 141\n# Check if \"path\" is in payload and not empty list\n# (path can be combined with volume so we need to take volume into account):\nif \"path\" in permission and permission[\"path\"]:\npath = permission[\"path\"]\nlogger.info(\n\"Found path -&gt; %s in permission definition. Determine node ID...\",\npath,\n)\nnode = self._otcs.get_node_by_volume_and_path(volume_type, path)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.error(\"Path -&gt; %s does not exist. Skipping...\", path)\nsuccess = False\ncontinue\n# Check if \"nickname\" is in payload and not empty string:\nif \"nickname\" in permission and permission[\"nickname\"]:\nnickname = permission[\"nickname\"]\nlogger.info(\n\"Found nickname -&gt; %s in permission definition. Determine node ID...\",\nnickname,\n)\nnode = self._otcs.get_node_from_nickname(nickname)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.error(\"Nickname -&gt; {} does not exist. Skipping...\")\nsuccess = False\ncontinue\n# Now we should have a value for node_id:\nif not node_id:\nlogger.error(\"No node ID found! Skipping permission...\")\nsuccess = False\ncontinue\nnode_name = self._otcs.get_result_value(node, \"name\")\nlogger.info(\n\"Found node -&gt; %s with ID -&gt; %s to apply permission to.\",\nnode_name,\nnode_id,\n)\n# write node information back into payload\n# for better debugging\npermission[\"node_name\"] = node_name\npermission[\"node_id\"] = node_id\nif \"apply_to\" in permission:\napply_to = permission[\"apply_to\"]\nelse:\napply_to = 2  # make item + sub-items the default\n# 1. Process Owner Permissions (list canbe empty!)\nif \"owner_permissions\" in permission:\nowner_permissions = permission[\"owner_permissions\"]\nlogger.info(\n\"Update owner permissions for item -&gt; %s (%s) to -&gt; %s\",\nnode_name,\nstr(node_id),\nstr(owner_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"owner\", 0, owner_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update owner permissions for item -&gt; %s (%s).\",\nnode_name,\nstr(node_id),\n)\nsuccess = False\n# 2. Process Owner Group Permissions\nif \"owner_group_permissions\" in permission:\nowner_group_permissions = permission[\"owner_group_permissions\"]\nlogger.info(\n\"Update owner group permissions for item -&gt; %s (%s) to -&gt; %s\",\nnode_name,\nstr(node_id),\nstr(owner_group_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"group\", 0, owner_group_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update group permissions for item -&gt; %s (%s).\",\nnode_name,\nstr(node_id),\n)\nsuccess = False\n# 3. Process Public Permissions\nif \"public_permissions\" in permission:\npublic_permissions = permission[\"public_permissions\"]\nlogger.info(\n\"Update public permissions for item -&gt; %s (%s) to -&gt; %s\",\nnode_name,\nstr(node_id),\nstr(public_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"public\", 0, public_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update public permissions for item -&gt; %s (%s).\",\nstr(node_id),\nnode_name,\n)\nsuccess = False\ncontinue\n# 4. Process Assigned User Permissions (if specified and not empty)\nif \"users\" in permission and permission[\"users\"]:\nusers = permission[\"users\"]\nfor user in users:\nif not \"name\" in user or not \"permissions\" in user:\nlogger.error(\n\"Missing user name or permissions in user permission specificiation. Cannot set user permissions. Skipping...\"\n)\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\nuser_permissions = user[\"permissions\"]\nresponse = self._otcs.get_user(user_name, True)\nuser_id = self._otcs.get_result_value(response=response, key=\"id\")\nif not user_id:\nlogger.error(\n\"Cannot find user with name -&gt; %s; cannot set user permissions. Skipping user...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser[\"id\"] = user_id  # write ID back into payload\nlogger.info(\n\"Update permission of user -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\nuser_name,\nnode_name,\nstr(node_id),\nstr(user_permissions),\n)\nresponse = self._otcs.assign_permission(\nint(node_id), \"custom\", user_id, user_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update assigned user permissions for item -&gt; %s.\",\nnode_id,\n)\nsuccess = False\n# 5. Process Assigned Group Permissions (if specified and not empty)\nif \"groups\" in permission and permission[\"groups\"]:\ngroups = permission[\"groups\"]\nfor group in groups:\nif not \"name\" in group or not \"permissions\" in group:\nlogger.error(\n\"Missing group name or permissions in group permission specificiation. Cannot set group permissions. Skipping...\"\n)\ncontinue\ngroup_name = group[\"name\"]\ngroup_permissions = group[\"permissions\"]\nlogger.info(\n\"Update permissions of group -&gt; %s for item -&gt; %s (%s) to -&gt; %s\",\ngroup_name,\nnode_name,\nstr(node_id),\nstr(group_permissions),\n)\notcs_group = self._otcs.get_group(group_name, True)\ngroup_id = self._otcs.get_result_value(otcs_group, \"id\")\nif not group_id:\nlogger.error(\n\"Cannot find group with name -&gt; %s; cannot set group permissions. Skipping group...\",\ngroup_name,\n)\nsuccess = False\ncontinue\ngroup[\"id\"] = group_id  # write ID back into payload\nresponse = self._otcs.assign_permission(\nint(node_id), \"custom\", group_id, group_permissions, apply_to\n)\nif not response:\nlogger.error(\n\"Failed to update assigned group permissions for item -&gt; %s (%s).\",\nnode_name,\nstr(node_id),\n)\nsuccess = False\nself.write_status_file(success, section_name, permissions)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_records_management_settings","title":"<code>process_records_management_settings(section_name='recordsManagementSettings')</code>","text":"<p>Process Records Management Settings for Extended ECM. The setting files need to be placed in the OTCS file system file via a transport into the Support Asset Volume.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'recordsManagementSettings'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_records_management_settings(\nself, section_name: str = \"recordsManagementSettings\"\n) -&gt; bool:\n\"\"\"Process Records Management Settings for Extended ECM.\n    The setting files need to be placed in the OTCS file system file via\n    a transport into the Support Asset Volume.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._records_management_settings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nif (\n\"records_management_system_settings\" in self._records_management_settings\nand self._records_management_settings[\"records_management_system_settings\"]\n!= \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\n\"records_management_system_settings\"\n]\n)\nresponse = self._otcs.import_records_management_settings(filename)\nif not response:\nsuccess = False\nif (\n\"records_management_codes\" in self._records_management_settings\nand self._records_management_settings[\"records_management_codes\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"records_management_codes\"]\n)\nresponse = self._otcs.import_records_management_codes(filename)\nif not response:\nsuccess = False\nif (\n\"records_management_rsis\" in self._records_management_settings\nand self._records_management_settings[\"records_management_rsis\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"records_management_rsis\"]\n)\nresponse = self._otcs.import_records_management_rsis(filename)\nif not response:\nsuccess = False\nif (\n\"physical_objects_system_settings\" in self._records_management_settings\nand self._records_management_settings[\"physical_objects_system_settings\"]\n!= \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"physical_objects_system_settings\"]\n)\nresponse = self._otcs.import_physical_objects_settings(filename)\nif not response:\nsuccess = False\nif (\n\"physical_objects_codes\" in self._records_management_settings\nand self._records_management_settings[\"physical_objects_codes\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"physical_objects_codes\"]\n)\nresponse = self._otcs.import_physical_objects_codes(filename)\nif not response:\nsuccess = False\nif (\n\"physical_objects_locators\" in self._records_management_settings\nand self._records_management_settings[\"physical_objects_locators\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"physical_objects_locators\"]\n)\nresponse = self._otcs.import_physical_objects_locators(filename)\nif not response:\nsuccess = False\nif (\n\"security_clearance_codes\" in self._records_management_settings\nand self._records_management_settings[\"security_clearance_codes\"] != \"\"\n):\nfilename = (\nself._custom_settings_dir\n+ self._records_management_settings[\"security_clearance_codes\"]\n)\nresponse = self._otcs.import_security_clearance_codes(filename)\nif not response:\nsuccess = False\nself.write_status_file(success, section_name, self._records_management_settings)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_renamings","title":"<code>process_renamings(section_name='renamings')</code>","text":"<p>Process renamings specified in payload and rename existing Extended ECM items.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'renamings'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_renamings(self, section_name: str = \"renamings\") -&gt; bool:\n\"\"\"Process renamings specified in payload and rename existing Extended ECM items.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._renamings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor renaming in self._renamings:\nif not \"nodeid\" in renaming:\nif not \"volume\" in renaming:\nlogger.error(\n\"Renamings require either a node ID or a volume! Skipping to next renaming...\"\n)\ncontinue\n# Determine object ID of volume:\nvolume = self._otcs.get_volume(renaming[\"volume\"])\nnode_id = self._otcs.get_result_value(volume, \"id\")\nelse:\nnode_id = renaming[\"nodeid\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in renaming and not renaming[\"enabled\"]:\nlogger.info(\"Payload for Renaming is disabled. Skipping...\")\ncontinue\nresponse = self._otcs.rename_node(\nint(node_id), renaming[\"name\"], renaming[\"description\"]\n)\nif not response:\nlogger.error(\n\"Failed to rename node ID -&gt; %s to new name -&gt; %s.\",\nnode_id,\nrenaming[\"name\"],\n)\nsuccess = False\nself.write_status_file(success, section_name, self._renamings)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_sap_rfcs","title":"<code>process_sap_rfcs(sap_object, section_name='sapRFCs')</code>","text":"<p>Process SAP RFCs in payload and run them in SAP S/4HANA.</p> <p>Parameters:</p> Name Type Description Default <code>sap_object</code> <code>SAP</code> <p>SAP object</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'sapRFCs'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_sap_rfcs(self, sap_object: SAP, section_name: str = \"sapRFCs\") -&gt; bool:\n\"\"\"Process SAP RFCs in payload and run them in SAP S/4HANA.\n    Args:\n        sap_object (SAP): SAP object\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not sap_object:\nlogger.info(\"SAP object is undefined. Cannot call RFCs. Bailing out.\")\nreturn False\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor sap_rfc in self._sap_rfcs:\nrfc_name = sap_rfc[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in sap_rfc and not sap_rfc[\"enabled\"]:\nlogger.info(\n\"Payload for SAP RFC -&gt; %s is disabled. Skipping...\", rfc_name\n)\ncontinue\nrfc_description = (\nsap_rfc[\"description\"] if sap_rfc.get(\"description\") else \"\"\n)\n# be careful to avoid key errors as SAP RFC parameters are optional:\nrfc_params = sap_rfc[\"parameters\"] if sap_rfc.get(\"parameters\") else {}\nif rfc_params:\nlogger.info(\n\"Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\nrfc_name,\nrfc_description,\nrfc_params,\n)\nelse:\nlogger.info(\n\"Calling SAP RFC -&gt; %s (%s) without parameters...\",\nrfc_name,\nrfc_description,\n)\n# be careful to avoid key errors as SAP RFC parameters are optional:\nrfc_call_options = (\nsap_rfc[\"call_options\"] if sap_rfc.get(\"call_options\") else {}\n)\nif rfc_call_options:\nlogger.debug(\"Using call options -&gt; %s ...\", rfc_call_options)\nresult = sap_object.call(rfc_name, rfc_call_options, rfc_params)\nif result is None:\nlogger.error(\"Failed to call SAP RFC -&gt; %s\", rfc_name)\nsuccess = False\nelif result.get(\"RESULT\") != \"OK\":\nlogger.error(\n\"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\nrfc_name,\nstr(result.get(\"FAILED\")),\nstr(result),\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n)\n# Save result for status file content\nsap_rfc[\"result\"] = result\nself.write_status_file(success, section_name, self._sap_rfcs)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_security_clearances","title":"<code>process_security_clearances(section_name='securityClearances')</code>","text":"<p>Process Security Clearances for Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'securityClearances'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_security_clearances(\nself, section_name: str = \"securityClearances\"\n) -&gt; bool:\n\"\"\"Process Security Clearances for Extended ECM.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._security_clearances:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor security_clearance in self._security_clearances:\nclearance_level = security_clearance.get(\"level\")\nclearance_name = security_clearance.get(\"name\")\nif \"enabled\" in security_clearance and not security_clearance[\"enabled\"]:\nlogger.info(\n\"Payload for Security Clearance -&gt; %s is disabled. Skipping...\",\nclearance_name,\n)\ncontinue\nclearance_description = security_clearance.get(\"description\")\nif not clearance_description:\nclearance_description = \"\"\nif clearance_level and clearance_name:\nlogger.info(\n\"Creating Security Clearance -&gt; %s : %s\",\nclearance_level,\nclearance_name,\n)\nself._otcs.run_web_report(\n\"web_report_security_clearance\", security_clearance\n)\nelse:\nlogger.error(\n\"Cannot create Security Clearance - either level or name is missing!\"\n)\nsuccess = False\nself.write_status_file(success, section_name, self._security_clearances)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_supplemental_markings","title":"<code>process_supplemental_markings(section_name='supplementalMarkings')</code>","text":"<p>Process Supplemental Markings for Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'supplementalMarkings'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_supplemental_markings(\nself, section_name: str = \"supplementalMarkings\"\n) -&gt; bool:\n\"\"\"Process Supplemental Markings for Extended ECM.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._supplemental_markings:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor supplemental_marking in self._supplemental_markings:\ncode = supplemental_marking.get(\"code\")\nif (\n\"enabled\" in supplemental_marking\nand not supplemental_marking[\"enabled\"]\n):\nlogger.info(\n\"Payload for Supplemental Marking -&gt; %s is disabled. Skipping...\",\ncode,\n)\ncontinue\ndescription = supplemental_marking.get(\"description\")\nif not description:\ndescription = \"\"\nif code:\nlogger.info(\n\"Creating Supplemental Marking -&gt; %s : %s\", code, description\n)\nself._otcs.run_web_report(\n\"web_report_supplemental_marking\", supplemental_marking\n)\nelse:\nlogger.error(\n\"Cannot create Supplemental Marking - either code or description is missing!\"\n)\nsuccess = False\nself.write_status_file(success, section_name, self._supplemental_markings)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_system_attributes","title":"<code>process_system_attributes(section_name='systemAttributes')</code>","text":"<p>Process OTDS system attributes in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'systemAttributes'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_system_attributes(self, section_name: str = \"systemAttributes\") -&gt; bool:\n\"\"\"Process OTDS system attributes in payload and create them in OTDS.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._system_attributes:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor system_attribute in self._system_attributes:\n# Check if there's a matching formal parameter defined on the Web Report node:\nif not system_attribute.get(\"name\"):\nlogger.error(\"OTDS System Attribute needs a name. Skipping...\")\nsuccess = False\ncontinue\nattribute_name = system_attribute[\"name\"]\nif \"enabled\" in system_attribute and not system_attribute[\"enabled\"]:\nlogger.info(\n\"Payload for OTDS System Attribute -&gt; %s is disabled. Skipping...\",\nattribute_name,\n)\ncontinue\nif not system_attribute.get(\"value\"):\nlogger.error(\"OTDS System Attribute needs a value. Skipping...\")\ncontinue\nattribute_value = system_attribute[\"value\"]\nattribute_description = system_attribute.get(\"description\")\nresponse = self._otds.add_system_attribute(\nattribute_name, attribute_value, attribute_description\n)\nif response:\nlogger.info(\n\"Added OTDS system attribute -&gt; %s with value -&gt; %s\",\nattribute_name,\nattribute_value,\n)\nelse:\nlogger.error(\n\"Failed to add OTDS system attribute -&gt; %s with value -&gt; %s\",\nattribute_name,\nattribute_value,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._system_attributes)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_teams_m365","title":"<code>process_teams_m365(section_name='teamsM365')</code>","text":"<p>Process groups in payload and create matching Teams in Microsoft 365.    We need to do this after the creation of the M365 users as wie require    Group Owners to create teams.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'teamsM365'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_teams_m365(self, section_name: str = \"teamsM365\") -&gt; bool:\n\"\"\"Process groups in payload and create matching Teams in Microsoft 365.\n       We need to do this after the creation of the M365 users as wie require\n       Group Owners to create teams.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Team needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\nif not \"enable_o365\" in group or not group[\"enable_o365\"]:\nlogger.info(\n\"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\ngroup_name,\n)\ncontinue\n# Check if the M365 group does not exist (this should actually never happen at this point)\nif not \"m365_id\" in group:\n# The \"m365_id\" value is set by the method process_groups_m365()\nlogger.error(\n\"No M365 Group exist for group -&gt; %s (M365 Group creation may have failed). Skipping...\",\ngroup_name,\n)\nsuccess = False\ncontinue\nif self._m365.has_team(group_name):\nlogger.info(\n\"M365 group -&gt; %s already has an MS Team connected. Skipping...\",\ngroup_name,\n)\ncontinue\nlogger.info(\n\"Create M365 Team -&gt; %s for existing M365 Group -&gt; %s...\",\ngroup_name,\ngroup_name,\n)\n# Now \"upgrading\" this group to a MS Team:\nnew_team = self._m365.add_team(group_name)\nif not new_team:\nsuccess = False\ncontinue\nself.write_status_file(success, section_name, self._groups)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_teams_m365_apps","title":"<code>process_teams_m365_apps(section_name='teamsM365Apps', tab_name='Extended ECM')</code>","text":"<p>Process groups in payload and configure Extended ECM Teams Apps    as a tab called \"Extended ECM\".    We need to do this after the transport as we need top level folders    we can point the Extended ECM teams app to.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'teamsM365Apps'</code> <code>tab_name</code> <code>str</code> <p>Name of the Extended ECM tab. Default is \"Extended ECM\".</p> <code>'Extended ECM'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_teams_m365_apps(\nself, section_name: str = \"teamsM365Apps\", tab_name: str = \"Extended ECM\"\n) -&gt; bool:\n\"\"\"Process groups in payload and configure Extended ECM Teams Apps\n       as a tab called \"Extended ECM\".\n       We need to do this after the transport as we need top level folders\n       we can point the Extended ECM teams app to.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n        tab_name (str, optional): Name of the Extended ECM tab. Default is \"Extended ECM\".\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._groups:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# Determine the ID of the Extended ECM App:\napp_name = self._m365.config()[\"teamsAppName\"]\nresponse = self._m365.get_teams_apps(f\"contains(displayName, '{app_name}')\")\n# Get the App catalog ID:\napp_catalog_id = self._m365.get_result_value(response, \"id\", 0)\nif not app_catalog_id:\nlogger.error(\"M365 App -&gt; %s not found in catalog!\", app_name)\nreturn False\nfor group in self._groups:\nif not \"name\" in group:\nlogger.error(\"Team needs a name. Skipping...\")\nsuccess = False\ncontinue\ngroup_name = group[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in group and not group[\"enabled\"]:\nlogger.info(\n\"Payload for Group -&gt; %s is disabled. Skipping...\", group_name\n)\ncontinue\nif not \"enable_o365\" in group or not group[\"enable_o365\"]:\nlogger.info(\n\"Office 365 is not enabled in payload for Group -&gt; %s. Skipping...\",\ngroup_name,\n)\ncontinue\n#\n# Now we create a tab in the \"General\" channel for the Extended ECM Teams App\n#\n# 1. Check if the tab is already assigned to the General channel.\n# This determines if we need to create or update the tab / app:\napp_name = self._m365.config()[\"teamsAppName\"]\nresponse = self._m365.get_team_channel_tabs(\nteam_name=group_name, channel_name=\"General\"\n)\n# Check if tab is already there:\nif self._m365.exist_result_item(response, \"displayName\", tab_name):\nlogger.info(\n\"M365 Teams app -&gt; %s is already configured for M365 Team -&gt; %s. Updating it with new URLs and IDs...\",\napp_name,\ntab_name,\n)\nupdate = True  # update existing tab\nelse:\nlogger.info(\n\"Add tab -&gt; %s to channel -&gt; General of M365 Team -&gt; %s for app -&gt; %s\",\ntab_name,\ngroup_name,\napp_name,\n)\nupdate = False  # create new tab\n# 2. Determine the M365 Team ID. If the team is not found then skip:\nresponse = self._m365.get_team(group_name)\nteam_id = self._m365.get_result_value(response, \"id\", 0)\nif not team_id:\nlogger.error(\"M365 Team -&gt; %s not found!\", group_name)\nsuccess = False\ncontinue\n# 3. Install the App for the particular M365 Team (if it is not yet installed):\nresponse = self._m365.get_teams_apps_of_team(\nteam_id,\nf\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n)\nif self._m365.exist_result_item(\nresponse, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n):\nlogger.info(\n\"App -&gt; %s is already installed for M365 Team -&gt; %s (%s). Trying to upgrade app...\",\napp_name,\ngroup_name,\nteam_id,\n)\nresponse = self._m365.upgrade_teams_app_of_team(team_id, app_name)\nif not response:\nlogger.error(\n\"Failed to upgrade the existing app -&gt; %s for the M365 Team -&gt; %s\",\napp_name,\ngroup_name,\n)\nsuccess = False\ncontinue\nelse:\nlogger.info(\n\"Install M365 Teams app -&gt; %s for M365 team -&gt; %s\",\napp_name,\ngroup_name,\n)\nresponse = self._m365.assign_teams_app_to_team(\nteam_id=team_id, app_id=app_catalog_id\n)\nif not response:\nlogger.error(\n\"Failed to install App -&gt; %s (%s) for M365 Team -&gt; %s\",\napp_name,\napp_catalog_id,\ngroup_name,\n)\nsuccess = False\ncontinue\n# 4. Create a Tab in the \"General\" channel of the M365 Team:\nif group_name == \"Innovate\":\n# Use the Enterprise Workspace for the\n# top-level group \"Innovate\":\nnode_id = 2000\nelse:\n# We assume the departmental group names are identical to\n# top-level folders in the Enterprise volume\nnode = self._otcs.get_node_by_parent_and_name(2000, group_name)\nnode_id = self._otcs.get_result_value(node, \"id\")\nif not node_id:\nlogger.warning(\n\"Cannot find a top-level container for group -&gt; %s. Cannot configure M365 Teams app. Skipping...\",\ngroup_name,\n)\ncontinue\napp_url = (\nself._otcs_frontend.cs_support_public_url()\n)  # it is important to use the frontend pod URL here\napp_url += \"/xecmoffice/teamsapp.html?nodeId=\"\napp_url += (\nstr(node_id) + \"&amp;type=container&amp;parentId=2000&amp;target=content&amp;csurl=\"\n)\napp_url += self._otcs_frontend.cs_public_url()\napp_url += \"&amp;appId=\" + app_catalog_id\nif update:\n# App / Tab exist but needs to be updated with new\n# IDs for the new deployment of Extended ECM\n# as the M365 Teams survive between Terrarium deployments:\nlogger.info(\n\"Updating tab -&gt; %s of M365 Team channel -&gt; General for app -&gt; %s (%s) with new URLs and node IDs\",\ntab_name,\napp_name,\napp_catalog_id,\n)\nresponse = self._m365.update_teams_app_of_channel(\nteam_name=group_name,\nchannel_name=\"General\",\ntab_name=tab_name,\napp_url=app_url,\ncs_node_id=node_id,\n)\nelse:\n# Tab does not exist in \"General\" channel so we\n# add / configure it freshly:\nlogger.info(\n\"Adding tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\ntab_name,\napp_name,\napp_catalog_id,\n)\nresponse = self._m365.add_teams_app_to_channel(\nteam_name=group_name,\nchannel_name=\"General\",\napp_id=app_catalog_id,\ntab_name=tab_name,\napp_url=app_url,\ncs_node_id=node_id,\n)\nif not response:\nlogger.error(\n\"Failed to add tab -&gt; %s to M365 Team channel -&gt; General for app -&gt; %s (%s)\",\ntab_name,\napp_name,\napp_catalog_id,\n)\nself.write_status_file(success, section_name, self._groups)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_transport_packages","title":"<code>process_transport_packages(transport_packages, section_name='transportPackages')</code>","text":"<p>Process transport packages in payload and import them to Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>transport_packages</code> <code>list</code> <p>list of transport packages. As we                        have three different lists (transport,                        content_transport, transport_post) so                        we need a parameter</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"transportPackagesPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'transportPackages'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_transport_packages(\nself, transport_packages: list, section_name: str = \"transportPackages\"\n) -&gt; bool:\n\"\"\"Process transport packages in payload and import them to Extended ECM.\n    Args:\n        transport_packages (list): list of transport packages. As we\n                                   have three different lists (transport,\n                                   content_transport, transport_post) so\n                                   we need a parameter\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"transportPackagesPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not transport_packages:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor transport_package in transport_packages:\nif not \"name\" in transport_package:\nlogger.error(\n\"Transport Package needs a name! Skipping to next transport...\"\n)\nsuccess = False\ncontinue\nname = transport_package[\"name\"]\nif \"enabled\" in transport_package and not transport_package[\"enabled\"]:\nlogger.info(\n\"Payload for Transport Package -&gt; %s is disabled. Skipping...\", name\n)\ncontinue\nif not \"url\" in transport_package:\nlogger.error(\n\"Transport Package -&gt; %s needs a URL! Skipping to next transport...\",\nname,\n)\nsuccess = False\ncontinue\nif not \"description\" in transport_package:\nlogger.warning(\"Transport Package -&gt; %s is missing a description\", name)\nurl = transport_package[\"url\"]\ndescription = transport_package[\"description\"]\n# For some transports there can be string replacements\n# configured:\nif \"replacements\" in transport_package:\nreplacements = transport_package[\"replacements\"]\nlogger.info(\n\"Deploy transport -&gt; %s with replacements -&gt; %s; URL -&gt; %s\",\ndescription,\nurl,\nreplacements,\n)\nresponse = self._otcs.deploy_transport(\nurl, name, description, replacements\n)\nelse:\nlogger.info(\"Deploy transport -&gt; %s; URL -&gt; %s\", description, url)\nresponse = self._otcs.deploy_transport(url, name, description)\nif response is None:\nlogger.error(\"Failed to deploy transport -&gt; %s; URL -&gt; %s\", name, url)\nsuccess = False\nif self._stop_on_error:\nbreak\nelse:\nlogger.info(\"Successfully deployed transport -&gt; %s\", name)\nself.write_status_file(success, section_name, transport_packages)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_trusted_sites","title":"<code>process_trusted_sites(section_name='trustedSites')</code>","text":"<p>Process OTDS trusted sites in payload and create them in OTDS.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'trustedSites'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_trusted_sites(self, section_name: str = \"trustedSites\") -&gt; bool:\n\"\"\"Process OTDS trusted sites in payload and create them in OTDS.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._trusted_sites:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor trusted_site in self._trusted_sites:\n# old payload may still have trusted sites as list of string\n# we changed also the trusted sites to dict with 23.3\n# We want to be backwards compatible so we handle both cases:\nif isinstance(trusted_site, dict):\nurl = trusted_site.get(\"url\")\nelif isinstance(trusted_site, str):\nurl = trusted_site\nif not url:\nlogger.error(\"OTDS Trusted site does not have a URL. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif (\nisinstance(trusted_site, dict)\nand \"enabled\" in trusted_site\nand not trusted_site[\"enabled\"]\n):\nlogger.info(\n\"Payload for OTDS Trusted Site -&gt; %s is disabled. Skipping...\",\nurl,\n)\ncontinue\nresponse = self._otds.add_trusted_site(url)\nif response:\nlogger.info(\"Added OTDS trusted site -&gt; %s\", trusted_site)\nelse:\nlogger.error(\"Failed to add trusted site -&gt; %s\", trusted_site)\nsuccess = False\nself.write_status_file(success, section_name, self._trusted_sites)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_favorites_and_profiles","title":"<code>process_user_favorites_and_profiles(section_name='userFavoritesAndProfiles')</code>","text":"<p>Process user favorites in payload and create them in Extended ECM.    This method also simulates browsing the favorites to populate the    widgets on the landing pages and sets personal preferences.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userFavoritesAndProfiles'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_favorites_and_profiles(\nself, section_name: str = \"userFavoritesAndProfiles\"\n) -&gt; bool:\n\"\"\"Process user favorites in payload and create them in Extended ECM.\n       This method also simulates browsing the favorites to populate the\n       widgets on the landing pages and sets personal preferences.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# We can only set favorites if we impersonate / authenticate as the user.\n# The following code (for loop) will change the authenticated user - we need to\n# switch it back to admin user later so we safe the admin credentials for this:\nif self._users:\n# save admin credentials for later switch back to admin user:\nadmin_credentials = self._otcs.credentials()\nelse:\nadmin_credentials = {}\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nuser_password = user[\"password\"]\n# we change the otcs credentials to the user:\nself._otcs.set_credentials(user_name, user_password)\n# we re-authenticate as the user:\nlogger.info(\"Authenticate user -&gt; %s...\", user_name)\n# True = force new login with new user\ncookie = self._otcs.authenticate(\nrevalidate=True, force_user_password_login=True\n)\nif not cookie:\nlogger.error(\"Couldn't authenticate user -&gt; %s\", user_name)\nsuccess = False\ncontinue\n# we update the user profile to activate responsive (dynamic) containers:\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for user -&gt; %s couldn't be updated with responsive container mode'!\",\nuser_name,\n)\nelse:\nlogger.info(\n\"Profile for user -&gt; %s has been updated to enable responsive container mode.\",\nuser_name,\n)\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMessageMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for user -&gt; %s couldn't be updated with responsive container message mode'!\",\nuser_name,\n)\nelse:\nlogger.info(\n\"Profile for user -&gt; %s has been updated to enable messages for responsive container mode.\",\nuser_name,\n)\n# we work through the list of favorites defined for the user:\nfavorites = user[\"favorites\"]\nfor favorite in favorites:\n# check if favorite is a logical workspace name\nfavorite_item = next(\n(item for item in self._workspaces if item[\"id\"] == favorite), None\n)\nis_workspace = False\nif favorite_item:\nlogger.info(\n\"Found favorite item (workspace) in payload -&gt; %s\",\nfavorite_item[\"name\"],\n)\nfavorite_id = self.determine_workspace_id(favorite_item)\nif not favorite_id:\nlogger.warning(\n\"Workspace of type -&gt; %s and name -&gt; %s does not exist. Cannot create favorite. Skipping...\",\nfavorite_item[\"type_name\"],\nfavorite_item[\"name\"],\n)\ncontinue\nis_workspace = True\nelse:\n# alternatively try to find the item as a nickname:\nfavorite_item = self._otcs.get_node_from_nickname(favorite)\nfavorite_id = self._otcs.get_result_value(favorite_item, \"id\")\n#                    if favorite_item is None:\nif favorite_id is None:\nlogger.warning(\n\"Favorite -&gt; %s neither found as workspace ID nor as nickname. Skipping to next favorite...\",\nfavorite,\n)\ncontinue\nresponse = self._otcs.add_favorite(favorite_id)\nif response is None:\nlogger.warning(\n\"Favorite ID -&gt; %s couldn't be added for user -&gt; %s!\",\nfavorite_id,\nuser_name,\n)\nelse:\nlogger.info(\n\"Added favorite for user -&gt; %s, node ID -&gt; %s.\",\nuser_name,\nfavorite_id,\n)\nlogger.info(\n\"Simulate user -&gt; %s browsing node ID -&gt; %s.\",\nuser_name,\nfavorite_id,\n)\n# simulate a browse by the user to populate recently accessed items\nif is_workspace:\nresponse = self._otcs.get_workspace(favorite_id)\nelse:\nresponse = self._otcs.get_node(favorite_id)\n# we work through the list of proxies defined for the user\n# (we need to consider that not all users have the proxies element):\nproxies = user[\"proxies\"] if user.get(\"proxies\") else []\nfor proxy in proxies:\nproxy_user = next(\n(item for item in self._users if item[\"name\"] == proxy),\nNone,\n)\nif not proxy_user or not \"id\" in proxy_user:\nlogger.error(\n\"The proxy -&gt; %s for user -&gt; %s does not exist! Skipping proxy...\",\nproxy,\nuser_name,\n)\nsuccess = False\ncontinue\nproxy_user_id = proxy_user[\"id\"]\n# Check if the proxy is already set:\nif not self._otcs.is_proxy(proxy):\nlogger.info(\n\"Set user -&gt; %s (%s) as proxy for user -&gt; %s.\",\nproxy,\nproxy_user_id,\nuser_name,\n)\n# set the user proxy - currently we don't support time based proxies in payload.\n# The called method is ready to support this.\nresponse = self._otcs.add_user_proxy(proxy_user_id)\nelse:\nlogger.info(\n\"User -&gt; %s (%s) is already proxy for user -&gt; %s. Skipping...\",\nproxy,\nproxy_user_id,\nuser_name,\n)\nif self._users:\n# Set back admin credentials:\nself._otcs.set_credentials(\nadmin_credentials[\"username\"], admin_credentials[\"password\"]\n)\n# we re-authenticate as the admin user:\nlogger.info(\n\"Authenticate as admin user -&gt; %s...\", admin_credentials[\"username\"]\n)\n# True = force new login with new user\ncookie = self._otcs.authenticate(True)\n# Also for the admin user we want to update the user profile to activate responsive (dynamic) containers:\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for admin user couldn't be updated with responsive container mode'!\",\n)\nelse:\nlogger.info(\n\"Profile for admin user has been updated to enable responsive container mode.\",\n)\nresponse = self._otcs.update_user_profile(\nfield=\"responsiveContainerMessageMode\",\nvalue=True,\nconfig_section=\"SmartUI\",\n)\nif response is None:\nlogger.warning(\n\"Profile for admin user couldn't be updated with responsive container message mode'!\",\n)\nelse:\nlogger.info(\n\"Profile for admin user has been updated to enable messages for responsive container mode.\",\n)\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_licenses","title":"<code>process_user_licenses(resource_name, license_feature, license_name, user_specific_payload_field='licenses', section_name='userLicenses')</code>","text":"<p>Assign a specific OTDS license feature to all Extended ECM users.    This method is used for OTIV and Extended ECM licenses.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>name of the OTDS resource</p> required <code>license_feature</code> <code>str</code> <p>license feature to assign to the user (product specific)</p> required <code>license_name</code> <code>str</code> <p>Name of the license Key (e.g. \"EXTENDED_ECM\" or \"INTELLIGENT_VIEWING\")</p> required <code>user_specific_payload_field</code> <code>str</code> <p>name of the user specific field in payload                                          (if empty it will be ignored)</p> <code>'licenses'</code> <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userLicenses'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_licenses(\nself,\nresource_name: str,\nlicense_feature: str,\nlicense_name: str,\nuser_specific_payload_field: str = \"licenses\",\nsection_name: str = \"userLicenses\",\n) -&gt; bool:\n\"\"\"Assign a specific OTDS license feature to all Extended ECM users.\n       This method is used for OTIV and Extended ECM licenses.\n    Args:\n        resource_name (str): name of the OTDS resource\n        license_feature (str): license feature to assign to the user (product specific)\n        license_name (str): Name of the license Key (e.g. \"EXTENDED_ECM\" or \"INTELLIGENT_VIEWING\")\n        user_specific_payload_field (str, optional): name of the user specific field in payload\n                                                     (if empty it will be ignored)\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\notds_resource = self._otds.get_resource(resource_name)\nif not otds_resource:\nlogger.error(\n\"OTDS Resource -&gt; {} not found. Cannot assign licenses to users.\"\n)\nreturn False\nuser_partition = self._otcs.config()[\"partition\"]\nif not user_partition:\nlogger.error(\"OTCS user partition not found in OTDS!\")\nreturn False\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif user_specific_payload_field and user_specific_payload_field in user:\nlogger.info(\n\"Found specific license feature -&gt; %s for User -&gt; %s. Overwriting default license feature -&gt; %s\",\nuser[user_specific_payload_field],\nuser_name,\nlicense_feature,\n)\nuser_license_feature = user[user_specific_payload_field]\nelse:  # use the default feature from the actual parameter\nuser_license_feature = [license_feature]\nfor license_feature in user_license_feature:\nif self._otds.is_user_licensed(\nuser_name=user_name,\nresource_id=otds_resource[\"resourceID\"],\nlicense_feature=license_feature,\nlicense_name=license_name,\n):\nlogger.info(\n\"User -&gt; %s is already licensed for -&gt; %s (%s)\",\nuser_name,\nlicense_name,\nlicense_feature,\n)\ncontinue\nassigned_license = self._otds.assign_user_to_license(\nuser_partition,\nuser_name,  # we want the plain login name here\notds_resource[\"resourceID\"],\nlicense_feature,\nlicense_name,\n)\nif not assigned_license:\nlogger.error(\n\"Failed to assign license feature -&gt; %s to user -&gt; %s!\",\nlicense_feature,\nuser_name,\n)\nsuccess = False\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_photos","title":"<code>process_user_photos(section_name='userPhotos')</code>","text":"<p>Process user photos in payload and assign them to Extended ECM users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userPhotos'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_photos(self, section_name: str = \"userPhotos\") -&gt; bool:\n\"\"\"Process user photos in payload and assign them to Extended ECM users.\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# we assume the nickname of the photo item equals the login name of the user\n# we also assume that the photos have been uploaded / transported into the target system\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif not \"id\" in user:\nlogger.error(\n\"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser_id = user[\"id\"]\nresponse = self._otcs.get_node_from_nickname(user_name)\nif response is None:\nlogger.warning(\n\"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\nuser_name,\n)\ncontinue\nphoto_id = self._otcs.get_result_value(response, \"id\")\nresponse = self._otcs.update_user_photo(user_id, photo_id)\nif not response:\nlogger.error(\"Failed to add photo for user -&gt; %s\", user_name)\nsuccess = False\nelse:\nlogger.info(\"Successfully added photo for user -&gt; %s\", user_name)\n# Check if Admin has a photo as well (nickname needs to be \"admin\"):\nresponse = self._otcs.get_node_from_nickname(\"admin\")\nif response is None:\nlogger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\nelse:\nphoto_id = self._otcs.get_result_value(response, \"id\")\nresponse = self._otcs.update_user_photo(1000, photo_id)\nif response is None:\nlogger.warning(\"Failed to add photo for admin\")\nelse:\nlogger.info(\"Successfully added photo for admin\")\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_photos_m365","title":"<code>process_user_photos_m365(section_name='userPhotosM365')</code>","text":"<p>Process user photos in payload and assign them to Microsoft 365 users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userPhotosM365'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_photos_m365(self, section_name: str = \"userPhotosM365\") -&gt; bool:\n\"\"\"Process user photos in payload and assign them to Microsoft 365 users.\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# we assume the nickname of the photo item equals the login name of the user\n# we also assume that the photos have been uploaded / transported into the target system\nfor user in self._users:\nuser_name = user[\"name\"]\nif not \"id\" in user:\nlogger.error(\n\"User -&gt; %s does not have an ID. The user creation may have failed before. Skipping...\",\nuser_name,\n)\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif not \"enable_o365\" in user or not user[\"enable_o365\"]:\nlogger.info(\n\"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\nuser_name,\n)\ncontinue\n# If the customizer pod is restarted it may be that\n# the M365 user exists even if the M365 user ID is\n# not yet written back into the payload. So we use the\n# determine_user_id_m365() method that handles both cases\n# and updates the payload if the user exists in M365 already.\nuser_m365_id = self.determine_user_id_m365(user)\nif not user_m365_id:\nlogger.error(\"M365 user -&gt; %s does not exist. Skipping...\", user_name)\nsuccess = False\ncontinue\nif self._m365.get_user_photo(user_m365_id, show_error=False):\nlogger.info(\n\"User -&gt; %s (%s) has already a photo in Microsoft 365. Skipping...\",\nuser_name,\nuser_m365_id,\n)\ncontinue\nelse:\nlogger.info(\n\"User -&gt; %s (%s) has not yet a photo in Microsoft 365. Uploading...\",\nuser_name,\nuser_m365_id,\n)\nresponse = self._otcs.get_node_from_nickname(user_name)\nif response is None:\nlogger.warning(\n\"Missing photo for user -&gt; %s - nickname not found. Skipping...\",\nuser_name,\n)\ncontinue\nphoto_id = self._otcs.get_result_value(response, \"id\")\nphoto_name = self._otcs.get_result_value(response, \"name\")\nphoto_path = \"/tmp/\" + str(photo_name)\nresponse = self._otcs.download_document(photo_id, photo_path)\nif response is None:\nlogger.warning(\n\"Failed to download photo for user -&gt; %s from Extended ECM\",\nuser_name,\n)\nsuccess = False\ncontinue\nelse:\nlogger.info(\n\"Successfully downloaded photo for user -&gt; %s from Extended ECM to file -&gt; %s\",\nuser_name,\nphoto_path,\n)\n# Upload photo to M365:\nresponse = self._m365.update_user_photo(user_m365_id, photo_path)\nif response is None:\nlogger.error(\n\"Failed to upload photo for user -&gt; %s to Microsoft 365\", user_name\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully uploaded photo for user -&gt; %s to Microsoft 365\",\nuser_name,\n)\n# Check if Admin has a photo as well (nickname needs to be \"admin\")\n# Then we want this to be applied in M365 as well:\nresponse = self._otcs.get_node_from_nickname(\"admin\")\nif response is None:\nlogger.warning(\"Missing photo for admin - nickname not found. Skipping...\")\nelse:\nphoto_id = self._otcs.get_result_value(response, \"id\")\nphoto_name = self._otcs.get_result_value(response, \"name\")\nphoto_path = \"/tmp/\" + str(photo_name)\nresponse = self._otcs.download_document(photo_id, photo_path)\nif response is None:\nlogger.warning(\n\"Failed to download photo for admin user from Extended ECM\",\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully downloaded photo for admin from Extended ECM to file -&gt; %s\",\nphoto_path,\n)\nm365_admin_email = \"admin@\" + self._m365.config()[\"domain\"]\nresponse = self._m365.update_user_photo(m365_admin_email, photo_path)\nif response is None:\nlogger.warning(\"Failed to add photo for %s\", m365_admin_email)\nelse:\nlogger.info(\"Successfully added photo for %s\", m365_admin_email)\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_placeholders","title":"<code>process_user_placeholders()</code>","text":"<p>For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%) with the actual ID of the Extended ECM user. For this we prepare a lookup dict. The dict self._placeholder_values already includes lookups for the OTCS and OTAWP OTDS resource IDs (see customizer.py)</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_placeholders(self):\n\"\"\"For some adminSettings we may need to replace a placeholder (sourrounded by %%...%%)\n    with the actual ID of the Extended ECM user. For this we prepare a lookup dict.\n    The dict self._placeholder_values already includes lookups for the OTCS and OTAWP\n    OTDS resource IDs (see customizer.py)\n    \"\"\"\nfor user in self._users:\nif not \"name\" in user:\nlogger.error(\n\"User needs a name for placeholder definition. Skipping...\"\n)\ncontinue\nuser_name = user[\"name\"]\n# Check if user has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Now we determine the ID. Either it is in the payload section from\n# the current customizer run or we try to look it up in the system.\n# The latter case may happen if the customizer pod got restarted.\nuser_id = self.determine_user_id(user)\nif not user_id:\nlogger.warning(\n\"User needs an ID for placeholder definition. Skipping...\"\n)\ncontinue\n# Add user with its ID to the dict self._placeholder_values:\nself._placeholder_values[\"OTCS_USER_ID_%s\", user_name.upper()] = str(\nuser_id\n)\nlogger.debug(\n\"Placeholder values after user processing = %s\", self._placeholder_values\n)\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_security","title":"<code>process_user_security(section_name='userSecurity')</code>","text":"<p>Process Security Clearance and Supplemental Markings for Extended ECM users.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userSecurity'</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_security(self, section_name: str = \"userSecurity\"):\n\"\"\"Process Security Clearance and Supplemental Markings for Extended ECM users.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor user in self._users:\nuser_id = user.get(\"id\")\nuser_name = user.get(\"name\")\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Read security clearance from user payload (it is optional!)\nuser_security_clearance = user.get(\"security_clearance\")\nif user_id and user_security_clearance:\nself._otcs.assign_user_security_clearance(\nuser_id, user_security_clearance\n)\n# Read supplemental markings from user payload (it is optional!)\nuser_supplemental_markings = user.get(\"supplemental_markings\")\nif user_id and user_supplemental_markings:\nself._otcs.assign_user_supplemental_markings(\nuser_id, user_supplemental_markings\n)\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_user_settings","title":"<code>process_user_settings(section_name='userSettings')</code>","text":"<p>Process user settings in payload and apply themin OTDS.    This includes password settings and user display settings.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'userSettings'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_user_settings(self, section_name: str = \"userSettings\") -&gt; bool:\n\"\"\"Process user settings in payload and apply themin OTDS.\n       This includes password settings and user display settings.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor user in self._users:\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nuser_partition = self._otcs.config()[\"partition\"]\nif not user_partition:\nlogger.error(\"User partition not found!\")\nsuccess = False\ncontinue\n# Set the OTDS display name. Extended ECM does not use this but\n# it makes AppWorks display users correctly (and it doesn't hurt)\n# We only set this if firstname _and_ last name are in the payload:\nif \"firstname\" in user and \"lastname\" in user:\nuser_display_name = user[\"firstname\"] + \" \" + user[\"lastname\"]\nresponse = self._otds.update_user(\nuser_partition, user_name, \"displayName\", user_display_name\n)\nif response:\nlogger.info(\n\"Display name for user -&gt; %s has been updated to -&gt; %s\",\nuser_name,\nuser_display_name,\n)\nelse:\nlogger.error(\n\"Display name for user -&gt; %s could not be updated to -&gt; %s\",\nuser_name,\nuser_display_name,\n)\nsuccess = False\n# Don't enforce the user to reset password at first login (settings in OTDS):\nlogger.info(\"Don't enforce password change for user -&gt; %s...\", user_name)\nresponse = self._otds.update_user(\nuser_partition, user_name, \"UserMustChangePasswordAtNextSignIn\", \"False\"\n)\nif not response:\nsuccess = False\nresponse = self._otds.update_user(\nuser_partition, user_name, \"UserCannotChangePassword\", \"True\"\n)\nif not response:\nsuccess = False\n# Set user password to never expire\nresponse = self._otds.update_user(\nuser_partition, user_name, \"PasswordNeverExpires\", \"True\"\n)\nif not response:\nsuccess = False\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_users","title":"<code>process_users(section_name='users')</code>","text":"<p>Process users in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'users'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Side Effects <p>the user items are modified by adding an \"id\" dict element that includes the technical ID of the user in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_users(self, section_name: str = \"users\") -&gt; bool:\n\"\"\"Process users in payload and create them in Extended ECM.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        the user items are modified by adding an \"id\" dict element that\n        includes the technical ID of the user in Extended ECM\n    \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\n#        if self.check_status_file(section_name):\n#            return True\nsuccess: bool = True\n# Add all users in payload and establish membership in\n# specified groups:\nfor user in self._users:\n# Sanity checks:\nif not \"name\" in user:\nlogger.error(\"User is missing a login. Skipping to next user...\")\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Sanity checks:\nif (\nnot \"password\" in user\nor user[\"password\"] is None\nor user[\"password\"] == \"\"\n):\nlogger.info(\n\"User -&gt; %s no password defined in payload, generating random password...\",\nuser_name,\n)\nuser[\"password\"] = self.generate_password(\nlength=10, use_special_chars=True\n)\ndescription_attribue = {\n\"name\": \"description\",\n\"value\": \"initial password: \" + user[\"password\"],\n}\ntry:\nuser[\"extra_attributes\"].append(description_attribue)\nexcept KeyError:\nuser[\"extra_attributes\"] = [description_attribue]\n# Sanity checks:\nif not \"base_group\" in user:\nlogger.warning(\n\"User -&gt; %s is missing a base group - setting to default group\",\nuser_name,\n)\nuser[\"base_group\"] = \"DefaultGroup\"\n# Check if the user does already exist (e.g. if job is restarted)\n# determine_user_id() also writes back the user ID into the payload\n# if it has gathered it from OTCS.\nuser_id = self.determine_user_id(user)\nif user_id:\nlogger.info(\n\"Found existing user -&gt; %s (%s). Skipping to next user...\",\nuser_name,\nuser_id,\n)\ncontinue\nlogger.info(\"Did not find an existing user - creating a new user...\")\n# Find the base group of the user. Assume 'Default Group' (= 1001) if not found:\nbase_group = next(\n(\nitem[\"id\"]\nfor item in self._groups\nif item[\"name\"] == user[\"base_group\"] and item.get(\"id\")\n),\n1001,\n)\n# Now we know it is a new user...\nnew_user = self._otcs.add_user(\nname=user_name,\npassword=user[\"password\"],\nfirst_name=user.get(\"firstname\", \"\"),  # be careful - can be empty\nlast_name=user.get(\"lastname\", \"\"),  # be careful - can be empty\nemail=user.get(\"email\", \"\"),  # be careful - can be empty\nbase_group=base_group,\nprivileges=user.get(\"privileges\", [\"Login\", \"Public Access\"]),\n)\n# Process group memberships of new user:\nif new_user is not None:\nnew_user_id = self._otcs.get_result_value(new_user, \"id\")\nlogger.info(\n\"New user -&gt; %s with ID -&gt; %s has been created\",\nuser_name,\nnew_user_id,\n)\n# Write back user ID into payload\nuser[\"id\"] = new_user_id\nuser_groups = user[\"groups\"]  # list of groups the user is in\nfor user_group in user_groups:\n# Try to find the group dictionary item in the payload\n# for user group name:\ngroup = next(\n(item for item in self._groups if item[\"name\"] == user_group),\nNone,\n)\nif group:\ngroup_id = group.get(\"id\")  # Careful ID may not exist\ngroup_name = group[\"name\"]\nelse:\n# if group is not in payload try to find group in OTCS\n# in case it is a pre-existing group:\ngroup = self._otcs.get_group(user_group)\ngroup_id = self._otcs.get_result_value(group, \"id\")\nif group_id is None:\nlogger.error(\n\"Group -&gt; %s not found. Skipping...\", user_group\n)\nsuccess = False\ncontinue\ngroup_name = self._otcs.get_result_value(group, \"name\")\nif group_id is None:\nlogger.error(\n\"Group -&gt; %s does not have an ID. Cannot add user -&gt; %s to this group. Skipping...\",\ngroup_name,\nuser[\"name\"],\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Add user -&gt; %s (%s) to group -&gt; %s (%s)\",\nuser[\"name\"],\nuser[\"id\"],\ngroup_name,\ngroup_id,\n)\nresponse = self._otcs.add_group_member(user[\"id\"], group_id)\nif not response:\nsuccess = False\n# for some unclear reason the user is not added to its base group in OTDS\n# so we do this explicitly:\nresponse = self._otds.add_user_to_group(\nuser[\"name\"], user[\"base_group\"]\n)\nif not response:\nsuccess = False\n# Extra OTDS attributes for the user can be provided in \"extra_attributes\"\n# as part of the user payload.\nif \"extra_attributes\" in user:\nextra_attributes = user[\"extra_attributes\"]\nfor extra_attribute in extra_attributes:\nattribute_name = extra_attribute.get(\"name\")\nattribute_value = extra_attribute.get(\"value\")\nif not attribute_name or not attribute_value:\nlogger.error(\n\"User attribute is missing a name or value. Skipping...\"\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Set user attribute -&gt; %s to -&gt; %s\",\nattribute_name,\nattribute_value,\n)\nuser_partition = self._otcs.config()[\"partition\"]\nif not user_partition:\nlogger.error(\"User partition not found!\")\nsuccess = False\ncontinue\nself._otds.update_user(\nuser_partition,\nuser[\"name\"],\nattribute_name,\nattribute_value,\n)\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_users_m365","title":"<code>process_users_m365(section_name='usersM365')</code>","text":"<p>Process users in payload and create them in Microsoft 365 via MS Graph API.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'usersM365'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_users_m365(self, section_name: str = \"usersM365\") -&gt; bool:\n\"\"\"Process users in payload and create them in Microsoft 365 via MS Graph API.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not isinstance(self._m365, M365):\nlogger.error(\n\"Office 365 connection not setup properly. Skipping payload section -&gt; %s...\",\nsection_name,\n)\nreturn False\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\n# Add all users in payload and establish membership in\n# specified groups:\nfor user in self._users:\n# Sanity checks:\nif not \"name\" in user:\nlogger.error(\"User is missing a login. Skipping to next user...\")\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\nif not \"enable_o365\" in user or not user[\"enable_o365\"]:\nlogger.info(\n\"Microsoft 365 is not enabled in payload for User -&gt; %s. Skipping...\",\nuser_name,\n)\ncontinue\n# Sanity checks:\nif not \"password\" in user:\nlogger.error(\n\"User -&gt; %s is missing a password. Skipping to next user...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser_password = user[\"password\"]\n# be careful with the following fields - they could be empty\nuser_department = user.get(\"base_group\", \"\")\nuser_first_name = user.get(\"firstname\", \"\")\nuser_last_name = user.get(\"lastname\", \"\")\nuser_location = user.get(\"location\", \"US\")\nuser_email = user.get(\"email\", user_name)\n# Check if the user does already exist in M365 (e.g. if job is restarted)\nm365_user_id = self.determine_user_id_m365(user)\nif not m365_user_id:\nlogger.info(\n\"Did not find existing Micosoft 365 user - creating user %s...\",\nuser_email,\n)\n# Now we know it is a new user...\nnew_user = self._m365.add_user(\nemail=user_email,\npassword=user_password,\nfirst_name=user_first_name,\nlast_name=user_last_name,\nlocation=user_location,\ndepartment=user_department,\n)\nif new_user is not None:\n# Store the Microsoft 365 user ID in payload:\nuser[\"m365_id\"] = new_user[\"id\"]\nlogger.info(\n\"New Microsoft 365 user -&gt; %s with ID -&gt; %s has been created\",\nuser_name,\nuser[\"m365_id\"],\n)\nelse:\nlogger.error(\n\"Failed to create new Microsoft 365 user -&gt; %s. Skipping...\",\nuser_name,\n)\nsuccess = False\ncontinue\n# Now we assign a license to the new M365 user.\n# First we see if there's a M365 SKU list in user\n# payload - if not we wrap the default SKU configured\n# for the m365 object into a single item list:\nexisting_user_licenses = self._m365.get_user_licenses(user[\"m365_id\"])\nsku_list = user.get(\"m365_skus\", [self._m365.config()[\"skuId\"]])\nfor sku_id in sku_list:\n# Check if the M365 user already has this license:\nif not self._m365.exist_result_item(\nexisting_user_licenses, \"skuId\", sku_id\n):\nresponse = self._m365.assign_license_to_user(\nuser[\"m365_id\"], sku_id\n)\nif not response:\nlogger.error(\n\"Failed to assign license -&gt; %s to Microsoft 365 user -&gt; %s\",\nsku_id,\nuser_name,\n)\nsuccess = False\nelse:\nif (\nnot \"m365_skus\" in user\n):  # this is only True if the default license from the m365 object is taken\nuser[\"m365_skus\"] = [sku_id]\nlogger.info(\n\"License -&gt; %s has been assigned to Microsoft 365 user -&gt; %s\",\nsku_id,\nuser_name,\n)\nelse:\nlogger.info(\n\"Microsoft 365 user -&gt; %s already has the license -&gt; %s\",\nuser_name,\nsku_id,\n)\n# Now we assign the Extended ECM Teams App to the new M365 user.\n# First we check if the app is already assigned to the user.\n# If not we install / assign the app. If the user already has\n# the Extended ECM app we try to uprade it:\napp_name = self._m365.config()[\"teamsAppName\"]\nresponse = self._m365.get_teams_apps_of_user(\nuser[\"m365_id\"],\nf\"contains(teamsAppDefinition/displayName, '{app_name}')\",\n)\nif self._m365.exist_result_item(\nresponse, \"displayName\", app_name, sub_dict_name=\"teamsAppDefinition\"\n):\nlogger.info(\n\"App -&gt; %s is already installed for M365 user -&gt; %s (%s). Trying to upgrade app...\",\napp_name,\nuser_name,\nuser[\"m365_id\"],\n)\nresponse = self._m365.upgrade_teams_app_of_user(\nuser[\"m365_id\"], app_name\n)\nelse:\nlogger.info(\n\"Install M365 Teams app -&gt; %s for M365 user -&gt; %s\",\napp_name,\nuser_name,\n)\nresponse = self._m365.assign_teams_app_to_user(\nuser[\"m365_id\"], app_name\n)\nif not response:\nlogger.error(\n\"Failed to install the App -&gt; %s for M365 user -&gt; %s\",\napp_name,\nuser_name,\n)\nsuccess = False\ncontinue\n# Process Microsoft 365 group memberships of new user:\nif \"m365_id\" in user:\nuser_id = user[\"m365_id\"]\n# don't forget the base group (department) !\ngroup_names = user[\"groups\"]\nif user_department:\ngroup_names.append(user_department)\nlogger.info(\n\"User -&gt; %s has these groups in payload -&gt; %s (including base group -&gt; %s). Checking if they are Microsoft 365 Groups...\",\nuser_name,\ngroup_names,\nuser_department,\n)\n# Go through all group names:\nfor group_name in group_names:\n# Find the group payload item to the parent group name:\ngroup = next(\n(item for item in self._groups if item[\"name\"] == group_name),\nNone,\n)\nif not group:\n# if group is not in payload then this membership\n# is not relevant for Microsoft 365. This could be system generated\n# groups like \"PageEdit\" or \"Business Administrators\".\n# In this case we do \"continue\" as we can't process parent groups\n# either:\nlogger.info(\n\"No payload found for Group -&gt; %s. Skipping...\", group_name\n)\ncontinue\nelif not \"enable_o365\" in group or not group[\"enable_o365\"]:\n# If Microsoft 365 is not enabled for this group in\n# the payload we don't create a M365 but we do NOT continue\n# as there may still be parent groups that are M365 enabled\n# we want to put the user in (see below):\nlogger.info(\n\"Payload Group -&gt; %s is not enabled for M365.\", group_name\n)\nelse:\nresponse = self._m365.get_group(group_name)\nif (\nresponse is None\nor not \"value\" in response\nor not response[\"value\"]\n):\nlogger.error(\n\"Microsoft 365 Group -&gt; %s not found. Skipping...\",\ngroup_name,\n)\nsuccess = False\nelse:\ngroup_id = response[\"value\"][0][\"id\"]\n# Check if user is already a member. We don't want\n# to throw an error if the user is not found as a member\n# so we pass show_error=False:\nif self._m365.is_member(\ngroup_id, user_id, show_error=False\n):\nlogger.info(\n\"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nelse:\nlogger.info(\n\"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nresponse = self._m365.add_group_member(\ngroup_id, user_id\n)\nif not response:\nlogger.error(\n\"Failed to add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nsuccess = False\n# As each group should have at least one owner in M365\n# we set all users also as owners for now. Later we\n# may want to configure this via payload:\nlogger.info(\n\"Make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nresponse = self._m365.add_group_owner(group_id, user_id)\nif not response:\nlogger.error(\n\"Failed to make Microsoft 365 user -&gt; %s (%s) owner of Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\ngroup_name,\ngroup_id,\n)\nsuccess = False\n# As M365 groups are flat (not nested) we also add the\n# user as member to the parent groups of the current group\n# if the parent group is enabled for M365:\nparent_group_names = group.get(\"parent_groups\")\nlogger.info(\n\"Group -&gt; %s has the following parent groups -&gt; %s\",\ngroup_name,\nparent_group_names,\n)\nfor parent_group_name in parent_group_names:\n# Find the group dictionary item to the parent group name:\nparent_group = next(\n(\nitem\nfor item in self._groups\nif item[\"name\"] == parent_group_name\n),\nNone,\n)\nif (\nparent_group is None\nor not \"enable_o365\" in parent_group\nor not parent_group[\"enable_o365\"]\n):\n# if parent group is not in payload then this membership\n# is not relevant for Microsoft 365.\n# If Office 365 is not enabled for this parent group in\n# the payload we can also skip:\nlogger.info(\n\"Parent Group -&gt; %s is not enabled for M365. Skipping...\",\ngroup_name,\n)\ncontinue\nresponse = self._m365.get_group(parent_group_name)\nif (\nresponse is None\nor not \"value\" in response\nor not response[\"value\"]\n):\nlogger.error(\n\"Microsoft 365 Group -&gt; %s not found. Skipping...\",\ngroup_name,\n)\nsuccess = False\ncontinue\nparent_group_id = response[\"value\"][0][\"id\"]\n# Check if user is already a member. We don't want\n# to throw an error if the user is not found as a member:\nif self._m365.is_member(\nparent_group_id, user_id, show_error=False\n):\nlogger.info(\n\"Microsoft 365 user -&gt; %s (%s) is already in Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\nparent_group_name,\nparent_group_id,\n)\ncontinue\nlogger.info(\n\"Add Microsoft 365 user -&gt; %s (%s) to Microsoft 365 group -&gt; %s (%s)\",\nuser[\"name\"],\nuser_id,\nparent_group_name,\nparent_group_id,\n)\nself._m365.add_group_member(parent_group_id, user_id)\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_users_sap","title":"<code>process_users_sap(sap_object, section_name='usersSAP')</code>","text":"<p>Process users in payload and sync them with SAP (passwords for now).</p> <p>Parameters:</p> Name Type Description Default <code>sap_object</code> <code>SAP</code> <p>SAP object</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'usersSAP'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Side Effects <p>the user items are modified by adding an \"id\" dict element that includes the technical ID of the user in Extended ECM</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_users_sap(\nself, sap_object: SAP, section_name: str = \"usersSAP\"\n) -&gt; bool:\n\"\"\"Process users in payload and sync them with SAP (passwords for now).\n    Args:\n        sap_object (SAP): SAP object\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        the user items are modified by adding an \"id\" dict element that\n        includes the technical ID of the user in Extended ECM\n    \"\"\"\nif not self._users:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nrfc_name = \"ZFM_TERRA_RFC_CHNG_USR_PW\"\nrfc_description = \"RFC to update the SAP user password\"\nrfc_call_options = ()\n# Add all users in payload and establish membership in\n# specified groups:\nfor user in self._users:\n# Sanity checks:\nif not \"name\" in user:\nlogger.error(\"User is missing a login. Skipping to next user...\")\nsuccess = False\ncontinue\nuser_name = user[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in user and not user[\"enabled\"]:\nlogger.info(\n\"Payload for User -&gt; %s is disabled. Skipping...\", user_name\n)\ncontinue\n# Check if the user is enabled for SAP:\nif not \"enable_sap\" in user or not user[\"enable_sap\"]:\nlogger.info(\"User -&gt; %s is not enabled for SAP. Skipping...\", user_name)\ncontinue\n# Sanity checks:\nif not \"password\" in user:\nlogger.error(\n\"User -&gt; %s is missing a password. Cannot sync with SAP. Skipping to next user...\",\nuser_name,\n)\nsuccess = False\ncontinue\nuser_password = user[\"password\"]\nrfc_params = {\n\"USERNAME\": user_name,\n\"PASSWORD\": user_password,\n}\nlogger.info(\n\"Updating password of user -&gt; %s in SAP. Calling SAP RFC -&gt; %s (%s) with parameters -&gt; %s ...\",\nuser_name,\nrfc_name,\nrfc_description,\nrfc_params,\n)\nresult = sap_object.call(rfc_name, rfc_call_options, rfc_params)\nif result is None:\nlogger.error(\n\"Failed to call SAP RFC -&gt; %s to update password of user -&gt; %s\",\nrfc_name,\nuser_name,\n)\nsuccess = False\nelif result.get(\"RESULT\") != \"OK\":\nlogger.error(\n\"Result of SAP RFC -&gt; %s is not OK, it returned -&gt; %s failed items in result -&gt; %s\",\nrfc_name,\nstr(result.get(\"FAILED\")),\nstr(result),\n)\nsuccess = False\n# Save result for status file content\nuser[\"sap_sync_result\"] = result\nelse:\nlogger.info(\n\"Successfully called RFC -&gt; %s. Result -&gt; %s\", rfc_name, str(result)\n)\n# Save result for status file content\nuser[\"sap_sync_result\"] = result\nself.write_status_file(success, section_name, self._users)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_web_hooks","title":"<code>process_web_hooks(webhooks, section_name='webHooks')</code>","text":"<p>Process Web Hooks in payload and do HTTP requests.</p> <p>Parameters:</p> Name Type Description Default <code>webhooks</code> <code>list</code> <p>list of web hook payload settings</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webHooksPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'webHooks'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_web_hooks(self, webhooks: list, section_name: str = \"webHooks\") -&gt; bool:\n\"\"\"Process Web Hooks in payload and do HTTP requests.\n    Args:\n        webhooks (list): list of web hook payload settings\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webHooksPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not webhooks:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\n# WE LET THIS RUN EACH TIME!\n#        if self.check_status_file(section_name):\n#            return True\nsuccess: bool = True\nfor webhook in webhooks:\nurl = webhook.get(\"url\")\nif not url:\nlogger.info(\"Web Hook does not have a url. Skipping...\")\nsuccess = False\ncontinue\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in webhook and not webhook[\"enabled\"]:\nlogger.info(\"Payload for Web Hook -&gt; %s is disabled. Skipping...\", url)\ncontinue\ndescription = webhook.get(\"description\")\nmethod = webhook.get(\"method\", \"POST\")\npayload = webhook.get(\"payload\", {})\nheaders = webhook.get(\"headers\", {})\nif description:\nlogger.info(\"Calling Web Hook -&gt; %s: %s (%s)\", method, url, description)\nelse:\nlogger.info(\"Calling Web Hook -&gt; %s: %s\", method, url)\nresponse = self._http_object.http_request(url, method, payload, headers)\nif not response or not response.ok:\nsuccess = False\nself.write_status_file(success, section_name, webhooks)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_web_reports","title":"<code>process_web_reports(web_reports, section_name='webReports')</code>","text":"<p>Process web reports in payload and run them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>web_reports</code> <code>list</code> <p>list of web reports. As we have two different list (pre and post)                 we need to pass the actual list as parameter.</p> required <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"webReportsPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'webReports'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_web_reports(\nself, web_reports: list, section_name: str = \"webReports\"\n) -&gt; bool:\n\"\"\"Process web reports in payload and run them in Extended ECM.\n    Args:\n        web_reports (list): list of web reports. As we have two different list (pre and post)\n                            we need to pass the actual list as parameter.\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"webReportsPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not web_reports:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor web_report in web_reports:\nnick_name = web_report[\"nickname\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in web_report and not web_report[\"enabled\"]:\nlogger.info(\n\"Payload for Web Report -&gt; %s is disabled. Skipping...\", nick_name\n)\ncontinue\ndescription = web_report[\"description\"]\nif not self._otcs.get_node_from_nickname(nick_name):\nlogger.error(\n\"Web Report with nickname -&gt; %s does not exist! Skipping...\",\nnick_name,\n)\nsuccess = False\ncontinue\n# be careful to avoid key errors as Web Report parameters are optional:\nactual_params = (\nweb_report[\"parameters\"] if web_report.get(\"parameters\") else {}\n)\nformal_params = self._otcs.get_web_report_parameters(nick_name)\nif actual_params:\nlogger.info(\n\"Running Web Report -&gt; %s (%s) with parameters -&gt; %s ...\",\nnick_name,\ndescription,\nactual_params,\n)\n# Do some sanity checks to see if the formal and actual parameters are matching...\n# Check 1: are there formal parameters at all?\nif not formal_params:\nlogger.error(\n\"Web Report -&gt; %s is called with actual parameters but it does not expect parameters! Skipping...\",\nnick_name,\n)\nsuccess = False\ncontinue\nlets_continue = False\n# Check 2: Iterate through the actual parameters given in the payload\n# and see if there's a matching formal parameter expected by the Web Report:\nfor key, value in actual_params.items():\n# Check if there's a matching formal parameter defined on the Web Report node:\nformal_param = next(\n(item for item in formal_params if item[\"parm_name\"] == key),\nNone,\n)\nif formal_param is None:\nlogger.error(\n\"Web Report -&gt; %s is called with parameter -&gt; %s that is not expected! Value: %s) Skipping...\",\nnick_name,\nkey,\nvalue,\n)\nsuccess = False\nlets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n# Check 3: Iterate through the formal parameters and validate there's a matching\n# actual parameter defined in the payload for each mandatory formal parameter\n# that does not have a default value:\nfor formal_param in formal_params:\nif (\n(formal_param[\"mandatory\"] is True)\nand (formal_param[\"default_value\"] is None)\nand not actual_params.get(formal_param[\"parm_name\"])\n):\nlogger.error(\n\"Web Report -&gt; %s is called without mandatory parameter -&gt; %s! Skipping...\",\nnick_name,\nformal_param[\"parm_name\"],\n)\nsuccess = False\nlets_continue = True  # we cannot do a \"continue\" here directly as we are in an inner loop\n# Did any of the checks fail?\nif lets_continue:\ncontinue\n# Actual parameters are validated, we can run the Web Report:\nresponse = self._otcs.run_web_report(nick_name, actual_params)\nelse:\nlogger.info(\n\"Running Web Report -&gt; %s (%s) without parameters...\",\nnick_name,\ndescription,\n)\n# Check if there's a formal parameter that is mandatory but\n# does not have a default value:\nif formal_params:\nrequired_param = next(\n(\nitem\nfor item in formal_params\nif (item[\"mandatory\"] is True)\nand (not item[\"default_value\"])\n),\nNone,\n)\nif required_param:\nlogger.error(\n\"Web Report -&gt; %s is called without parameters but has a mandatory parameter -&gt; %s without a default value! Skipping...\",\nnick_name,\nrequired_param[\"parm_name\"],\n)\nsuccess = False\ncontinue\nelse:  # we are good to proceed!\nlogger.debug(\n\"Web Report -&gt; %s does not have a mandatory parameter without a default value!\",\nnick_name,\n)\nresponse = self._otcs.run_web_report(nick_name)\nif response is None:\nlogger.error(\"Failed to run web report -&gt; %s\", nick_name)\nsuccess = False\nself.write_status_file(success, section_name, web_reports)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_aviators","title":"<code>process_workspace_aviators(section_name='workspaceAviators')</code>","text":"<p>Process workspaces Content Aviator settings in payload and enable Aviator for selected workspaces.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceAviators'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_aviators(\nself, section_name: str = \"workspaceAviators\"\n) -&gt; bool:\n\"\"\"Process workspaces Content Aviator settings in payload and enable Aviator for selected workspaces.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload (just for logging):\nif not \"name\" in workspace:\ncontinue\nworkspace_name = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\",\nworkspace_name,\n)\ncontinue\n# Read Aviator setting from payload:\nif not \"enable_aviator\" in workspace or not workspace[\"enable_aviator\"]:\nlogger.info(\n\"Aviator is not enabled for Workspace -&gt; %s. Skipping to next workspace...\",\nworkspace_name,\n)\ncontinue\n# We cannot just lookup with workspace.get(\"nodeId\") as the customizer\n# may have been restarted inbetween - so we use our proper determine_workspace_id\n# here...\nworkspace_id = self.determine_workspace_id(workspace)\nif not workspace_id:\nlogger.error(\n\"Cannot find node ID for workspace -&gt; %s. Workspace creation may have failed. Skipping to next workspace...\",\nworkspace_name,\n)\nsuccess = False\ncontinue\n# Make code idem-potent and check if Aviator is already enabled\n# for this workspace:\nif self._otcs.check_workspace_aviator(workspace_id=workspace_id):\nlogger.info(\n\"Skip workspace -&gt; %s (%s) as Aviator is already enabled...\",\nworkspace_name,\nworkspace_id,\n)\ncontinue\n# Now enable the Content Aviator for the workspace:\nresponse = self._otcs.update_workspace_aviator(workspace_id, True)\nif not response:\nlogger.error(\n\"Failed to enable Content Aviator for workspace -&gt; %s (%s)\",\nworkspace_name,\nworkspace_id,\n)\nsuccess = False\ncontinue\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_members","title":"<code>process_workspace_members(section_name='workspaceMembers')</code>","text":"<p>Process workspaces members in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections)                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceMembers'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_members(self, section_name: str = \"workspaceMembers\") -&gt; bool:\n\"\"\"Process workspaces members in payload and create them in Extended ECM.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections)\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload (just for logging):\nif not \"name\" in workspace:\ncontinue\nworkspace_name = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\",\nworkspace_name,\n)\ncontinue\n# Read members from payload:\nif not \"members\" in workspace:\nlogger.info(\n\"Workspace -&gt; %s has no members in payload. Skipping to next workspace...\",\nworkspace_name,\n)\ncontinue\nmembers = workspace[\"members\"]\nworkspace_id = workspace[\"id\"]\nlogger.info(\n\"Workspace -&gt; %s has memberships in payload - establishing...\",\nworkspace_name,\n)\nworkspace_node_id = int(self.determine_workspace_id(workspace))\nif not workspace_node_id:\nlogger.warning(\n\"Workspace without node ID cannot have members (workspaces creation may have failed). Skipping to next workspace...\"\n)\ncontinue\n# now determine the actual node IDs of the workspaces (have been created by process_workspaces()):\nworkspace_node = self._otcs.get_node(workspace_node_id)\nworkspace_owner_id = self._otcs.get_result_value(\nworkspace_node, \"owner_user_id\"\n)\nworkspace_owner_name = self._otcs.get_result_value(workspace_node, \"owner\")\nworkspace_roles = self._otcs.get_workspace_roles(workspace_node_id)\nif workspace_roles is None:\nlogger.info(\n\"Workspace with ID -&gt; %s and node Id -&gt; %s has no roles. Skipping to next workspace...\",\nworkspace_id,\nworkspace_node_id,\n)\ncontinue\n# We don't want the workspace creator to be in the leader role\n# of automatically created workspaces - this can happen because the\n# creator gets added to the leader role automatically:\nleader_role_id = self._otcs.lookup_result_value(\nworkspace_roles, \"leader\", True, \"id\"\n)\nif leader_role_id:\nleader_role_name = self._otcs.lookup_result_value(\nworkspace_roles, \"leader\", True, \"name\"\n)\nresponse = self._otcs.remove_member_from_workspace(\nworkspace_node_id, leader_role_id, workspace_owner_id, False\n)\nif response:\nlogger.info(\n\"Removed creator user -&gt; %s (%s) from leader role -&gt; {%s (%s) of workspace -&gt; %s\",\nworkspace_owner_name,\nworkspace_owner_id,\nleader_role_name,\nleader_role_id,\nworkspace_name,\n)\nlogger.info(\n\"Adding members to workspace with ID -&gt; %s and node ID -&gt; %s defined in payload...\",\nworkspace_id,\nworkspace_node_id,\n)\nfor member in members:\n# read user list and role name from payload:\nmember_users = (\nmember[\"users\"] if member.get(\"users\") else []\n)  # be careful to avoid key errors as users are optional\nmember_groups = (\nmember[\"groups\"] if member.get(\"groups\") else []\n)  # be careful to avoid key errors as groups are optional\nmember_role_name = member[\"role\"]\nif member_role_name == \"\":  # role name is required\nlogger.error(\n\"Members of workspace -&gt; %s is missing the role name.\",\nworkspace_name,\n)\nsuccess = False\ncontinue\nif (\nmember_users == [] and member_groups == []\n):  # we either need users or groups (or both)\nlogger.warning(\n\"Role -&gt; %s of workspace -&gt; %s does not have any members (no users nor groups).\",\nmember_role_name,\nworkspace_name,\n)\ncontinue\nrole_id = self._otcs.lookup_result_value(\nworkspace_roles, \"name\", member_role_name, \"id\"\n)\nif role_id is None:\n#    if member_role is None:\nlogger.error(\n\"Workspace -&gt; %s does not have a role with name -&gt; %s\",\nworkspace_name,\nmember_role_name,\n)\nsuccess = False\ncontinue\nlogger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n# Process users as workspaces members:\nfor member_user in member_users:\n# find member user in current payload:\nmember_user_id = next(\n(item for item in self._users if item[\"name\"] == member_user),\n{},\n)\nif member_user_id:\nuser_id = member_user_id[\"id\"]\nelse:\n# If this didn't work, try to get the member user from OTCS. This covers\n# cases where the user is system generated or part\n# of a former payload processing (thus not in the current payload):\nlogger.info(\n\"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\nmember_user,\n)\nresponse = self._otcs.get_user(member_user)\nuser_id = self._otcs.lookup_result_value(\nresponse, key=\"name\", value=member_user, return_key=\"id\"\n)\nif not user_id:\nlogger.error(\n\"Cannot find member user with login -&gt; %s. Skipping...\",\nmember_user,\n)\ncontinue\n# Add member if it does not yet exists - suppress warning\n# message if user is already in role:\nresponse = self._otcs.add_member_to_workspace(\nworkspace_node_id, int(role_id), user_id, False\n)\nif response is None:\nlogger.error(\n\"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_user,\nuser_id,\nmember_role_name,\nworkspace_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_user,  # member_user_id[\"name\"],\nuser_id,\nmember_role_name,\nworkspace_name,\n)\n# Process groups as workspaces members:\nfor member_group in member_groups:\nmember_group_id = next(\n(item for item in self._groups if item[\"name\"] == member_group),\nNone,\n)\nif member_group_id is None:\nlogger.error(\"Cannot find group with name -&gt; %s\", member_group)\nsuccess = False\ncontinue\ngroup_id = member_group_id[\"id\"]\nresponse = self._otcs.add_member_to_workspace(\nworkspace_node_id, int(role_id), group_id\n)\nif response is None:\nlogger.error(\n\"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\nworkspace_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\nworkspace_name,\n)\n# Optionally the payload may have a permission list for the role\n# to change the default permission from the workspace template\n# to something more specific:\nmember_permissions = member.get(\"permissions\", [])\nif member_permissions == []:\nlogger.info(\n\"No permission change for workspace -&gt; %s and role -&gt; %s.\",\nworkspace_name,\nmember_role_name,\n)\ncontinue\nlogger.info(\n\"Update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s\",\nworkspace_name,\nstr(workspace_node_id),\nmember_role_name,\nstr(member_permissions),\n)\nresponse = self._otcs.assign_permission(\nnode_id=workspace_node_id,\nassignee_type=\"custom\",\nassignee=role_id,\npermissions=member_permissions,\napply_to=2,\n)\nif not response:\nlogger.error(\n\"Failed to update permissions of workspace -&gt; %s (%s) and role -&gt; %s to -&gt; %s.\",\nworkspace_name,\nstr(workspace_node_id),\nmember_role_name,\nstr(member_permissions),\n)\nsuccess = False\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_relationships","title":"<code>process_workspace_relationships(section_name='workspaceRelationships')</code>","text":"<p>Process workspaces relationships in payload and create them in Extended ECM.</p> <p>Relationships can only be created if all workspaces have been created before. Once a workspace got created, the node ID of that workspaces has been added to the payload[\"workspaces\"] data structure (see process_workspaces()) Relationships are created between the node IDs of two business workspaces (and not the logical IDs in the inital payload specification)</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceRelationships'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_relationships(\nself, section_name: str = \"workspaceRelationships\"\n) -&gt; bool:\n\"\"\"Process workspaces relationships in payload and create them in Extended ECM.\n    Relationships can only be created if all workspaces have been created before.\n    Once a workspace got created, the node ID of that workspaces has been added\n    to the payload[\"workspaces\"] data structure (see process_workspaces())\n    Relationships are created between the node IDs of two business workspaces\n    (and not the logical IDs in the inital payload specification)\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload:\nif not \"name\" in workspace:\ncontinue\nname = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n)\ncontinue\n# Read relationships from payload:\nif not \"relationships\" in workspace:\nlogger.info(\n\"Workspace -&gt; %s has no relationships. Skipping to next workspace...\",\nname,\n)\ncontinue\n# Check that workspaces actually have a logical ID -\n# otherwise we cannot establish the relationship:\nif not \"id\" in workspace:\nlogger.warning(\n\"Workspace without ID cannot have a relationship. Skipping to next workspace...\"\n)\ncontinue\nworkspace_id = workspace[\"id\"]\nlogger.info(\"Workspace -&gt; %s has relationships - creating...\", name)\nworkspace_node_id = self.determine_workspace_id(workspace)\nif not workspace_node_id:\nlogger.warning(\n\"Workspace without node ID cannot have a relationship (workspace creation may have failed). Skipping to next workspace...\"\n)\ncontinue\n# now determine the actual node IDs of the workspaces (have been created above):\nlogger.info(\n\"Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\nworkspace_id,\nworkspace_node_id,\n)\nfor related_workspace_id in workspace[\"relationships\"]:\n# Find the workspace type with the name given in the payload:\nrelated_workspace = next(\n(\nitem\nfor item in self._workspaces\nif item[\"id\"] == related_workspace_id\n),\nNone,\n)\nif related_workspace is None:\nlogger.error(\n\"Related Workspace with logical ID -&gt; %s not found.\",\nrelated_workspace_id,\n)\nsuccess = False\ncontinue\nif \"enabled\" in related_workspace and not related_workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Related Workspace -&gt; %s is disabled. Skipping...\",\nrelated_workspace[\"name\"],\n)\ncontinue\nrelated_workspace_node_id = self.determine_workspace_id(\nrelated_workspace\n)\nif not related_workspace_node_id:\nlogger.warning(\n\"Related Workspace without node ID (workspaces creation may have failed). Skipping to next workspace...\"\n)\ncontinue\nlogger.info(\n\"Related Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\nrelated_workspace_id,\nrelated_workspace_node_id,\n)\nlogger.info(\n\"Create Workspace Relationship between workspace node ID -&gt; %s and workspace node ID -&gt; %s\",\nworkspace_node_id,\nrelated_workspace_node_id,\n)\n# Check if relationship does already exists:\nresponse = self._otcs.get_workspace_relationships(workspace_node_id)\nexisting_workspace_relationship = self._otcs.exist_result_item(\nresponse, \"id\", related_workspace_node_id\n)\nif existing_workspace_relationship:\nlogger.info(\n\"Workspace relationship between workspace ID -&gt; %s and related workspace ID -&gt; %s does already exist. Skipping...\",\nworkspace_node_id,\nrelated_workspace_node_id,\n)\ncontinue\nresponse = self._otcs.create_workspace_relationship(\nworkspace_node_id, related_workspace_node_id\n)\nif not response:\nlogger.error(\"Failed to create workspace relationship.\")\nsuccess = False\nelse:\nlogger.info(\"Successfully created workspace relationship.\")\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_templates","title":"<code>process_workspace_templates(section_name='workspaceTemplates')</code>","text":"<p>Process Workspace Template playload. This allows to define role members on    template basis. This avoids having to \"pollute\" workspace template templates    with user or group information and instead controls this via payload.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceTemplates'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_templates(\nself, section_name: str = \"workspaceTemplates\"\n) -&gt; bool:\n\"\"\"Process Workspace Template playload. This allows to define role members on\n       template basis. This avoids having to \"pollute\" workspace template templates\n       with user or group information and instead controls this via payload.\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    \"\"\"\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace_template in self._workspace_templates:\n# Read Workspace Type Name from payload:\nif not \"type_name\" in workspace_template:\nlogger.error(\n\"Workspace template needs a type name! Skipping to next workspace template...\",\n)\nsuccess = False\ncontinue\ntype_name = workspace_template[\"type_name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace_template and not workspace_template[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace Template -&gt; %s is disabled. Skipping to next workspace template...\",\ntype_name,\n)\ncontinue\n# Read Workspace Template Name from payload:\nif not \"template_name\" in workspace_template:\nlogger.error(\n\"Workspace Template for Workspace Type -&gt; %s needs a template name! Skipping to next workspace template...\",\ntype_name,\n)\nsuccess = False\ncontinue\ntemplate_name = workspace_template[\"template_name\"]\n# Read members from payload:\nif not \"members\" in workspace_template:\nlogger.info(\n\"Workspace template with type -&gt; %s and name -&gt; %s has no members in payload. Skipping to next workspace...\",\ntype_name,\ntemplate_name,\n)\ncontinue\nmembers = workspace_template[\"members\"]\n# Find the workspace type with the name given in the _workspace_types\n# datastructure that has been generated by process_workspace_type() method before:\nworkspace_type = next(\n(item for item in self._workspace_types if item[\"name\"] == type_name),\nNone,\n)\nif workspace_type is None:\nlogger.error(\n\"Workspace Type -&gt; %s not found. Skipping to next workspace template...\",\ntype_name,\n)\nsuccess = False\ncontinue\nif workspace_type[\"templates\"] == []:\nlogger.error(\n\"Workspace Type -&gt; %s does not have templates. Skipping to next workspace template...\",\ntype_name,\n)\nsuccess = False\ncontinue\nworkspace_template = next(\n(\nitem\nfor item in workspace_type[\"templates\"]\nif item[\"name\"] == template_name\n),\nNone,\n)\nif workspace_template:  # does this template exist?\nlogger.info(\n\"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\ntemplate_name,\n)\nelse:\nlogger.error(\n\"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\ntemplate_name,\n)\nlogger.error(\n\"Workspace Type -&gt; %s has only these templates -&gt; %s\",\ntype_name,\nworkspace_type[\"templates\"],\n)\nsuccess = False\ncontinue\ntemplate_id = workspace_template[\"id\"]\nworkspace_roles = self._otcs.get_workspace_roles(template_id)\nif workspace_roles is None:\nlogger.info(\n\"Workspace Template %s with node Id -&gt; %s has no roles. Skipping to next workspace...\",\ntemplate_name,\ntemplate_id,\n)\ncontinue\nfor member in members:\n# read user list and role name from payload:\nmember_users = (\nmember[\"users\"] if member.get(\"users\") else []\n)  # be careful to avoid key errors as users are optional\nmember_groups = (\nmember[\"groups\"] if member.get(\"groups\") else []\n)  # be careful to avoid key errors as groups are optional\nmember_role_name = member[\"role\"]\nif member_role_name == \"\":  # role name is required\nlogger.error(\n\"Members of workspace template -&gt; %s is missing the role name.\",\ntemplate_name,\n)\nsuccess = False\ncontinue\nif (\nmember_users == [] and member_groups == []\n):  # we either need users or groups (or both)\nlogger.warning(\n\"Role -&gt; %s of workspace template -&gt; %s does not have any members (no users nor groups).\",\nmember_role_name,\ntemplate_name,\n)\ncontinue\nrole_id = self._otcs.lookup_result_value(\nworkspace_roles, \"name\", member_role_name, \"id\"\n)\nif role_id is None:\n#    if member_role is None:\nlogger.error(\n\"Workspace template -&gt; %s does not have a role with name -&gt; %s\",\ntemplate_name,\nmember_role_name,\n)\nsuccess = False\ncontinue\nlogger.info(\"Role -&gt; %s has ID -&gt; %s\", member_role_name, role_id)\n# Process users as workspace template members:\nfor member_user in member_users:\n# find member user in current payload:\nmember_user_id = next(\n(item for item in self._users if item[\"name\"] == member_user),\n{},\n)\nif member_user_id:\nuser_id = member_user_id[\"id\"]\nelse:\n# If this didn't work, try to get the member user from OTCS. This covers\n# cases where the user is system generated or part\n# of a former payload processing (thus not in the current payload):\nlogger.info(\n\"Member -&gt; %s not found in current payload - check if it exists in OTCS already...\",\nmember_user,\n)\nresponse = self._otcs.get_user(member_user)\nuser_id = self._otcs.lookup_result_value(\nresponse, key=\"name\", value=member_user, return_key=\"id\"\n)\nif not user_id:\nlogger.error(\n\"Cannot find member user with login -&gt; %s. Skipping...\",\nmember_user,\n)\nsuccess = False\ncontinue\n# Add member if it does not yet exists - suppress warning\n# message if user is already in role:\nresponse = self._otcs.add_member_to_workspace(\ntemplate_id, int(role_id), user_id, False\n)\nif response is None:\nlogger.error(\n\"Failed to add user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_user,\nuser_id,\nmember_role_name,\ntemplate_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added user -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_user,\nuser_id,\nmember_role_name,\ntemplate_name,\n)\n# Process groups as workspace template members:\nfor member_group in member_groups:\nmember_group_id = next(\n(item for item in self._groups if item[\"name\"] == member_group),\nNone,\n)\nif member_group_id is None:\nlogger.error(\"Cannot find group with name -&gt; %s\", member_group)\nsuccess = False\ncontinue\ngroup_id = member_group_id[\"id\"]\nresponse = self._otcs.add_member_to_workspace(\ntemplate_id, int(role_id), group_id\n)\nif response is None:\nlogger.error(\n\"Failed to add group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\ntemplate_name,\n)\nsuccess = False\nelse:\nlogger.info(\n\"Successfully added group -&gt; %s (%s) to role -&gt; %s of workspace template -&gt; %s\",\nmember_group_id[\"name\"],\ngroup_id,\nmember_role_name,\ntemplate_name,\n)\nself.write_status_file(success, section_name, self._workspace_types)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspace_types","title":"<code>process_workspace_types(section_name='workspaceTypes')</code>","text":"<p>Create a data structure for all workspace types in the Extended ECM system.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section.                           This name is used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaceTypes'</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of workspace types. Each list element is a dict with these values: - id (str) - name (str) - templates (list)     + name (str)     + id</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspace_types(self, section_name: str = \"workspaceTypes\") -&gt; list:\n\"\"\"Create a data structure for all workspace types in the Extended ECM system.\n    Args:\n        section_name (str, optional): name of the section.\n                                      This name is used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        list: list of workspace types. Each list element is a dict with these values:\n            - id (str)\n            - name (str)\n            - templates (list)\n                + name (str)\n                + id\n    \"\"\"\n# If this payload section has been processed successfully before we\n# still need to read the data structure from the status file and\n# initialize self._workspace_types:\nif self.check_status_file(section_name):\n# read the list from the json file in admin Home\n# this is important for restart of customizer pod\n# as this data structure is used later on for workspace processing\nlogger.info(\"Re-Initialize workspace types list for later use...\")\nself._workspace_types = self.get_status_file(section_name)\nreturn self._workspace_types\n# get all workspace types (these have been created by the transports and are not in the payload!):\nresponse = self._otcs.get_workspace_types()\nif response is None:\nlogger.error(\"No workspace types found!\")\nself._workspace_types = []\nelse:\nself._workspace_types = response[\"results\"]\n# now we enrich the workspace_type list elments (which are dicts)\n# with additional dict elements for further processing:\nfor workspace_type in self._workspace_types:\nworkspace_type_id = workspace_type[\"data\"][\"properties\"][\"wksp_type_id\"]\nlogger.info(\"Workspace Types ID -&gt; %s\", workspace_type_id)\nworkspace_type[\"id\"] = workspace_type_id\nworkspace_type_name = workspace_type[\"data\"][\"properties\"][\"wksp_type_name\"]\nlogger.info(\"Workspace Types Name -&gt; %s\", workspace_type_name)\nworkspace_type[\"name\"] = workspace_type_name\nworkspace_templates = workspace_type[\"data\"][\"properties\"][\"templates\"]\n# Create empty lists of dicts with template names and node IDs:\nworkspace_type[\"templates\"] = []\nif workspace_templates:\n# Determine available templates per workspace type (there can be multiple!)\nfor workspace_template in workspace_templates:\nworkspace_template_id = workspace_template[\"id\"]\nworkspace_template_name = workspace_template[\"name\"]\nlogger.info(\n\"Found template with name -&gt; %s and ID -&gt; %s\",\nworkspace_template_name,\nworkspace_template_id,\n)\ntemplate = {\n\"name\": workspace_template_name,\n\"id\": workspace_template_id,\n}\nworkspace_type[\"templates\"].append(template)\n# Workaround for problem with workspace role inheritance\n# which may be related to Transport or REST API: to work-around this we\n# push down the workspace roles to the workspace folders explicitly:\nresponse = self._otcs.get_workspace_roles(workspace_template_id)\nfor roles in response[\"results\"]:\nrole_name = roles[\"data\"][\"properties\"][\"name\"]\nrole_id = roles[\"data\"][\"properties\"][\"id\"]\npermissions = roles[\"data\"][\"properties\"][\"perms\"]\n# as get_workspace_roles() delivers permissions as a value (bit encoded)\n# we need to convert it to a permissions string list:\npermission_string_list = (\nself._otcs.convert_permission_value_to_permission_string(\npermissions\n)\n)\nlogger.info(\n\"Inherit permissions of workspace template -&gt; %s and role -&gt; %s to workspace folders...\",\nworkspace_template_name,\nrole_name,\n)\n# Inherit permissions to folders of workspace template:\nresponse = self._otcs.assign_workspace_permissions(\nworkspace_template_id,\nrole_id,\npermission_string_list,\n1,  # Only sub items - workspace node itself is OK\n)\nelse:\nlogger.warning(\n\"Workspace Types Name -&gt; %s has no templates!\", workspace_type_name\n)\ncontinue\nself.write_status_file(True, section_name, self._workspace_types)\nreturn self._workspace_types\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.process_workspaces","title":"<code>process_workspaces(section_name='workspaces')</code>","text":"<p>Process workspaces in payload and create them in Extended ECM.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>name of the section. It can be overridden                           for cases where multiple sections of same type                           are used (e.g. the \"Post\" sections like \"workspacesPost\")                           This name is also used for the \"success\" status                           files written to the Admin Personal Workspace</p> <code>'workspaces'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payload has been processed without errors, False otherwise</p> Side Effects <p>Set workspace[\"nodeId] to the node ID of the created workspace</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def process_workspaces(self, section_name: str = \"workspaces\") -&gt; bool:\n\"\"\"Process workspaces in payload and create them in Extended ECM.\n    Args:\n        section_name (str, optional): name of the section. It can be overridden\n                                      for cases where multiple sections of same type\n                                      are used (e.g. the \"Post\" sections like \"workspacesPost\")\n                                      This name is also used for the \"success\" status\n                                      files written to the Admin Personal Workspace\n    Returns:\n        bool: True if payload has been processed without errors, False otherwise\n    Side Effects:\n        Set workspace[\"nodeId] to the node ID of the created workspace\n    \"\"\"\nif not self._workspaces:\nlogger.info(\"Payload section -&gt; %s is empty. Skipping...\", section_name)\nreturn True\n# If this payload section has been processed successfully before we\n# can return True and skip processing it once more:\nif self.check_status_file(section_name):\nreturn True\nsuccess: bool = True\nfor workspace in self._workspaces:\n# Read name from payload:\nif not \"name\" in workspace:\nlogger.error(\"Workspace needs a name! Skipping to next workspace...\")\nsuccess = False\ncontinue\nname = workspace[\"name\"]\n# Check if element has been disabled in payload (enabled = false).\n# In this case we skip the element:\nif \"enabled\" in workspace and not workspace[\"enabled\"]:\nlogger.info(\n\"Payload for Workspace -&gt; %s is disabled. Skipping...\", name\n)\ncontinue\n# Read Type Name from payload:\nif not \"type_name\" in workspace:\nlogger.error(\n\"Workspace -&gt; %s needs a type name! Skipping to next workspace...\",\nname,\n)\nsuccess = False\ncontinue\ntype_name = workspace[\"type_name\"]\n# check if the workspace has been created before (effort to make the customizing code idem-potent)\nlogger.info(\n\"Check if workspace -&gt; %s of type -&gt; %s does already exist...\",\nname,\ntype_name,\n)\n# Check if workspace does already exist\n# In case the workspace exists, determine_workspace_id()\n# also stores the node ID into workspace[\"nodeId\"]\nworkspace_id = self.determine_workspace_id(workspace)\nif workspace_id:\nlogger.info(\n\"Workspace -&gt; %s of type -&gt; %s does already exist and has ID -&gt; %s! Skipping to next workspace...\",\nname,\ntype_name,\nworkspace_id,\n)\ncontinue\nlogger.info(\n\"Creating new Workspace -&gt; %s; Workspace Type -&gt; %s...\", name, type_name\n)\n# Read optional description from payload:\nif not \"description\" in workspace:\ndescription = \"\"\nelse:\ndescription = workspace[\"description\"]\n# Parent ID is optional and only required if workspace type does not specify a create location.\n# This is typically the case if it is a nested workspace or workspaces of the same type can be created\n# in different locations in the Enterprise Workspace:\nparent_id = workspace[\"parent_id\"] if workspace.get(\"parent_id\") else None\nif parent_id is not None:\nparent_workspace = next(\n(item for item in self._workspaces if item[\"id\"] == parent_id), None\n)\nif parent_workspace is None:\nlogger.error(\n\"Parent Workspace with logical ID -&gt; %s not found.\", parent_id\n)\nsuccess = False\ncontinue\nparent_workspace_node_id = self.determine_workspace_id(parent_workspace)\nif not parent_workspace_node_id:\nlogger.warning(\n\"Parent Workspace without node ID (parent workspace creation may have failed). Skipping to next workspace...\"\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Parent Workspace with logical ID -&gt; %s has node ID -&gt; %s\",\nparent_id,\nparent_workspace_node_id,\n)\nelse:\n# if no parent_id is specified the workspace location is determined by the workspace type definition\n# and we pass None as parent ID to the get_workspace_create_form and create_workspace methods below:\nparent_workspace_node_id = None\n# Find the workspace type with the name given in the payload:\nworkspace_type = next(\n(item for item in self._workspace_types if item[\"name\"] == type_name),\nNone,\n)\nif workspace_type is None:\nlogger.error(\n\"Workspace Type -&gt; %s not found. Skipping to next workspace...\",\ntype_name,\n)\nsuccess = False\ncontinue\nif workspace_type[\"templates\"] == []:\nlogger.error(\n\"Workspace Type -&gt; %s does not have templates. Skipping to next workspace...\",\ntype_name,\n)\nsuccess = False\ncontinue\n# check if the template to be used is specified in the payload:\nif \"template_name\" in workspace:\ntemplate_name = workspace[\"template_name\"]\nworkspace_template = next(\n(\nitem\nfor item in workspace_type[\"templates\"]\nif item[\"name\"] == template_name\n),\nNone,\n)\nif workspace_template:  # does this template exist?\nlogger.info(\n\"Workspace Template -&gt; %s has been specified in payload and it does exist.\",\ntemplate_name,\n)\nelse:\nlogger.error(\n\"Workspace Template -&gt; %s has been specified in payload but it doesn't exist!\",\ntemplate_name,\n)\nlogger.error(\n\"Workspace Type -&gt; %s has only these templates -&gt; %s\",\ntype_name,\nworkspace_type[\"templates\"],\n)\nsuccess = False\ncontinue\n# template to be used is NOT specified in the payload - then we just take the first one:\nelse:\nworkspace_template = workspace_type[\"templates\"][0]\nlogger.info(\n\"Workspace Template has not been specified in payload - we just take the first one (%s)\",\nworkspace_template,\n)\ntemplate_id = workspace_template[\"id\"]\ntemplate_name = workspace_template[\"name\"]\nworkspace_type_id = workspace_type[\"id\"]\nlogger.info(\n\"Create Workspace -&gt; %s (type -&gt; %s) from workspace template -&gt; %s (ID -&gt; %s)\",\nname,\ntype_name,\ntemplate_name,\ntemplate_id,\n)\n# Read business object data from workspace payload:\next_system_id = None\nbo_type = None\nbo_id = None\n# Check if business objects are in workspace payload and list is not empty:\nif \"business_objects\" in workspace and workspace[\"business_objects\"]:\n# Currently we can only process one business object (workspaces connected to multiple leading systems are not support yet)\nbusiness_object_data = workspace[\"business_objects\"][0]\n# business_object_data is a dict with 3 elements:\nif \"external_system\" in business_object_data:\next_system_id = business_object_data[\"external_system\"]\nif \"bo_type\" in business_object_data:\nbo_type = business_object_data[\"bo_type\"]\nif \"bo_id\" in business_object_data:\nbo_id = business_object_data[\"bo_id\"]\nlogger.info(\n\"Workspace -&gt; %s has business object information -&gt; (%s, %s, %s)\",\nname,\next_system_id,\nbo_type,\nbo_id,\n)\n# Check if external system has been declared in payload:\nexternal_system = next(\n(\nitem\nfor item in self._external_systems\nif (item[\"external_system_name\"] == ext_system_id)\n),\nNone,\n)\nif not external_system:\nlogger.warning(\n\"External System -&gt; %s does not exist. Cannot connect workspace -&gt; %s to -&gt; %s. Create workspace without connection.\",\next_system_id,\nname,\next_system_id,\n)\n# we remove the Business Object information to avoid communication\n# errors during workspace create form and workspace creation\next_system_id = None\nbo_type = None\nbo_id = None\nelif not external_system.get(\"reachable\"):\nlogger.warning(\n\"External System -&gt; %s is not reachable. Cannot connect workspace -&gt; %s to -&gt; (%s, %s, %s). Create workspace without connection...\",\next_system_id,\nname,\next_system_id,\nbo_type,\nbo_id,\n)\n# we remove the Business Object information to avoid communication\n# errors during workspace create form and workspace creation\next_system_id = None\nbo_type = None\nbo_id = None\nelse:\nlogger.info(\n\"Workspace -&gt; %s will be connected with external system -&gt; %s (%s, %s)\",\nname,\next_system_id,\nbo_type,\nbo_id,\n)\n# Read categories from payload:\nif not \"categories\" in workspace:\nlogger.info(\n\"Workspace payload has no category data! Will leave category attributes empty...\"\n)\ncategory_create_data = {}\nelse:\ncategories = workspace[\"categories\"]\ncategory_create_data = {\"categories\": {}}\nresponse = self._otcs.get_workspace_create_form(\ntemplate_id, ext_system_id, bo_type, bo_id, parent_workspace_node_id\n)\nif response is None:\nlogger.error(\n\"Failed to retrieve create information for template -&gt; %s\",\ntemplate_id,\n)\nsuccess = False\ncontinue\nlogger.info(\n\"Successfully retrieved create information for template -&gt; %s\",\ntemplate_id,\n)\n# Process category information\nforms = response[\"forms\"]\ncategories_form = {}\n# Typically the the create workspace form delivers 3 forms:\n# 1. Form for System Attributes (has no role name)\n# 2. Form for Category Data (role name = \"categories\")\n# 3. Form for Classifications (role name = \"classifications\")\n# First we extract these 3 forms:\nfor form in forms:\nif \"role_name\" in form and form[\"role_name\"] == \"categories\":\ncategories_form = form\nlogger.debug(\"Found Categories form -&gt; %s\", form)\ncontinue\nif \"role_name\" in form and form[\"role_name\"] == \"classifications\":\nlogger.debug(\"Found Classification form -&gt; %s\", form)\ncontinue\n# the remaining option is that this form is the system attributes form:\nlogger.debug(\"Found System Attributes form -&gt; %s\", form)\n# We are just interested in the single category data set (role_name = \"categories\"):\ndata = categories_form[\"data\"]\nlogger.debug(\"Categories data found -&gt; %s\", data)\nschema = categories_form[\"schema\"][\"properties\"]\nlogger.debug(\"Categories schema found -&gt; %s\", schema)\n# parallel loop over category data and schema\nfor cat_data, cat_schema in zip(data, schema):\nlogger.info(\"Category ID -&gt; %s\", cat_data)\ndata_attributes = data[cat_data]\nlogger.debug(\"Data Attributes -&gt; %s\", data_attributes)\nschema_attributes = schema[cat_schema][\"properties\"]\nlogger.debug(\"Schema Attributes -&gt; %s\", schema_attributes)\ncat_name = schema[cat_schema][\"title\"]\nlogger.info(\"Category name -&gt; %s\", cat_name)\n# parallel loop over attribute data and schema\n# Sets with one (fixed) row have type = object\n# Multi-value Sets with (multiple) rows have type = array and \"properties\" in \"items\" schema\n# Multi-value attributes have also type = array but NO \"properties\" in \"items\" schema\nfor attr_data, attr_schema in zip(\ndata_attributes, schema_attributes\n):\nlogger.debug(\"Attribute ID -&gt; %s\", attr_data)\nlogger.debug(\"Attribute Data -&gt; %s\", data_attributes[attr_data])\nlogger.debug(\n\"Attribute Schema -&gt; %s\", schema_attributes[attr_schema]\n)\nattr_type = schema_attributes[attr_schema][\"type\"]\nlogger.debug(\"Attribute Type -&gt; %s\", attr_type)\nif not \"title\" in schema_attributes[attr_schema]:\nlogger.debug(\"Attribute has no title. Skipping...\")\ncontinue\n# Check if it is an multi-line set:\nif attr_type == \"array\" and (\n\"properties\" in schema_attributes[attr_schema][\"items\"]\n):\nset_name = schema_attributes[attr_schema][\"title\"]\nlogger.info(\"Multi-line Set -&gt; %s\", set_name)\nset_data_attributes = data_attributes[\nattr_data\n]  # this is a list []\nlogger.debug(\n\"Set Data Attributes -&gt; %s\", set_data_attributes\n)\nset_schema_attributes = schema_attributes[attr_schema][\n\"items\"\n][\"properties\"]\nlogger.debug(\n\"Set Schema Attributes -&gt; %s\", set_schema_attributes\n)\nset_schema_max_rows = schema_attributes[attr_schema][\n\"items\"\n][\"maxItems\"]\nlogger.debug(\n\"Set Schema Max Rows -&gt; %s\", set_schema_max_rows\n)\nset_data_max_rows = len(set_data_attributes)\nlogger.debug(\"Set Data Max Rows -&gt; %s\", set_data_max_rows)\nrow = 1\n# it can happen that the payload contains more rows than the\n# initial rows in the set data structure. In this case we use\n# a copy of the data structure from row 0 as template...\nfirst_row = dict(set_data_attributes[0])\n# We don't know upfront how many rows of data we will find in payload\n# but we at max process the maxItems specified in the schema:\nwhile row &lt;= set_schema_max_rows:\n# Test if we have any payload for this row:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand \"set\"\nin item  # not all items may have a \"set\" key\nand item[\"set\"] == set_name\nand \"row\"\nin item  # not all items may have a \"row\" key\nand item[\"row\"] == row\n)\n),\nNone,\n)\n# stop if there's no payload for the row:\nif attribute is None:\nlogger.info(\n\"No payload found for set -&gt; %s, row -&gt; %s\",\nset_name,\nrow,\n)\n# we assume that if there's no payload for row n there will be no payload for rows &gt; n\n# and break the while loop:\nbreak\n# do we need to create a new row in the data set?\nelif row &gt; set_data_max_rows:\n# use the row we stored above to create a new empty row:\nlogger.info(\n\"Found payload for row -&gt; %s, we need a new data row for it\",\nrow,\n)\nlogger.info(\n\"Adding an additional row -&gt; %s to set data -&gt; %s\",\nrow,\nset_name,\n)\n# add the empty dict to the list:\nset_data_attributes.append(dict(first_row))\nset_data_max_rows += 1\nelse:\nlogger.info(\n\"Found payload for row -&gt; %s %s we can store in existing data row\",\nrow,\nset_name,\n)\n# traverse all attributes in a single row:\nfor set_attr_schema in set_schema_attributes:\nlogger.debug(\n\"Set Attribute ID -&gt; %s (row -&gt; %s)\",\nset_attr_schema,\nrow,\n)\nlogger.debug(\n\"Set Attribute Schema -&gt; %s (row -&gt; %s)\",\nset_schema_attributes[set_attr_schema],\nrow,\n)\nset_attr_type = set_schema_attributes[\nset_attr_schema\n][\"type\"]\nlogger.debug(\n\"Set Attribute Type -&gt; %s (row -&gt; %s)\",\nset_attr_type,\nrow,\n)\nset_attr_name = set_schema_attributes[\nset_attr_schema\n][\"title\"]\nlogger.debug(\n\"Set Attribute Name -&gt; %s (row -&gt; %s)\",\nset_attr_name,\nrow,\n)\n# Lookup the attribute with the right category, set, attribute name, and row number in payload:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand \"set\"\nin item  # not all items may have a \"set\" key\nand item[\"set\"] == set_name\nand item[\"attribute\"] == set_attr_name\nand \"row\"\nin item  # not all items may have a \"row\" key\nand item[\"row\"] == row\n)\n),\nNone,\n)\nif attribute is None:\nlogger.warning(\n\"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s not found in payload.\",\nset_name,\nset_attr_name,\nrow,\n)\n# need to use row - 1 as index starts with 0 but payload rows start with 1\nset_data_attributes[row - 1][\nset_attr_schema\n] = \"\"\nelse:\nlogger.info(\n\"Set -&gt; %s, Attribute -&gt; %s, Row -&gt; %s found in payload, value -&gt; %s\",\nset_name,\nset_attr_name,\nrow,\nattribute[\"value\"],\n)\n# Put the value from the payload into data structure\n# need to use row - 1 as index starts with 0 but payload rows start with 1\nset_data_attributes[row - 1][\nset_attr_schema\n] = attribute[\"value\"]\nrow += 1  # continue the while loop with the next row\n# Check if it is single-line set:\nelif attr_type == \"object\":\nset_name = schema_attributes[attr_schema][\"title\"]\nlogger.info(\"Single-line Set -&gt; %s\", set_name)\nset_data_attributes = data_attributes[attr_data]\nlogger.debug(\n\"Set Data Attributes -&gt; %s\", set_data_attributes\n)\nset_schema_attributes = schema_attributes[attr_schema][\n\"properties\"\n]\nlogger.debug(\n\"Set Schema Attributes -&gt; %s\", set_schema_attributes\n)\nfor set_attr_data, set_attr_schema in zip(\nset_data_attributes, set_schema_attributes\n):\nlogger.debug(\"Set Attribute ID -&gt; %s\", set_attr_data)\nlogger.debug(\n\"Set Attribute Data -&gt; %s\",\nset_data_attributes[set_attr_data],\n)\nlogger.debug(\n\"Set Attribute Schema -&gt; %s\",\nset_schema_attributes[set_attr_schema],\n)\nset_attr_type = set_schema_attributes[set_attr_schema][\n\"type\"\n]\nlogger.debug(\"Set Attribute Type -&gt; %s\", set_attr_type)\nset_attr_name = set_schema_attributes[set_attr_schema][\n\"title\"\n]\nlogger.debug(\"Set Attribute Name -&gt; %s\", set_attr_name)\n# Lookup the attribute with the right category, set and attribute name in payload:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand \"set\"\nin item  # not all items may have a \"set\" key\nand item[\"set\"] == set_name\nand item[\"attribute\"] == set_attr_name\n)\n),\nNone,\n)\nif attribute is None:\nlogger.warning(\n\"Set -&gt; %s, Attribute -&gt; %s not found in payload.\",\nset_name,\nset_attr_name,\n)\nset_data_attributes[set_attr_data] = \"\"\nelse:\nlogger.info(\n\"Set -&gt; %s, Attribute -&gt; %s found in payload, value -&gt; %s\",\nset_name,\nset_attr_name,\nattribute[\"value\"],\n)\n# Put the value from the payload into data structure\nset_data_attributes[set_attr_data] = attribute[\n\"value\"\n]\n# It is a plain attribute (not inside a set) or it is a multi-value attribute (not inside a set):\nelse:\nattr_name = schema_attributes[attr_schema][\"title\"]\nlogger.debug(\"Attribute Name -&gt; %s\", attr_name)\n# Lookup the attribute with the right category and attribute name in payload:\nattribute = next(\n(\nitem\nfor item in categories\nif (\nitem[\"name\"] == cat_name\nand item[\"attribute\"] == attr_name\n)\n),\nNone,\n)\nif attribute is None:\nlogger.warning(\n\"Attribute -&gt; %s not found in payload.\", attr_name\n)\ndata_attributes[attr_data] = \"\"\nelse:\nlogger.info(\n\"Attribute -&gt; %s found in payload, value -&gt; %s\",\nattr_name,\nattribute[\"value\"],\n)\n# We need to handle a very special case here for Extended ECM for Government\n# which has an attribute type \"Organizational Unit\" (OU). This is referring to a group ID\n# which is not stable across deployments. So we need to lookup the Group ID and add it\n# to the data structure. This expects that the payload has the Group Name and not the Group ID\nif attr_type == str(11480):\nlogger.info(\n\"Attribute -&gt; %s is is of type -&gt; Organizational Unit (%s). Looking up group ID for group name -&gt; %s\",\nattr_name,\nattr_type,\nattribute[\"value\"],\n)\ngroup = self._otcs.get_group(attribute[\"value\"])\ngroup_id = self._otcs.lookup_result_value(\ngroup, \"name\", attribute[\"value\"], \"id\"\n)\nif group_id:\nlogger.info(\n\"Group for Organizational Unit -&gt; %s has ID -&gt; %s\",\nattribute[\"value\"],\ngroup_id,\n)\n# Put the group ID into data structure\ndata_attributes[attr_data] = str(group_id)\nelse:\nlogger.error(\n\"Group for Organizational Unit -&gt; %s does not exist!\",\nattribute[\"value\"],\n)\n# Clear the value to avoid workspace create failure\ndata_attributes[attr_data] = \"\"\n# handle special case where attribute type is a user picker.\n# we expect that the payload includes the login name for this\n# (as user IDs are not stable across systems) but then we need\n# to lookup the real user ID here:\nelif attr_type == \"otcs_user_picker\":\nlogger.info(\n\"Attribute -&gt; %s is is of type -&gt; User Picker (%s). Looking up user ID for user login name -&gt; %s\",\nattr_name,\nattr_type,\nattribute[\"value\"],\n)\nuser = self._otcs.get_user(attribute[\"value\"])\nuser_id = self._otcs.lookup_result_value(\nresponse=user,\nkey=\"name\",\nvalue=attribute[\"value\"],\nreturn_key=\"id\",\n)\nif user_id:\n# User has been found - determine ID:\nlogger.info(\n\"User -&gt; %s has ID -&gt; %s\",\nattribute[\"value\"],\nuser_id,\n)\n# Put the user ID into data structure\ndata_attributes[attr_data] = str(user_id)\nelse:\nlogger.error(\n\"User with login name -&gt; %s does not exist!\",\nattribute[\"value\"],\n)\n# Clear the value to avoid workspace create failure\ndata_attributes[attr_data] = \"\"\nelse:\n# Put the value from the payload into data structure\ndata_attributes[attr_data] = attribute[\"value\"]\ncategory_create_data[\"categories\"][cat_data] = data_attributes\nlogger.debug(\"Category Create Data -&gt; %s\", category_create_data)\n# Create the workspace with all provided information:\nresponse = self._otcs.create_workspace(\ntemplate_id,\nname,\ndescription,\nworkspace_type_id,\ncategory_create_data,\next_system_id,\nbo_type,\nbo_id,\nparent_workspace_node_id,\n)\nif response is None:\nlogger.error(\"Failed to create workspace -&gt; %s\", name)\nsuccess = False\ncontinue\n# Now we add the node ID of the new workspace to the payload data structure\n# This will be reused when creating the workspace relationships!\nworkspace[\"nodeId\"] = self._otcs.get_result_value(response, \"id\")\n# We also get the name the workspace was finally created with.\n# This can be different form the name in the payload as additional\n# naming conventions from the Workspace Type definitions may apply.\n# This is important to make the python container idem-potent.\nresponse = self._otcs.get_workspace(workspace[\"nodeId\"])\nworkspace[\"name\"] = self._otcs.get_result_value(response, \"name\")\nlogger.info(\n\"Successfully created workspace with final name -&gt; %s and node ID -&gt; %s\",\nworkspace[\"name\"],\nworkspace[\"nodeId\"],\n)\n# Check if there's an workspace icon/image configured:\nif \"image_nickname\" in workspace:\nimage_nickname = workspace[\"image_nickname\"]\nresponse = self._otcs.get_node_from_nickname(image_nickname)\nnode_id = self._otcs.get_result_value(response, \"id\")\nif node_id:\nmime_type = self._otcs.get_result_value(response, \"mime_type\")\nif not mime_type:\nlogger.warning(\n\"Missing mime type information - assuming image/png\"\n)\nmime_type = \"image/png\"\nfile_path = \"/tmp/\" + image_nickname\nself._otcs.download_document(node_id=node_id, file_path=file_path)\nresponse = self._otcs.update_workspace_icon(\nworkspace_id=workspace[\"nodeId\"],\nfile_path=file_path,\nfile_mimetype=mime_type,\n)\nif not response:\nlogger.error(\n\"Failed to assign icon -&gt; %s to workspace -&gt; %s from file -&gt; %s \",\nimage_nickname,\nname,\nfile_path,\n)\nelse:\nlogger.error(\n\"Cannot find workspace image with nickname -&gt; %s for workspace -&gt; %s\",\nimage_nickname,\nname,\n)\n# Check if an RM classification is specified for the workspace:\n# RM Classification is specified as list of path elements (top-down)\nif (\n\"rm_classification_path\" in workspace\nand workspace[\"rm_classification_path\"] != []\n):\nrm_class_node = self._otcs.get_node_by_volume_and_path(\n198, workspace[\"rm_classification_path\"]\n)\nrm_class_node_id = self._otcs.get_result_value(rm_class_node, \"id\")\nif rm_class_node_id:\nresponse = self._otcs.assign_rm_classification(\nworkspace[\"nodeId\"], rm_class_node_id, False\n)\nif response is None:\nlogger.error(\n\"Failed to assign RM classification -&gt; %s (%s) to workspace -&gt; %s\",\nworkspace[\"rm_classification_path\"][-1],\nrm_class_node_id,\nname,\n)\nelse:\nlogger.info(\n\"Assigned RM Classification -&gt; %s to workspace -&gt; %s\",\nworkspace[\"rm_classification_path\"][-1],\nname,\n)\n# Check if one or multiple classifications are specified for the workspace\n# Classifications are specified as list of path elements (top-down)\nif (\n\"classification_pathes\" in workspace\nand workspace[\"classification_pathes\"] != []\n):\nfor classification_path in workspace[\"classification_pathes\"]:\nclass_node = self._otcs.get_node_by_volume_and_path(\n198, classification_path\n)\nclass_node_id = self._otcs.get_result_value(class_node, \"id\")\nif class_node_id:\nresponse = self._otcs.assign_classification(\nworkspace[\"nodeId\"], [class_node_id], False\n)\nif response is None:\nlogger.error(\n\"Failed to assign classification -&gt; %s to workspace -&gt; %s\",\nclass_node_id,\nname,\n)\nelse:\nlogger.info(\n\"Assigned Classification -&gt; %s to workspace -&gt; %s\",\nclassification_path[-1],\nname,\n)\nself.write_status_file(success, section_name, self._workspaces)\nreturn success\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.replace_placeholders","title":"<code>replace_placeholders(content)</code>","text":"<p>Function to replace placeholders in file content.    The content of the file is provided via a parameter.    The replacements are defined in a object variable    _placeholder_values (type = dictionary)    The placeholder values are supposed to be surrounded by    double % signs like %%OTAWP_RESOURCE_ID%%</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>file content to replace placeholders in</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>updated content with all defined replacements</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def replace_placeholders(self, content: str) -&gt; str:\n\"\"\"Function to replace placeholders in file content.\n       The content of the file is provided via a parameter.\n       The replacements are defined in a object variable\n       _placeholder_values (type = dictionary)\n       The placeholder values are supposed to be surrounded by\n       double % signs like %%OTAWP_RESOURCE_ID%%\n    Args:\n        content (str): file content to replace placeholders in\n    Returns:\n        str: updated content with all defined replacements\n    \"\"\"\n# https://stackoverflow.com/questions/63502218/replacing-placeholders-in-a-text-file-with-python\n# if no placeholders are defined we can return the\n# initial value:\nif not self._placeholder_values:\nreturn content\ntry:\n# We do a dynamic replacement here. The replacement is calculated\n# by the lambda function that is basically a lookup of the replacement\n# key found in the settings file with the value defined in the list\n# of replacement values in self._placeholder_values\nreturn re.sub(\nr\"%%(\\w+?)%%\",\nlambda match: self._placeholder_values[match.group(1)],\ncontent,\n)\nexcept KeyError as key_error:\nlogger.error(\n\"Found placeholder in settings file without a defined value; error -&gt; %s\",\nstr(key_error),\n)\nreturn content\nexcept re.error as re_error:\nlogger.error(\"Regex substitution error -&gt; %s\", str(re_error))\nreturn content\n</code></pre>"},{"location":"pyxecm/payload/#pyxecm.customizer.payload.Payload.write_status_file","title":"<code>write_status_file(success, payload_section_name, payload_section, payload_specific=True)</code>","text":"<p>Write a status file into the Admin Personal Workspace in Extended ECM    to indicate that the payload section has been deployed successfully.    This speeds up the customizing process in case the customizer pod    is restarted.</p> <p>Parameters:</p> Name Type Description Default <code>success</code> <code>bool</code> <p>True if the section was processed successful, False otherwise.</p> required <code>payload_section_name</code> <code>str</code> <p>name of the payload section</p> required <code>payload_section</code> <code>list</code> <p>payload section content - this is written as JSon into the file</p> required <code>payload_specific</code> <code>bool</code> <p>whether or not the success should be specific for                      each payload file or if success is \"global\" - like for the deletion                      of the existing M365 teams (which we don't want to execute per                      payload file)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the status file as been upladed to Extended ECM successfully, False otherwise</p> Source code in <code>pyxecm/customizer/payload.py</code> <pre><code>def write_status_file(\nself,\nsuccess: bool,\npayload_section_name: str,\npayload_section: list,\npayload_specific: bool = True,\n) -&gt; bool:\n\"\"\"Write a status file into the Admin Personal Workspace in Extended ECM\n       to indicate that the payload section has been deployed successfully.\n       This speeds up the customizing process in case the customizer pod\n       is restarted.\n    Args:\n        success (bool): True if the section was processed successful, False otherwise.\n        payload_section_name (str): name of the payload section\n        payload_section (list): payload section content - this is written as JSon into the file\n        payload_specific (bool): whether or not the success should be specific for\n                                 each payload file or if success is \"global\" - like for the deletion\n                                 of the existing M365 teams (which we don't want to execute per\n                                 payload file)\n    Returns:\n        bool: True if the status file as been upladed to Extended ECM successfully, False otherwise\n    \"\"\"\nif success:\nlogger.info(\n\"Payload section -&gt; %s has been completed successfully!\",\npayload_section_name,\n)\nprefix = \"success_\"\nelse:\nlogger.error(\n\"Payload section -&gt; %s had failures!\",\npayload_section_name,\n)\nprefix = \"failure_\"\nresponse = self._otcs.get_node_by_volume_and_path(\n142\n)  # write to Personal Workspace of Admin (with Volume Type ID = 142)\ntarget_folder_id = self._otcs.get_result_value(response, \"id\")\nif not target_folder_id:\ntarget_folder_id = 2004  # use Personal Workspace of Admin as fallback\n# Some sections are actually not payload specific like teamsM365Cleanup\n# and we don't want external payload runs to re-process these:\nif payload_specific:\nfile_name = os.path.basename(self._payload_source)  # remove directories\n# Split once at the first occurance of a dot\n# as the _payload_source may have multiple suffixes\n# such as .yml.gz.b64:\nfile_name = file_name.split(\".\", 1)[0]\nfile_name = prefix + file_name + \"_\" + payload_section_name + \".json\"\nelse:\nfile_name = prefix + payload_section_name + \".json\"\nfull_path = \"/tmp/\" + file_name\nwith open(full_path, mode=\"w\", encoding=\"utf-8\") as localfile:\nlocalfile.write(json.dumps(payload_section, indent=2))\n# Check if the status file has been uploaded before.\n# This can happen if we re-run the python container.\n# In this case we add a version to the existing document:\nresponse = self._otcs.get_node_by_parent_and_name(\nparent_id=int(target_folder_id), name=file_name, show_error=False\n)\ntarget_document_id = self._otcs.get_result_value(response, \"id\")\nif target_document_id:\nresponse = self._otcs.add_document_version(\nnode_id=int(target_document_id),\nfile_url=full_path,\nfile_name=file_name,\nmime_type=\"text/plain\",\ndescription=\"Updated status file after re-run of customization\",\n)\nelse:\nresponse = self._otcs.upload_file_to_parent(\nfile_url=full_path,\nfile_name=file_name,\nmime_type=\"text/plain\",\nparent_id=int(target_folder_id),\n)\nif response:\nlogger.info(\n\"Status file -&gt; %s has been written to Personal Workspace of admin user\",\nfile_name,\n)\nreturn True\nlogger.error(\n\"Failed to write status file -&gt; %s to Personal Workspace of admin user\",\nfile_name,\n)\nreturn False\n</code></pre>"},{"location":"pyxecm/sap/","title":"SAP","text":"<p>SAP RFC Module to implement Remote Function calls to SAP S/4HANA For documentation of PyRFC see here: https://github.com/SAP/PyRFC and here: https://sap.github.io/PyRFC/pyrfc.html </p> <p>RFC typically uses port 3300 to communication with the SAP server. Make sure this port is not blocked by your firewall.</p> <p>Connection Parameter: * ashost (hostname or IP address of the application server - this should NOT be a full URL!) * sysnr (the backend's system number, e.g. 00) * client (the client or \"Mandant\" to which to logon, e.g. 100) * user (e.g. \"nwheeler\") * passwd (password of the user) * lang (logon language as two-character ISO-Code, e.g. EN) * trace (on of 0(off), 1(brief), 2(verbose), 3(detailed), 4(full)) * use_tls (activates SSL/TLS encryption. Set to 0 or 1. By default TLS is turned on (1)) * tls_client_pse (Specifies the PSE file containing the necessary certificates for TLS communication.                   A PSE file is a SAP proprietary certificate store, similar to a p12 file,                   containing the private key and the certificate chain to be used in the TLS                   handshake with the server, beginning with the server's public certificate and                   ending with the root CA certifcate. It should also contain the client certificate                   used for login at the server, if your client program does not use basic                   user &amp; password authentication)</p> <p>Class: SAP Methods:</p> <p>init : class initializer call: Calls and RFC based on its name and passes parameters.</p>"},{"location":"pyxecm/sap/#pyxecm.customizer.sap.SAP","title":"<code>SAP</code>","text":"<p>         Bases: <code>object</code></p> <p>Used to implement Remote Function Calls (RFC) to SAP S/4HANA</p> Source code in <code>pyxecm/customizer/sap.py</code> <pre><code>class SAP(object):\n\"\"\"Used to implement Remote Function Calls (RFC) to SAP S/4HANA\"\"\"\n_connection_parameters = {}\ndef __init__(\nself,\nusername: str,\npassword: str,\nsystem_id: str,\nashost: str = \"\",\nmshost: str = \"\",\nmsport: str = \"3601\",\ngroup: str = \"PUBLIC\",\ndestination: str = \"\",\nclient: str = \"100\",\nsystem_number: str = \"00\",\nlang: str = \"EN\",\ntrace: str = \"3\",\n):\n\"\"\"Initialize the SAP object.\"\"\"\nlogger.info(\"Initializing SAP object...\")\nlogger.info(\"Using PyRFC version -&gt; %s\", pyrfc.__version__)\n# Set up connection parameters\nself._connection_parameters = {\n\"user\": username,\n\"passwd\": password,\n\"client\": client,\n\"trace\": trace,\n\"lang\": lang,\n}\n# see https://sap.github.io/PyRFC/pyrfc.html#connection\nif ashost:\nlogger.info(\"Logon with application server logon: requiring ashost, sysnr\")\nself._connection_parameters[\"ashost\"] = ashost\nself._connection_parameters[\"sysnr\"] = system_number\nself._connection_parameters[\"sysid\"] = system_id\nelif mshost:\nlogger.info(\n\"Logon with load balancing: requiring mshost, msserv, sysid, group\"\n)\nself._connection_parameters[\"mshost\"] = mshost\nself._connection_parameters[\"sysid\"] = system_id\nself._connection_parameters[\"msserv\"] = msport\nself._connection_parameters[\"group\"] = group\nif destination:\nself._connection_parameters[\"dest\"] = destination\n# end method definition\ndef call(self, rfc_name: str, options: dict, rfc_parameters: dict) -&gt; dict | None:\n\"\"\"Do an RFC Call. See http://sap.github.io/PyRFC/pyrfc.html#pyrfc.Connection.call\n        Args:\n            rfc_name (str): this is the name of the RFC (typical in capital letters), e.g. SM02_ADD_MESSAGE\n            options (dictionary, optional): the call options for the RFC call. Defaults to {}.\n            * not_requested: Allows to deactivate certain parameters in the function module interface.\n              This is particularly useful for BAPIs which have many large tables, the Python client is not interested in.\n              Deactivate those, to reduce network traffic and memory consumption in your application considerably.\n              This functionality can be used for input and output parameters. If the parameter is an input,\n              no data for that parameter will be sent to the backend. If it\u2019s an output, the backend will be\n              informed not to return data for that parameter.\n            * timeout: Cancel RFC connection if ongoing RFC call not completed within timeout seconds.\n              Timeout can be also set as client connection configuration option, in which case is valid for all RFC calls.\n            rfc_parameters (dict, optional): the actual RFC parameters thatare specific for\n                                                   the type of the call. Defaults to {}.\n        Returns:\n            dict: Result of the RFC call or None if the call fails or timeouts.\n        \"\"\"\n# Create the connection object and call the RFC function\nparams = self._connection_parameters\nlogger.debug(\"Connection Parameters -&gt; %s\", params)\ntry:\nwith pyrfc.Connection(**params) as conn:\nresult = conn.call(rfc_name, options=options, **rfc_parameters)\nreturn result\nexcept pyrfc.RFCError as exception:\nlogger.error(\"Failed to call RFC -&gt; %s; error -&gt; %s\", rfc_name, exception)\nreturn None\n</code></pre>"},{"location":"pyxecm/sap/#pyxecm.customizer.sap.SAP.__init__","title":"<code>__init__(username, password, system_id, ashost='', mshost='', msport='3601', group='PUBLIC', destination='', client='100', system_number='00', lang='EN', trace='3')</code>","text":"<p>Initialize the SAP object.</p> Source code in <code>pyxecm/customizer/sap.py</code> <pre><code>def __init__(\nself,\nusername: str,\npassword: str,\nsystem_id: str,\nashost: str = \"\",\nmshost: str = \"\",\nmsport: str = \"3601\",\ngroup: str = \"PUBLIC\",\ndestination: str = \"\",\nclient: str = \"100\",\nsystem_number: str = \"00\",\nlang: str = \"EN\",\ntrace: str = \"3\",\n):\n\"\"\"Initialize the SAP object.\"\"\"\nlogger.info(\"Initializing SAP object...\")\nlogger.info(\"Using PyRFC version -&gt; %s\", pyrfc.__version__)\n# Set up connection parameters\nself._connection_parameters = {\n\"user\": username,\n\"passwd\": password,\n\"client\": client,\n\"trace\": trace,\n\"lang\": lang,\n}\n# see https://sap.github.io/PyRFC/pyrfc.html#connection\nif ashost:\nlogger.info(\"Logon with application server logon: requiring ashost, sysnr\")\nself._connection_parameters[\"ashost\"] = ashost\nself._connection_parameters[\"sysnr\"] = system_number\nself._connection_parameters[\"sysid\"] = system_id\nelif mshost:\nlogger.info(\n\"Logon with load balancing: requiring mshost, msserv, sysid, group\"\n)\nself._connection_parameters[\"mshost\"] = mshost\nself._connection_parameters[\"sysid\"] = system_id\nself._connection_parameters[\"msserv\"] = msport\nself._connection_parameters[\"group\"] = group\nif destination:\nself._connection_parameters[\"dest\"] = destination\n</code></pre>"},{"location":"pyxecm/sap/#pyxecm.customizer.sap.SAP.call","title":"<code>call(rfc_name, options, rfc_parameters)</code>","text":"<p>Do an RFC Call. See http://sap.github.io/PyRFC/pyrfc.html#pyrfc.Connection.call</p> <p>Parameters:</p> Name Type Description Default <code>rfc_name</code> <code>str</code> <p>this is the name of the RFC (typical in capital letters), e.g. SM02_ADD_MESSAGE</p> required <code>options</code> <code>dictionary</code> <p>the call options for the RFC call. Defaults to {}.</p> required <code>*</code> <code>not_requested</code> <p>Allows to deactivate certain parameters in the function module interface. This is particularly useful for BAPIs which have many large tables, the Python client is not interested in. Deactivate those, to reduce network traffic and memory consumption in your application considerably. This functionality can be used for input and output parameters. If the parameter is an input, no data for that parameter will be sent to the backend. If it\u2019s an output, the backend will be informed not to return data for that parameter.</p> required <code>*</code> <code>timeout</code> <p>Cancel RFC connection if ongoing RFC call not completed within timeout seconds. Timeout can be also set as client connection configuration option, in which case is valid for all RFC calls.</p> required <code>rfc_parameters</code> <code>dict</code> <p>the actual RFC parameters thatare specific for                                    the type of the call. Defaults to {}.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>Result of the RFC call or None if the call fails or timeouts.</p> Source code in <code>pyxecm/customizer/sap.py</code> <pre><code>def call(self, rfc_name: str, options: dict, rfc_parameters: dict) -&gt; dict | None:\n\"\"\"Do an RFC Call. See http://sap.github.io/PyRFC/pyrfc.html#pyrfc.Connection.call\n    Args:\n        rfc_name (str): this is the name of the RFC (typical in capital letters), e.g. SM02_ADD_MESSAGE\n        options (dictionary, optional): the call options for the RFC call. Defaults to {}.\n        * not_requested: Allows to deactivate certain parameters in the function module interface.\n          This is particularly useful for BAPIs which have many large tables, the Python client is not interested in.\n          Deactivate those, to reduce network traffic and memory consumption in your application considerably.\n          This functionality can be used for input and output parameters. If the parameter is an input,\n          no data for that parameter will be sent to the backend. If it\u2019s an output, the backend will be\n          informed not to return data for that parameter.\n        * timeout: Cancel RFC connection if ongoing RFC call not completed within timeout seconds.\n          Timeout can be also set as client connection configuration option, in which case is valid for all RFC calls.\n        rfc_parameters (dict, optional): the actual RFC parameters thatare specific for\n                                               the type of the call. Defaults to {}.\n    Returns:\n        dict: Result of the RFC call or None if the call fails or timeouts.\n    \"\"\"\n# Create the connection object and call the RFC function\nparams = self._connection_parameters\nlogger.debug(\"Connection Parameters -&gt; %s\", params)\ntry:\nwith pyrfc.Connection(**params) as conn:\nresult = conn.call(rfc_name, options=options, **rfc_parameters)\nreturn result\nexcept pyrfc.RFCError as exception:\nlogger.error(\"Failed to call RFC -&gt; %s; error -&gt; %s\", rfc_name, exception)\nreturn None\n</code></pre>"},{"location":"pyxecm/translate/","title":"Translate","text":"<p>Experimental module to automate translations</p> <p>Class: Translator Methods:</p> <p>init : class initializer config: Return the configuration parameters translate: Translate a string from one language to another using the Google Translate V2 API translateV3: Translate a string from one language to another using the Google Translate V3 API</p>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator","title":"<code>Translator</code>","text":"<p>Class for translation of of strings based on the Google Translate API. The class supports V2 and V3 translation APIs</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>class Translator:\n\"\"\"Class for translation of of strings based on the Google Translate API.\n       The class supports V2 and V3 translation APIs\n    \"\"\"\n_config = None\n_headers = None\ndef __init__(self, api_key: str, project_key: str = \"\", domain: str = \"\"):\ntranslateConfig = {}\ntranslateConfig[\"apiKey\"] = api_key\ntranslateConfig[\n\"translateUrlV2\"\n] = \"https://translation.googleapis.com/language/translate/v2\"\ntranslateConfig[\n\"translateUrlV3\"\n] = \"https://translation.googleapis.com/v3/projects/{}:translateText\".format(\nproject_key\n)\ntranslateConfig[\"project\"] = project_key\ntranslateConfig[\"parent\"] = \"projects/{}/locations/global\".format(project_key)\ntranslateConfig[\"model\"] = f'nmt{\":{}\".format(domain) if domain else \"\"}'\nself._headers = {\n\"Authorization\": f\"Bearer {api_key}\",\n\"Content-Type\": \"application/json; charset=utf-8\",\n}\nself._config = translateConfig\ndef config(self) -&gt; dict:\n\"\"\"Return the configuration parameters\n        Returns:\n            dict: configuration parameters\n        \"\"\"\nreturn self._config\ndef translate(self, source_language: str, target_language: str, text: str) -&gt; str:\n\"\"\"Translate a string from one language to another using the Google Translate V2 API\n        Args:\n            source_language (str): source language\n            target_language (str): destination language\n            text (str): string to translate\n        Returns:\n            str: translated string\n        \"\"\"\nparams = {\n\"key\": self.config()[\"apiKey\"],\n\"q\": text,\n\"source\": source_language,\n\"target\": target_language,\n}\nrequest_url = self.config()[\"translateUrlV2\"]\nresponse = requests.post(url=request_url, params=params, timeout=None)\nif response.status_code != 200:\nlogger.error(\"Failed to translate text -&gt; %s\", response.content)\nreturn None\ntranslated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\nreturn translated_text\n# end method definition\ndef translateV3(self, source_language: str, target_language: str, text: str) -&gt; str:\n\"\"\"Translate a string from one language to another using the Google Translate V3 API\n        Args:\n            source_language (str): source language\n            target_language (str): destination language\n            text (str): string to translate\n        Returns:\n            str: translated string\n        \"\"\"\ndata = {\n\"source_language_code\": source_language,\n\"target_language_code\": target_language,\n\"contents\": [text],\n}\nrequest_header = self._headers\nrequest_url = self.config()[\"translateUrlV3\"]\nresponse = requests.post(\nurl=request_url, headers=request_header, json=data, timeout=None\n)\nif response.status_code != 200:\nlogger.error(\"Failed to translate text -&gt; %s\", response.content)\nreturn None\ntranslated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\nreturn translated_text\n</code></pre>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator.config","title":"<code>config()</code>","text":"<p>Return the configuration parameters</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>configuration parameters</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>def config(self) -&gt; dict:\n\"\"\"Return the configuration parameters\n    Returns:\n        dict: configuration parameters\n    \"\"\"\nreturn self._config\n</code></pre>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator.translate","title":"<code>translate(source_language, target_language, text)</code>","text":"<p>Translate a string from one language to another using the Google Translate V2 API</p> <p>Parameters:</p> Name Type Description Default <code>source_language</code> <code>str</code> <p>source language</p> required <code>target_language</code> <code>str</code> <p>destination language</p> required <code>text</code> <code>str</code> <p>string to translate</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>translated string</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>def translate(self, source_language: str, target_language: str, text: str) -&gt; str:\n\"\"\"Translate a string from one language to another using the Google Translate V2 API\n    Args:\n        source_language (str): source language\n        target_language (str): destination language\n        text (str): string to translate\n    Returns:\n        str: translated string\n    \"\"\"\nparams = {\n\"key\": self.config()[\"apiKey\"],\n\"q\": text,\n\"source\": source_language,\n\"target\": target_language,\n}\nrequest_url = self.config()[\"translateUrlV2\"]\nresponse = requests.post(url=request_url, params=params, timeout=None)\nif response.status_code != 200:\nlogger.error(\"Failed to translate text -&gt; %s\", response.content)\nreturn None\ntranslated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\nreturn translated_text\n</code></pre>"},{"location":"pyxecm/translate/#pyxecm.customizer.translate.Translator.translateV3","title":"<code>translateV3(source_language, target_language, text)</code>","text":"<p>Translate a string from one language to another using the Google Translate V3 API</p> <p>Parameters:</p> Name Type Description Default <code>source_language</code> <code>str</code> <p>source language</p> required <code>target_language</code> <code>str</code> <p>destination language</p> required <code>text</code> <code>str</code> <p>string to translate</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>translated string</p> Source code in <code>pyxecm/customizer/translate.py</code> <pre><code>def translateV3(self, source_language: str, target_language: str, text: str) -&gt; str:\n\"\"\"Translate a string from one language to another using the Google Translate V3 API\n    Args:\n        source_language (str): source language\n        target_language (str): destination language\n        text (str): string to translate\n    Returns:\n        str: translated string\n    \"\"\"\ndata = {\n\"source_language_code\": source_language,\n\"target_language_code\": target_language,\n\"contents\": [text],\n}\nrequest_header = self._headers\nrequest_url = self.config()[\"translateUrlV3\"]\nresponse = requests.post(\nurl=request_url, headers=request_header, json=data, timeout=None\n)\nif response.status_code != 200:\nlogger.error(\"Failed to translate text -&gt; %s\", response.content)\nreturn None\ntranslated_text = response.json()[\"data\"][\"translations\"][0][\"translatedText\"]\nreturn translated_text\n</code></pre>"}]}